================================================================================
// FILE: ./tests/disposable.test.ts
================================================================================
import * as vscode from 'vscode';
import { Disposable, toDisposable } from '../src/utils/disposable';

class DisposableTest extends Disposable {
	constructor() {
		super();
	}

	public registerDisposable(disposable: vscode.Disposable) {
		super.registerDisposable(disposable);
	}

	public registerDisposables(...disposables: vscode.Disposable[]) {
		super.registerDisposables(...disposables);
	}

	public isDisposed() {
		return super.isDisposed();
	}
}

describe('Disposable', () => {
	it('Should register a disposable', () => {
		// Setup
		const disposableTest = new DisposableTest();
		const disposable = { dispose: jest.fn() };

		// Run
		disposableTest.registerDisposable(disposable);

		// Assert
		expect(disposableTest.isDisposed()).toBe(false);
		expect(disposableTest['disposables']).toStrictEqual([disposable]);
	});

	it('Should register multiple disposables', () => {
		// Setup
		const disposableTest = new DisposableTest();
		const disposable1 = { dispose: jest.fn() };
		const disposable2 = { dispose: jest.fn() };

		// Run
		disposableTest.registerDisposables(disposable1, disposable2);

		// Assert
		expect(disposableTest.isDisposed()).toBe(false);
		expect(disposableTest['disposables']).toStrictEqual([disposable1, disposable2]);
	});

	it('Should dispose all registered disposables', () => {
		// Setup
		const disposableTest = new DisposableTest();
		const disposable1 = { dispose: jest.fn() };
		const disposable2 = { dispose: jest.fn() };
		disposableTest.registerDisposables(disposable1, disposable2);

		// Run
		disposableTest.dispose();

		// Assert
		expect(disposableTest.isDisposed()).toBe(true);
		expect(disposableTest['disposables']).toStrictEqual([]);
		expect(disposable1.dispose).toHaveBeenCalled();
		expect(disposable2.dispose).toHaveBeenCalled();
	});

	it('Should dispose all registered disposables independently, catching any exceptions', () => {
		// Setup
		const disposableTest = new DisposableTest();
		const disposable1 = { dispose: jest.fn() };
		const disposable2 = {
			dispose: jest.fn(() => {
				throw new Error();
			})
		};
		const disposable3 = { dispose: jest.fn() };
		disposableTest.registerDisposables(disposable1, disposable2, disposable3);

		// Run
		disposableTest.dispose();

		// Assert
		expect(disposableTest.isDisposed()).toBe(true);
		expect(disposableTest['disposables']).toStrictEqual([]);
		expect(disposable1.dispose).toHaveBeenCalled();
		expect(disposable2.dispose).toHaveBeenCalled();
		expect(disposable3.dispose).toHaveBeenCalled();
	});
});

describe('toDisposable', () => {
	it('Should wrap a function with a disposable', () => {
		// Setup
		const fn = () => { };

		// Run
		const result = toDisposable(fn);

		// Assert
		expect(result).toStrictEqual({ dispose: fn });
	});
});
-e 

================================================================================
// FILE: ./tests/helpers/expectations.ts
================================================================================
import { mocks } from '../mocks/vscode';

export function expectRenamedExtensionSettingToHaveBeenCalled(newSection: string, oldSection: string) {
	expect(mocks.workspaceConfiguration.inspect).toBeCalledWith(newSection);
	expect(mocks.workspaceConfiguration.inspect).toBeCalledWith(oldSection);
}

export function waitForExpect(expect: () => void) {
	return new Promise((resolve, reject) => {
		let attempts = 0;
		const testInterval = setInterval(() => {
			try {
				attempts++;
				expect();
				resolve();
			} catch (e) {
				if (attempts === 100) {
					clearInterval(testInterval);
					reject(e);
				}
			}
		}, 20);
	});
}
-e 

================================================================================
// FILE: ./tests/helpers/utils.ts
================================================================================
import { DEFAULT_REPO_STATE } from '../../src/extensionState';
import { GitRepoState } from '../../src/types';

export function mockRepoState(custom: Partial<GitRepoState> = {}): GitRepoState {
	return Object.assign({}, DEFAULT_REPO_STATE, custom);
}
-e 

================================================================================
// FILE: ./tests/statusBarItem.test.ts
================================================================================
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });
jest.mock('../src/logger');

import { ConfigurationChangeEvent } from 'vscode';
import { Logger } from '../src/logger';
import { RepoChangeEvent } from '../src/repoManager';
import { StatusBarItem } from '../src/statusBarItem';
import { EventEmitter } from '../src/utils/event';

const vscodeStatusBarItem = vscode.mocks.statusBarItem;
let onDidChangeRepos: EventEmitter<RepoChangeEvent>;
let onDidChangeConfiguration: EventEmitter<ConfigurationChangeEvent>;
let logger: Logger;

beforeAll(() => {
	onDidChangeRepos = new EventEmitter<RepoChangeEvent>();
	onDidChangeConfiguration = new EventEmitter<ConfigurationChangeEvent>();
	logger = new Logger();
});

afterAll(() => {
	logger.dispose();
});

describe('StatusBarItem', () => {
	it('Should show the Status Bar Item on vscode startup', () => {
		// Setup
		vscode.mockExtensionSettingReturnValue('showStatusBarItem', true);

		// Run
		const statusBarItem = new StatusBarItem(1, onDidChangeRepos.subscribe, onDidChangeConfiguration.subscribe, logger);

		// Assert
		expect(vscodeStatusBarItem.text).toBe('Git Graph');
		expect(vscodeStatusBarItem.tooltip).toBe('View Git Graph');
		expect(vscodeStatusBarItem.command).toBe('git-graph.view');
		expect(vscodeStatusBarItem.show).toHaveBeenCalledTimes(1);
		expect(vscodeStatusBarItem.hide).toHaveBeenCalledTimes(0);

		// Teardown
		statusBarItem.dispose();

		// Asset
		expect(vscodeStatusBarItem.dispose).toHaveBeenCalledTimes(1);
		expect(onDidChangeRepos['listeners']).toHaveLength(0);
		expect(onDidChangeConfiguration['listeners']).toHaveLength(0);
	});

	it('Should hide the Status Bar Item after the number of repositories becomes zero', () => {
		// Setup
		vscode.mockExtensionSettingReturnValue('showStatusBarItem', true);

		// Run
		const statusBarItem = new StatusBarItem(1, onDidChangeRepos.subscribe, onDidChangeConfiguration.subscribe, logger);

		// Assert
		expect(vscodeStatusBarItem.show).toHaveBeenCalledTimes(1);
		expect(vscodeStatusBarItem.hide).toHaveBeenCalledTimes(0);

		// Run
		onDidChangeRepos.emit({
			repos: {},
			numRepos: 0,
			loadRepo: null
		});

		// Assert
		expect(vscodeStatusBarItem.show).toHaveBeenCalledTimes(1);
		expect(vscodeStatusBarItem.hide).toHaveBeenCalledTimes(1);

		// Teardown
		statusBarItem.dispose();
	});

	it('Should show the Status Bar Item after the number of repositories increases above zero', () => {
		// Setup
		vscode.mockExtensionSettingReturnValue('showStatusBarItem', true);

		// Run
		const statusBarItem = new StatusBarItem(0, onDidChangeRepos.subscribe, onDidChangeConfiguration.subscribe, logger);

		// Assert
		expect(vscodeStatusBarItem.show).toHaveBeenCalledTimes(0);
		expect(vscodeStatusBarItem.hide).toHaveBeenCalledTimes(0);

		// Run
		onDidChangeRepos.emit({
			repos: {},
			numRepos: 1,
			loadRepo: null
		});

		// Assert
		expect(vscodeStatusBarItem.show).toHaveBeenCalledTimes(1);
		expect(vscodeStatusBarItem.hide).toHaveBeenCalledTimes(0);

		// Teardown
		statusBarItem.dispose();
	});

	it('Should hide the Status Bar Item the extension setting git-graph.showStatusBarItem becomes disabled', () => {
		// Setup
		vscode.mockExtensionSettingReturnValue('showStatusBarItem', true);

		// Run
		const statusBarItem = new StatusBarItem(1, onDidChangeRepos.subscribe, onDidChangeConfiguration.subscribe, logger);

		// Assert
		expect(vscodeStatusBarItem.show).toHaveBeenCalledTimes(1);
		expect(vscodeStatusBarItem.hide).toHaveBeenCalledTimes(0);

		// Run
		vscode.mockExtensionSettingReturnValue('showStatusBarItem', false);
		onDidChangeConfiguration.emit({
			affectsConfiguration: () => true
		});

		// Assert
		expect(vscodeStatusBarItem.show).toHaveBeenCalledTimes(1);
		expect(vscodeStatusBarItem.hide).toHaveBeenCalledTimes(1);

		// Teardown
		statusBarItem.dispose();
	});

	it('Should ignore extension setting changes unrelated to git-graph.showStatusBarItem', () => {
		// Setup
		vscode.mockExtensionSettingReturnValue('showStatusBarItem', true);

		// Run
		const statusBarItem = new StatusBarItem(1, onDidChangeRepos.subscribe, onDidChangeConfiguration.subscribe, logger);

		// Assert
		expect(vscodeStatusBarItem.show).toHaveBeenCalledTimes(1);
		expect(vscodeStatusBarItem.hide).toHaveBeenCalledTimes(0);

		// Run
		onDidChangeConfiguration.emit({
			affectsConfiguration: () => false
		});

		// Assert
		expect(vscodeStatusBarItem.show).toHaveBeenCalledTimes(1);
		expect(vscodeStatusBarItem.hide).toHaveBeenCalledTimes(0);

		// Teardown
		statusBarItem.dispose();
	});
});
-e 

================================================================================
// FILE: ./tests/repoFileWatcher.test.ts
================================================================================
import * as date from './mocks/date';
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });
jest.mock('../src/logger');

import { Logger } from '../src/logger';
import { RepoFileWatcher } from '../src/repoFileWatcher';

let logger: Logger;
let spyOnLog: jest.SpyInstance;

beforeAll(() => {
	logger = new Logger();
	spyOnLog = jest.spyOn(logger, 'log');
	jest.useFakeTimers();
});

afterAll(() => {
	logger.dispose();
});

describe('RepoFileWatcher', () => {
	let repoFileWatcher: RepoFileWatcher;
	let callback: jest.Mock;
	beforeEach(() => {
		callback = jest.fn();
		repoFileWatcher = new RepoFileWatcher(logger, callback);
	});

	it('Should start and receive file events', () => {
		// Setup
		repoFileWatcher.start('/path/to/repo');
		const onDidCreate = (<jest.Mock<any, any>>repoFileWatcher['fsWatcher']!.onDidCreate).mock.calls[0][0];
		const onDidChange = (<jest.Mock<any, any>>repoFileWatcher['fsWatcher']!.onDidChange).mock.calls[0][0];
		const onDidDelete = (<jest.Mock<any, any>>repoFileWatcher['fsWatcher']!.onDidDelete).mock.calls[0][0];

		// Run
		onDidCreate(vscode.Uri.file('/path/to/repo/file'));
		onDidChange(vscode.Uri.file('/path/to/repo/file'));
		onDidDelete(vscode.Uri.file('/path/to/repo/file'));
		jest.runOnlyPendingTimers();

		// Assert
		expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('/path/to/repo/**');
		expect(callback).toHaveBeenCalledTimes(1);
	});

	it('Should stop a previous active File System Watcher before creating a new one', () => {
		// Setup
		repoFileWatcher.start('/path/to/repo1');
		const watcher = repoFileWatcher['fsWatcher']!;
		const onDidCreate = (<jest.Mock<any, any>>watcher.onDidCreate).mock.calls[0][0];

		// Run
		onDidCreate(vscode.Uri.file('/path/to/repo1/file'));
		repoFileWatcher.start('/path/to/repo2');
		jest.runOnlyPendingTimers();

		// Assert
		expect(<jest.Mock<any, any>>watcher.dispose).toHaveBeenCalledTimes(1);
		expect(callback).toHaveBeenCalledTimes(0);
	});

	it('Should only dispose the active File System Watcher if it exists', () => {
		// Run
		repoFileWatcher.stop();

		// Assert
		expect(spyOnLog).toHaveBeenCalledTimes(0);
	});

	it('Should ignore file system events while muted', () => {
		// Setup
		repoFileWatcher.start('/path/to/repo');
		const onDidCreate = (<jest.Mock<any, any>>repoFileWatcher['fsWatcher']!.onDidCreate).mock.calls[0][0];

		// Run
		repoFileWatcher.mute();
		onDidCreate(vscode.Uri.file('/path/to/repo/file'));
		jest.runOnlyPendingTimers();

		// Assert
		expect(callback).toHaveBeenCalledTimes(0);
	});

	it('Should resume reporting file events after 1.5 seconds', () => {
		// Setup
		date.setCurrentTime(1587559258);
		repoFileWatcher.start('/path/to/repo');
		const onDidCreate = (<jest.Mock<any, any>>repoFileWatcher['fsWatcher']!.onDidCreate).mock.calls[0][0];
		const onDidChange = (<jest.Mock<any, any>>repoFileWatcher['fsWatcher']!.onDidChange).mock.calls[0][0];

		// Run
		repoFileWatcher.mute();
		repoFileWatcher.unmute();
		onDidCreate(vscode.Uri.file('/path/to/repo/file'));
		date.setCurrentTime(1587559260);
		onDidChange(vscode.Uri.file('/path/to/repo/file'));
		jest.runOnlyPendingTimers();

		// Assert
		expect(callback).toHaveBeenCalledTimes(1);
	});

	it('Should ignore file system events on files ignored within .git directory', () => {
		// Setup
		repoFileWatcher.start('/path/to/repo');
		const onDidCreate = (<jest.Mock<any, any>>repoFileWatcher['fsWatcher']!.onDidCreate).mock.calls[0][0];

		// Run
		onDidCreate(vscode.Uri.file('/path/to/repo/.git/config-x'));
		jest.runOnlyPendingTimers();

		// Assert
		expect(callback).toHaveBeenCalledTimes(0);
	});
});
-e 

================================================================================
// FILE: ./tests/gitGraphView.test.ts
================================================================================
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });
jest.mock('../src/avatarManager');
jest.mock('../src/dataSource');
jest.mock('../src/extensionState');
jest.mock('../src/logger');
jest.mock('../src/repoManager');

import * as path from 'path';
import { ConfigurationChangeEvent } from 'vscode';
import { AvatarEvent, AvatarManager } from '../src/avatarManager';
import { DataSource } from '../src/dataSource';
import { ExtensionState } from '../src/extensionState';
import { GitGraphView, standardiseCspSource } from '../src/gitGraphView';
import { Logger } from '../src/logger';
import { RepoChangeEvent, RepoManager } from '../src/repoManager';
import { CodeReview, CommitOrdering, GitCommitStash, GitConfigLocation, GitFileStatus, GitGraphViewGlobalState, GitGraphViewWorkspaceState, GitPushBranchMode, GitResetMode, MergeActionOn, PullRequestConfig, PullRequestProvider, RebaseActionOn, RequestMessage, ResponseMessage, TagType } from '../src/types';
import * as utils from '../src/utils';
import { EventEmitter } from '../src/utils/event';

import { waitForExpect } from './helpers/expectations';
import { mockRepoState } from './helpers/utils';

describe('GitGraphView', () => {
	let onDidChangeConfiguration: EventEmitter<ConfigurationChangeEvent>;
	let onDidChangeGitExecutable: EventEmitter<utils.GitExecutable>;
	let onDidChangeRepos: EventEmitter<RepoChangeEvent>;
	let onAvatar: EventEmitter<AvatarEvent>;

	let logger: Logger;
	let dataSource: DataSource;
	let extensionState: ExtensionState;
	let avatarManager: AvatarManager;
	let repoManager: RepoManager;

	let spyOnLog: jest.SpyInstance;
	let spyOnLogError: jest.SpyInstance;
	let spyOnGetRepos: jest.SpyInstance;
	let spyOnIsGitExecutableUnknown: jest.SpyInstance;

	beforeAll(() => {
		onDidChangeConfiguration = new EventEmitter<ConfigurationChangeEvent>();
		onDidChangeGitExecutable = new EventEmitter<utils.GitExecutable>();
		onDidChangeRepos = new EventEmitter<RepoChangeEvent>();
		onAvatar = new EventEmitter<AvatarEvent>();

		logger = new Logger();
		dataSource = new DataSource({ path: '/path/to/git', version: '2.25.0' }, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);
		extensionState = new ExtensionState(vscode.mocks.extensionContext, onDidChangeGitExecutable.subscribe);
		avatarManager = new AvatarManager(dataSource, extensionState, logger);
		repoManager = new RepoManager(dataSource, extensionState, onDidChangeConfiguration.subscribe, logger);

		spyOnLog = jest.spyOn(logger, 'log');
		spyOnLogError = jest.spyOn(logger, 'logError');
		spyOnGetRepos = jest.spyOn(repoManager, 'getRepos');
		spyOnIsGitExecutableUnknown = jest.spyOn(dataSource, 'isGitExecutableUnknown');

		spyOnGetRepos.mockReturnValue({ '/path/to/repo': mockRepoState() });
		spyOnIsGitExecutableUnknown.mockReturnValue(false);
		Object.defineProperty(repoManager, 'onDidChangeRepos', {
			get: () => onDidChangeRepos.subscribe
		});
		Object.defineProperty(avatarManager, 'onAvatar', {
			get: () => onAvatar.subscribe
		});
		jest.spyOn(extensionState, 'getLastActiveRepo').mockReturnValue(null);
	});

	afterAll(() => {
		repoManager.dispose();
		avatarManager.dispose();
		extensionState.dispose();
		dataSource.dispose();
		logger.dispose();
		onAvatar.dispose();
		onDidChangeRepos.dispose();
		onDidChangeGitExecutable.dispose();
		onDidChangeConfiguration.dispose();
	});

	afterEach(() => {
		if (GitGraphView.currentPanel) {
			GitGraphView.currentPanel.dispose();
		}
	});

	describe('WebviewPanel Construction', () => {
		it('Should construct a new WebviewPanel', () => {
			// Setup
			vscode.window.activeTextEditor = {
				document: {
					uri: vscode.Uri.file('/path/to/workspace-folder/active-file.txt')
				},
				viewColumn: vscode.ViewColumn.Two
			};

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			expect(vscode.window.createWebviewPanel).toHaveBeenCalledWith('git-graph', 'Git Graph', vscode.ViewColumn.Two, {
				enableScripts: true,
				localResourceRoots: [vscode.Uri.file(path.join('/path/to/extension', 'media'))],
				retainContextWhenHidden: true
			});
			expect(spyOnLog).toHaveBeenCalledWith('Created Git Graph View');
		});

		it('Should reveal the existing WebviewPanel (when one exists)', () => {
			// Setup
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			expect(vscode.window.createWebviewPanel).toHaveBeenCalledTimes(1);
			expect(mockedWebviewPanel.panel.reveal).toHaveBeenCalledTimes(1);
		});

		it('Should reveal the existing WebviewPanel (when one exists, but it isn\'t visible)', () => {
			// Setup
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/repo' });
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			mockedWebviewPanel.mocks.panel.setVisibility(false);

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/repo' });

			// Assert
			expect(vscode.window.createWebviewPanel).toHaveBeenCalledTimes(1);
			expect(mockedWebviewPanel.panel.reveal).toHaveBeenCalledTimes(1);
			expect(mockedWebviewPanel.mocks.messages).toStrictEqual([]);
		});

		it('Should reveal the existing WebviewPanel (when one exists), and send loadViewTo', () => {
			// Setup
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/repo' });

			// Assert
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			expect(vscode.window.createWebviewPanel).toHaveBeenCalledTimes(1);
			expect(mockedWebviewPanel.panel.reveal).toHaveBeenCalledTimes(1);
			expect(mockedWebviewPanel.mocks.messages).toStrictEqual([
				{
					command: 'loadRepos',
					lastActiveRepo: null,
					loadViewTo: { repo: '/path/to/repo' },
					repos: {
						'/path/to/repo': mockRepoState()
					}
				}
			]);
		});

		it('Should construct a new WebviewPanel, providing loadViewTo', () => {
			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/repo' });

			// Assert
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			expect(spyOnLog).toHaveBeenCalledWith('Created Git Graph View (active repo: /path/to/repo)');
			expect(mockedWebviewPanel.panel.webview.html).toContain('"loadViewTo":{"repo":"/path/to/repo"}');
		});

		it('Should construct a new WebviewPanel (no active text editor)', () => {
			// Setup
			vscode.window.activeTextEditor = undefined;

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			expect(vscode.window.createWebviewPanel).toHaveBeenCalledWith('git-graph', 'Git Graph', vscode.ViewColumn.One, {
				enableScripts: true,
				localResourceRoots: [vscode.Uri.file(path.join('/path/to/extension', 'media'))],
				retainContextWhenHidden: true
			});
			expect(spyOnLog).toHaveBeenCalledWith('Created Git Graph View');
		});

		it('Should construct a WebviewPanel with retainContextWhenHidden set to TRUE', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('retainContextWhenHidden', true);

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			expect(vscode.window.createWebviewPanel).toHaveBeenCalledWith('git-graph', 'Git Graph', vscode.ViewColumn.One, {
				enableScripts: true,
				localResourceRoots: [vscode.Uri.file(path.join('/path/to/extension', 'media'))],
				retainContextWhenHidden: true
			});
			expect(spyOnLog).toHaveBeenCalledWith('Created Git Graph View');
		});

		it('Should construct a WebviewPanel with retainContextWhenHidden set to FALSE', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('retainContextWhenHidden', false);

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			expect(vscode.window.createWebviewPanel).toHaveBeenCalledWith('git-graph', 'Git Graph', vscode.ViewColumn.One, {
				enableScripts: true,
				localResourceRoots: [vscode.Uri.file(path.join('/path/to/extension', 'media'))],
				retainContextWhenHidden: false
			});
			expect(spyOnLog).toHaveBeenCalledWith('Created Git Graph View');
		});

		it('Should construct a WebviewPanel with a colour icon', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('tabIconColourTheme', 'colour');

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			expect(mockedWebviewPanel.panel.iconPath).toStrictEqual(vscode.Uri.file(path.join('/path/to/extension', 'resources', 'webview-icon.svg')));
		});

		it('Should construct a WebviewPanel with a grey icon', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('tabIconColourTheme', 'grey');

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			expect(mockedWebviewPanel.panel.iconPath).toStrictEqual({
				light: vscode.Uri.file(path.join('/path/to/extension', 'resources', 'webview-icon-light.svg')),
				dark: vscode.Uri.file(path.join('/path/to/extension', 'resources', 'webview-icon-dark.svg'))
			});
		});

		describe('WebviewPanel.onDidDispose', () => {
			it('Should dispose the GitGraphView when the WebviewPanel is disposed', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

				// Run
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				mockedWebviewPanel.mocks.panel.onDidDispose();

				// Asset
				expect(GitGraphView.currentPanel).toBeUndefined();
			});
		});

		describe('WebviewPanel.onDidChangeViewState', () => {
			it('Should transition from visible to not-visible correctly', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				const spyOnRepoFileWatcherStop = jest.spyOn(GitGraphView.currentPanel!['repoFileWatcher'], 'stop');

				// Run
				mockedWebviewPanel.mocks.panel.setVisibility(false);

				// Assert
				expect(GitGraphView.currentPanel!['currentRepo']).toBeNull();
				expect(spyOnRepoFileWatcherStop).toHaveBeenCalledTimes(1);
				expect(GitGraphView.currentPanel!['isPanelVisible']).toBe(false);
			});

			it('Should transition from not-visible to visible correctly', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				mockedWebviewPanel.mocks.panel.setVisibility(false);
				GitGraphView.currentPanel!['panel']['webview'].html = '';

				// Run
				mockedWebviewPanel.mocks.panel.setVisibility(true);

				// Assert
				expect(mockedWebviewPanel.panel.webview.html).not.toBe('');
				expect(GitGraphView.currentPanel!['isPanelVisible']).toBe(true);
			});

			it('Should ignore events if they have no effect', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				GitGraphView.currentPanel!['panel']['webview'].html = '';

				// Run
				mockedWebviewPanel.mocks.panel.setVisibility(true);

				// Assert
				expect(mockedWebviewPanel.panel.webview.html).toBe('');
				expect(GitGraphView.currentPanel!['isPanelVisible']).toBe(true);
			});
		});

		describe('RepoManager.onDidChangeRepos', () => {
			it('Should send the updated repositories to the front-end when the view is already loaded', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

				// Run
				onDidChangeRepos.emit({
					repos: { '/path/to/repo': mockRepoState() },
					numRepos: 1,
					loadRepo: null
				});

				// Assert
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				expect(mockedWebviewPanel.mocks.messages).toStrictEqual([
					{
						command: 'loadRepos',
						lastActiveRepo: null,
						loadViewTo: null,
						repos: {
							'/path/to/repo': mockRepoState()
						}
					}
				]);
			});

			it('Should send the updated repositories to the front-end when the view is already loaded (with loadViewTo)', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

				// Run
				onDidChangeRepos.emit({
					repos: { '/path/to/repo': mockRepoState() },
					numRepos: 1,
					loadRepo: '/path/to/repo'
				});

				// Assert
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				expect(mockedWebviewPanel.mocks.messages).toStrictEqual([
					{
						command: 'loadRepos',
						lastActiveRepo: null,
						loadViewTo: {
							repo: '/path/to/repo'
						},
						repos: {
							'/path/to/repo': mockRepoState()
						}
					}
				]);
			});

			it('Shouldn\'t send the updated repositories to the front-end when the view is not visible', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				mockedWebviewPanel.mocks.panel.setVisibility(false);

				// Run
				onDidChangeRepos.emit({
					repos: { '/path/to/repo': mockRepoState() },
					numRepos: 1,
					loadRepo: null
				});

				// Assert
				expect(mockedWebviewPanel.mocks.messages).toHaveLength(0);
			});

			it('Should transition to no repositories correctly', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);
				spyOnGetRepos.mockReturnValueOnce({});

				// Run
				onDidChangeRepos.emit({
					repos: {},
					numRepos: 0,
					loadRepo: null
				});

				// Assert
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				expect(mockedWebviewPanel.mocks.messages).toHaveLength(0);
				expect(mockedWebviewPanel.panel.webview.html).toContain('No Git repositories were found');
			});

			it('Should transition from no repositories correctly', () => {
				// Setup
				spyOnGetRepos.mockReturnValueOnce({});
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

				// Run
				onDidChangeRepos.emit({
					repos: {
						'/path/to/repo': mockRepoState()
					},
					numRepos: 1,
					loadRepo: '/path/to/repo'
				});

				// Assert
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				expect(mockedWebviewPanel.mocks.messages).toHaveLength(0);
				expect(mockedWebviewPanel.panel.webview.html).toContain('"loadViewTo":{"repo":"/path/to/repo"}');
			});
		});

		describe('AvatarManager.onAvatar', () => {
			it('Should send the avatar', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

				// Run
				onAvatar.emit({
					email: 'user1@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				});

				// Assert
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				expect(mockedWebviewPanel.mocks.messages).toStrictEqual([
					{
						command: 'fetchAvatar',
						email: 'user1@mhutchie.com',
						image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
					}
				]);
			});
		});

		describe('RepoFileWatcher.repoChangeCallback', () => {
			it('Should refresh the view when it\'s visible', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

				// Run
				GitGraphView.currentPanel!['repoFileWatcher']['repoChangeCallback']();

				// Assert
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				expect(mockedWebviewPanel.mocks.messages).toStrictEqual([
					{
						command: 'refresh'
					}
				]);
			});

			it('Shouldn\'t refresh the view when it isn\'t visible', () => {
				// Setup
				GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);
				const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
				mockedWebviewPanel.mocks.panel.setVisibility(false);

				// Run
				GitGraphView.currentPanel!['repoFileWatcher']['repoChangeCallback']();

				// Assert
				expect(mockedWebviewPanel.mocks.messages).toHaveLength(0);
			});
		});
	});

	describe('respondToMessage', () => {
		let onDidReceiveMessage: (msg: RequestMessage) => void;
		let messages: ResponseMessage[];

		let spyOnRepoFileWatcherMute: jest.SpyInstance;
		let spyOnRepoFileWatcherUnmute: jest.SpyInstance;
		beforeEach(() => {
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);

			onDidReceiveMessage = mockedWebviewPanel.mocks.panel.webview.onDidReceiveMessage;
			messages = mockedWebviewPanel.mocks.messages;

			spyOnRepoFileWatcherMute = jest.spyOn(GitGraphView.currentPanel!['repoFileWatcher'], 'mute');
			spyOnRepoFileWatcherUnmute = jest.spyOn(GitGraphView.currentPanel!['repoFileWatcher'], 'unmute');
		});

		afterEach(() => {
			expect(spyOnRepoFileWatcherMute).toHaveBeenCalledWith();
			expect(spyOnRepoFileWatcherUnmute).toHaveBeenCalledWith();
		});

		describe('addRemote', () => {
			it('Should add a remote', async () => {
				// Setup
				const addRemoteResolvedValue = null;
				const spyOnAddRemote = jest.spyOn(dataSource, 'addRemote');
				spyOnAddRemote.mockResolvedValueOnce(addRemoteResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'addRemote',
					repo: '/path/to/repo',
					name: 'origin',
					url: 'url',
					pushUrl: 'pushUrl',
					fetch: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnAddRemote).toHaveBeenCalledWith('/path/to/repo', 'origin', 'url', 'pushUrl', true);
					expect(messages).toStrictEqual([
						{
							command: 'addRemote',
							error: addRemoteResolvedValue
						}
					]);
				});
			});
		});

		describe('addTag', () => {
			it('Should add a tag', async () => {
				// Setup
				const addTagResolvedValue = null;
				const spyOnAddTag = jest.spyOn(dataSource, 'addTag');
				const spyOnPushTag = jest.spyOn(dataSource, 'pushTag');
				spyOnAddTag.mockResolvedValueOnce(addTagResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'addTag',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					tagName: 'name',
					type: TagType.Annotated,
					message: 'message',
					pushToRemote: null,
					pushSkipRemoteCheck: true,
					force: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnAddTag).toHaveBeenCalledWith('/path/to/repo', 'name', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', TagType.Annotated, 'message', false);
					expect(spyOnPushTag).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'addTag',
							repo: '/path/to/repo',
							tagName: 'name',
							pushToRemote: null,
							commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							errors: [addTagResolvedValue]
						}
					]);
				});
			});

			it('Should add a tag, and then push the tag to a remote', async () => {
				// Setup
				const addTagResolvedValue = null;
				const spyOnPushTagResolvedValue = [null];
				const spyOnAddTag = jest.spyOn(dataSource, 'addTag');
				const spyOnPushTag = jest.spyOn(dataSource, 'pushTag');
				spyOnAddTag.mockResolvedValueOnce(addTagResolvedValue);
				spyOnPushTag.mockResolvedValueOnce(spyOnPushTagResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'addTag',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					tagName: 'name',
					type: TagType.Annotated,
					message: 'message',
					pushToRemote: 'origin',
					pushSkipRemoteCheck: true,
					force: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnAddTag).toHaveBeenCalledWith('/path/to/repo', 'name', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', TagType.Annotated, 'message', false);
					expect(spyOnPushTag).toHaveBeenCalledWith('/path/to/repo', 'name', ['origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);
					expect(messages).toStrictEqual([
						{
							command: 'addTag',
							repo: '/path/to/repo',
							tagName: 'name',
							pushToRemote: 'origin',
							commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							errors: [addTagResolvedValue, spyOnPushTagResolvedValue[0]]
						}
					]);
				});
			});

			it('Shouldn\'t push the tag if an error occurred when adding the tag', async () => {
				// Setup
				const addTagResolvedValue = 'error message';
				const spyOnAddTag = jest.spyOn(dataSource, 'addTag');
				const spyOnPushTag = jest.spyOn(dataSource, 'pushTag');
				spyOnAddTag.mockResolvedValueOnce(addTagResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'addTag',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					tagName: 'name',
					type: TagType.Annotated,
					message: 'message',
					pushToRemote: 'origin',
					pushSkipRemoteCheck: true,
					force: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnAddTag).toHaveBeenCalledWith('/path/to/repo', 'name', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', TagType.Annotated, 'message', false);
					expect(spyOnPushTag).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'addTag',
							repo: '/path/to/repo',
							tagName: 'name',
							pushToRemote: 'origin',
							commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							errors: [addTagResolvedValue]
						}
					]);
				});
			});
		});

		describe('applyStash', () => {
			it('Should apply a stash', async () => {
				// Setup
				const applyStashResolvedValue = null;
				const spyOnApplyStash = jest.spyOn(dataSource, 'applyStash');
				spyOnApplyStash.mockResolvedValueOnce(applyStashResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'applyStash',
					repo: '/path/to/repo',
					selector: 'refs/stash@{0}',
					reinstateIndex: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnApplyStash).toHaveBeenCalledWith('/path/to/repo', 'refs/stash@{0}', true);
					expect(messages).toStrictEqual([
						{
							command: 'applyStash',
							error: applyStashResolvedValue
						}
					]);
				});
			});
		});

		describe('branchFromStash', () => {
			it('Should create a branch from a stash', async () => {
				// Setup
				const branchFromStashResolvedValue = null;
				const spyOnBranchFromStash = jest.spyOn(dataSource, 'branchFromStash');
				spyOnBranchFromStash.mockResolvedValueOnce(branchFromStashResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'branchFromStash',
					repo: '/path/to/repo',
					selector: 'refs/stash@{0}',
					branchName: 'new-branch'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnBranchFromStash).toHaveBeenCalledWith('/path/to/repo', 'refs/stash@{0}', 'new-branch');
					expect(messages).toStrictEqual([
						{
							command: 'branchFromStash',
							error: branchFromStashResolvedValue
						}
					]);
				});
			});
		});

		describe('checkoutBranch', () => {
			it('Should check out a branch', async () => {
				// Setup
				const checkoutBranchResolvedValue = null;
				const spyOnCheckoutBranch = jest.spyOn(dataSource, 'checkoutBranch');
				const spyOnPullBranch = jest.spyOn(dataSource, 'pullBranch');
				spyOnCheckoutBranch.mockResolvedValueOnce(checkoutBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'checkoutBranch',
					repo: '/path/to/repo',
					branchName: 'develop',
					remoteBranch: 'origin/develop',
					pullAfterwards: null
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCheckoutBranch).toHaveBeenCalledWith('/path/to/repo', 'develop', 'origin/develop');
					expect(spyOnPullBranch).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'checkoutBranch',
							pullAfterwards: null,
							errors: [checkoutBranchResolvedValue]
						}
					]);
				});
			});

			it('Should check out a branch, and then pull the branch from a remote', async () => {
				// Setup
				const checkoutBranchResolvedValue = null;
				const pullBranchResolvedValue = null;
				const spyOnCheckoutBranch = jest.spyOn(dataSource, 'checkoutBranch');
				const spyOnPullBranch = jest.spyOn(dataSource, 'pullBranch');
				spyOnCheckoutBranch.mockResolvedValueOnce(checkoutBranchResolvedValue);
				spyOnPullBranch.mockResolvedValueOnce(pullBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'checkoutBranch',
					repo: '/path/to/repo',
					branchName: 'develop',
					remoteBranch: null,
					pullAfterwards: {
						branchName: 'develop',
						remote: 'origin',
						createNewCommit: true,
						squash: false
					}
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCheckoutBranch).toHaveBeenCalledWith('/path/to/repo', 'develop', null);
					expect(spyOnPullBranch).toHaveBeenCalledWith('/path/to/repo', 'develop', 'origin', true, false);
					expect(messages).toStrictEqual([
						{
							command: 'checkoutBranch',
							pullAfterwards: {
								branchName: 'develop',
								remote: 'origin',
								createNewCommit: true,
								squash: false
							},
							errors: [checkoutBranchResolvedValue, pullBranchResolvedValue]
						}
					]);
				});
			});

			it('Shouldn\'t pull the branch if an error occurred when checking out the branch', async () => {
				// Setup
				const checkoutBranchResolvedValue = 'error message';
				const spyOnCheckoutBranch = jest.spyOn(dataSource, 'checkoutBranch');
				const spyOnPullBranch = jest.spyOn(dataSource, 'pullBranch');
				spyOnCheckoutBranch.mockResolvedValueOnce(checkoutBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'checkoutBranch',
					repo: '/path/to/repo',
					branchName: 'develop',
					remoteBranch: null,
					pullAfterwards: {
						branchName: 'develop',
						remote: 'origin',
						createNewCommit: true,
						squash: false
					}
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCheckoutBranch).toHaveBeenCalledWith('/path/to/repo', 'develop', null);
					expect(spyOnPullBranch).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'checkoutBranch',
							pullAfterwards: {
								branchName: 'develop',
								remote: 'origin',
								createNewCommit: true,
								squash: false
							},
							errors: [checkoutBranchResolvedValue]
						}
					]);
				});
			});
		});

		describe('checkoutCommit', () => {
			it('Should check out a commit', async () => {
				// Setup
				const checkoutCommitResolvedValue = null;
				const spyOnCheckoutCommit = jest.spyOn(dataSource, 'checkoutCommit');
				spyOnCheckoutCommit.mockResolvedValueOnce(checkoutCommitResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'checkoutCommit',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCheckoutCommit).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');
					expect(messages).toStrictEqual([
						{
							command: 'checkoutCommit',
							error: checkoutCommitResolvedValue
						}
					]);
				});
			});
		});

		describe('cherrypickCommit', () => {
			it('Should cherrypick a commit', async () => {
				// Setup
				const cherrypickCommitResolvedValue = null;
				const spyOnCherrypickCommit = jest.spyOn(dataSource, 'cherrypickCommit');
				const spyOnViewScm = jest.spyOn(utils, 'viewScm');
				spyOnCherrypickCommit.mockResolvedValueOnce(cherrypickCommitResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'cherrypickCommit',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parentIndex: 1,
					recordOrigin: true,
					noCommit: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCherrypickCommit).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 1, true, false);
					expect(spyOnViewScm).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'cherrypickCommit',
							errors: [cherrypickCommitResolvedValue]
						}
					]);
				});
			});

			it('Should cherrypick a commit, and then open the Visual Studio Code Source Control View', async () => {
				// Setup
				const cherrypickCommitResolvedValue = null;
				const viewScmResolvedValue = null;
				const spyOnCherrypickCommit = jest.spyOn(dataSource, 'cherrypickCommit');
				const spyOnViewScm = jest.spyOn(utils, 'viewScm');
				spyOnCherrypickCommit.mockResolvedValueOnce(cherrypickCommitResolvedValue);
				spyOnViewScm.mockResolvedValueOnce(viewScmResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'cherrypickCommit',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parentIndex: 1,
					recordOrigin: false,
					noCommit: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCherrypickCommit).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 1, false, true);
					expect(spyOnViewScm).toHaveBeenCalledWith();
					expect(messages).toStrictEqual([
						{
							command: 'cherrypickCommit',
							errors: [cherrypickCommitResolvedValue, viewScmResolvedValue]
						}
					]);
				});
			});

			it('Shouldn\'t open the Visual Studio Code Source Control View if an error occurred when cherrypicking the commit', async () => {
				// Setup
				const cherrypickCommitResolvedValue = 'error message';
				const spyOnCherrypickCommit = jest.spyOn(dataSource, 'cherrypickCommit');
				const spyOnViewScm = jest.spyOn(utils, 'viewScm');
				spyOnCherrypickCommit.mockResolvedValueOnce(cherrypickCommitResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'cherrypickCommit',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parentIndex: 1,
					recordOrigin: false,
					noCommit: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCherrypickCommit).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 1, false, true);
					expect(spyOnViewScm).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'cherrypickCommit',
							errors: [cherrypickCommitResolvedValue]
						}
					]);
				});
			});
		});

		describe('cleanUntrackedFiles', () => {
			it('Should clean the untracked files', async () => {
				// Setup
				const cleanUntrackedFilesResolvedValue = null;
				const spyOnCleanUntrackedFiles = jest.spyOn(dataSource, 'cleanUntrackedFiles');
				spyOnCleanUntrackedFiles.mockResolvedValueOnce(cleanUntrackedFilesResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'cleanUntrackedFiles',
					repo: '/path/to/repo',
					directories: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCleanUntrackedFiles).toHaveBeenCalledWith('/path/to/repo', true);
					expect(messages).toStrictEqual([
						{
							command: 'cleanUntrackedFiles',
							error: cleanUntrackedFilesResolvedValue
						}
					]);
				});
			});
		});

		describe('commitDetails', () => {
			it('Should get the data for the Commit Details View', async () => {
				// Setup
				const getCommitDetailsResolvedValue = { commitDetails: null, error: null };
				const getAvatarImageResolvedValue = 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE=';
				const getCodeReviewResolvedValue: CodeReview = {
					id: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					lastActive: 1587559258000,
					lastViewedFile: 'file1.txt',
					remainingFiles: ['file2.txt', 'file3.txt']
				};
				const spyOnGetCommitDetails = jest.spyOn(dataSource, 'getCommitDetails');
				const spyOnGetAvatarImage = jest.spyOn(avatarManager, 'getAvatarImage');
				const spyOnGetCodeReview = jest.spyOn(extensionState, 'getCodeReview');
				spyOnGetCommitDetails.mockResolvedValueOnce(getCommitDetailsResolvedValue);
				spyOnGetAvatarImage.mockResolvedValueOnce(getAvatarImageResolvedValue);
				spyOnGetCodeReview.mockReturnValueOnce(getCodeReviewResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'commitDetails',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					hasParents: true,
					stash: null,
					avatarEmail: 'user@mhutchie.com',
					refresh: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetCommitDetails).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);
					expect(spyOnGetAvatarImage).toHaveBeenCalledWith('user@mhutchie.com');
					expect(spyOnGetCodeReview).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');
					expect(messages).toStrictEqual([
						{
							command: 'commitDetails',
							commitDetails: null,
							avatar: getAvatarImageResolvedValue,
							codeReview: getCodeReviewResolvedValue,
							refresh: false,
							error: null
						}
					]);
				});
			});

			it('Should get the data for the Commit Details View (Uncommitted Changes)', async () => {
				// Setup
				const getUncommittedDetailsResolvedValue = { commitDetails: null, error: null };
				const spyOnGetUncommittedDetails = jest.spyOn(dataSource, 'getUncommittedDetails');
				const spyOnGetAvatarImage = jest.spyOn(avatarManager, 'getAvatarImage');
				const spyOnGetCodeReview = jest.spyOn(extensionState, 'getCodeReview');
				spyOnGetUncommittedDetails.mockResolvedValueOnce(getUncommittedDetailsResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'commitDetails',
					repo: '/path/to/repo',
					commitHash: utils.UNCOMMITTED,
					hasParents: true,
					stash: null,
					avatarEmail: null,
					refresh: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetUncommittedDetails).toHaveBeenCalledWith('/path/to/repo');
					expect(spyOnGetAvatarImage).not.toHaveBeenCalled();
					expect(spyOnGetCodeReview).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'commitDetails',
							commitDetails: null,
							avatar: null,
							codeReview: null,
							refresh: false,
							error: null
						}
					]);
				});
			});

			it('Should get the data for the Commit Details View (Stash)', async () => {
				// Setup
				const stash: GitCommitStash = {
					selector: 'refs/stash@{0}',
					baseHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					untrackedFilesHash: null
				};
				const getStashDetailsResolvedValue = { commitDetails: null, error: null };
				const getCodeReviewResolvedValue = null;
				const spyOnGetStashDetails = jest.spyOn(dataSource, 'getStashDetails');
				const spyOnGetAvatarImage = jest.spyOn(avatarManager, 'getAvatarImage');
				const spyOnGetCodeReview = jest.spyOn(extensionState, 'getCodeReview');
				spyOnGetStashDetails.mockResolvedValueOnce(getStashDetailsResolvedValue);
				spyOnGetCodeReview.mockReturnValueOnce(getCodeReviewResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'commitDetails',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					hasParents: true,
					stash: stash,
					avatarEmail: null,
					refresh: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetStashDetails).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', stash);
					expect(spyOnGetAvatarImage).not.toHaveBeenCalled();
					expect(spyOnGetCodeReview).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');
					expect(messages).toStrictEqual([
						{
							command: 'commitDetails',
							commitDetails: null,
							avatar: null,
							codeReview: getCodeReviewResolvedValue,
							refresh: false,
							error: null
						}
					]);
				});
			});
		});

		describe('compareCommits', () => {
			it('Should get the data for the Commit Details View (Comparison)', async () => {
				// Setup
				const getCommitComparisonResolvedValue = { fileChanges: [], error: null };
				const getCodeReviewResolvedValue: CodeReview = {
					id: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2-1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					lastActive: 1587559258000,
					lastViewedFile: 'file1.txt',
					remainingFiles: ['file2.txt', 'file3.txt']
				};
				const spyOnGetCommitComparison = jest.spyOn(dataSource, 'getCommitComparison');
				const spyOnGetCodeReview = jest.spyOn(extensionState, 'getCodeReview');
				spyOnGetCommitComparison.mockResolvedValueOnce(getCommitComparisonResolvedValue);
				spyOnGetCodeReview.mockReturnValueOnce(getCodeReviewResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'compareCommits',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					compareWithHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					fromHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					toHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					refresh: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetCommitComparison).toHaveBeenCalledWith('/path/to/repo', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');
					expect(spyOnGetCodeReview).toHaveBeenCalledWith('/path/to/repo', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2-1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');
					expect(messages).toStrictEqual([
						{
							command: 'compareCommits',
							commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							compareWithHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
							fileChanges: [],
							codeReview: getCodeReviewResolvedValue,
							refresh: false,
							error: null
						}
					]);
				});
			});

			it('Should get the data for the Commit Details View (Comparison with the Uncommitted Changes)', async () => {
				// Setup
				const getCommitComparisonResolvedValue = { fileChanges: [], error: null };
				const spyOnGetCommitComparison = jest.spyOn(dataSource, 'getCommitComparison');
				const spyOnGetCodeReview = jest.spyOn(extensionState, 'getCodeReview');
				spyOnGetCommitComparison.mockResolvedValueOnce(getCommitComparisonResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'compareCommits',
					repo: '/path/to/repo',
					commitHash: utils.UNCOMMITTED,
					compareWithHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					fromHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					toHash: utils.UNCOMMITTED,
					refresh: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetCommitComparison).toHaveBeenCalledWith('/path/to/repo', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', utils.UNCOMMITTED);
					expect(spyOnGetCodeReview).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'compareCommits',
							commitHash: utils.UNCOMMITTED,
							compareWithHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
							fileChanges: [],
							codeReview: null,
							refresh: false,
							error: null
						}
					]);
				});
			});
		});

		describe('copyFilePath', () => {
			it('Should copy a file path to the clipboard', async () => {
				// Setup
				const copyFilePathToClipboardResolvedValue = null;
				const spyOnCopyFilePathToClipboard = jest.spyOn(utils, 'copyFilePathToClipboard');
				spyOnCopyFilePathToClipboard.mockResolvedValueOnce(copyFilePathToClipboardResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'copyFilePath',
					repo: '/path/to/repo',
					filePath: 'file.txt',
					absolute: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCopyFilePathToClipboard).toHaveBeenCalledWith('/path/to/repo', 'file.txt', true);
					expect(messages).toStrictEqual([
						{
							command: 'copyFilePath',
							error: copyFilePathToClipboardResolvedValue
						}
					]);
				});
			});
		});

		describe('copyToClipboard', () => {
			it('Should copy text to the clipboard', async () => {
				// Setup
				const copyToClipboardResolvedValue = null;
				const spyOnCopyToClipboard = jest.spyOn(utils, 'copyToClipboard');
				spyOnCopyToClipboard.mockResolvedValueOnce(copyToClipboardResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'copyToClipboard',
					type: 'Branch Name',
					data: 'master'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCopyToClipboard).toHaveBeenCalledWith('master');
					expect(messages).toStrictEqual([
						{
							command: 'copyToClipboard',
							type: 'Branch Name',
							error: copyToClipboardResolvedValue
						}
					]);
				});
			});
		});

		describe('createArchive', () => {
			it('Should create an archive', async () => {
				// Setup
				const archiveResolvedValue = null;
				const spyOnArchive = jest.spyOn(utils, 'archive');
				spyOnArchive.mockResolvedValueOnce(archiveResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'createArchive',
					repo: '/path/to/repo',
					ref: 'master'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnArchive).toHaveBeenCalledWith('/path/to/repo', 'master', dataSource);
					expect(messages).toStrictEqual([
						{
							command: 'createArchive',
							error: archiveResolvedValue
						}
					]);
				});
			});
		});

		describe('createBranch', () => {
			it('Should create a branch', async () => {
				// Setup
				const createBranchResolvedValue = [null];
				const spyOnCreateBranch = jest.spyOn(dataSource, 'createBranch');
				spyOnCreateBranch.mockResolvedValueOnce(createBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'createBranch',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					branchName: 'feature-1',
					checkout: true,
					force: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCreateBranch).toHaveBeenCalledWith('/path/to/repo', 'feature-1', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true, false);
					expect(messages).toStrictEqual([
						{
							command: 'createBranch',
							errors: createBranchResolvedValue
						}
					]);
				});
			});
		});

		describe('createPullRequest', () => {
			it('Should create a pull request', async () => {
				// Setup
				const pullRequestConfig: PullRequestConfig = {
					provider: PullRequestProvider.Bitbucket,
					custom: null,
					hostRootUrl: 'https://bitbucket.org',
					sourceOwner: 'sourceOwner',
					sourceRepo: 'sourceRepo',
					sourceRemote: 'sourceRemote',
					destOwner: 'destOwner',
					destRepo: 'destRepo',
					destBranch: 'destBranch',
					destRemote: 'destRemote',
					destProjectId: 'destProjectId'
				};
				const createPullRequestResolvedValue = null;
				const spyOnPushBranch = jest.spyOn(dataSource, 'pushBranch');
				const spyOnCreatePullRequest = jest.spyOn(utils, 'createPullRequest');
				spyOnCreatePullRequest.mockResolvedValueOnce(createPullRequestResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'createPullRequest',
					repo: '/path/to/repo',
					config: pullRequestConfig,
					sourceRemote: 'origin',
					sourceOwner: 'sourceOwner',
					sourceRepo: 'sourceRepo',
					sourceBranch: 'sourceBranch',
					push: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnPushBranch).not.toHaveBeenCalled();
					expect(spyOnCreatePullRequest).toHaveBeenCalledWith(pullRequestConfig, 'sourceOwner', 'sourceRepo', 'sourceBranch');
					expect(messages).toStrictEqual([
						{
							command: 'createPullRequest',
							push: false,
							errors: [null, createPullRequestResolvedValue]
						}
					]);
				});
			});

			it('Should push the branch, and then create a pull request', async () => {
				// Setup
				const pullRequestConfig: PullRequestConfig = {
					provider: PullRequestProvider.Bitbucket,
					custom: null,
					hostRootUrl: 'https://bitbucket.org',
					sourceOwner: 'sourceOwner',
					sourceRepo: 'sourceRepo',
					sourceRemote: 'sourceRemote',
					destOwner: 'destOwner',
					destRepo: 'destRepo',
					destBranch: 'destBranch',
					destRemote: 'destRemote',
					destProjectId: 'destProjectId'
				};
				const pushBranchResolvedValue = null;
				const createPullRequestResolvedValue = null;
				const spyOnPushBranch = jest.spyOn(dataSource, 'pushBranch');
				const spyOnCreatePullRequest = jest.spyOn(utils, 'createPullRequest');
				spyOnPushBranch.mockResolvedValueOnce(pushBranchResolvedValue);
				spyOnCreatePullRequest.mockResolvedValueOnce(createPullRequestResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'createPullRequest',
					repo: '/path/to/repo',
					config: pullRequestConfig,
					sourceRemote: 'origin',
					sourceOwner: 'sourceOwner',
					sourceRepo: 'sourceRepo',
					sourceBranch: 'sourceBranch',
					push: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnPushBranch).toHaveBeenCalledWith('/path/to/repo', 'sourceBranch', 'origin', true, GitPushBranchMode.Normal);
					expect(spyOnCreatePullRequest).toHaveBeenCalledWith(pullRequestConfig, 'sourceOwner', 'sourceRepo', 'sourceBranch');

					expect(messages).toStrictEqual([
						{
							command: 'createPullRequest',
							push: true,
							errors: [pushBranchResolvedValue, createPullRequestResolvedValue]
						}
					]);
				});
			});

			it('Shouldn\'t create a pull request if an error occurred when pushing the branch', async () => {
				// Setup
				const pullRequestConfig: PullRequestConfig = {
					provider: PullRequestProvider.Bitbucket,
					custom: null,
					hostRootUrl: 'https://bitbucket.org',
					sourceOwner: 'sourceOwner',
					sourceRepo: 'sourceRepo',
					sourceRemote: 'sourceRemote',
					destOwner: 'destOwner',
					destRepo: 'destRepo',
					destBranch: 'destBranch',
					destRemote: 'destRemote',
					destProjectId: 'destProjectId'
				};
				const pushBranchResolvedValue = 'error message';
				const spyOnPushBranch = jest.spyOn(dataSource, 'pushBranch');
				const spyOnCreatePullRequest = jest.spyOn(utils, 'createPullRequest');
				spyOnPushBranch.mockResolvedValueOnce(pushBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'createPullRequest',
					repo: '/path/to/repo',
					config: pullRequestConfig,
					sourceRemote: 'origin',
					sourceOwner: 'sourceOwner',
					sourceRepo: 'sourceRepo',
					sourceBranch: 'sourceBranch',
					push: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnPushBranch).toHaveBeenCalledWith('/path/to/repo', 'sourceBranch', 'origin', true, GitPushBranchMode.Normal);
					expect(spyOnCreatePullRequest).not.toHaveBeenCalled();

					expect(messages).toStrictEqual([
						{
							command: 'createPullRequest',
							push: true,
							errors: [pushBranchResolvedValue]
						}
					]);
				});
			});
		});

		describe('deleteBranch', () => {
			it('Should delete a branch', async () => {
				// Setup
				const deleteBranchResolvedValue = null;
				const spyOnDeleteBranch = jest.spyOn(dataSource, 'deleteBranch');
				const spyOnDeleteRemoteBranch = jest.spyOn(dataSource, 'deleteRemoteBranch');
				spyOnDeleteBranch.mockResolvedValueOnce(deleteBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'deleteBranch',
					repo: '/path/to/repo',
					branchName: 'feature-1',
					forceDelete: false,
					deleteOnRemotes: []
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnDeleteBranch).toHaveBeenCalledWith('/path/to/repo', 'feature-1', false);
					expect(spyOnDeleteRemoteBranch).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'deleteBranch',
							repo: '/path/to/repo',
							branchName: 'feature-1',
							deleteOnRemotes: [],
							errors: [deleteBranchResolvedValue]
						}
					]);
				});
			});

			it('Should delete a branch, and then delete the branch on the specified remotes', async () => {
				// Setup
				const deleteBranchResolvedValue = null;
				const deleteRemoteBranchResolvedValue1 = null;
				const deleteRemoteBranchResolvedValue2 = null;
				const spyOnDeleteBranch = jest.spyOn(dataSource, 'deleteBranch');
				const spyOnDeleteRemoteBranch = jest.spyOn(dataSource, 'deleteRemoteBranch');
				spyOnDeleteBranch.mockResolvedValueOnce(deleteBranchResolvedValue);
				spyOnDeleteRemoteBranch.mockResolvedValueOnce(deleteRemoteBranchResolvedValue1);
				spyOnDeleteRemoteBranch.mockResolvedValueOnce(deleteRemoteBranchResolvedValue2);

				// Run
				onDidReceiveMessage({
					command: 'deleteBranch',
					repo: '/path/to/repo',
					branchName: 'feature-1',
					forceDelete: false,
					deleteOnRemotes: ['origin', 'upstream']
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnDeleteBranch).toHaveBeenCalledWith('/path/to/repo', 'feature-1', false);
					expect(spyOnDeleteRemoteBranch).toHaveBeenNthCalledWith(1, '/path/to/repo', 'feature-1', 'origin');
					expect(spyOnDeleteRemoteBranch).toHaveBeenNthCalledWith(2, '/path/to/repo', 'feature-1', 'upstream');
					expect(messages).toStrictEqual([
						{
							command: 'deleteBranch',
							repo: '/path/to/repo',
							branchName: 'feature-1',
							deleteOnRemotes: ['origin', 'upstream'],
							errors: [deleteBranchResolvedValue, deleteRemoteBranchResolvedValue1, deleteRemoteBranchResolvedValue2]
						}
					]);
				});
			});

			it('Shouldn\'t delete a branch on a remote if an error occurred when deleting the local branch', async () => {
				// Setup
				const deleteBranchResolvedValue = 'error message';
				const spyOnDeleteBranch = jest.spyOn(dataSource, 'deleteBranch');
				const spyOnDeleteRemoteBranch = jest.spyOn(dataSource, 'deleteRemoteBranch');
				spyOnDeleteBranch.mockResolvedValueOnce(deleteBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'deleteBranch',
					repo: '/path/to/repo',
					branchName: 'feature-1',
					forceDelete: false,
					deleteOnRemotes: ['origin', 'upstream']
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnDeleteBranch).toHaveBeenCalledWith('/path/to/repo', 'feature-1', false);
					expect(spyOnDeleteRemoteBranch).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'deleteBranch',
							repo: '/path/to/repo',
							branchName: 'feature-1',
							deleteOnRemotes: ['origin', 'upstream'],
							errors: [deleteBranchResolvedValue]
						}
					]);
				});
			});
		});

		describe('deleteRemote', () => {
			it('Should delete a remote', async () => {
				// Setup
				const deleteRemoteResolvedValue = null;
				const spyOnDeleteRemote = jest.spyOn(dataSource, 'deleteRemote');
				spyOnDeleteRemote.mockResolvedValueOnce(deleteRemoteResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'deleteRemote',
					repo: '/path/to/repo',
					name: 'origin'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnDeleteRemote).toHaveBeenCalledWith('/path/to/repo', 'origin');
					expect(messages).toStrictEqual([
						{
							command: 'deleteRemote',
							error: deleteRemoteResolvedValue
						}
					]);
				});
			});
		});

		describe('deleteRemoteBranch', () => {
			it('Should delete a remote branch', async () => {
				// Setup
				const deleteRemoteBranchResolvedValue = null;
				const spyOnDeleteRemoteBranch = jest.spyOn(dataSource, 'deleteRemoteBranch');
				spyOnDeleteRemoteBranch.mockResolvedValueOnce(deleteRemoteBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'deleteRemoteBranch',
					repo: '/path/to/repo',
					branchName: 'feature-1',
					remote: 'origin'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnDeleteRemoteBranch).toHaveBeenCalledWith('/path/to/repo', 'feature-1', 'origin');
					expect(messages).toStrictEqual([
						{
							command: 'deleteRemoteBranch',
							error: deleteRemoteBranchResolvedValue
						}
					]);
				});
			});
		});

		describe('deleteTag', () => {
			it('Should delete a tag', async () => {
				// Setup
				const deleteTagResolvedValue = null;
				const spyOnDeleteTag = jest.spyOn(dataSource, 'deleteTag');
				spyOnDeleteTag.mockResolvedValueOnce(deleteTagResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'deleteTag',
					repo: '/path/to/repo',
					tagName: 'v1.0',
					deleteOnRemote: null
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnDeleteTag).toHaveBeenCalledWith('/path/to/repo', 'v1.0', null);
					expect(messages).toStrictEqual([
						{
							command: 'deleteTag',
							error: deleteTagResolvedValue
						}
					]);
				});
			});
		});

		describe('deleteUserDetails', () => {
			it('Should delete user.name and user.email', async () => {
				// Setup
				const unsetConfigValueResolvedValue1 = null;
				const unsetConfigValueResolvedValue2 = null;
				const spyOnUnsetConfigValue = jest.spyOn(dataSource, 'unsetConfigValue');
				spyOnUnsetConfigValue.mockResolvedValueOnce(unsetConfigValueResolvedValue1);
				spyOnUnsetConfigValue.mockResolvedValueOnce(unsetConfigValueResolvedValue2);

				// Run
				onDidReceiveMessage({
					command: 'deleteUserDetails',
					repo: '/path/to/repo',
					name: true,
					email: true,
					location: GitConfigLocation.Local
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnUnsetConfigValue).toHaveBeenNthCalledWith(1, '/path/to/repo', 'user.name', GitConfigLocation.Local);
					expect(spyOnUnsetConfigValue).toHaveBeenNthCalledWith(2, '/path/to/repo', 'user.email', GitConfigLocation.Local);
					expect(messages).toStrictEqual([
						{
							command: 'deleteUserDetails',
							errors: [unsetConfigValueResolvedValue1, unsetConfigValueResolvedValue2]
						}
					]);
				});
			});

			it('Should only delete user.name', async () => {
				// Setup
				const unsetConfigValueResolvedValue = null;
				const spyOnUnsetConfigValue = jest.spyOn(dataSource, 'unsetConfigValue');
				spyOnUnsetConfigValue.mockResolvedValueOnce(unsetConfigValueResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'deleteUserDetails',
					repo: '/path/to/repo',
					name: true,
					email: false,
					location: GitConfigLocation.Global
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnUnsetConfigValue).toHaveBeenCalledTimes(1);
					expect(spyOnUnsetConfigValue).toHaveBeenCalledWith('/path/to/repo', 'user.name', GitConfigLocation.Global);
					expect(messages).toStrictEqual([
						{
							command: 'deleteUserDetails',
							errors: [unsetConfigValueResolvedValue]
						}
					]);
				});
			});

			it('Should only delete user.email', async () => {
				// Setup
				const unsetConfigValueResolvedValue = null;
				const spyOnUnsetConfigValue = jest.spyOn(dataSource, 'unsetConfigValue');
				spyOnUnsetConfigValue.mockResolvedValueOnce(unsetConfigValueResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'deleteUserDetails',
					repo: '/path/to/repo',
					name: false,
					email: true,
					location: GitConfigLocation.Global
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnUnsetConfigValue).toHaveBeenCalledTimes(1);
					expect(spyOnUnsetConfigValue).toHaveBeenCalledWith('/path/to/repo', 'user.email', GitConfigLocation.Global);
					expect(messages).toStrictEqual([
						{
							command: 'deleteUserDetails',
							errors: [unsetConfigValueResolvedValue]
						}
					]);
				});
			});
		});

		describe('dropCommit', () => {
			it('Should drop a commit', async () => {
				// Setup
				const dropCommitResolvedValue = null;
				const spyOnDropCommit = jest.spyOn(dataSource, 'dropCommit');
				spyOnDropCommit.mockResolvedValueOnce(dropCommitResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'dropCommit',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnDropCommit).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');
					expect(messages).toStrictEqual([
						{
							command: 'dropCommit',
							error: dropCommitResolvedValue
						}
					]);
				});
			});
		});

		describe('dropStash', () => {
			it('Should drop a stash', async () => {
				// Setup
				const dropStashResolvedValue = null;
				const spyOnDropStash = jest.spyOn(dataSource, 'dropStash');
				spyOnDropStash.mockResolvedValueOnce(dropStashResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'dropStash',
					repo: '/path/to/repo',
					selector: 'refs/stash@{0}'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnDropStash).toHaveBeenCalledWith('/path/to/repo', 'refs/stash@{0}');
					expect(messages).toStrictEqual([
						{
							command: 'dropStash',
							error: dropStashResolvedValue
						}
					]);
				});
			});
		});

		describe('editRemote', () => {
			it('Should edit a remote', async () => {
				// Setup
				const editRemoteResolvedValue = null;
				const spyOnEditRemote = jest.spyOn(dataSource, 'editRemote');
				spyOnEditRemote.mockResolvedValueOnce(editRemoteResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'editRemote',
					repo: '/path/to/repo',
					nameOld: 'old-origin',
					nameNew: 'new-origin',
					urlOld: 'https://github.com/mhutchie/old.git',
					urlNew: 'https://github.com/mhutchie/new.git',
					pushUrlOld: 'https://github.com/mhutchie/old-push.git',
					pushUrlNew: 'https://github.com/mhutchie/new-push.git'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnEditRemote).toHaveBeenCalledWith('/path/to/repo', 'old-origin', 'new-origin', 'https://github.com/mhutchie/old.git', 'https://github.com/mhutchie/new.git', 'https://github.com/mhutchie/old-push.git', 'https://github.com/mhutchie/new-push.git');
					expect(messages).toStrictEqual([
						{
							command: 'editRemote',
							error: editRemoteResolvedValue
						}
					]);
				});
			});
		});

		describe('editUserDetails', () => {
			it('Should edit the local user.name and user.email', async () => {
				// Setup
				const setConfigValueResolvedValue1 = null;
				const setConfigValueResolvedValue2 = null;
				const spyOnSetConfigValue = jest.spyOn(dataSource, 'setConfigValue');
				const spyOnUnsetConfigValue = jest.spyOn(dataSource, 'unsetConfigValue');
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue1);
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue2);

				// Run
				onDidReceiveMessage({
					command: 'editUserDetails',
					repo: '/path/to/repo',
					name: 'name',
					email: 'user@mhutchie.com',
					location: GitConfigLocation.Local,
					deleteLocalName: false,
					deleteLocalEmail: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(1, '/path/to/repo', 'user.name', 'name', GitConfigLocation.Local);
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(2, '/path/to/repo', 'user.email', 'user@mhutchie.com', GitConfigLocation.Local);
					expect(spyOnUnsetConfigValue).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'editUserDetails',
							errors: [setConfigValueResolvedValue1, setConfigValueResolvedValue2]
						}
					]);
				});
			});

			it('Should edit the global user.name and user.email, and delete the local user.name and user.email', async () => {
				// Setup
				const setConfigValueResolvedValue1 = null;
				const setConfigValueResolvedValue2 = null;
				const unsetConfigValueResolvedValue1 = null;
				const unsetConfigValueResolvedValue2 = null;
				const spyOnSetConfigValue = jest.spyOn(dataSource, 'setConfigValue');
				const spyOnUnsetConfigValue = jest.spyOn(dataSource, 'unsetConfigValue');
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue1);
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue2);
				spyOnUnsetConfigValue.mockResolvedValueOnce(unsetConfigValueResolvedValue1);
				spyOnUnsetConfigValue.mockResolvedValueOnce(unsetConfigValueResolvedValue2);

				// Run
				onDidReceiveMessage({
					command: 'editUserDetails',
					repo: '/path/to/repo',
					name: 'name',
					email: 'user@mhutchie.com',
					location: GitConfigLocation.Global,
					deleteLocalName: true,
					deleteLocalEmail: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(1, '/path/to/repo', 'user.name', 'name', GitConfigLocation.Global);
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(2, '/path/to/repo', 'user.email', 'user@mhutchie.com', GitConfigLocation.Global);
					expect(spyOnUnsetConfigValue).toHaveBeenNthCalledWith(1, '/path/to/repo', 'user.name', GitConfigLocation.Local);
					expect(spyOnUnsetConfigValue).toHaveBeenNthCalledWith(2, '/path/to/repo', 'user.email', GitConfigLocation.Local);
					expect(messages).toStrictEqual([
						{
							command: 'editUserDetails',
							errors: [setConfigValueResolvedValue1, setConfigValueResolvedValue2, unsetConfigValueResolvedValue1, unsetConfigValueResolvedValue2]
						}
					]);
				});
			});

			it('Should edit the global user.name and user.email, and only delete the local user.name', async () => {
				// Setup
				const setConfigValueResolvedValue1 = null;
				const setConfigValueResolvedValue2 = null;
				const unsetConfigValueResolvedValue = null;
				const spyOnSetConfigValue = jest.spyOn(dataSource, 'setConfigValue');
				const spyOnUnsetConfigValue = jest.spyOn(dataSource, 'unsetConfigValue');
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue1);
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue2);
				spyOnUnsetConfigValue.mockResolvedValueOnce(unsetConfigValueResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'editUserDetails',
					repo: '/path/to/repo',
					name: 'name',
					email: 'user@mhutchie.com',
					location: GitConfigLocation.Global,
					deleteLocalName: true,
					deleteLocalEmail: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(1, '/path/to/repo', 'user.name', 'name', GitConfigLocation.Global);
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(2, '/path/to/repo', 'user.email', 'user@mhutchie.com', GitConfigLocation.Global);
					expect(spyOnUnsetConfigValue).toHaveBeenCalledTimes(1);
					expect(spyOnUnsetConfigValue).toHaveBeenCalledWith('/path/to/repo', 'user.name', GitConfigLocation.Local);
					expect(messages).toStrictEqual([
						{
							command: 'editUserDetails',
							errors: [setConfigValueResolvedValue1, setConfigValueResolvedValue2, unsetConfigValueResolvedValue]
						}
					]);
				});
			});

			it('Should edit the global user.name and user.email, and only delete the local user.email', async () => {
				// Setup
				const setConfigValueResolvedValue1 = null;
				const setConfigValueResolvedValue2 = null;
				const unsetConfigValueResolvedValue = null;
				const spyOnSetConfigValue = jest.spyOn(dataSource, 'setConfigValue');
				const spyOnUnsetConfigValue = jest.spyOn(dataSource, 'unsetConfigValue');
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue1);
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue2);
				spyOnUnsetConfigValue.mockResolvedValueOnce(unsetConfigValueResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'editUserDetails',
					repo: '/path/to/repo',
					name: 'name',
					email: 'user@mhutchie.com',
					location: GitConfigLocation.Global,
					deleteLocalName: false,
					deleteLocalEmail: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(1, '/path/to/repo', 'user.name', 'name', GitConfigLocation.Global);
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(2, '/path/to/repo', 'user.email', 'user@mhutchie.com', GitConfigLocation.Global);
					expect(spyOnUnsetConfigValue).toHaveBeenCalledTimes(1);
					expect(spyOnUnsetConfigValue).toHaveBeenCalledWith('/path/to/repo', 'user.email', GitConfigLocation.Local);
					expect(messages).toStrictEqual([
						{
							command: 'editUserDetails',
							errors: [setConfigValueResolvedValue1, setConfigValueResolvedValue2, unsetConfigValueResolvedValue]
						}
					]);
				});
			});

			it('Shouldn\'t delete the local user.name or user.email if an error occurred when editing the global user.name', async () => {
				// Setup
				const setConfigValueResolvedValue1 = 'error message';
				const setConfigValueResolvedValue2 = null;
				const spyOnSetConfigValue = jest.spyOn(dataSource, 'setConfigValue');
				const spyOnUnsetConfigValue = jest.spyOn(dataSource, 'unsetConfigValue');
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue1);
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue2);

				// Run
				onDidReceiveMessage({
					command: 'editUserDetails',
					repo: '/path/to/repo',
					name: 'name',
					email: 'user@mhutchie.com',
					location: GitConfigLocation.Global,
					deleteLocalName: true,
					deleteLocalEmail: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(1, '/path/to/repo', 'user.name', 'name', GitConfigLocation.Global);
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(2, '/path/to/repo', 'user.email', 'user@mhutchie.com', GitConfigLocation.Global);
					expect(spyOnUnsetConfigValue).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'editUserDetails',
							errors: [setConfigValueResolvedValue1, setConfigValueResolvedValue2]
						}
					]);
				});
			});

			it('Shouldn\'t delete the local user.name or user.email if an error occurred when editing the global user.email', async () => {
				// Setup
				const setConfigValueResolvedValue1 = null;
				const setConfigValueResolvedValue2 = 'error message';
				const spyOnSetConfigValue = jest.spyOn(dataSource, 'setConfigValue');
				const spyOnUnsetConfigValue = jest.spyOn(dataSource, 'unsetConfigValue');
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue1);
				spyOnSetConfigValue.mockResolvedValueOnce(setConfigValueResolvedValue2);

				// Run
				onDidReceiveMessage({
					command: 'editUserDetails',
					repo: '/path/to/repo',
					name: 'name',
					email: 'user@mhutchie.com',
					location: GitConfigLocation.Global,
					deleteLocalName: true,
					deleteLocalEmail: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(1, '/path/to/repo', 'user.name', 'name', GitConfigLocation.Global);
					expect(spyOnSetConfigValue).toHaveBeenNthCalledWith(2, '/path/to/repo', 'user.email', 'user@mhutchie.com', GitConfigLocation.Global);
					expect(spyOnUnsetConfigValue).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'editUserDetails',
							errors: [setConfigValueResolvedValue1, setConfigValueResolvedValue2]
						}
					]);
				});
			});
		});

		describe('endCodeReview', () => {
			it('Should end a code review', async () => {
				// Setup
				const spyOnEndCodeReview = jest.spyOn(extensionState, 'endCodeReview');
				spyOnEndCodeReview.mockResolvedValueOnce(null);

				// Run
				onDidReceiveMessage({
					command: 'endCodeReview',
					repo: '/path/to/repo',
					id: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnEndCodeReview).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');
					expect(messages).toHaveLength(0);
				});
			});
		});

		describe('exportRepoConfig', () => {
			it('Should export the repository configuration', async () => {
				// Setup
				const exportRepoConfigResolvedValue = null;
				const spyOnExportRepoConfig = jest.spyOn(repoManager, 'exportRepoConfig');
				spyOnExportRepoConfig.mockResolvedValueOnce(exportRepoConfigResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'exportRepoConfig',
					repo: '/path/to/repo'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnExportRepoConfig).toHaveBeenCalledWith('/path/to/repo');
					expect(messages).toStrictEqual([
						{
							command: 'exportRepoConfig',
							error: exportRepoConfigResolvedValue
						}
					]);
				});
			});
		});

		describe('fetch', () => {
			it('Should fetch a remote, and prune it', async () => {
				// Setup
				const fetchResolvedValue = null;
				const spyOnFetch = jest.spyOn(dataSource, 'fetch');
				spyOnFetch.mockResolvedValueOnce(fetchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'fetch',
					repo: '/path/to/repo',
					name: null,
					prune: true,
					pruneTags: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnFetch).toHaveBeenCalledWith('/path/to/repo', null, true, false);
					expect(messages).toStrictEqual([
						{
							command: 'fetch',
							error: fetchResolvedValue
						}
					]);
				});
			});
		});

		describe('fetchAvatar', () => {
			it('Should fetch an avatar', async () => {
				// Setup
				const spyOnFetchAvatarImage = jest.spyOn(avatarManager, 'fetchAvatarImage');
				spyOnFetchAvatarImage.mockImplementationOnce(() => { });

				// Run
				onDidReceiveMessage({
					command: 'fetchAvatar',
					repo: '/path/to/repo',
					remote: 'origin',
					email: 'user@mhutchie.com',
					commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnFetchAvatarImage).toHaveBeenCalledWith('user@mhutchie.com', '/path/to/repo', 'origin', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);
					expect(messages).toHaveLength(0);
				});
			});
		});

		describe('fetchIntoLocalBranch', () => {
			it('Should fetch into local branch', async () => {
				// Setup
				const fetchIntoLocalBranchResolvedValue = null;
				const spyOnFetchIntoLocalBranch = jest.spyOn(dataSource, 'fetchIntoLocalBranch');
				spyOnFetchIntoLocalBranch.mockResolvedValueOnce(fetchIntoLocalBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'fetchIntoLocalBranch',
					repo: '/path/to/repo',
					remote: 'origin',
					remoteBranch: 'remote-branch',
					localBranch: 'local-branch',
					force: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnFetchIntoLocalBranch).toHaveBeenCalledWith('/path/to/repo', 'origin', 'remote-branch', 'local-branch', false);
					expect(messages).toStrictEqual([
						{
							command: 'fetchIntoLocalBranch',
							error: fetchIntoLocalBranchResolvedValue
						}
					]);
				});
			});
		});

		describe('loadCommits', () => {
			const getCommitsResolvedValue = {
				commits: [
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1', 'tag2'],
				moreCommitsAvailable: false,
				error: null
			};

			it('Should get commits (show tags)', async () => {
				// Setup
				const spyOnGetCommits = jest.spyOn(dataSource, 'getCommits');
				spyOnGetCommits.mockResolvedValueOnce(getCommitsResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'loadCommits',
					repo: '/path/to/repo',
					refreshId: 2,
					branches: null,
					maxCommits: 300,
					showTags: true,
					showRemoteBranches: false,
					includeCommitsMentionedByReflogs: false,
					onlyFollowFirstParent: false,
					commitOrdering: CommitOrdering.Date,
					remotes: ['origin', 'upstream'],
					hideRemotes: ['upstream'],
					stashes: []
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetCommits).toHaveBeenCalledWith('/path/to/repo', null, 300, true, false, false, false, CommitOrdering.Date, ['origin', 'upstream'], ['upstream'], []);
					expect(messages).toStrictEqual([
						{
							command: 'loadCommits',
							refreshId: 2,
							commits: getCommitsResolvedValue.commits,
							head: getCommitsResolvedValue.head,
							tags: getCommitsResolvedValue.tags,
							moreCommitsAvailable: getCommitsResolvedValue.moreCommitsAvailable,
							onlyFollowFirstParent: false,
							error: getCommitsResolvedValue.error
						}
					]);
					expect(GitGraphView.currentPanel!['loadCommitsRefreshId']).toBe(2);
				});
			});

			it('Should get commits (show remote branches)', async () => {
				// Setup
				const spyOnGetCommits = jest.spyOn(dataSource, 'getCommits');
				spyOnGetCommits.mockResolvedValueOnce(getCommitsResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'loadCommits',
					repo: '/path/to/repo',
					refreshId: 2,
					branches: null,
					maxCommits: 300,
					showTags: false,
					showRemoteBranches: true,
					includeCommitsMentionedByReflogs: false,
					onlyFollowFirstParent: false,
					commitOrdering: CommitOrdering.Date,
					remotes: ['origin', 'upstream'],
					hideRemotes: ['upstream'],
					stashes: []
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetCommits).toHaveBeenCalledWith('/path/to/repo', null, 300, false, true, false, false, CommitOrdering.Date, ['origin', 'upstream'], ['upstream'], []);
					expect(messages).toStrictEqual([
						{
							command: 'loadCommits',
							refreshId: 2,
							commits: getCommitsResolvedValue.commits,
							head: getCommitsResolvedValue.head,
							tags: getCommitsResolvedValue.tags,
							moreCommitsAvailable: getCommitsResolvedValue.moreCommitsAvailable,
							onlyFollowFirstParent: false,
							error: getCommitsResolvedValue.error
						}
					]);
					expect(GitGraphView.currentPanel!['loadCommitsRefreshId']).toBe(2);
				});
			});

			it('Should get commits (include commits mentioned by reflogs)', async () => {
				// Setup
				const spyOnGetCommits = jest.spyOn(dataSource, 'getCommits');
				spyOnGetCommits.mockResolvedValueOnce(getCommitsResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'loadCommits',
					repo: '/path/to/repo',
					refreshId: 2,
					branches: null,
					maxCommits: 300,
					showTags: false,
					showRemoteBranches: false,
					includeCommitsMentionedByReflogs: true,
					onlyFollowFirstParent: false,
					commitOrdering: CommitOrdering.Date,
					remotes: ['origin', 'upstream'],
					hideRemotes: ['upstream'],
					stashes: []
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetCommits).toHaveBeenCalledWith('/path/to/repo', null, 300, false, false, true, false, CommitOrdering.Date, ['origin', 'upstream'], ['upstream'], []);
					expect(messages).toStrictEqual([
						{
							command: 'loadCommits',
							refreshId: 2,
							commits: getCommitsResolvedValue.commits,
							head: getCommitsResolvedValue.head,
							tags: getCommitsResolvedValue.tags,
							moreCommitsAvailable: getCommitsResolvedValue.moreCommitsAvailable,
							onlyFollowFirstParent: false,
							error: getCommitsResolvedValue.error
						}
					]);
					expect(GitGraphView.currentPanel!['loadCommitsRefreshId']).toBe(2);
				});
			});

			it('Should get commits (only follow first parent)', async () => {
				// Setup
				const spyOnGetCommits = jest.spyOn(dataSource, 'getCommits');
				spyOnGetCommits.mockResolvedValueOnce(getCommitsResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'loadCommits',
					repo: '/path/to/repo',
					refreshId: 2,
					branches: null,
					maxCommits: 300,
					showTags: false,
					showRemoteBranches: false,
					includeCommitsMentionedByReflogs: false,
					onlyFollowFirstParent: true,
					commitOrdering: CommitOrdering.Date,
					remotes: ['origin', 'upstream'],
					hideRemotes: ['upstream'],
					stashes: []
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetCommits).toHaveBeenCalledWith('/path/to/repo', null, 300, false, false, false, true, CommitOrdering.Date, ['origin', 'upstream'], ['upstream'], []);
					expect(messages).toStrictEqual([
						{
							command: 'loadCommits',
							refreshId: 2,
							commits: getCommitsResolvedValue.commits,
							head: getCommitsResolvedValue.head,
							tags: getCommitsResolvedValue.tags,
							moreCommitsAvailable: getCommitsResolvedValue.moreCommitsAvailable,
							onlyFollowFirstParent: true,
							error: getCommitsResolvedValue.error
						}
					]);
					expect(GitGraphView.currentPanel!['loadCommitsRefreshId']).toBe(2);
				});
			});
		});

		describe('loadRepoInfo', () => {
			it('Should get the repository information (initial repo load)', async () => {
				// Setup
				const getRepoInfoResolvedValue = {
					branches: ['master'],
					head: 'master',
					remotes: ['origin', 'upstream'],
					stashes: [],
					error: null
				};
				const spyOnGetRepoInfo = jest.spyOn(dataSource, 'getRepoInfo');
				const spyOnRepoRoot = jest.spyOn(dataSource, 'repoRoot');
				const spyOnSetLastActiveRepo = jest.spyOn(extensionState, 'setLastActiveRepo');
				const spyOnRepoFileWatcherStart = jest.spyOn(GitGraphView.currentPanel!['repoFileWatcher'], 'start');
				spyOnGetRepoInfo.mockResolvedValueOnce(getRepoInfoResolvedValue);
				spyOnSetLastActiveRepo.mockImplementationOnce(() => { });
				spyOnRepoFileWatcherStart.mockImplementationOnce(() => { });

				// Run
				onDidReceiveMessage({
					command: 'loadRepoInfo',
					repo: '/path/to/repo',
					refreshId: 0,
					showRemoteBranches: true,
					showStashes: false,
					hideRemotes: ['upstream']
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetRepoInfo).toHaveBeenCalledWith('/path/to/repo', true, false, ['upstream']);
					expect(spyOnRepoRoot).not.toHaveBeenCalled();
					expect(spyOnSetLastActiveRepo).toHaveBeenCalledWith('/path/to/repo');
					expect(spyOnRepoFileWatcherStart).toHaveBeenCalledWith('/path/to/repo');
					expect(messages).toStrictEqual([
						{
							command: 'loadRepoInfo',
							refreshId: 0,
							branches: getRepoInfoResolvedValue.branches,
							head: getRepoInfoResolvedValue.head,
							remotes: getRepoInfoResolvedValue.remotes,
							stashes: getRepoInfoResolvedValue.stashes,
							isRepo: true,
							error: getRepoInfoResolvedValue.error
						}
					]);
					expect(GitGraphView.currentPanel!['currentRepo']).toBe('/path/to/repo');
					expect(GitGraphView.currentPanel!['loadRepoInfoRefreshId']).toBe(0);
				});
			});

			it('Should get the repository information (subsequent repo load)', async () => {
				// Setup
				const getRepoInfoResolvedValue = {
					branches: ['master'],
					head: 'master',
					remotes: ['origin', 'upstream'],
					stashes: [],
					error: null
				};
				const spyOnGetRepoInfo = jest.spyOn(dataSource, 'getRepoInfo');
				const spyOnRepoRoot = jest.spyOn(dataSource, 'repoRoot');
				const spyOnSetLastActiveRepo = jest.spyOn(extensionState, 'setLastActiveRepo');
				const spyOnRepoFileWatcherStart = jest.spyOn(GitGraphView.currentPanel!['repoFileWatcher'], 'start');
				spyOnGetRepoInfo.mockResolvedValueOnce(getRepoInfoResolvedValue);
				GitGraphView.currentPanel!['currentRepo'] = '/path/to/repo';

				// Run
				onDidReceiveMessage({
					command: 'loadRepoInfo',
					repo: '/path/to/repo',
					refreshId: 1,
					showRemoteBranches: true,
					showStashes: false,
					hideRemotes: ['upstream']
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetRepoInfo).toHaveBeenCalledWith('/path/to/repo', true, false, ['upstream']);
					expect(spyOnRepoRoot).not.toHaveBeenCalled();
					expect(spyOnSetLastActiveRepo).not.toHaveBeenCalled();
					expect(spyOnRepoFileWatcherStart).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'loadRepoInfo',
							refreshId: 1,
							branches: getRepoInfoResolvedValue.branches,
							head: getRepoInfoResolvedValue.head,
							remotes: getRepoInfoResolvedValue.remotes,
							stashes: getRepoInfoResolvedValue.stashes,
							isRepo: true,
							error: getRepoInfoResolvedValue.error
						}
					]);
					expect(GitGraphView.currentPanel!['currentRepo']).toBe('/path/to/repo');
					expect(GitGraphView.currentPanel!['loadRepoInfoRefreshId']).toBe(1);
				});
			});

			it('Should get the repository information (error thrown by getRepoInfo)', async () => {
				// Setup
				const getRepoInfoResolvedValue = {
					branches: ['master'],
					head: 'master',
					remotes: ['origin', 'upstream'],
					stashes: [],
					error: 'error message'
				};
				const spyOnGetRepoInfo = jest.spyOn(dataSource, 'getRepoInfo');
				const spyOnRepoRoot = jest.spyOn(dataSource, 'repoRoot');
				const spyOnSetLastActiveRepo = jest.spyOn(extensionState, 'setLastActiveRepo');
				const spyOnRepoFileWatcherStart = jest.spyOn(GitGraphView.currentPanel!['repoFileWatcher'], 'start');
				spyOnGetRepoInfo.mockResolvedValueOnce(getRepoInfoResolvedValue);
				spyOnRepoRoot.mockResolvedValueOnce('/path/to/repo');
				GitGraphView.currentPanel!['currentRepo'] = '/path/to/repo';

				// Run
				onDidReceiveMessage({
					command: 'loadRepoInfo',
					repo: '/path/to/repo',
					refreshId: 2,
					showRemoteBranches: true,
					showStashes: false,
					hideRemotes: ['upstream']
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetRepoInfo).toHaveBeenCalledWith('/path/to/repo', true, false, ['upstream']);
					expect(spyOnRepoRoot).toHaveBeenCalledWith('/path/to/repo');
					expect(spyOnSetLastActiveRepo).not.toHaveBeenCalled();
					expect(spyOnRepoFileWatcherStart).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'loadRepoInfo',
							refreshId: 2,
							branches: getRepoInfoResolvedValue.branches,
							head: getRepoInfoResolvedValue.head,
							remotes: getRepoInfoResolvedValue.remotes,
							stashes: getRepoInfoResolvedValue.stashes,
							isRepo: true,
							error: getRepoInfoResolvedValue.error
						}
					]);
					expect(GitGraphView.currentPanel!['currentRepo']).toBe('/path/to/repo');
					expect(GitGraphView.currentPanel!['loadRepoInfoRefreshId']).toBe(2);
				});
			});

			it('Should get the repository information (repo no longer exists)', async () => {
				// Setup
				const getRepoInfoResolvedValue = {
					branches: ['master'],
					head: 'master',
					remotes: ['origin', 'upstream'],
					stashes: [],
					error: 'error message'
				};
				const spyOnGetRepoInfo = jest.spyOn(dataSource, 'getRepoInfo');
				const spyOnRepoRoot = jest.spyOn(dataSource, 'repoRoot');
				const spyOnSetLastActiveRepo = jest.spyOn(extensionState, 'setLastActiveRepo');
				const spyOnRepoFileWatcherStart = jest.spyOn(GitGraphView.currentPanel!['repoFileWatcher'], 'start');
				spyOnGetRepoInfo.mockResolvedValueOnce(getRepoInfoResolvedValue);
				spyOnRepoRoot.mockResolvedValueOnce(null);
				GitGraphView.currentPanel!['currentRepo'] = '/path/to/repo';

				// Run
				onDidReceiveMessage({
					command: 'loadRepoInfo',
					repo: '/path/to/repo',
					refreshId: 3,
					showRemoteBranches: true,
					showStashes: false,
					hideRemotes: ['upstream']
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetRepoInfo).toHaveBeenCalledWith('/path/to/repo', true, false, ['upstream']);
					expect(spyOnRepoRoot).toHaveBeenCalledWith('/path/to/repo');
					expect(spyOnSetLastActiveRepo).not.toHaveBeenCalled();
					expect(spyOnRepoFileWatcherStart).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'loadRepoInfo',
							refreshId: 3,
							branches: getRepoInfoResolvedValue.branches,
							head: getRepoInfoResolvedValue.head,
							remotes: getRepoInfoResolvedValue.remotes,
							stashes: getRepoInfoResolvedValue.stashes,
							isRepo: false,
							error: null
						}
					]);
					expect(GitGraphView.currentPanel!['currentRepo']).toBe('/path/to/repo');
					expect(GitGraphView.currentPanel!['loadRepoInfoRefreshId']).toBe(3);
				});
			});
		});

		describe('loadConfig', () => {
			it('Should get the Git configuration for a repository', async () => {
				// Setup
				const getConfigResolvedValue = { config: null, error: null };
				const spyOnGetConfig = jest.spyOn(dataSource, 'getConfig');
				spyOnGetConfig.mockResolvedValueOnce(getConfigResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'loadConfig',
					repo: '/path/to/repo',
					remotes: ['origin']
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetConfig).toHaveBeenCalledWith('/path/to/repo', ['origin']);
					expect(messages).toStrictEqual([
						{
							command: 'loadConfig',
							repo: '/path/to/repo',
							config: getConfigResolvedValue.config,
							error: getConfigResolvedValue.error
						}
					]);
				});
			});
		});

		describe('loadRepos', () => {
			it('Should load the repositories (without checking for new repositories)', async () => {
				// Setup
				const spyOnCheckReposExist = jest.spyOn(repoManager, 'checkReposExist');

				// Run
				onDidReceiveMessage({
					command: 'loadRepos',
					check: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCheckReposExist).not.toHaveBeenCalled();
					expect(messages).toStrictEqual([
						{
							command: 'loadRepos',
							repos: { '/path/to/repo': mockRepoState() },
							lastActiveRepo: null,
							loadViewTo: null
						}
					]);
				});
			});

			it('Should load the repositories (found one new repository)', async () => {
				// Setup
				const spyOnCheckReposExist = jest.spyOn(repoManager, 'checkReposExist');
				spyOnCheckReposExist.mockResolvedValueOnce(true);

				// Run
				onDidReceiveMessage({
					command: 'loadRepos',
					check: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCheckReposExist).toHaveBeenCalledWith();
					expect(messages).toHaveLength(0);
				});
			});

			it('Should load the repositories (no new repositories)', async () => {
				// Setup
				const spyOnCheckReposExist = jest.spyOn(repoManager, 'checkReposExist');
				spyOnCheckReposExist.mockResolvedValueOnce(false);

				// Run
				onDidReceiveMessage({
					command: 'loadRepos',
					check: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnCheckReposExist).toHaveBeenCalledWith();
					expect(messages).toStrictEqual([
						{
							command: 'loadRepos',
							repos: { '/path/to/repo': mockRepoState() },
							lastActiveRepo: null,
							loadViewTo: null
						}
					]);
				});
			});
		});

		describe('merge', () => {
			it('Should perform a merge (creating a new commit)', async () => {
				// Setup
				const mergeResolvedValue = null;
				const spyOnMerge = jest.spyOn(dataSource, 'merge');
				spyOnMerge.mockResolvedValueOnce(mergeResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'merge',
					repo: '/path/to/repo',
					obj: 'master',
					actionOn: MergeActionOn.Branch,
					createNewCommit: true,
					squash: false,
					noCommit: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnMerge).toHaveBeenCalledWith('/path/to/repo', 'master', MergeActionOn.Branch, true, false, false);
					expect(messages).toStrictEqual([
						{
							command: 'merge',
							actionOn: MergeActionOn.Branch,
							error: mergeResolvedValue
						}
					]);
				});
			});

			it('Should perform a merge (squash)', async () => {
				// Setup
				const mergeResolvedValue = null;
				const spyOnMerge = jest.spyOn(dataSource, 'merge');
				spyOnMerge.mockResolvedValueOnce(mergeResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'merge',
					repo: '/path/to/repo',
					obj: 'master',
					actionOn: MergeActionOn.Branch,
					createNewCommit: false,
					squash: true,
					noCommit: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnMerge).toHaveBeenCalledWith('/path/to/repo', 'master', MergeActionOn.Branch, false, true, false);
					expect(messages).toStrictEqual([
						{
							command: 'merge',
							actionOn: MergeActionOn.Branch,
							error: mergeResolvedValue
						}
					]);
				});
			});

			it('Should perform a merge (no commit)', async () => {
				// Setup
				const mergeResolvedValue = null;
				const spyOnMerge = jest.spyOn(dataSource, 'merge');
				spyOnMerge.mockResolvedValueOnce(mergeResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'merge',
					repo: '/path/to/repo',
					obj: 'master',
					actionOn: MergeActionOn.Branch,
					createNewCommit: false,
					squash: false,
					noCommit: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnMerge).toHaveBeenCalledWith('/path/to/repo', 'master', MergeActionOn.Branch, false, false, true);
					expect(messages).toStrictEqual([
						{
							command: 'merge',
							actionOn: MergeActionOn.Branch,
							error: mergeResolvedValue
						}
					]);
				});
			});
		});

		describe('openExtensionSettings', () => {
			it('Should open the Extension Settings', async () => {
				// Setup
				const openExtensionSettingsResolvedValue = null;
				const spyOnOpenExtensionSettings = jest.spyOn(utils, 'openExtensionSettings');
				spyOnOpenExtensionSettings.mockResolvedValueOnce(openExtensionSettingsResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'openExtensionSettings'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnOpenExtensionSettings).toHaveBeenCalledWith();
					expect(messages).toStrictEqual([
						{
							command: 'openExtensionSettings',
							error: openExtensionSettingsResolvedValue
						}
					]);
				});
			});
		});

		describe('openExternalDirDiff', () => {
			it('Should open an External Directory Diff', async () => {
				// Setup
				const openExternalDirDiffResolvedValue = null;
				const spyOnOpenExternalDirDiff = jest.spyOn(dataSource, 'openExternalDirDiff');
				spyOnOpenExternalDirDiff.mockResolvedValueOnce(openExternalDirDiffResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'openExternalDirDiff',
					repo: '/path/to/repo',
					fromHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					toHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					isGui: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnOpenExternalDirDiff).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', false);
					expect(messages).toStrictEqual([
						{
							command: 'openExternalDirDiff',
							error: openExternalDirDiffResolvedValue
						}
					]);
				});
			});
		});

		describe('openExternalUrl', () => {
			it('Should open an External URL', async () => {
				// Setup
				const openExternalUrlResolvedValue = null;
				const spyOnOpenExternalUrl = jest.spyOn(utils, 'openExternalUrl');
				spyOnOpenExternalUrl.mockResolvedValueOnce(openExternalUrlResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'openExternalUrl',
					url: 'https://www.mhutchie.com'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnOpenExternalUrl).toHaveBeenCalledWith('https://www.mhutchie.com');
					expect(messages).toStrictEqual([
						{
							command: 'openExternalUrl',
							error: openExternalUrlResolvedValue
						}
					]);
				});
			});
		});

		describe('openFile', () => {
			it('Should open a file', async () => {
				// Setup
				const openFileResolvedValue = null;
				const spyOnOpenFile = jest.spyOn(utils, 'openFile');
				spyOnOpenFile.mockResolvedValueOnce(openFileResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'openFile',
					repo: '/path/to/repo',
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					filePath: 'file.txt'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnOpenFile).toHaveBeenCalledWith('/path/to/repo', 'file.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);
					expect(messages).toStrictEqual([
						{
							command: 'openFile',
							error: openFileResolvedValue
						}
					]);
				});
			});
		});

		describe('openTerminal', () => {
			it('Should open a terminal', async () => {
				// Setup
				const openGitTerminalResolvedValue = null;
				const spyOnOpenGitTerminal = jest.spyOn(dataSource, 'openGitTerminal');
				spyOnOpenGitTerminal.mockResolvedValueOnce(openGitTerminalResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'openTerminal',
					repo: '/path/to/repo',
					name: 'repo-name'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnOpenGitTerminal).toHaveBeenCalledWith('/path/to/repo', null, 'repo-name');
					expect(messages).toStrictEqual([
						{
							command: 'openTerminal',
							error: openGitTerminalResolvedValue
						}
					]);
				});
			});
		});

		describe('popStash', () => {
			it('Should pop a stash', async () => {
				// Setup
				const popStashResolvedValue = null;
				const spyOnPopStash = jest.spyOn(dataSource, 'popStash');
				spyOnPopStash.mockResolvedValueOnce(popStashResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'popStash',
					repo: '/path/to/repo',
					selector: 'refs/stash@{0}',
					reinstateIndex: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnPopStash).toHaveBeenCalledWith('/path/to/repo', 'refs/stash@{0}', true);
					expect(messages).toStrictEqual([
						{
							command: 'popStash',
							error: popStashResolvedValue
						}
					]);
				});
			});
		});

		describe('pruneRemote', () => {
			it('Should prune a remote', async () => {
				// Setup
				const pruneRemoteResolvedValue = null;
				const spyOnPruneRemote = jest.spyOn(dataSource, 'pruneRemote');
				spyOnPruneRemote.mockResolvedValueOnce(pruneRemoteResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'pruneRemote',
					repo: '/path/to/repo',
					name: 'origin'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnPruneRemote).toHaveBeenCalledWith('/path/to/repo', 'origin');
					expect(messages).toStrictEqual([
						{
							command: 'pruneRemote',
							error: pruneRemoteResolvedValue
						}
					]);
				});
			});
		});

		describe('pullBranch', () => {
			it('Should pull a branch from a remote', async () => {
				// Setup
				const pullBranchResolvedValue = null;
				const spyOnPullBranch = jest.spyOn(dataSource, 'pullBranch');
				spyOnPullBranch.mockResolvedValueOnce(pullBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'pullBranch',
					repo: '/path/to/repo',
					branchName: 'master',
					remote: 'origin',
					createNewCommit: true,
					squash: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnPullBranch).toHaveBeenCalledWith('/path/to/repo', 'master', 'origin', true, false);
					expect(messages).toStrictEqual([
						{
							command: 'pullBranch',
							error: pullBranchResolvedValue
						}
					]);
				});
			});
		});

		describe('pushBranch', () => {
			it('Should push a branch to a remote', async () => {
				// Setup
				const pushBranchToMultipleRemotesResolvedValue = [null];
				const spyOnPushBranchToMultipleRemotes = jest.spyOn(dataSource, 'pushBranchToMultipleRemotes');
				spyOnPushBranchToMultipleRemotes.mockResolvedValueOnce(pushBranchToMultipleRemotesResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'pushBranch',
					repo: '/path/to/repo',
					branchName: 'develop',
					remotes: ['origin'],
					setUpstream: true,
					mode: GitPushBranchMode.Normal,
					willUpdateBranchConfig: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnPushBranchToMultipleRemotes).toHaveBeenCalledWith('/path/to/repo', 'develop', ['origin'], true, GitPushBranchMode.Normal);
					expect(messages).toStrictEqual([
						{
							command: 'pushBranch',
							willUpdateBranchConfig: false,
							errors: pushBranchToMultipleRemotesResolvedValue
						}
					]);
				});
			});
		});

		describe('pushStash', () => {
			it('Should push a stash', async () => {
				// Setup
				const pushStashResolvedValue = null;
				const spyOnPushStash = jest.spyOn(dataSource, 'pushStash');
				spyOnPushStash.mockResolvedValueOnce(pushStashResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'pushStash',
					repo: '/path/to/repo',
					message: 'stash message',
					includeUntracked: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnPushStash).toHaveBeenCalledWith('/path/to/repo', 'stash message', true);
					expect(messages).toStrictEqual([
						{
							command: 'pushStash',
							error: pushStashResolvedValue
						}
					]);
				});
			});
		});

		describe('pushTag', () => {
			it('Should push a tag to a remote', async () => {
				// Setup
				const spyOnPushTagResolvedValue = [null];
				const spyOnPushTag = jest.spyOn(dataSource, 'pushTag');
				spyOnPushTag.mockResolvedValueOnce(spyOnPushTagResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'pushTag',
					repo: '/path/to/repo',
					tagName: 'tag-name',
					remotes: ['origin'],
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					skipRemoteCheck: true
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnPushTag).toHaveBeenCalledWith('/path/to/repo', 'tag-name', ['origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);
					expect(messages).toStrictEqual([
						{
							command: 'pushTag',
							repo: '/path/to/repo',
							tagName: 'tag-name',
							remotes: ['origin'],
							commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							errors: spyOnPushTagResolvedValue
						}
					]);
				});
			});
		});

		describe('rebase', () => {
			it('Should rebase the current branch on a branch', async () => {
				// Setup
				const rebaseResolvedValue = null;
				const spyOnRebase = jest.spyOn(dataSource, 'rebase');
				spyOnRebase.mockResolvedValueOnce(rebaseResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'rebase',
					repo: '/path/to/repo',
					obj: 'feature',
					actionOn: RebaseActionOn.Branch,
					ignoreDate: true,
					interactive: false
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnRebase).toHaveBeenCalledWith('/path/to/repo', 'feature', RebaseActionOn.Branch, true, false);
					expect(messages).toStrictEqual([
						{
							command: 'rebase',
							actionOn: RebaseActionOn.Branch,
							interactive: false,
							error: rebaseResolvedValue
						}
					]);
				});
			});
		});

		describe('renameBranch', () => {
			it('Should rename a branch', async () => {
				// Setup
				const renameBranchResolvedValue = null;
				const spyOnRenameBranch = jest.spyOn(dataSource, 'renameBranch');
				spyOnRenameBranch.mockResolvedValueOnce(renameBranchResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'renameBranch',
					repo: '/path/to/repo',
					oldName: 'old-branch',
					newName: 'new-branch'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnRenameBranch).toHaveBeenCalledWith('/path/to/repo', 'old-branch', 'new-branch');
					expect(messages).toStrictEqual([
						{
							command: 'renameBranch',
							error: renameBranchResolvedValue
						}
					]);
				});
			});
		});

		describe('rescanForRepos', () => {
			it('Should rescan the workspace for repositories (repositories added)', async () => {
				// Setup
				const spyOnSearchWorkspaceForRepos = jest.spyOn(repoManager, 'searchWorkspaceForRepos');
				const spyOnShowErrorMessage = jest.spyOn(utils, 'showErrorMessage');
				spyOnSearchWorkspaceForRepos.mockResolvedValueOnce(true);

				// Run
				onDidReceiveMessage({
					command: 'rescanForRepos'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSearchWorkspaceForRepos).toHaveBeenCalledWith();
					expect(spyOnShowErrorMessage).not.toHaveBeenCalled();
					expect(messages).toHaveLength(0);
				});
			});

			it('Should rescan the workspace for repositories (no new repositories were found)', async () => {
				// Setup
				const spyOnSearchWorkspaceForRepos = jest.spyOn(repoManager, 'searchWorkspaceForRepos');
				const spyOnShowErrorMessage = jest.spyOn(utils, 'showErrorMessage');
				spyOnSearchWorkspaceForRepos.mockResolvedValueOnce(false);
				spyOnShowErrorMessage.mockResolvedValueOnce();

				// Run
				onDidReceiveMessage({
					command: 'rescanForRepos'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSearchWorkspaceForRepos).toHaveBeenCalledWith();
					expect(spyOnShowErrorMessage).toHaveBeenCalledWith('No Git repositories were found in the current workspace.');
					expect(messages).toHaveLength(0);
				});
			});
		});

		describe('resetFileToRevision', () => {
			it('Should reset the file to a revision', async () => {
				// Setup
				const resetFileToRevisionResolvedValue = null;
				const spyOnResetFileToRevision = jest.spyOn(dataSource, 'resetFileToRevision');
				spyOnResetFileToRevision.mockResolvedValueOnce(resetFileToRevisionResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'resetFileToRevision',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					filePath: 'path/to/file'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnResetFileToRevision).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'path/to/file');
					expect(messages).toStrictEqual([
						{
							command: 'resetFileToRevision',
							error: resetFileToRevisionResolvedValue
						}
					]);
				});
			});
		});

		describe('resetToCommit', () => {
			it('Should reset the current branch to a commit', async () => {
				// Setup
				const resetToCommitResolvedValue = null;
				const spyOnResetToCommit = jest.spyOn(dataSource, 'resetToCommit');
				spyOnResetToCommit.mockResolvedValueOnce(resetToCommitResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'resetToCommit',
					repo: '/path/to/repo',
					commit: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					resetMode: GitResetMode.Mixed
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnResetToCommit).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitResetMode.Mixed);
					expect(messages).toStrictEqual([
						{
							command: 'resetToCommit',
							error: resetToCommitResolvedValue
						}
					]);
				});
			});
		});

		describe('revertCommit', () => {
			it('Should revert a commit', async () => {
				// Setup
				const revertCommitResolvedValue = null;
				const spyOnRevertCommit = jest.spyOn(dataSource, 'revertCommit');
				spyOnRevertCommit.mockResolvedValueOnce(revertCommitResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'revertCommit',
					repo: '/path/to/repo',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parentIndex: 1
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnRevertCommit).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 1);
					expect(messages).toStrictEqual([
						{
							command: 'revertCommit',
							error: revertCommitResolvedValue
						}
					]);
				});
			});
		});

		describe('setGlobalViewState', () => {
			it('Should set the Global View State', async () => {
				// Setup
				const globalViewState: GitGraphViewGlobalState = {
					alwaysAcceptCheckoutCommit: true,
					issueLinkingConfig: null,
					pushTagSkipRemoteCheck: false
				};
				const setGlobalViewStateResolvedValue = null;
				const spyOnSetGlobalViewState = jest.spyOn(extensionState, 'setGlobalViewState');
				spyOnSetGlobalViewState.mockResolvedValueOnce(setGlobalViewStateResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'setGlobalViewState',
					state: globalViewState
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSetGlobalViewState).toHaveBeenCalledWith(globalViewState);
					expect(messages).toStrictEqual([
						{
							command: 'setGlobalViewState',
							error: setGlobalViewStateResolvedValue
						}
					]);
				});
			});
		});

		describe('setRepoState', () => {
			it('Should set the Repository State', async () => {
				// Setup
				const repoState = mockRepoState();
				const spyOnSetRepoState = jest.spyOn(repoManager, 'setRepoState');
				spyOnSetRepoState.mockImplementationOnce(() => { });

				// Run
				onDidReceiveMessage({
					command: 'setRepoState',
					repo: '/path/to/repo',
					state: repoState
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSetRepoState).toHaveBeenCalledWith('/path/to/repo', repoState);
					expect(messages).toHaveLength(0);
				});
			});
		});

		describe('setWorkspaceViewState', () => {
			it('Should set the Workspace View State', async () => {
				// Setup
				const workspaceViewState: GitGraphViewWorkspaceState = {
					findIsCaseSensitive: true,
					findIsRegex: false,
					findOpenCommitDetailsView: true
				};
				const setWorkspaceViewStateResolvedValue = null;
				const spyOnSetWorkspaceViewState = jest.spyOn(extensionState, 'setWorkspaceViewState');
				spyOnSetWorkspaceViewState.mockResolvedValueOnce(setWorkspaceViewStateResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'setWorkspaceViewState',
					state: workspaceViewState
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnSetWorkspaceViewState).toHaveBeenCalledWith(workspaceViewState);
					expect(messages).toStrictEqual([
						{
							command: 'setWorkspaceViewState',
							error: setWorkspaceViewStateResolvedValue
						}
					]);
				});
			});
		});

		describe('showErrorMessage', () => {
			it('Should show a Visual Studio Code Error Message', async () => {
				// Setup
				const spyOnShowErrorMessage = jest.spyOn(utils, 'showErrorMessage');
				spyOnShowErrorMessage.mockResolvedValueOnce();

				// Run
				onDidReceiveMessage({
					command: 'showErrorMessage',
					message: 'error message'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnShowErrorMessage).toHaveBeenCalledWith('error message');
					expect(messages).toHaveLength(0);
				});
			});
		});

		describe('startCodeReview', () => {
			it('Should start a code review', async () => {
				// Setup
				const startCodeReviewResolvedValue = {
					codeReview: {
						id: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						lastActive: 1587559258000,
						lastViewedFile: null,
						remainingFiles: ['file1.txt', 'file2.txt', 'file3.txt']
					},
					error: null
				};
				const spyOnStartCodeReview = jest.spyOn(extensionState, 'startCodeReview');
				spyOnStartCodeReview.mockResolvedValueOnce(startCodeReviewResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'startCodeReview',
					repo: '/path/to/repo',
					id: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					files: ['file1.txt', 'file2.txt', 'file3.txt'],
					lastViewedFile: null,
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					compareWithHash: null
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnStartCodeReview).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', ['file1.txt', 'file2.txt', 'file3.txt'], null);
					expect(messages).toStrictEqual([
						{
							command: 'startCodeReview',
							codeReview: startCodeReviewResolvedValue.codeReview,
							commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							compareWithHash: null,
							error: startCodeReviewResolvedValue.error
						}
					]);
				});
			});
		});

		describe('tagDetails', () => {
			it('Should get a tag\'s details', async () => {
				// Setup
				const getTagDetailsResolvedValue = { details: null, error: null };
				const spyOnGetTagDetails = jest.spyOn(dataSource, 'getTagDetails');
				spyOnGetTagDetails.mockResolvedValueOnce(getTagDetailsResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'tagDetails',
					repo: '/path/to/repo',
					tagName: 'tag-name',
					commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnGetTagDetails).toHaveBeenCalledWith('/path/to/repo', 'tag-name');
					expect(messages).toStrictEqual([
						{
							command: 'tagDetails',
							tagName: 'tag-name',
							commitHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							details: null,
							error: null
						}
					]);
				});
			});
		});

		describe('updateCodeReview', () => {
			it('Should update a code review', async () => {
				// Setup
				const updateCodeReviewResolvedValue = null;
				const spyOnUpdateCodeReview = jest.spyOn(extensionState, 'updateCodeReview');
				spyOnUpdateCodeReview.mockResolvedValueOnce(updateCodeReviewResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'updateCodeReview',
					repo: '/path/to/repo',
					id: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					remainingFiles: ['file2.txt', 'file3.txt'],
					lastViewedFile: 'file1.txt'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnUpdateCodeReview).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', ['file2.txt', 'file3.txt'], 'file1.txt');
					expect(messages).toStrictEqual([
						{
							command: 'updateCodeReview',
							error: updateCodeReviewResolvedValue
						}
					]);
				});
			});
		});

		describe('viewDiff', () => {
			it('Should open a diff', async () => {
				// Setup
				const viewDiffResolvedValue = null;
				const spyOnViewDiff = jest.spyOn(utils, 'viewDiff');
				spyOnViewDiff.mockResolvedValueOnce(viewDiffResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'viewDiff',
					repo: '/path/to/repo',
					fromHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					toHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					oldFilePath: 'old-file.txt',
					newFilePath: 'new-file.txt',
					type: GitFileStatus.Renamed
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnViewDiff).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', 'old-file.txt', 'new-file.txt', GitFileStatus.Renamed);
					expect(messages).toStrictEqual([
						{
							command: 'viewDiff',
							error: viewDiffResolvedValue
						}
					]);
				});
			});
		});

		describe('viewDiffWithWorkingFile', () => {
			it('Should open a diff with the working file', async () => {
				// Setup
				const viewDiffWithWorkingFileResolvedValue = null;
				const spyOnViewDiffWithWorkingFile = jest.spyOn(utils, 'viewDiffWithWorkingFile');
				spyOnViewDiffWithWorkingFile.mockResolvedValueOnce(viewDiffWithWorkingFileResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'viewDiffWithWorkingFile',
					repo: '/path/to/repo',
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					filePath: 'file.txt'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnViewDiffWithWorkingFile).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'file.txt', dataSource);
					expect(messages).toStrictEqual([
						{
							command: 'viewDiffWithWorkingFile',
							error: viewDiffWithWorkingFileResolvedValue
						}
					]);
				});
			});
		});

		describe('viewFileAtRevision', () => {
			it('Should view a file at a revision', async () => {
				// Setup
				const viewFileAtRevisionResolvedValue = null;
				const spyOnViewFileAtRevision = jest.spyOn(utils, 'viewFileAtRevision');
				spyOnViewFileAtRevision.mockResolvedValueOnce(viewFileAtRevisionResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'viewFileAtRevision',
					repo: '/path/to/repo',
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					filePath: 'file.txt'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnViewFileAtRevision).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'file.txt');
					expect(messages).toStrictEqual([
						{
							command: 'viewFileAtRevision',
							error: viewFileAtRevisionResolvedValue
						}
					]);
				});
			});
		});

		describe('viewScm', () => {
			it('Should open the Visual Studio Code Source Control View', async () => {
				// Setup
				const viewScmResolvedValue = null;
				const spyOnViewScm = jest.spyOn(utils, 'viewScm');
				spyOnViewScm.mockResolvedValueOnce(viewScmResolvedValue);

				// Run
				onDidReceiveMessage({
					command: 'viewScm'
				});

				// Assert
				await waitForExpect(() => {
					expect(spyOnViewScm).toHaveBeenCalledWith();
					expect(messages).toStrictEqual([
						{
							command: 'viewScm',
							error: viewScmResolvedValue
						}
					]);
				});
			});
		});
	});

	describe('sendMessage', () => {
		beforeEach(() => {
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);
			spyOnLog.mockReset();
			spyOnLogError.mockReset();
		});

		it('Should send a message to the Webview', async () => {
			// Setup
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			jest.spyOn(utils, 'viewScm').mockResolvedValueOnce(null);
			jest.spyOn(mockedWebviewPanel.panel.webview, 'postMessage').mockResolvedValueOnce(true);

			// Run
			mockedWebviewPanel.mocks.panel.webview.onDidReceiveMessage({
				command: 'viewScm'
			});

			// Assert
			await waitForExpect(() => {
				expect(mockedWebviewPanel.panel.webview.postMessage).toHaveBeenCalledWith({
					command: 'viewScm',
					error: null
				});
				expect(spyOnLog).not.toHaveBeenCalled();
				expect(spyOnLogError).not.toHaveBeenCalled();
			});
		});

		it('Should log an error message when Webview.postMessage rejects, and the GitGraphView hasn\'t been disposed', async () => {
			// Setup
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			jest.spyOn(utils, 'viewScm').mockResolvedValueOnce(null);
			jest.spyOn(mockedWebviewPanel.panel.webview, 'postMessage').mockRejectedValueOnce(null);

			// Run
			mockedWebviewPanel.mocks.panel.webview.onDidReceiveMessage({
				command: 'viewScm'
			});

			// Assert
			await waitForExpect(() => {
				expect(mockedWebviewPanel.panel.webview.postMessage).toHaveBeenCalledWith({
					command: 'viewScm',
					error: null
				});
				expect(spyOnLog).not.toHaveBeenCalled();
				expect(spyOnLogError).toHaveBeenCalledWith('Unable to send "viewScm" message to the Git Graph View.');
			});
		});

		it('Should log an information message when Webview.postMessage rejects, and the GitGraphView has been disposed', async () => {
			// Setup
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			jest.spyOn(utils, 'viewScm').mockResolvedValueOnce(null);
			jest.spyOn(mockedWebviewPanel.panel.webview, 'postMessage').mockImplementationOnce(() => {
				GitGraphView.currentPanel!.dispose();
				return Promise.reject();
			});

			// Run
			mockedWebviewPanel.mocks.panel.webview.onDidReceiveMessage({
				command: 'viewScm'
			});

			// Assert
			await waitForExpect(() => {
				expect(mockedWebviewPanel.panel.webview.postMessage).toHaveBeenCalledWith({
					command: 'viewScm',
					error: null
				});
				expect(spyOnLog).toHaveBeenCalledWith('The Git Graph View was disposed while sending "viewScm" message.');
				expect(spyOnLogError).not.toHaveBeenCalled();
			});
		});

		it('Shouldn\'t send a message to the Webview if it has been disposed', async () => {
			// Setup
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			jest.spyOn(utils, 'viewScm').mockResolvedValueOnce(null);
			jest.spyOn(mockedWebviewPanel.panel.webview, 'postMessage').mockResolvedValueOnce(true);

			// Run
			GitGraphView.currentPanel!.dispose();
			mockedWebviewPanel.mocks.panel.webview.onDidReceiveMessage({
				command: 'viewScm'
			});

			// Assert
			await waitForExpect(() => {
				expect(mockedWebviewPanel.panel.webview.postMessage).not.toHaveBeenCalled();
				expect(spyOnLog).toHaveBeenCalledWith('The Git Graph View has already been disposed, ignored sending "viewScm" message.');
				expect(spyOnLogError).not.toHaveBeenCalled();
			});
		});
	});

	describe('getHtmlForWebview', () => {
		beforeEach(() => {
			jest.spyOn(utils, 'getNonce').mockReturnValueOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d');
		});
		afterEach(() => {
			// Assert
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			expect(mockedWebviewPanel.panel.webview.html).toContain('<meta http-equiv="Content-Security-Policy" content="default-src \'none\'; style-src vscode-webview-resource: \'unsafe-inline\'; script-src \'nonce-1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d\'; img-src data:;">');
			expect(mockedWebviewPanel.panel.webview.html).toContain('<link rel="stylesheet" type="text/css" href="vscode-webview-resource://file///path/to/extension/media/out.min.css">');
			expect(mockedWebviewPanel.panel.webview.html).toContain('<title>Git Graph</title>');
			expect(mockedWebviewPanel.panel.webview.html).toContain('<style>body{--git-graph-color0:#0085d9; --git-graph-color1:#d9008f; --git-graph-color2:#00d90a; --git-graph-color3:#d98500; --git-graph-color4:#a300d9; --git-graph-color5:#ff0000; --git-graph-color6:#00d9cc; --git-graph-color7:#e138e8; --git-graph-color8:#85d900; --git-graph-color9:#dc5b23; --git-graph-color10:#6f24d6; --git-graph-color11:#ffcc00; } [data-color=\"0\"]{--git-graph-color:var(--git-graph-color0);} [data-color=\"1\"]{--git-graph-color:var(--git-graph-color1);} [data-color=\"2\"]{--git-graph-color:var(--git-graph-color2);} [data-color=\"3\"]{--git-graph-color:var(--git-graph-color3);} [data-color=\"4\"]{--git-graph-color:var(--git-graph-color4);} [data-color=\"5\"]{--git-graph-color:var(--git-graph-color5);} [data-color=\"6\"]{--git-graph-color:var(--git-graph-color6);} [data-color=\"7\"]{--git-graph-color:var(--git-graph-color7);} [data-color=\"8\"]{--git-graph-color:var(--git-graph-color8);} [data-color=\"9\"]{--git-graph-color:var(--git-graph-color9);} [data-color=\"10\"]{--git-graph-color:var(--git-graph-color10);} [data-color=\"11\"]{--git-graph-color:var(--git-graph-color11);} </style>');
		});

		it('Should get HTML when no Git executable is known', () => {
			// Setup
			spyOnIsGitExecutableUnknown.mockReturnValueOnce(true);

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			expect(mockedWebviewPanel.panel.webview.html).toContain('<h2>Unable to load Git Graph</h2>');
			expect(mockedWebviewPanel.panel.webview.html).toContain(utils.UNABLE_TO_FIND_GIT_MSG);
		});

		it('Should get HTML when no repositories are found in the workspace', () => {
			// Setup
			spyOnGetRepos.mockResolvedValueOnce({});

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			expect(mockedWebviewPanel.panel.webview.html).toContain('<h2>Unable to load Git Graph</h2>');
			expect(mockedWebviewPanel.panel.webview.html).toContain('No Git repositories were found in the current workspace when it was last scanned by Git Graph.');
			expect(mockedWebviewPanel.panel.webview.html).toContain('<script nonce="1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d">');
		});

		it('Should get HTML when repositories exist', () => {
			// Setup
			const spyOnIsAvatarStorageAvailable = jest.spyOn(extensionState, 'isAvatarStorageAvailable');
			vscode.mockExtensionSettingReturnValue('repository.commits.fetchAvatars', false);

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			expect(mockedWebviewPanel.panel.webview.html).toContain('<div id="view" tabindex="-1">');
			expect(mockedWebviewPanel.panel.webview.html).toContain('<script nonce="1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d">');
			expect(mockedWebviewPanel.panel.webview.html).toContain('<script nonce="1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d" src="vscode-webview-resource://file///path/to/extension/media/out.min.js"></script>');
			expect(spyOnIsAvatarStorageAvailable).not.toHaveBeenCalled();
		});

		it('Should get HTML when repositories exist (fetch avatars enabled)', () => {
			// Setup
			const spyOnIsAvatarStorageAvailable = jest.spyOn(extensionState, 'isAvatarStorageAvailable');
			vscode.mockExtensionSettingReturnValue('repository.commits.fetchAvatars', true);

			// Run
			GitGraphView.createOrShow('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);

			// Assert
			const mockedWebviewPanel = vscode.getMockedWebviewPanel(0);
			expect(mockedWebviewPanel.panel.webview.html).toContain('<div id="view" tabindex="-1">');
			expect(mockedWebviewPanel.panel.webview.html).toContain('<script nonce="1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d">');
			expect(mockedWebviewPanel.panel.webview.html).toContain('<script nonce="1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d" src="vscode-webview-resource://file///path/to/extension/media/out.min.js"></script>');
			expect(spyOnIsAvatarStorageAvailable).toHaveBeenCalledWith();
		});
	});
});

describe('standardiseCspSource', () => {
	it('Should not affect vscode-resource scheme-only sources', () => {
		// Run
		const result = standardiseCspSource('vscode-resource:');

		// Assert
		expect(result).toBe('vscode-resource:');
	});

	it('Should not affect file scheme-only sources', () => {
		// Run
		const result = standardiseCspSource('file:');

		// Assert
		expect(result).toBe('file:');
	});

	it('Should not affect http scheme-only sources', () => {
		// Run
		const result = standardiseCspSource('http:');

		// Assert
		expect(result).toBe('http:');
	});

	it('Should not affect https scheme-only sources', () => {
		// Run
		const result = standardiseCspSource('https:');

		// Assert
		expect(result).toBe('https:');
	});

	it('Should not affect file scheme sources', () => {
		// Run
		const result = standardiseCspSource('file://server');

		// Assert
		expect(result).toBe('file://server');
	});

	it('Should not affect http host-only sources', () => {
		// Run
		const result = standardiseCspSource('http://www.mhutchie.com');

		// Assert
		expect(result).toBe('http://www.mhutchie.com');
	});

	it('Should not affect https host-only sources', () => {
		// Run
		const result = standardiseCspSource('https://www.mhutchie.com');

		// Assert
		expect(result).toBe('https://www.mhutchie.com');
	});

	it('Should not affect https host-only IP sources', () => {
		// Run
		const result = standardiseCspSource('https://192.168.1.101');

		// Assert
		expect(result).toBe('https://192.168.1.101');
	});

	it('Should remove the path component from http sources', () => {
		// Run
		const result = standardiseCspSource('http://www.mhutchie.com/path/to/file');

		// Assert
		expect(result).toBe('http://www.mhutchie.com');
	});

	it('Should remove the path component from https sources', () => {
		// Run
		const result = standardiseCspSource('https://www.mhutchie.com/path/to/file');

		// Assert
		expect(result).toBe('https://www.mhutchie.com');
	});

	it('Should remove the path component from https IP sources', () => {
		// Run
		const result = standardiseCspSource('https://192.168.1.101:8080/path/to/file');

		// Assert
		expect(result).toBe('https://192.168.1.101:8080');
	});

	it('Should remove the query from http/https sources', () => {
		// Run
		const result = standardiseCspSource('https://www.mhutchie.com?query');

		// Assert
		expect(result).toBe('https://www.mhutchie.com');
	});

	it('Should remove the fragment from http/https sources', () => {
		// Run
		const result = standardiseCspSource('https://www.mhutchie.com#fragment');

		// Assert
		expect(result).toBe('https://www.mhutchie.com');
	});

	it('Should remove the path, query & fragment from http/https sources', () => {
		// Run
		const result = standardiseCspSource('https://www.mhutchie.com:443/path/to/file?query#fragment');

		// Assert
		expect(result).toBe('https://www.mhutchie.com:443');
	});
});
-e 

================================================================================
// FILE: ./tests/config.test.ts
================================================================================
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });

import { getConfig } from '../src/config';
import { CommitDetailsViewLocation, CommitOrdering, DateFormatType, DateType, FileViewType, GitResetMode, GraphStyle, GraphUncommittedChangesStyle, RepoDropdownOrder, SquashMessageFormat, TabIconColourTheme, TagType } from '../src/types';

import { expectRenamedExtensionSettingToHaveBeenCalled } from './helpers/expectations';

const workspaceConfiguration = vscode.mocks.workspaceConfiguration;

type Config = ReturnType<typeof getConfig>;

describe('Config', () => {
	let config: Config;
	beforeEach(() => {
		config = getConfig();
	});

	it('Should construct a Config instance', () => {
		// Run
		getConfig();

		// Assert
		expect(vscode.workspace.getConfiguration).toHaveBeenCalledWith('git-graph', undefined);
	});

	it('Should construct a Config instance (for a specific repository)', () => {
		// Run
		getConfig('/path/to/repo');

		// Assert
		expect(vscode.workspace.getConfiguration).toHaveBeenCalledWith('git-graph', {
			scheme: 'file',
			authority: '',
			path: '/path/to/repo',
			query: '',
			fragment: ''
		});
	});

	describe('commitDetailsView', () => {
		describe('autoCenter', () => {
			it('Should return TRUE when the configuration value is TRUE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.autoCenter', true);

				// Run
				const value = config.commitDetailsView.autoCenter;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.autoCenter', 'autoCenterCommitDetailsView');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is FALSE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.autoCenter', false);

				// Run
				const value = config.commitDetailsView.autoCenter;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.autoCenter', 'autoCenterCommitDetailsView');
				expect(value).toBe(false);
			});

			it('Should return TRUE when the configuration value is truthy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.autoCenter', 5);

				// Run
				const value = config.commitDetailsView.autoCenter;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.autoCenter', 'autoCenterCommitDetailsView');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is falsy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.autoCenter', 0);

				// Run
				const value = config.commitDetailsView.autoCenter;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.autoCenter', 'autoCenterCommitDetailsView');
				expect(value).toBe(false);
			});

			it('Should return the default value (TRUE) when the configuration value is unknown', () => {
				// Run
				const value = config.commitDetailsView.autoCenter;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.autoCenter', 'autoCenterCommitDetailsView');
				expect(value).toBe(true);
			});
		});

		describe('fileTreeCompactFolders', () => {
			it('Should return TRUE when the configuration value is TRUE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.fileView.fileTree.compactFolders', true);

				// Run
				const value = config.commitDetailsView.fileTreeCompactFolders;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.fileView.fileTree.compactFolders', 'commitDetailsViewFileTreeCompactFolders');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is FALSE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.fileView.fileTree.compactFolders', false);

				// Run
				const value = config.commitDetailsView.fileTreeCompactFolders;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.fileView.fileTree.compactFolders', 'commitDetailsViewFileTreeCompactFolders');
				expect(value).toBe(false);
			});

			it('Should return TRUE when the configuration value is truthy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.fileView.fileTree.compactFolders', 5);

				// Run
				const value = config.commitDetailsView.fileTreeCompactFolders;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.fileView.fileTree.compactFolders', 'commitDetailsViewFileTreeCompactFolders');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is falsy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.fileView.fileTree.compactFolders', 0);

				// Run
				const value = config.commitDetailsView.fileTreeCompactFolders;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.fileView.fileTree.compactFolders', 'commitDetailsViewFileTreeCompactFolders');
				expect(value).toBe(false);
			});

			it('Should return the default value (TRUE) when the configuration value is unknown', () => {
				// Run
				const value = config.commitDetailsView.fileTreeCompactFolders;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.fileView.fileTree.compactFolders', 'commitDetailsViewFileTreeCompactFolders');
				expect(value).toBe(true);
			});
		});

		describe('fileViewType', () => {
			it('Should return FileViewType.Tree when the configuration value is "File Tree"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.fileView.type', 'File Tree');

				// Run
				const value = config.commitDetailsView.fileViewType;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.fileView.type', 'defaultFileViewType');
				expect(value).toBe(FileViewType.Tree);
			});

			it('Should return FileViewType.List when the configuration value is "File List"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.fileView.type', 'File List');

				// Run
				const value = config.commitDetailsView.fileViewType;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.fileView.type', 'defaultFileViewType');
				expect(value).toBe(FileViewType.List);
			});

			it('Should return the default value (FileViewType.Tree) when the configuration value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.fileView.type', 'invalid');

				// Run
				const value = config.commitDetailsView.fileViewType;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.fileView.type', 'defaultFileViewType');
				expect(value).toBe(FileViewType.Tree);
			});

			it('Should return the default value (FileViewType.Tree) when the configuration value is unknown', () => {
				// Run
				const value = config.commitDetailsView.fileViewType;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.fileView.type', 'defaultFileViewType');
				expect(value).toBe(FileViewType.Tree);
			});
		});

		describe('location', () => {
			it('Should return CommitDetailsViewLocation.Inline when the configuration value is "Inline"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.location', 'Inline');

				// Run
				const value = config.commitDetailsView.location;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.location', 'commitDetailsViewLocation');
				expect(value).toBe(CommitDetailsViewLocation.Inline);
			});

			it('Should return CommitDetailsViewLocation.DockedToBottom when the configuration value is "Docked to Bottom"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.location', 'Docked to Bottom');

				// Run
				const value = config.commitDetailsView.location;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.location', 'commitDetailsViewLocation');
				expect(value).toBe(CommitDetailsViewLocation.DockedToBottom);
			});

			it('Should return the default value (CommitDetailsViewLocation.Inline) when the configuration value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('commitDetailsView.location', 'invalid');

				// Run
				const value = config.commitDetailsView.location;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.location', 'commitDetailsViewLocation');
				expect(value).toBe(CommitDetailsViewLocation.Inline);
			});

			it('Should return the default value (CommitDetailsViewLocation.Inline) when the configuration value is unknown', () => {
				// Run
				const value = config.commitDetailsView.location;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('commitDetailsView.location', 'commitDetailsViewLocation');
				expect(value).toBe(CommitDetailsViewLocation.Inline);
			});
		});
	});

	describe('contextMenuActionsVisibility', () => {
		it('Should return the default value (all items enabled) when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('contextMenuActionsVisibility', 1);

			// Run
			const value = config.contextMenuActionsVisibility;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('contextMenuActionsVisibility', {});
			expect(value).toStrictEqual({
				branch: {
					checkout: true,
					rename: true,
					delete: true,
					merge: true,
					rebase: true,
					push: true,
					viewIssue: true,
					createPullRequest: true,
					createArchive: true,
					selectInBranchesDropdown: true,
					unselectInBranchesDropdown: true,
					copyName: true
				},
				commit: {
					addTag: true,
					createBranch: true,
					checkout: true,
					cherrypick: true,
					revert: true,
					drop: true,
					merge: true,
					rebase: true,
					reset: true,
					copyHash: true,
					copySubject: true
				},
				commitDetailsViewFile: {
					viewDiff: true,
					viewFileAtThisRevision: true,
					viewDiffWithWorkingFile: true,
					openFile: true,
					markAsReviewed: true,
					markAsNotReviewed: true,
					resetFileToThisRevision: true,
					copyAbsoluteFilePath: true,
					copyRelativeFilePath: true
				},
				remoteBranch: {
					checkout: true,
					delete: true,
					fetch: true,
					merge: true,
					pull: true,
					viewIssue: true,
					createPullRequest: true,
					createArchive: true,
					selectInBranchesDropdown: true,
					unselectInBranchesDropdown: true,
					copyName: true
				},
				stash: {
					apply: true,
					createBranch: true,
					pop: true,
					drop: true,
					copyName: true,
					copyHash: true
				},
				tag: {
					viewDetails: true,
					delete: true,
					push: true,
					createArchive: true,
					copyName: true
				},
				uncommittedChanges: {
					stash: true,
					reset: true,
					clean: true,
					openSourceControlView: true
				}
			});
		});

		it('Should return the default value (all items enabled) when the configuration value is not set', () => {
			// Run
			const value = config.contextMenuActionsVisibility;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('contextMenuActionsVisibility', {});
			expect(value).toStrictEqual({
				branch: {
					checkout: true,
					rename: true,
					delete: true,
					merge: true,
					rebase: true,
					push: true,
					viewIssue: true,
					createPullRequest: true,
					createArchive: true,
					selectInBranchesDropdown: true,
					unselectInBranchesDropdown: true,
					copyName: true
				},
				commit: {
					addTag: true,
					createBranch: true,
					checkout: true,
					cherrypick: true,
					revert: true,
					drop: true,
					merge: true,
					rebase: true,
					reset: true,
					copyHash: true,
					copySubject: true
				},
				commitDetailsViewFile: {
					viewDiff: true,
					viewFileAtThisRevision: true,
					viewDiffWithWorkingFile: true,
					openFile: true,
					markAsReviewed: true,
					markAsNotReviewed: true,
					resetFileToThisRevision: true,
					copyAbsoluteFilePath: true,
					copyRelativeFilePath: true
				},
				remoteBranch: {
					checkout: true,
					delete: true,
					fetch: true,
					merge: true,
					pull: true,
					viewIssue: true,
					createPullRequest: true,
					createArchive: true,
					selectInBranchesDropdown: true,
					unselectInBranchesDropdown: true,
					copyName: true
				},
				stash: {
					apply: true,
					createBranch: true,
					pop: true,
					drop: true,
					copyName: true,
					copyHash: true
				},
				tag: {
					viewDetails: true,
					delete: true,
					push: true,
					createArchive: true,
					copyName: true
				},
				uncommittedChanges: {
					stash: true,
					reset: true,
					clean: true,
					openSourceControlView: true
				}
			});
		});

		it('Should only affect the provided configuration overrides', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('contextMenuActionsVisibility', {
				branch: {
					rename: false
				},
				commit: {
					checkout: false
				},
				commitDetailsViewFile: {
					resetFileToThisRevision: false
				},
				remoteBranch: {
					delete: true,
					fetch: false,
					pull: true
				}
			});

			// Run
			const value = config.contextMenuActionsVisibility;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('contextMenuActionsVisibility', {});
			expect(value).toStrictEqual({
				branch: {
					checkout: true,
					rename: false,
					delete: true,
					merge: true,
					rebase: true,
					push: true,
					viewIssue: true,
					createPullRequest: true,
					createArchive: true,
					selectInBranchesDropdown: true,
					unselectInBranchesDropdown: true,
					copyName: true
				},
				commit: {
					addTag: true,
					createBranch: true,
					checkout: false,
					cherrypick: true,
					revert: true,
					drop: true,
					merge: true,
					rebase: true,
					reset: true,
					copyHash: true,
					copySubject: true
				},
				commitDetailsViewFile: {
					viewDiff: true,
					viewFileAtThisRevision: true,
					viewDiffWithWorkingFile: true,
					openFile: true,
					markAsReviewed: true,
					markAsNotReviewed: true,
					resetFileToThisRevision: false,
					copyAbsoluteFilePath: true,
					copyRelativeFilePath: true
				},
				remoteBranch: {
					checkout: true,
					delete: true,
					fetch: false,
					merge: true,
					pull: true,
					viewIssue: true,
					createPullRequest: true,
					createArchive: true,
					selectInBranchesDropdown: true,
					unselectInBranchesDropdown: true,
					copyName: true
				},
				stash: {
					apply: true,
					createBranch: true,
					pop: true,
					drop: true,
					copyName: true,
					copyHash: true
				},
				tag: {
					viewDetails: true,
					delete: true,
					push: true,
					createArchive: true,
					copyName: true
				},
				uncommittedChanges: {
					stash: true,
					reset: true,
					clean: true,
					openSourceControlView: true
				}
			});
		});
	});

	describe('customBranchGlobPatterns', () => {
		it('Should return a filtered array of glob patterns based on the configuration value', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('customBranchGlobPatterns', [
				{ name: 'Name 1', glob: 'glob1' },
				{ name: 'Name 2', glob: 'glob2' },
				{ name: 'Name 3' },
				{ name: 'Name 4', glob: 'glob4' }
			]);

			// Run
			const value = config.customBranchGlobPatterns;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('customBranchGlobPatterns', []);
			expect(value).toHaveLength(3);
			expect(value[0]).toStrictEqual({ name: 'Name 1', glob: '--glob=glob1' });
			expect(value[1]).toStrictEqual({ name: 'Name 2', glob: '--glob=glob2' });
			expect(value[2]).toStrictEqual({ name: 'Name 4', glob: '--glob=glob4' });
		});

		it('Should return the default value ([]) when the configuration value is not set', () => {
			// Run
			const value = config.customBranchGlobPatterns;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('customBranchGlobPatterns', []);
			expect(value).toHaveLength(0);
		});
	});

	describe('customEmojiShortcodeMappings', () => {
		it('Should return a filtered array of emoji shortcode mappings based on the configuration value', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('customEmojiShortcodeMappings', [
				{ shortcode: 'dog', emoji: '' },
				{ shortcode: 'cat', emoji: '' },
				{ shortcode: 'bird' },
				{ shortcode: 'fish', emoji: '' }
			]);

			// Run
			const value = config.customEmojiShortcodeMappings;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('customEmojiShortcodeMappings', []);
			expect(value).toStrictEqual([
				{ shortcode: 'dog', emoji: '' },
				{ shortcode: 'cat', emoji: '' },
				{ shortcode: 'fish', emoji: '' }
			]);
		});

		it('Should return the default value ([]) when the configuration value is not set', () => {
			// Run
			const value = config.customEmojiShortcodeMappings;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('customEmojiShortcodeMappings', []);
			expect(value).toHaveLength(0);
		});
	});

	describe('customPullRequestProviders', () => {
		it('Should return a filtered array of pull request providers based on the configuration value', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('customPullRequestProviders', [
				{ name: 'dog', templateUrl: '$1/$2' },
				{ name: 'cat', templateUrl: '$1/$3' },
				{ name: 'bird' },
				{ name: 'fish', templateUrl: '$1/$4' },
				{ templateUrl: '$1/$5' }
			]);

			// Run
			const value = config.customPullRequestProviders;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('customPullRequestProviders', []);
			expect(value).toStrictEqual([
				{ name: 'dog', templateUrl: '$1/$2' },
				{ name: 'cat', templateUrl: '$1/$3' },
				{ name: 'fish', templateUrl: '$1/$4' }
			]);
		});

		it('Should return the default value ([]) when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('customPullRequestProviders', 5);

			// Run
			const value = config.customPullRequestProviders;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('customPullRequestProviders', []);
			expect(value).toHaveLength(0);
		});

		it('Should return the default value ([]) when the configuration value is not set', () => {
			// Run
			const value = config.customPullRequestProviders;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('customPullRequestProviders', []);
			expect(value).toHaveLength(0);
		});
	});

	describe('dateFormat', () => {
		it('Should successfully parse the configuration value "Date & Time"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('date.format', 'Date & Time');

			// Run
			const value = config.dateFormat;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.format', 'dateFormat');
			expect(value).toStrictEqual({ type: DateFormatType.DateAndTime, iso: false });
		});

		it('Should successfully parse the configuration value "Date Only"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('date.format', 'Date Only');

			// Run
			const value = config.dateFormat;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.format', 'dateFormat');
			expect(value).toStrictEqual({ type: DateFormatType.DateOnly, iso: false });
		});

		it('Should successfully parse the configuration value "ISO Date & Time"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('date.format', 'ISO Date & Time');

			// Run
			const value = config.dateFormat;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.format', 'dateFormat');
			expect(value).toStrictEqual({ type: DateFormatType.DateAndTime, iso: true });
		});

		it('Should successfully parse the configuration value "ISO Date Only"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('date.format', 'ISO Date Only');

			// Run
			const value = config.dateFormat;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.format', 'dateFormat');
			expect(value).toStrictEqual({ type: DateFormatType.DateOnly, iso: true });
		});

		it('Should successfully parse the configuration value "Relative"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('date.format', 'Relative');

			// Run
			const value = config.dateFormat;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.format', 'dateFormat');
			expect(value).toStrictEqual({ type: DateFormatType.Relative, iso: false });
		});

		it('Should return the default value when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('date.format', 'invalid');

			// Run
			const value = config.dateFormat;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.format', 'dateFormat');
			expect(value).toStrictEqual({ type: DateFormatType.DateAndTime, iso: false });
		});

		it('Should return the default value when the configuration value is unknown', () => {
			// Run
			const value = config.dateFormat;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.format', 'dateFormat');
			expect(value).toStrictEqual({ type: DateFormatType.DateAndTime, iso: false });
		});
	});

	describe('dateType', () => {
		it('Should return DateType.Author when the configuration value is "Author Date"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('date.type', 'Author Date');

			// Run
			const value = config.dateType;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.type', 'dateType');
			expect(value).toBe(DateType.Author);
		});

		it('Should return DateType.Commit when the configuration value is "Commit Date"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('date.type', 'Commit Date');

			// Run
			const value = config.dateType;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.type', 'dateType');
			expect(value).toBe(DateType.Commit);
		});

		it('Should return the default value (DateType.Author) when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('date.type', 'invalid');

			// Run
			const value = config.dateType;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.type', 'dateType');
			expect(value).toBe(DateType.Author);
		});

		it('Should return the default value (DateType.Author) when the configuration value is unknown', () => {
			// Run
			const value = config.dateType;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('date.type', 'dateType');
			expect(value).toBe(DateType.Author);
		});
	});

	describe('defaultColumnVisibility', () => {
		it('Should successfully parse the configuration value (Date column disabled)', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('defaultColumnVisibility', { Date: false, Author: true, Commit: true });

			// Run
			const value = config.defaultColumnVisibility;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('defaultColumnVisibility', {});
			expect(value).toStrictEqual({ date: false, author: true, commit: true });
		});

		it('Should successfully parse the configuration value (Author column disabled)', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('defaultColumnVisibility', { Date: true, Author: false, Commit: true });

			// Run
			const value = config.defaultColumnVisibility;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('defaultColumnVisibility', {});
			expect(value).toStrictEqual({ date: true, author: false, commit: true });
		});

		it('Should successfully parse the configuration value (Commit  column disabled)', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('defaultColumnVisibility', { Date: true, Author: true, Commit: false });

			// Run
			const value = config.defaultColumnVisibility;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('defaultColumnVisibility', {});
			expect(value).toStrictEqual({ date: true, author: true, commit: false });
		});

		it('Should return the default value when the configuration value is invalid (not an object)', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('defaultColumnVisibility', 'invalid');

			// Run
			const value = config.defaultColumnVisibility;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('defaultColumnVisibility', {});
			expect(value).toStrictEqual({ date: true, author: true, commit: true });
		});

		it('Should return the default value when the configuration value is invalid (NULL)', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('defaultColumnVisibility', null);

			// Run
			const value = config.defaultColumnVisibility;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('defaultColumnVisibility', {});
			expect(value).toStrictEqual({ date: true, author: true, commit: true });
		});

		it('Should return the default value when the configuration value is invalid (column value is not a boolean)', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('defaultColumnVisibility', { Date: true, Author: true, Commit: 5 });

			// Run
			const value = config.defaultColumnVisibility;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('defaultColumnVisibility', {});
			expect(value).toStrictEqual({ date: true, author: true, commit: true });
		});

		it('Should return the default value when the configuration value is not set', () => {
			// Run
			const value = config.defaultColumnVisibility;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('defaultColumnVisibility', {});
			expect(value).toStrictEqual({ date: true, author: true, commit: true });
		});
	});

	describe('dialogDefaults', () => {
		it('Should return TRUE values for boolean-based configuration values when they are TRUE', () => {
			// Setup
			[
				'dialog.addTag.pushToRemote',
				'dialog.applyStash.reinstateIndex',
				'dialog.cherryPick.noCommit',
				'dialog.cherryPick.recordOrigin',
				'dialog.createBranch.checkOut',
				'dialog.deleteBranch.forceDelete',
				'dialog.fetchIntoLocalBranch.forceFetch',
				'dialog.fetchRemote.prune',
				'dialog.fetchRemote.pruneTags',
				'dialog.merge.noCommit',
				'dialog.merge.noFastForward',
				'dialog.merge.squashCommits',
				'dialog.popStash.reinstateIndex',
				'dialog.pullBranch.noFastForward',
				'dialog.pullBranch.squashCommits',
				'dialog.rebase.ignoreDate',
				'dialog.rebase.launchInteractiveRebase',
				'dialog.stashUncommittedChanges.includeUntracked'
			].forEach((section) => vscode.mockExtensionSettingReturnValue(section, true));

			// Run
			const value = config.dialogDefaults;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.pushToRemote', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.type', 'Annotated');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.applyStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.recordOrigin', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.createBranch.checkOut', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.deleteBranch.forceDelete', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchIntoLocalBranch.forceFetch', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.prune', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.pruneTags', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.general.referenceInputSpaceSubstitution', 'None');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noFastForward', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.popStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.noFastForward', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.ignoreDate', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.launchInteractiveRebase', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetCurrentBranchToCommit.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetUncommittedChanges.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.stashUncommittedChanges.includeUntracked', true);
			expect(value).toStrictEqual({
				addTag: {
					pushToRemote: true,
					type: TagType.Annotated
				},
				applyStash: {
					reinstateIndex: true
				},
				cherryPick: {
					noCommit: true,
					recordOrigin: true
				},
				createBranch: {
					checkout: true
				},
				deleteBranch: {
					forceDelete: true
				},
				fetchIntoLocalBranch: {
					forceFetch: true
				},
				fetchRemote: {
					prune: true,
					pruneTags: true
				},
				general: {
					referenceInputSpaceSubstitution: null
				},
				merge: {
					noCommit: true,
					noFastForward: true,
					squash: true
				},
				popStash: {
					reinstateIndex: true
				},
				pullBranch: {
					noFastForward: true,
					squash: true
				},
				rebase: {
					ignoreDate: true,
					interactive: true
				},
				resetCommit: {
					mode: GitResetMode.Mixed
				},
				resetUncommitted: {
					mode: GitResetMode.Mixed
				},
				stashUncommittedChanges: {
					includeUntracked: true
				}
			});
		});

		it('Should return FALSE values for boolean-based configuration values when they are FALSE', () => {
			// Setup
			[
				'dialog.addTag.pushToRemote',
				'dialog.applyStash.reinstateIndex',
				'dialog.cherryPick.noCommit',
				'dialog.cherryPick.recordOrigin',
				'dialog.createBranch.checkOut',
				'dialog.deleteBranch.forceDelete',
				'dialog.fetchIntoLocalBranch.forceFetch',
				'dialog.fetchRemote.prune',
				'dialog.fetchRemote.pruneTags',
				'dialog.merge.noCommit',
				'dialog.merge.noFastForward',
				'dialog.merge.squashCommits',
				'dialog.popStash.reinstateIndex',
				'dialog.pullBranch.noFastForward',
				'dialog.pullBranch.squashCommits',
				'dialog.rebase.ignoreDate',
				'dialog.rebase.launchInteractiveRebase',
				'dialog.stashUncommittedChanges.includeUntracked'
			].forEach((section) => vscode.mockExtensionSettingReturnValue(section, false));

			// Run
			const value = config.dialogDefaults;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.pushToRemote', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.type', 'Annotated');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.applyStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.recordOrigin', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.createBranch.checkOut', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.deleteBranch.forceDelete', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchIntoLocalBranch.forceFetch', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.prune', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.pruneTags', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.general.referenceInputSpaceSubstitution', 'None');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noFastForward', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.popStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.noFastForward', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.ignoreDate', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.launchInteractiveRebase', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetCurrentBranchToCommit.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetUncommittedChanges.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.stashUncommittedChanges.includeUntracked', true);
			expect(value).toStrictEqual({
				addTag: {
					pushToRemote: false,
					type: TagType.Annotated
				},
				applyStash: {
					reinstateIndex: false
				},
				cherryPick: {
					noCommit: false,
					recordOrigin: false
				},
				createBranch: {
					checkout: false
				},
				deleteBranch: {
					forceDelete: false
				},
				fetchIntoLocalBranch: {
					forceFetch: false
				},
				fetchRemote: {
					prune: false,
					pruneTags: false
				},
				general: {
					referenceInputSpaceSubstitution: null
				},
				merge: {
					noCommit: false,
					noFastForward: false,
					squash: false
				},
				popStash: {
					reinstateIndex: false
				},
				pullBranch: {
					noFastForward: false,
					squash: false
				},
				rebase: {
					ignoreDate: false,
					interactive: false
				},
				resetCommit: {
					mode: GitResetMode.Mixed
				},
				resetUncommitted: {
					mode: GitResetMode.Mixed
				},
				stashUncommittedChanges: {
					includeUntracked: false
				}
			});
		});

		it('Should return TRUE values for boolean-based configuration values when they are truthy', () => {
			// Setup
			[
				'dialog.addTag.pushToRemote',
				'dialog.applyStash.reinstateIndex',
				'dialog.cherryPick.noCommit',
				'dialog.cherryPick.recordOrigin',
				'dialog.createBranch.checkOut',
				'dialog.deleteBranch.forceDelete',
				'dialog.fetchIntoLocalBranch.forceFetch',
				'dialog.fetchRemote.prune',
				'dialog.fetchRemote.pruneTags',
				'dialog.merge.noCommit',
				'dialog.merge.noFastForward',
				'dialog.merge.squashCommits',
				'dialog.popStash.reinstateIndex',
				'dialog.pullBranch.noFastForward',
				'dialog.pullBranch.squashCommits',
				'dialog.rebase.ignoreDate',
				'dialog.rebase.launchInteractiveRebase',
				'dialog.stashUncommittedChanges.includeUntracked'
			].forEach((section) => vscode.mockExtensionSettingReturnValue(section, 1));

			// Run
			const value = config.dialogDefaults;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.pushToRemote', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.type', 'Annotated');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.applyStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.recordOrigin', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.createBranch.checkOut', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.deleteBranch.forceDelete', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchIntoLocalBranch.forceFetch', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.prune', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.pruneTags', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.general.referenceInputSpaceSubstitution', 'None');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noFastForward', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.popStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.noFastForward', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.ignoreDate', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.launchInteractiveRebase', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetCurrentBranchToCommit.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetUncommittedChanges.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.stashUncommittedChanges.includeUntracked', true);
			expect(value).toStrictEqual({
				addTag: {
					pushToRemote: true,
					type: TagType.Annotated
				},
				applyStash: {
					reinstateIndex: true
				},
				cherryPick: {
					noCommit: true,
					recordOrigin: true
				},
				createBranch: {
					checkout: true
				},
				deleteBranch: {
					forceDelete: true
				},
				fetchIntoLocalBranch: {
					forceFetch: true
				},
				fetchRemote: {
					prune: true,
					pruneTags: true
				},
				general: {
					referenceInputSpaceSubstitution: null
				},
				merge: {
					noCommit: true,
					noFastForward: true,
					squash: true
				},
				popStash: {
					reinstateIndex: true
				},
				pullBranch: {
					noFastForward: true,
					squash: true
				},
				rebase: {
					ignoreDate: true,
					interactive: true
				},
				resetCommit: {
					mode: GitResetMode.Mixed
				},
				resetUncommitted: {
					mode: GitResetMode.Mixed
				},
				stashUncommittedChanges: {
					includeUntracked: true
				}
			});
		});

		it('Should return FALSE values for boolean-based configuration values when they are falsy', () => {
			// Setup
			[
				'dialog.addTag.pushToRemote',
				'dialog.applyStash.reinstateIndex',
				'dialog.cherryPick.noCommit',
				'dialog.cherryPick.recordOrigin',
				'dialog.createBranch.checkOut',
				'dialog.deleteBranch.forceDelete',
				'dialog.fetchIntoLocalBranch.forceFetch',
				'dialog.fetchRemote.prune',
				'dialog.fetchRemote.pruneTags',
				'dialog.merge.noCommit',
				'dialog.merge.noFastForward',
				'dialog.merge.squashCommits',
				'dialog.popStash.reinstateIndex',
				'dialog.pullBranch.noFastForward',
				'dialog.pullBranch.squashCommits',
				'dialog.rebase.ignoreDate',
				'dialog.rebase.launchInteractiveRebase',
				'dialog.stashUncommittedChanges.includeUntracked'
			].forEach((section) => vscode.mockExtensionSettingReturnValue(section, 0));

			// Run
			const value = config.dialogDefaults;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.pushToRemote', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.type', 'Annotated');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.applyStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.recordOrigin', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.createBranch.checkOut', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.deleteBranch.forceDelete', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchIntoLocalBranch.forceFetch', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.prune', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.pruneTags', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.general.referenceInputSpaceSubstitution', 'None');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noFastForward', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.popStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.noFastForward', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.ignoreDate', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.launchInteractiveRebase', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetCurrentBranchToCommit.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetUncommittedChanges.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.stashUncommittedChanges.includeUntracked', true);
			expect(value).toStrictEqual({
				addTag: {
					pushToRemote: false,
					type: TagType.Annotated
				},
				applyStash: {
					reinstateIndex: false
				},
				cherryPick: {
					noCommit: false,
					recordOrigin: false
				},
				createBranch: {
					checkout: false
				},
				deleteBranch: {
					forceDelete: false
				},
				fetchIntoLocalBranch: {
					forceFetch: false
				},
				fetchRemote: {
					prune: false,
					pruneTags: false
				},
				general: {
					referenceInputSpaceSubstitution: null
				},
				merge: {
					noCommit: false,
					noFastForward: false,
					squash: false
				},
				popStash: {
					reinstateIndex: false
				},
				pullBranch: {
					noFastForward: false,
					squash: false
				},
				rebase: {
					ignoreDate: false,
					interactive: false
				},
				resetCommit: {
					mode: GitResetMode.Mixed
				},
				resetUncommitted: {
					mode: GitResetMode.Mixed
				},
				stashUncommittedChanges: {
					includeUntracked: false
				}
			});
		});

		it('Should return the default values for text-based configuration values when they are invalid', () => {
			// Setup
			[
				'dialog.addTag.type',
				'dialog.resetCurrentBranchToCommit.mode',
				'dialog.resetUncommittedChanges.mode'
			].forEach((section) => vscode.mockExtensionSettingReturnValue(section, 'invalid'));

			// Run
			const value = config.dialogDefaults;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.pushToRemote', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.type', 'Annotated');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.applyStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.recordOrigin', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.createBranch.checkOut', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.deleteBranch.forceDelete', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchIntoLocalBranch.forceFetch', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.prune', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.pruneTags', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.general.referenceInputSpaceSubstitution', 'None');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noFastForward', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.popStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.noFastForward', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.ignoreDate', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.launchInteractiveRebase', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetCurrentBranchToCommit.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetUncommittedChanges.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.stashUncommittedChanges.includeUntracked', true);
			expect(value).toStrictEqual({
				addTag: {
					pushToRemote: false,
					type: TagType.Annotated
				},
				applyStash: {
					reinstateIndex: false
				},
				cherryPick: {
					noCommit: false,
					recordOrigin: false
				},
				createBranch: {
					checkout: false
				},
				deleteBranch: {
					forceDelete: false
				},
				fetchIntoLocalBranch: {
					forceFetch: false
				},
				fetchRemote: {
					prune: false,
					pruneTags: false
				},
				general: {
					referenceInputSpaceSubstitution: null
				},
				merge: {
					noCommit: false,
					noFastForward: true,
					squash: false
				},
				popStash: {
					reinstateIndex: false
				},
				pullBranch: {
					noFastForward: false,
					squash: false
				},
				rebase: {
					ignoreDate: true,
					interactive: false
				},
				resetCommit: {
					mode: GitResetMode.Mixed
				},
				resetUncommitted: {
					mode: GitResetMode.Mixed
				},
				stashUncommittedChanges: {
					includeUntracked: true
				}
			});
		});

		it('Should return the default values when the configuration values are not set', () => {
			// Run
			const value = config.dialogDefaults;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.pushToRemote', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.addTag.type', 'Annotated');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.applyStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.cherryPick.recordOrigin', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.createBranch.checkOut', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.deleteBranch.forceDelete', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchIntoLocalBranch.forceFetch', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.prune', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.fetchRemote.pruneTags', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.general.referenceInputSpaceSubstitution', 'None');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noCommit', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.noFastForward', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.popStash.reinstateIndex', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.noFastForward', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashCommits', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.ignoreDate', true);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.rebase.launchInteractiveRebase', false);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetCurrentBranchToCommit.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.resetUncommittedChanges.mode', 'Mixed');
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.stashUncommittedChanges.includeUntracked', true);
			expect(value).toStrictEqual({
				addTag: {
					pushToRemote: false,
					type: TagType.Annotated
				},
				applyStash: {
					reinstateIndex: false
				},
				cherryPick: {
					noCommit: false,
					recordOrigin: false
				},
				createBranch: {
					checkout: false
				},
				deleteBranch: {
					forceDelete: false
				},
				fetchIntoLocalBranch: {
					forceFetch: false
				},
				fetchRemote: {
					prune: false,
					pruneTags: false
				},
				general: {
					referenceInputSpaceSubstitution: null
				},
				merge: {
					noCommit: false,
					noFastForward: true,
					squash: false
				},
				popStash: {
					reinstateIndex: false
				},
				pullBranch: {
					noFastForward: false,
					squash: false
				},
				rebase: {
					ignoreDate: true,
					interactive: false
				},
				resetCommit: {
					mode: GitResetMode.Mixed
				},
				resetUncommitted: {
					mode: GitResetMode.Mixed
				},
				stashUncommittedChanges: {
					includeUntracked: true
				}
			});
		});

		describe('dialogDefaults.addTag.type', () => {
			it('Should return TagType.Annotated when the configuration value is "Annotated"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.addTag.type', 'Annotated');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.addTag.type).toBe(TagType.Annotated);
			});

			it('Should return TagType.Lightweight when the configuration value is "Lightweight"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.addTag.type', 'Lightweight');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.addTag.type).toBe(TagType.Lightweight);
			});
		});

		describe('dialogDefaults.general.referenceInputSpaceSubstitution', () => {
			it('Should return NULL when the configuration value is "None"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.general.referenceInputSpaceSubstitution', 'None');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.general.referenceInputSpaceSubstitution).toBe(null);
			});

			it('Should return "-" when the configuration value is "Hyphen"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.general.referenceInputSpaceSubstitution', 'Hyphen');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.general.referenceInputSpaceSubstitution).toBe('-');
			});

			it('Should return "_" when the configuration value is "Underscore"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.general.referenceInputSpaceSubstitution', 'Underscore');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.general.referenceInputSpaceSubstitution).toBe('_');
			});

			it('Should return the default value (NULL) when the configuration value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.general.referenceInputSpaceSubstitution', 'invalid');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.general.referenceInputSpaceSubstitution).toBe(null);
			});
		});

		describe('dialogDefaults.resetCommit.mode', () => {
			it('Should return GitResetMode.Hard when the configuration value is "Hard"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.resetCurrentBranchToCommit.mode', 'Hard');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.resetCommit.mode).toBe(GitResetMode.Hard);
			});

			it('Should return GitResetMode.Mixed when the configuration value is "Mixed"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.resetCurrentBranchToCommit.mode', 'Mixed');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.resetCommit.mode).toBe(GitResetMode.Mixed);
			});

			it('Should return GitResetMode.Soft when the configuration value is "Soft"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.resetCurrentBranchToCommit.mode', 'Soft');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.resetCommit.mode).toBe(GitResetMode.Soft);
			});
		});

		describe('dialogDefaults.resetUncommitted.mode', () => {
			it('Should return GitResetMode.Hard when the configuration value is "Hard"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.resetUncommittedChanges.mode', 'Hard');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.resetUncommitted.mode).toBe(GitResetMode.Hard);
			});

			it('Should return GitResetMode.Mixed when the configuration value is "Mixed"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('dialog.resetUncommittedChanges.mode', 'Mixed');

				// Run
				const value = config.dialogDefaults;

				// Assert
				expect(value.resetUncommitted.mode).toBe(GitResetMode.Mixed);
			});
		});
	});

	describe('squashMergeMessageFormat', () => {
		it('Should return SquashMessageFormat.Default when the configuration value is "Default"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('dialog.merge.squashMessageFormat', 'Default');

			// Run
			const value = config.squashMergeMessageFormat;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashMessageFormat', 'Default');
			expect(value).toBe(SquashMessageFormat.Default);
		});

		it('Should return SquashMessageFormat.GitSquashMsg when the configuration value is "Git SQUASH_MSG"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('dialog.merge.squashMessageFormat', 'Git SQUASH_MSG');

			// Run
			const value = config.squashMergeMessageFormat;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashMessageFormat', 'Default');
			expect(value).toBe(SquashMessageFormat.GitSquashMsg);
		});

		it('Should return the default value (SquashMessageFormat.Default) when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('dialog.merge.squashMessageFormat', 'invalid');

			// Run
			const value = config.squashMergeMessageFormat;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashMessageFormat', 'Default');
			expect(value).toBe(SquashMessageFormat.Default);
		});

		it('Should return the default value (SquashMessageFormat.Default) when the configuration value is not set', () => {
			// Run
			const value = config.squashMergeMessageFormat;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashMessageFormat', 'Default');
			expect(value).toBe(SquashMessageFormat.Default);
		});
	});

	describe('squashPullMessageFormat', () => {
		it('Should return SquashMessageFormat.Default when the configuration value is "Default"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('dialog.pullBranch.squashMessageFormat', 'Default');

			// Run
			const value = config.squashPullMessageFormat;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashMessageFormat', 'Default');
			expect(value).toBe(SquashMessageFormat.Default);
		});

		it('Should return SquashMessageFormat.GitSquashMsg when the configuration value is "Git SQUASH_MSG"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('dialog.pullBranch.squashMessageFormat', 'Git SQUASH_MSG');

			// Run
			const value = config.squashPullMessageFormat;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashMessageFormat', 'Default');
			expect(value).toBe(SquashMessageFormat.GitSquashMsg);
		});

		it('Should return the default value (SquashMessageFormat.Default) when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('dialog.pullBranch.squashMessageFormat', 'invalid');

			// Run
			const value = config.squashPullMessageFormat;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashMessageFormat', 'Default');
			expect(value).toBe(SquashMessageFormat.Default);
		});

		it('Should return the default value (SquashMessageFormat.Default) when the configuration value is not set', () => {
			// Run
			const value = config.squashPullMessageFormat;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashMessageFormat', 'Default');
			expect(value).toBe(SquashMessageFormat.Default);
		});
	});

	describe('enhancedAccessibility', testBooleanExtensionSetting('enhancedAccessibility', 'enhancedAccessibility', false));

	describe('fileEncoding', () => {
		it('Should return the configured value', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('fileEncoding', 'file-encoding');

			// Run
			const value = config.fileEncoding;

			expect(workspaceConfiguration.get).toBeCalledWith('fileEncoding', 'utf8');
			expect(value).toBe('file-encoding');
		});

		it('Should return the default configuration value ("utf8")', () => {
			// Run
			const value = config.fileEncoding;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('fileEncoding', 'utf8');
			expect(value).toBe('utf8');
		});
	});

	describe('graph', () => {
		describe('colours', () => {
			it('Should return a filtered array of colours based on the configuration value', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('graph.colours', ['#ff0000', '#0000000', '#00ff0088', 'rgb(1,2,3)', 'rgb(1,2,x)']);

				// Run
				const value = config.graph.colours;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('graph.colours', 'graphColours');
				expect(value).toHaveLength(3);
				expect(value[0]).toBe('#ff0000');
				expect(value[1]).toBe('#00ff0088');
				expect(value[2]).toBe('rgb(1,2,3)');
			});

			it('Should return the default value when the configuration value is invalid (not an array)', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('graph.colours', 5);

				// Run
				const value = config.graph.colours;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('graph.colours', 'graphColours');
				expect(value).toStrictEqual(['#0085d9', '#d9008f', '#00d90a', '#d98500', '#a300d9', '#ff0000', '#00d9cc', '#e138e8', '#85d900', '#dc5b23', '#6f24d6', '#ffcc00']);
			});

			it('Should return the default value when the configuration value is invalid (an empty array)', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('graph.colours', []);

				// Run
				const value = config.graph.colours;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('graph.colours', 'graphColours');
				expect(value).toStrictEqual(['#0085d9', '#d9008f', '#00d90a', '#d98500', '#a300d9', '#ff0000', '#00d9cc', '#e138e8', '#85d900', '#dc5b23', '#6f24d6', '#ffcc00']);
			});

			it('Should return the default value when the configuration value is unknown', () => {
				// Run
				const value = config.graph.colours;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('graph.colours', 'graphColours');
				expect(value).toStrictEqual(['#0085d9', '#d9008f', '#00d90a', '#d98500', '#a300d9', '#ff0000', '#00d9cc', '#e138e8', '#85d900', '#dc5b23', '#6f24d6', '#ffcc00']);
			});
		});

		describe('style', () => {
			it('Should return GraphStyle.Rounded when the configuration value is "rounded"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('graph.style', 'rounded');

				// Run
				const value = config.graph.style;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('graph.style', 'graphStyle');
				expect(value).toBe(GraphStyle.Rounded);
			});

			it('Should return GraphStyle.Angular when the configuration value is "angular"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('graph.style', 'angular');

				// Run
				const value = config.graph.style;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('graph.style', 'graphStyle');
				expect(value).toBe(GraphStyle.Angular);
			});

			it('Should return the default value (GraphStyle.Rounded) when the configuration value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('graph.style', 'invalid');

				// Run
				const value = config.graph.style;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('graph.style', 'graphStyle');
				expect(value).toBe(GraphStyle.Rounded);
			});

			it('Should return the default value (GraphStyle.Rounded) when the configuration value is unknown', () => {
				// Run
				const value = config.graph.style;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('graph.style', 'graphStyle');
				expect(value).toBe(GraphStyle.Rounded);
			});
		});

		describe('uncommittedChanges', () => {
			it('Should return GraphUncommittedChangesStyle.OpenCircleAtTheUncommittedChanges when the configuration value is "Open Circle at the Uncommitted Changes"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('graph.uncommittedChanges', 'Open Circle at the Uncommitted Changes');

				// Run
				const value = config.graph.uncommittedChanges;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('graph.uncommittedChanges', 'Open Circle at the Uncommitted Changes');
				expect(value).toBe(GraphUncommittedChangesStyle.OpenCircleAtTheUncommittedChanges);
			});

			it('Should return GraphUncommittedChangesStyle.OpenCircleAtTheCheckedOutCommit when the configuration value is "Open Circle at the Checked Out Commit"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('graph.uncommittedChanges', 'Open Circle at the Checked Out Commit');

				// Run
				const value = config.graph.uncommittedChanges;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('graph.uncommittedChanges', 'Open Circle at the Uncommitted Changes');
				expect(value).toBe(GraphUncommittedChangesStyle.OpenCircleAtTheCheckedOutCommit);
			});

			it('Should return the default value (GraphUncommittedChangesStyle.OpenCircleAtTheUncommittedChanges) when the configuration value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('graph.uncommittedChanges', 'invalid');

				// Run
				const value = config.graph.uncommittedChanges;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('graph.uncommittedChanges', 'Open Circle at the Uncommitted Changes');
				expect(value).toBe(GraphUncommittedChangesStyle.OpenCircleAtTheUncommittedChanges);
			});

			it('Should return the default value (GraphUncommittedChangesStyle.OpenCircleAtTheUncommittedChanges) when the configuration value is unknown', () => {
				// Run
				const value = config.graph.uncommittedChanges;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('graph.uncommittedChanges', 'Open Circle at the Uncommitted Changes');
				expect(value).toBe(GraphUncommittedChangesStyle.OpenCircleAtTheUncommittedChanges);
			});
		});
	});

	describe('integratedTerminalShell', () => {
		it('Should return the configured value', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('integratedTerminalShell', '/path/to/shell');

			// Run
			const value = config.integratedTerminalShell;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('integratedTerminalShell', '');
			expect(value).toBe('/path/to/shell');
		});

		it('Should return the default configuration value ("")', () => {
			// Run
			const value = config.integratedTerminalShell;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('integratedTerminalShell', '');
			expect(value).toBe('');
		});
	});

	describe('keybindings', () => {
		describe('find', () => {
			it('Should return the configured keybinding', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.find', 'CTRL/CMD + A');

				// Run
				const value = config.keybindings.find;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.find');
				expect(value).toBe('a');
			});

			it('Should return the configured keybinding (unassigned)', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.find', 'UNASSIGNED');

				// Run
				const value = config.keybindings.find;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.find');
				expect(value).toBeNull();
			});

			it('Should return the default keybinding when the value is not one of the available keybindings', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.find', 'CTRL/CMD + Shift + A');

				// Run
				const value = config.keybindings.find;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.find');
				expect(value).toBe('f');
			});

			it('Should return the default keybinding when the value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.find', 5);

				// Run
				const value = config.keybindings.find;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.find');
				expect(value).toBe('f');
			});

			it('Should return the default keybinding', () => {
				// Run
				const value = config.keybindings.find;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.find');
				expect(value).toBe('f');
			});
		});

		describe('refresh', () => {
			it('Should return the configured keybinding', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.refresh', 'CTRL/CMD + A');

				// Run
				const value = config.keybindings.refresh;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.refresh');
				expect(value).toBe('a');
			});

			it('Should return the configured keybinding (unassigned)', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.refresh', 'UNASSIGNED');

				// Run
				const value = config.keybindings.refresh;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.refresh');
				expect(value).toBeNull();
			});

			it('Should return the default keybinding when the value is not one of the available keybindings', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.refresh', 'CTRL/CMD + Shift + A');

				// Run
				const value = config.keybindings.refresh;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.refresh');
				expect(value).toBe('r');
			});

			it('Should return the default keybinding when the value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.refresh', 5);

				// Run
				const value = config.keybindings.refresh;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.refresh');
				expect(value).toBe('r');
			});

			it('Should return the default keybinding', () => {
				// Run
				const value = config.keybindings.refresh;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.refresh');
				expect(value).toBe('r');
			});
		});

		describe('scrollToHead', () => {
			it('Should return the configured keybinding', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.scrollToHead', 'CTRL/CMD + A');

				// Run
				const value = config.keybindings.scrollToHead;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.scrollToHead');
				expect(value).toBe('a');
			});

			it('Should return the configured keybinding (unassigned)', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.scrollToHead', 'UNASSIGNED');

				// Run
				const value = config.keybindings.scrollToHead;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.scrollToHead');
				expect(value).toBeNull();
			});

			it('Should return the default keybinding when the value is not one of the available keybindings', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.scrollToHead', 'CTRL/CMD + Shift + A');

				// Run
				const value = config.keybindings.scrollToHead;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.scrollToHead');
				expect(value).toBe('h');
			});

			it('Should return the default keybinding when the value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.scrollToHead', 5);

				// Run
				const value = config.keybindings.scrollToHead;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.scrollToHead');
				expect(value).toBe('h');
			});

			it('Should return the default keybinding', () => {
				// Run
				const value = config.keybindings.scrollToHead;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.scrollToHead');
				expect(value).toBe('h');
			});
		});

		describe('scrollToStash', () => {
			it('Should return the configured keybinding', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.scrollToStash', 'CTRL/CMD + A');

				// Run
				const value = config.keybindings.scrollToStash;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.scrollToStash');
				expect(value).toBe('a');
			});

			it('Should return the configured keybinding (unassigned)', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.scrollToStash', 'UNASSIGNED');

				// Run
				const value = config.keybindings.scrollToStash;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.scrollToStash');
				expect(value).toBeNull();
			});

			it('Should return the default keybinding when the value is not one of the available keybindings', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.scrollToStash', 'CTRL/CMD + Shift + A');

				// Run
				const value = config.keybindings.scrollToStash;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.scrollToStash');
				expect(value).toBe('s');
			});

			it('Should return the default keybinding when the value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('keyboardShortcut.scrollToStash', 5);

				// Run
				const value = config.keybindings.scrollToStash;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.scrollToStash');
				expect(value).toBe('s');
			});

			it('Should return the default keybinding', () => {
				// Run
				const value = config.keybindings.scrollToStash;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('keyboardShortcut.scrollToStash');
				expect(value).toBe('s');
			});
		});
	});

	describe('markdown', testBooleanExtensionSetting('markdown', 'markdown', true));

	describe('maxDepthOfRepoSearch', () => {
		it('Should return the configured value', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('maxDepthOfRepoSearch', 5);

			// Run
			const value = config.maxDepthOfRepoSearch;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('maxDepthOfRepoSearch', 0);
			expect(value).toBe(5);
		});

		it('Should return the default configuration value (0)', () => {
			// Run
			const value = config.maxDepthOfRepoSearch;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('maxDepthOfRepoSearch', 0);
			expect(value).toBe(0);
		});
	});

	describe('openNewTabEditorGroup', () => {
		it('Should return vscode.ViewColumn.Active when the configuration value is "Active"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'Active');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Active);
		});

		it('Should return vscode.ViewColumn.Beside when the configuration value is "Beside"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'Beside');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Beside);
		});

		it('Should return vscode.ViewColumn.One when the configuration value is "One"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'One');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.One);
		});

		it('Should return vscode.ViewColumn.Two when the configuration value is "Two"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'Two');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Two);
		});

		it('Should return vscode.ViewColumn.Three when the configuration value is "Three"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'Three');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Three);
		});

		it('Should return vscode.ViewColumn.Four when the configuration value is "Four"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'Four');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Four);
		});

		it('Should return vscode.ViewColumn.Five when the configuration value is "Five"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'Five');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Five);
		});

		it('Should return vscode.ViewColumn.Six when the configuration value is "Six"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'Six');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Six);
		});

		it('Should return vscode.ViewColumn.Seven when the configuration value is "Seven"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'Seven');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Seven);
		});

		it('Should return vscode.ViewColumn.Eight when the configuration value is "Eight"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'Eight');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Eight);
		});

		it('Should return vscode.ViewColumn.Nine when the configuration value is "Nine"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'Nine');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Nine);
		});

		it('Should return the default value (vscode.ViewColumn.Active) when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openNewTabEditorGroup', 'invalid');

			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Active);
		});

		it('Should return the default value (vscode.ViewColumn.Active) when the configuration value is unknown', () => {
			// Run
			const value = config.openNewTabEditorGroup;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('openNewTabEditorGroup', 'openDiffTabLocation');
			expect(value).toBe(vscode.ViewColumn.Active);
		});
	});

	describe('openToTheRepoOfTheActiveTextEditorDocument', testBooleanExtensionSetting('openToTheRepoOfTheActiveTextEditorDocument', 'openToTheRepoOfTheActiveTextEditorDocument', false));

	describe('referenceLabels', () => {
		describe('combineLocalAndRemoteBranchLabels', () => {
			it('Should return TRUE when the configuration value is TRUE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('referenceLabels.combineLocalAndRemoteBranchLabels', true);

				// Run
				const value = config.referenceLabels.combineLocalAndRemoteBranchLabels;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('referenceLabels.combineLocalAndRemoteBranchLabels', 'combineLocalAndRemoteBranchLabels');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is FALSE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('referenceLabels.combineLocalAndRemoteBranchLabels', false);

				// Run
				const value = config.referenceLabels.combineLocalAndRemoteBranchLabels;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('referenceLabels.combineLocalAndRemoteBranchLabels', 'combineLocalAndRemoteBranchLabels');
				expect(value).toBe(false);
			});

			it('Should return TRUE when the configuration value is truthy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('referenceLabels.combineLocalAndRemoteBranchLabels', 5);

				// Run
				const value = config.referenceLabels.combineLocalAndRemoteBranchLabels;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('referenceLabels.combineLocalAndRemoteBranchLabels', 'combineLocalAndRemoteBranchLabels');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is falsy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('referenceLabels.combineLocalAndRemoteBranchLabels', 0);

				// Run
				const value = config.referenceLabels.combineLocalAndRemoteBranchLabels;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('referenceLabels.combineLocalAndRemoteBranchLabels', 'combineLocalAndRemoteBranchLabels');
				expect(value).toBe(false);
			});

			it('Should return the default value (TRUE) when the configuration value is unknown', () => {
				// Run
				const value = config.referenceLabels.combineLocalAndRemoteBranchLabels;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('referenceLabels.combineLocalAndRemoteBranchLabels', 'combineLocalAndRemoteBranchLabels');
				expect(value).toBe(true);
			});
		});

		describe('branchLabelsAlignedToGraph & tagLabelsOnRight', () => {
			it('Should return correct alignment values when the configuration value is "Normal"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('referenceLabels.alignment', 'Normal');

				// Run
				const value = config.referenceLabels;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('referenceLabels.alignment', 'referenceLabelAlignment');
				expect(value.branchLabelsAlignedToGraph).toBe(false);
				expect(value.tagLabelsOnRight).toBe(false);
			});

			it('Should return correct alignment values when the configuration value is "Branches (on the left) & Tags (on the right)"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('referenceLabels.alignment', 'Branches (on the left) & Tags (on the right)');

				// Run
				const value = config.referenceLabels;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('referenceLabels.alignment', 'referenceLabelAlignment');
				expect(value.branchLabelsAlignedToGraph).toBe(false);
				expect(value.tagLabelsOnRight).toBe(true);
			});

			it('Should return correct alignment values when the configuration value is "Branches (aligned to the graph) & Tags (on the right)"', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('referenceLabels.alignment', 'Branches (aligned to the graph) & Tags (on the right)');

				// Run
				const value = config.referenceLabels;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('referenceLabels.alignment', 'referenceLabelAlignment');
				expect(value.branchLabelsAlignedToGraph).toBe(true);
				expect(value.tagLabelsOnRight).toBe(true);
			});

			it('Should return the default values when the configuration value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('referenceLabels.alignment', 'invalid');

				// Run
				const value = config.referenceLabels;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('referenceLabels.alignment', 'referenceLabelAlignment');
				expect(value.branchLabelsAlignedToGraph).toBe(false);
				expect(value.tagLabelsOnRight).toBe(false);
			});

			it('Should return the default values when the configuration value is unknown', () => {
				// Run
				const value = config.referenceLabels;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('referenceLabels.alignment', 'referenceLabelAlignment');
				expect(value.branchLabelsAlignedToGraph).toBe(false);
				expect(value.tagLabelsOnRight).toBe(false);
			});
		});
	});

	describe('fetchAvatars', testRenamedBooleanExtensionSetting('fetchAvatars', 'repository.commits.fetchAvatars', 'fetchAvatars', false));

	describe('initialLoadCommits', () => {
		it('Should return the configured value', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('repository.commits.initialLoad', 600);

			// Run
			const value = config.initialLoadCommits;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.initialLoad', 'initialLoadCommits');
			expect(value).toBe(600);
		});

		it('Should return the default configuration value (300)', () => {
			// Run
			const value = config.initialLoadCommits;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.initialLoad', 'initialLoadCommits');
			expect(value).toBe(300);
		});
	});

	describe('loadMoreCommits', () => {
		it('Should return the configured value', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('repository.commits.loadMore', 200);

			// Run
			const value = config.loadMoreCommits;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.loadMore', 'loadMoreCommits');
			expect(value).toBe(200);
		});

		it('Should return the default configuration value (100)', () => {
			// Run
			const value = config.loadMoreCommits;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.loadMore', 'loadMoreCommits');
			expect(value).toBe(100);
		});
	});

	describe('loadMoreCommitsAutomatically', testRenamedBooleanExtensionSetting('loadMoreCommitsAutomatically', 'repository.commits.loadMoreAutomatically', 'loadMoreCommitsAutomatically', true));

	describe('muteCommits', () => {
		describe('commitsNotAncestorsOfHead', () => {
			it('Should return TRUE when the configuration value is TRUE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.commits.mute.commitsThatAreNotAncestorsOfHead', true);

				// Run
				const value = config.muteCommits.commitsNotAncestorsOfHead;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.mute.commitsThatAreNotAncestorsOfHead', 'muteCommitsThatAreNotAncestorsOfHead');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is FALSE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.commits.mute.commitsThatAreNotAncestorsOfHead', false);

				// Run
				const value = config.muteCommits.commitsNotAncestorsOfHead;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.mute.commitsThatAreNotAncestorsOfHead', 'muteCommitsThatAreNotAncestorsOfHead');
				expect(value).toBe(false);
			});

			it('Should return TRUE when the configuration value is truthy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.commits.mute.commitsThatAreNotAncestorsOfHead', 5);

				// Run
				const value = config.muteCommits.commitsNotAncestorsOfHead;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.mute.commitsThatAreNotAncestorsOfHead', 'muteCommitsThatAreNotAncestorsOfHead');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is falsy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.commits.mute.commitsThatAreNotAncestorsOfHead', 0);

				// Run
				const value = config.muteCommits.commitsNotAncestorsOfHead;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.mute.commitsThatAreNotAncestorsOfHead', 'muteCommitsThatAreNotAncestorsOfHead');
				expect(value).toBe(false);
			});

			it('Should return the default value (FALSE) when the configuration value is unknown', () => {
				// Run
				const value = config.muteCommits.commitsNotAncestorsOfHead;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.mute.commitsThatAreNotAncestorsOfHead', 'muteCommitsThatAreNotAncestorsOfHead');
				expect(value).toBe(false);
			});
		});

		describe('mergeCommits', () => {
			it('Should return TRUE when the configuration value is TRUE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.commits.mute.mergeCommits', true);

				// Run
				const value = config.muteCommits.mergeCommits;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.mute.mergeCommits', 'muteMergeCommits');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is FALSE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.commits.mute.mergeCommits', false);

				// Run
				const value = config.muteCommits.mergeCommits;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.mute.mergeCommits', 'muteMergeCommits');
				expect(value).toBe(false);
			});

			it('Should return TRUE when the configuration value is truthy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.commits.mute.mergeCommits', 5);

				// Run
				const value = config.muteCommits.mergeCommits;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.mute.mergeCommits', 'muteMergeCommits');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is falsy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.commits.mute.mergeCommits', 0);

				// Run
				const value = config.muteCommits.mergeCommits;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.mute.mergeCommits', 'muteMergeCommits');
				expect(value).toBe(false);
			});

			it('Should return the default value (TRUE) when the configuration value is unknown', () => {
				// Run
				const value = config.muteCommits.mergeCommits;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.mute.mergeCommits', 'muteMergeCommits');
				expect(value).toBe(true);
			});
		});
	});

	describe('commitOrder', () => {
		it('Should return CommitOrdering.Date when the configuration value is "date"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('repository.commits.order', 'date');

			// Run
			const value = config.commitOrder;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.order', 'commitOrdering');
			expect(value).toBe(CommitOrdering.Date);
		});

		it('Should return CommitOrdering.AuthorDate when the configuration value is "author-date"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('repository.commits.order', 'author-date');

			// Run
			const value = config.commitOrder;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.order', 'commitOrdering');
			expect(value).toBe(CommitOrdering.AuthorDate);
		});

		it('Should return CommitOrdering.Topological when the configuration value is "topo"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('repository.commits.order', 'topo');

			// Run
			const value = config.commitOrder;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.order', 'commitOrdering');
			expect(value).toBe(CommitOrdering.Topological);
		});

		it('Should return the default value (CommitOrdering.Date) when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('repository.commits.order', 'invalid');

			// Run
			const value = config.commitOrder;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.order', 'commitOrdering');
			expect(value).toBe(CommitOrdering.Date);
		});

		it('Should return the default value (CommitOrdering.Date) when the configuration value is unknown', () => {
			// Run
			const value = config.commitOrder;

			// Assert
			expectRenamedExtensionSettingToHaveBeenCalled('repository.commits.order', 'commitOrdering');
			expect(value).toBe(CommitOrdering.Date);
		});
	});

	describe('fetchAndPrune', testRenamedBooleanExtensionSetting('fetchAndPrune', 'repository.fetchAndPrune', 'fetchAndPrune', false));

	describe('fetchAndPruneTags', testBooleanExtensionSetting('fetchAndPruneTags', 'repository.fetchAndPruneTags', false));

	describe('includeCommitsMentionedByReflogs', testRenamedBooleanExtensionSetting('includeCommitsMentionedByReflogs', 'repository.includeCommitsMentionedByReflogs', 'includeCommitsMentionedByReflogs', false));

	describe('onRepoLoad', () => {
		describe('scrollToHead', () => {
			it('Should return TRUE when the configuration value is TRUE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.scrollToHead', true);

				// Run
				const value = config.onRepoLoad.scrollToHead;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.onLoad.scrollToHead', 'openRepoToHead');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is FALSE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.scrollToHead', false);

				// Run
				const value = config.onRepoLoad.scrollToHead;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.onLoad.scrollToHead', 'openRepoToHead');
				expect(value).toBe(false);
			});

			it('Should return TRUE when the configuration value is truthy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.scrollToHead', 5);

				// Run
				const value = config.onRepoLoad.scrollToHead;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.onLoad.scrollToHead', 'openRepoToHead');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is falsy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.scrollToHead', 0);

				// Run
				const value = config.onRepoLoad.scrollToHead;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.onLoad.scrollToHead', 'openRepoToHead');
				expect(value).toBe(false);
			});

			it('Should return the default value (FALSE) when the configuration value is unknown', () => {
				// Run
				const value = config.onRepoLoad.scrollToHead;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.onLoad.scrollToHead', 'openRepoToHead');
				expect(value).toBe(false);
			});
		});

		describe('showCheckedOutBranch', () => {
			it('Should return TRUE when the configuration value is TRUE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.showCheckedOutBranch', true);

				// Run
				const value = config.onRepoLoad.showCheckedOutBranch;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.onLoad.showCheckedOutBranch', 'showCurrentBranchByDefault');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is FALSE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.showCheckedOutBranch', false);

				// Run
				const value = config.onRepoLoad.showCheckedOutBranch;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.onLoad.showCheckedOutBranch', 'showCurrentBranchByDefault');
				expect(value).toBe(false);
			});

			it('Should return TRUE when the configuration value is truthy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.showCheckedOutBranch', 5);

				// Run
				const value = config.onRepoLoad.showCheckedOutBranch;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.onLoad.showCheckedOutBranch', 'showCurrentBranchByDefault');
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is falsy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.showCheckedOutBranch', 0);

				// Run
				const value = config.onRepoLoad.showCheckedOutBranch;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.onLoad.showCheckedOutBranch', 'showCurrentBranchByDefault');
				expect(value).toBe(false);
			});

			it('Should return the default value (FALSE) when the configuration value is unknown', () => {
				// Run
				const value = config.onRepoLoad.showCheckedOutBranch;

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled('repository.onLoad.showCheckedOutBranch', 'showCurrentBranchByDefault');
				expect(value).toBe(false);
			});
		});

		describe('showSpecificBranches', () => {
			it('Should return all branches when correctly configured', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.showSpecificBranches', ['master', 'develop']);

				// Run
				const value = config.onRepoLoad.showSpecificBranches;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('repository.onLoad.showSpecificBranches', expect.anything());
				expect(value).toStrictEqual(['master', 'develop']);
			});

			it('Should filter out all non-string branches', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.showSpecificBranches', ['master', 5, 'develop']);

				// Run
				const value = config.onRepoLoad.showSpecificBranches;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('repository.onLoad.showSpecificBranches', expect.anything());
				expect(value).toStrictEqual(['master', 'develop']);
			});

			it('Should return the default value ([]) when the configuration value is invalid', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue('repository.onLoad.showSpecificBranches', 'master');

				// Run
				const value = config.onRepoLoad.showSpecificBranches;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('repository.onLoad.showSpecificBranches', expect.anything());
				expect(value).toStrictEqual([]);
			});

			it('Should return the default value ([]) when the configuration value is unknown', () => {
				// Run
				const value = config.onRepoLoad.showSpecificBranches;

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith('repository.onLoad.showSpecificBranches', expect.anything());
				expect(value).toStrictEqual([]);
			});
		});
	});

	describe('onlyFollowFirstParent', testRenamedBooleanExtensionSetting('onlyFollowFirstParent', 'repository.onlyFollowFirstParent', 'onlyFollowFirstParent', false));

	describe('showCommitsOnlyReferencedByTags', testRenamedBooleanExtensionSetting('showCommitsOnlyReferencedByTags', 'repository.showCommitsOnlyReferencedByTags', 'showCommitsOnlyReferencedByTags', true));

	describe('showSignatureStatus', testRenamedBooleanExtensionSetting('showSignatureStatus', 'repository.commits.showSignatureStatus', 'showSignatureStatus', false));

	describe('showRemoteBranches', testBooleanExtensionSetting('showRemoteBranches', 'repository.showRemoteBranches', true));

	describe('showRemoteHeads', testBooleanExtensionSetting('showRemoteHeads', 'repository.showRemoteHeads', true));

	describe('showStashes', testBooleanExtensionSetting('showStashes', 'repository.showStashes', true));

	describe('showTags', testRenamedBooleanExtensionSetting('showTags', 'repository.showTags', 'showTags', true));

	describe('showUncommittedChanges', testRenamedBooleanExtensionSetting('showUncommittedChanges', 'repository.showUncommittedChanges', 'showUncommittedChanges', true));

	describe('showUntrackedFiles', testRenamedBooleanExtensionSetting('showUntrackedFiles', 'repository.showUntrackedFiles', 'showUntrackedFiles', true));

	describe('signCommits', testBooleanExtensionSetting('signCommits', 'repository.sign.commits', false));

	describe('signTags', testBooleanExtensionSetting('signTags', 'repository.sign.tags', false));

	describe('useMailmap', testRenamedBooleanExtensionSetting('useMailmap', 'repository.useMailmap', 'useMailmap', false));

	describe('repoDropdownOrder', () => {
		it('Should return RepoDropdownOrder.Name when the configuration value is "Name"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('repositoryDropdownOrder', 'Name');

			// Run
			const value = config.repoDropdownOrder;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('repositoryDropdownOrder', 'Workspace Full Path');
			expect(value).toBe(RepoDropdownOrder.Name);
		});

		it('Should return RepoDropdownOrder.FullPath when the configuration value is "Full Path"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('repositoryDropdownOrder', 'Full Path');

			// Run
			const value = config.repoDropdownOrder;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('repositoryDropdownOrder', 'Workspace Full Path');
			expect(value).toBe(RepoDropdownOrder.FullPath);
		});

		it('Should return RepoDropdownOrder.WorkspaceFullPath when the configuration value is "Workspace Full Path"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('repositoryDropdownOrder', 'Workspace Full Path');

			// Run
			const value = config.repoDropdownOrder;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('repositoryDropdownOrder', 'Workspace Full Path');
			expect(value).toBe(RepoDropdownOrder.WorkspaceFullPath);
		});

		it('Should return the default value (RepoDropdownOrder.WorkspaceFullPath) when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('repositoryDropdownOrder', 'invalid');

			// Run
			const value = config.repoDropdownOrder;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('repositoryDropdownOrder', 'Workspace Full Path');
			expect(value).toBe(RepoDropdownOrder.WorkspaceFullPath);
		});

		it('Should return the default value (RepoDropdownOrder.WorkspaceFullPath) when the configuration value is not set', () => {
			// Run
			const value = config.repoDropdownOrder;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('repositoryDropdownOrder', 'Workspace Full Path');
			expect(value).toBe(RepoDropdownOrder.WorkspaceFullPath);
		});
	});

	describe('retainContextWhenHidden', testBooleanExtensionSetting('retainContextWhenHidden', 'retainContextWhenHidden', true));

	describe('showStatusBarItem', testBooleanExtensionSetting('showStatusBarItem', 'showStatusBarItem', true));

	describe('tabIconColourTheme', () => {
		it('Should return TabIconColourTheme.Colour when the configuration value is "colour"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('tabIconColourTheme', 'colour');

			// Run
			const value = config.tabIconColourTheme;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('tabIconColourTheme', 'colour');
			expect(value).toBe(TabIconColourTheme.Colour);
		});

		it('Should return TabIconColourTheme.Grey when the configuration value is "grey"', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('tabIconColourTheme', 'grey');

			// Run
			const value = config.tabIconColourTheme;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('tabIconColourTheme', 'colour');
			expect(value).toBe(TabIconColourTheme.Grey);
		});

		it('Should return the default value (TabIconColourTheme.Colour) when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('tabIconColourTheme', 'invalid');

			// Run
			const value = config.tabIconColourTheme;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('tabIconColourTheme', 'colour');
			expect(value).toBe(TabIconColourTheme.Colour);
		});

		it('Should return the default value (TabIconColourTheme.Colour) when the configuration value is not set', () => {
			// Run
			const value = config.tabIconColourTheme;

			// Assert
			expect(workspaceConfiguration.get).toBeCalledWith('tabIconColourTheme', 'colour');
			expect(value).toBe(TabIconColourTheme.Colour);
		});
	});

	describe('gitPaths', () => {
		it('Should return the configured path', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('path', '/path/to/git');

			// Run
			const value = config.gitPaths;

			// Assert
			expect(vscode.workspace.getConfiguration).toBeCalledWith('git');
			expect(workspaceConfiguration.get).toBeCalledWith('path', null);
			expect(value).toStrictEqual(['/path/to/git']);
		});

		it('Should return the valid configured paths', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('path', ['/path/to/first/git', '/path/to/second/git', 4, {}, null, '/path/to/third/git']);

			// Run
			const value = config.gitPaths;

			// Assert
			expect(vscode.workspace.getConfiguration).toBeCalledWith('git');
			expect(workspaceConfiguration.get).toBeCalledWith('path', null);
			expect(value).toStrictEqual(['/path/to/first/git', '/path/to/second/git', '/path/to/third/git']);
		});

		it('Should return an empty array when the configuration value is NULL', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('path', null);

			// Run
			const value = config.gitPaths;

			// Assert
			expect(vscode.workspace.getConfiguration).toBeCalledWith('git');
			expect(workspaceConfiguration.get).toBeCalledWith('path', null);
			expect(value).toStrictEqual([]);
		});

		it('Should return an empty array when the configuration value is invalid', () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('path', 4);

			// Run
			const value = config.gitPaths;

			// Assert
			expect(vscode.workspace.getConfiguration).toBeCalledWith('git');
			expect(workspaceConfiguration.get).toBeCalledWith('path', null);
			expect(value).toStrictEqual([]);
		});

		it('Should return an empty array when the default configuration value (NULL) is received', () => {
			// Run
			const value = config.gitPaths;

			// Assert
			expect(vscode.workspace.getConfiguration).toBeCalledWith('git');
			expect(workspaceConfiguration.get).toBeCalledWith('path', null);
			expect(value).toStrictEqual([]);
		});
	});

	describe('getRenamedExtensionSetting', () => {
		it('Should return new workspace value', () => {
			// Setup
			workspaceConfiguration.inspect.mockReturnValueOnce({
				workspaceValue: true,
				globalValue: false
			});
			workspaceConfiguration.inspect.mockReturnValueOnce({
				workspaceValue: false,
				globalValue: false
			});

			// Run
			const value = config.fetchAndPrune;

			// Assert
			expect(value).toBe(true);
		});

		it('Should return old workspace value', () => {
			// Setup
			workspaceConfiguration.inspect.mockReturnValueOnce({
				workspaceValue: undefined,
				globalValue: false
			});
			workspaceConfiguration.inspect.mockReturnValueOnce({
				workspaceValue: true,
				globalValue: false
			});

			// Run
			const value = config.fetchAndPrune;

			// Assert
			expect(value).toBe(true);
		});

		it('Should return new global value', () => {
			// Setup
			workspaceConfiguration.inspect.mockReturnValueOnce({
				workspaceValue: undefined,
				globalValue: true
			});
			workspaceConfiguration.inspect.mockReturnValueOnce({
				workspaceValue: undefined,
				globalValue: false
			});

			// Run
			const value = config.fetchAndPrune;

			// Assert
			expect(value).toBe(true);
		});

		it('Should return old global value', () => {
			// Setup
			workspaceConfiguration.inspect.mockReturnValueOnce({
				workspaceValue: undefined,
				globalValue: undefined
			});
			workspaceConfiguration.inspect.mockReturnValueOnce({
				workspaceValue: undefined,
				globalValue: true
			});

			// Run
			const value = config.fetchAndPrune;

			// Assert
			expect(value).toBe(true);
		});

		it('Should return the default value', () => {
			// Setup
			workspaceConfiguration.inspect.mockReturnValueOnce({
				workspaceValue: undefined,
				globalValue: undefined
			});
			workspaceConfiguration.inspect.mockReturnValueOnce({
				workspaceValue: undefined,
				globalValue: undefined
			});

			// Run
			const value = config.fetchAndPrune;

			// Assert
			expect(value).toBe(false);
		});
	});

	function testBooleanExtensionSetting(configKey: keyof Config, section: string, defaultValue: boolean) {
		return () => {
			it('Should return TRUE when the configuration value is TRUE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue(section, true);

				// Run
				const value = config[configKey];

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith(section, defaultValue);
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is FALSE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue(section, false);

				// Run
				const value = config[configKey];

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith(section, defaultValue);
				expect(value).toBe(false);
			});

			it('Should return TRUE when the configuration value is truthy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue(section, 5);

				// Run
				const value = config[configKey];

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith(section, defaultValue);
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is falsy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue(section, 0);

				// Run
				const value = config[configKey];

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith(section, defaultValue);
				expect(value).toBe(false);
			});

			it('Should return the default value (' + (defaultValue ? 'TRUE' : 'FALSE') + ') when the configuration value is not set', () => {
				// Run
				const value = config[configKey];

				// Assert
				expect(workspaceConfiguration.get).toBeCalledWith(section, defaultValue);
				expect(value).toBe(defaultValue);
			});
		};
	}

	function testRenamedBooleanExtensionSetting(configKey: keyof Config, section: string, oldSection: string, defaultValue: boolean) {
		return () => {
			it('Should return TRUE when the configuration value is TRUE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue(section, true);

				// Run
				const value = config[configKey];

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled(section, oldSection);
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is FALSE', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue(section, false);

				// Run
				const value = config[configKey];

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled(section, oldSection);
				expect(value).toBe(false);
			});

			it('Should return TRUE when the configuration value is truthy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue(section, 5);

				// Run
				const value = config[configKey];

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled(section, oldSection);
				expect(value).toBe(true);
			});

			it('Should return FALSE when the configuration value is falsy', () => {
				// Setup
				vscode.mockExtensionSettingReturnValue(section, 0);

				// Run
				const value = config[configKey];

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled(section, oldSection);
				expect(value).toBe(false);
			});

			it('Should return the default value (' + (defaultValue ? 'TRUE' : 'FALSE') + ') when the configuration value is not set', () => {
				// Run
				const value = config[configKey];

				// Assert
				expectRenamedExtensionSettingToHaveBeenCalled(section, oldSection);
				expect(value).toBe(defaultValue);
			});
		};
	}
});
-e 

================================================================================
// FILE: ./tests/logger.test.ts
================================================================================
import * as date from './mocks/date';
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });

import { Logger } from '../src/logger';

const outputChannel = vscode.mocks.outputChannel;

describe('Logger', () => {
	let logger: Logger;
	beforeEach(() => {
		logger = new Logger();
	});
	afterEach(() => {
		logger.dispose();
	});

	it('Should create and dispose an output channel', () => {
		// Run
		logger.dispose();

		// Assert
		expect(vscode.window.createOutputChannel).toHaveBeenCalledWith('Git Graph');
		expect(outputChannel.dispose).toBeCalledTimes(1);
	});

	it('Should log a message to the Output Channel', () => {
		// Run
		logger.log('Test');

		// Assert
		expect(outputChannel.appendLine).toHaveBeenCalledWith('[2020-04-22 12:40:58.000] Test');
	});

	describe('Should log a command to the Output Channel', () => {
		it('Standard arguments are unchanged', () => {
			// Run
			logger.logCmd('git', ['cmd', '-f', '--arg1']);

			// Assert
			expect(outputChannel.appendLine).toHaveBeenCalledWith('[2020-04-22 12:40:58.000] > git cmd -f --arg1');
		});

		it('Format arguments are abbreviated', () => {
			// Run
			logger.logCmd('git', ['cmd', '--format="format-string"']);

			// Assert
			expect(outputChannel.appendLine).toHaveBeenCalledWith('[2020-04-22 12:40:58.000] > git cmd --format=...');
		});

		it('Arguments with spaces are surrounded with double quotes', () => {
			// Run
			logger.logCmd('git', ['cmd', 'argument with spaces']);

			// Assert
			expect(outputChannel.appendLine).toHaveBeenCalledWith('[2020-04-22 12:40:58.000] > git cmd "argument with spaces"');
		});

		it('Arguments with spaces are surrounded with double quotes, and any internal double quotes are escaped', () => {
			// Run
			logger.logCmd('git', ['cmd', 'argument with "double quotes" and spaces']);

			// Assert
			expect(outputChannel.appendLine).toHaveBeenCalledWith('[2020-04-22 12:40:58.000] > git cmd "argument with \\"double quotes\\" and spaces"');
		});

		it('Empty string arguments are shown as two double quotes', () => {
			// Run
			logger.logCmd('git', ['cmd', '']);

			// Assert
			expect(outputChannel.appendLine).toHaveBeenCalledWith('[2020-04-22 12:40:58.000] > git cmd ""');
		});

		it('Should transform all arguments of a command, when logging it to the Output Channel', () => {
			// Setup
			date.setCurrentTime(1587559258.1);

			// Run
			logger.logCmd('git', ['cmd', '--arg1', '--format="format-string"', '', 'argument with spaces', 'argument with "double quotes" and spaces']);

			// Assert
			expect(outputChannel.appendLine).toHaveBeenCalledWith('[2020-04-22 12:40:58.100] > git cmd --arg1 --format=... "" "argument with spaces" "argument with \\"double quotes\\" and spaces"');
		});
	});

	it('Should log an error to the Output Channel', () => {
		// Setup
		date.setCurrentTime(1587559258.01);

		// Run
		logger.logError('Test');

		// Assert
		expect(outputChannel.appendLine).toHaveBeenCalledWith('[2020-04-22 12:40:58.010] ERROR: Test');
	});
});
-e 

================================================================================
// FILE: ./tests/utils.test.ts
================================================================================
import * as date from './mocks/date';
import { mockSpyOnSpawn } from './mocks/spawn';
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });
jest.mock('../src/dataSource');
jest.mock('../src/extensionState');
jest.mock('../src/logger');

import * as fs from 'fs';
const mockedFileSystemModule: any = {
	access: jest.fn(),
	constants: fs.constants,
	readFile: jest.fn(),
	realpath: jest.fn(),
	stat: jest.fn()
};
mockedFileSystemModule.realpath['native'] = jest.fn();
jest.doMock('fs', () => mockedFileSystemModule);

import * as cp from 'child_process';
import * as path from 'path';
import { ConfigurationChangeEvent } from 'vscode';
import { DataSource } from '../src/dataSource';
import { ExtensionState } from '../src/extensionState';
import { Logger } from '../src/logger';
import { GitFileStatus, PullRequestProvider, RepoDropdownOrder } from '../src/types';
import { GitExecutable, GitVersionRequirement, UNCOMMITTED, abbrevCommit, abbrevText, archive, constructIncompatibleGitVersionMessage, copyFilePathToClipboard, copyToClipboard, createPullRequest, doesFileExist, doesVersionMeetRequirement, evalPromises, findGit, getExtensionVersion, getGitExecutable, getGitExecutableFromPaths, getNonce, getPathFromStr, getPathFromUri, getRelativeTimeDiff, getRepoName, getSortedRepositoryPaths, isPathInWorkspace, openExtensionSettings, openExternalUrl, openFile, openGitTerminal, pathWithTrailingSlash, realpath, resolveSpawnOutput, resolveToSymbolicPath, showErrorMessage, showInformationMessage, viewDiff, viewDiffWithWorkingFile, viewFileAtRevision, viewScm } from '../src/utils';
import { EventEmitter } from '../src/utils/event';

import { mockRepoState } from './helpers/utils';

const extensionContext = vscode.mocks.extensionContext;
const terminal = vscode.mocks.terminal;
let onDidChangeConfiguration: EventEmitter<ConfigurationChangeEvent>;
let onDidChangeGitExecutable: EventEmitter<GitExecutable>;
let logger: Logger;
let dataSource: DataSource;
let spyOnSpawn: jest.SpyInstance;

beforeAll(() => {
	onDidChangeConfiguration = new EventEmitter<ConfigurationChangeEvent>();
	onDidChangeGitExecutable = new EventEmitter<GitExecutable>();
	logger = new Logger();
	dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);
	spyOnSpawn = jest.spyOn(cp, 'spawn');
});

afterAll(() => {
	dataSource.dispose();
	logger.dispose();
	onDidChangeConfiguration.dispose();
	onDidChangeGitExecutable.dispose();
});

const mockSpawnGitVersionSuccessOnce = () => {
	mockSpyOnSpawn(spyOnSpawn, (onCallbacks, stderrOnCallbacks, stdoutOnCallbacks) => {
		stdoutOnCallbacks['data'](Buffer.from('git '));
		stdoutOnCallbacks['data'](Buffer.from('version 1.2.3'));
		stdoutOnCallbacks['close']();
		stderrOnCallbacks['close']();
		onCallbacks['exit'](0);
	});
};

const mockSpawnGitVersionThrowingErrorOnce = () => {
	mockSpyOnSpawn(spyOnSpawn, (onCallbacks, stderrOnCallbacks, stdoutOnCallbacks) => {
		stdoutOnCallbacks['close']();
		stderrOnCallbacks['close']();
		onCallbacks['error']();
	});
};

describe('getPathFromUri', () => {
	it('Doesn\'t affect paths using "/" as the separator', () => {
		// Run
		const path = getPathFromUri(vscode.Uri.file('/a/b/c'));

		// Assert
		expect(path).toBe('/a/b/c');
	});

	it('Replaces "\\" with "/"', () => {
		// Run
		const path = getPathFromUri(vscode.Uri.file('\\a\\b\\c'));

		// Assert
		expect(path).toBe('/a/b/c');
	});
});

describe('getPathFromStr', () => {
	it('Doesn\'t affect paths using "/" as the separator', () => {
		// Run
		const path = getPathFromStr('/a/b/c');

		// Assert
		expect(path).toBe('/a/b/c');
	});

	it('Replaces "\\" with "/"', () => {
		// Run
		const path = getPathFromStr('\\a\\b\\c');

		// Assert
		expect(path).toBe('/a/b/c');
	});
});

describe('pathWithTrailingSlash', () => {
	it('Adds trailing "/" to path', () => {
		// Run
		const path = pathWithTrailingSlash('/a/b');

		// Assert
		expect(path).toBe('/a/b/');
	});

	it('Doesn\'t add a trailing "/" to path if it already exists', () => {
		// Run
		const path = pathWithTrailingSlash('/a/b/');

		// Assert
		expect(path).toBe('/a/b/');
	});
});

describe('realpath', () => {
	it('Should return the normalised canonical absolute path', async () => {
		// Setup
		mockedFileSystemModule.realpath.mockImplementationOnce((path: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void) => callback(null, path as string));

		// Run
		const path = await realpath('\\a\\b');

		// Assert
		expect(path).toBe('/a/b');
		expect(mockedFileSystemModule.realpath).toBeCalledWith('\\a\\b', expect.anything());
		expect(mockedFileSystemModule.realpath.native).toHaveBeenCalledTimes(0);
	});

	it('Should return the normalised canonical absolute path (using the native version realpath)', async () => {
		// Setup
		mockedFileSystemModule.realpath.native.mockImplementationOnce((path: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void) => callback(null, path as string));

		// Run
		const path = await realpath('\\a\\b', true);

		// Assert
		expect(path).toBe('/a/b');
		expect(mockedFileSystemModule.realpath).toHaveBeenCalledTimes(0);
		expect(mockedFileSystemModule.realpath.native).toBeCalledWith('\\a\\b', expect.anything());
	});

	it('Should return the original path if fs.realpath returns an error', async () => {
		// Setup
		mockedFileSystemModule.realpath.mockImplementationOnce((_: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void) => callback(new Error('message'), ''));

		// Run
		const path = await realpath('/a/b');

		// Assert
		expect(path).toBe('/a/b');
		expect(mockedFileSystemModule.realpath).toBeCalledWith('/a/b', expect.anything());
		expect(mockedFileSystemModule.realpath.native).toHaveBeenCalledTimes(0);
	});
});

describe('isPathInWorkspace', () => {
	it('Should return TRUE if a path is a workspace folder', () => {
		// Setup
		vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/path/to/workspace-folder1'), index: 0 }, { uri: vscode.Uri.file('/path/to/workspace-folder2'), index: 1 }];

		// Run
		const result = isPathInWorkspace('/path/to/workspace-folder1');

		// Assert
		expect(result).toBe(true);
	});

	it('Should return TRUE if a path is within a workspace folder', () => {
		// Setup
		vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/path/to/workspace-folder1'), index: 0 }, { uri: vscode.Uri.file('/path/to/workspace-folder2'), index: 1 }];

		// Run
		const result = isPathInWorkspace('/path/to/workspace-folder1/subfolder');

		// Assert
		expect(result).toBe(true);
	});

	it('Should return FALSE if a path is not within a workspace folder', () => {
		// Setup
		vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/path/to/workspace-folder1'), index: 0 }, { uri: vscode.Uri.file('/path/to/workspace-folder2'), index: 1 }];

		// Run
		const result = isPathInWorkspace('/path/to/workspace-folder3/file');

		// Assert
		expect(result).toBe(false);
	});

	it('Should return FALSE if vscode is not running in a workspace', () => {
		// Setup
		vscode.workspace.workspaceFolders = undefined;

		// Run
		const result = isPathInWorkspace('/path/to/workspace-folder1');

		// Assert
		expect(result).toBe(false);
	});
});

describe('resolveToSymbolicPath', () => {
	it('Should return the original path if it matches a vscode workspace folder', async () => {
		// Setup
		mockedFileSystemModule.realpath.mockImplementation((path: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void) => callback(null, path as string));
		vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/path/to/workspace-folder1'), index: 0 }];

		// Run
		const result = await resolveToSymbolicPath('/path/to/workspace-folder1');

		// Assert
		expect(result).toBe('/path/to/workspace-folder1');
	});

	it('Should return the symbolic path if a vscode workspace folder resolves to it', async () => {
		// Setup
		mockedFileSystemModule.realpath.mockImplementation((path: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void) => callback(null, (path as string).replace('symbolic', 'workspace')));
		vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/path/to/symbolic-folder1'), index: 0 }];

		// Run
		const result = await resolveToSymbolicPath('/path/to/workspace-folder1');

		// Assert
		expect(result).toBe('/path/to/symbolic-folder1');
	});

	it('Should return the original path if it is within a vscode workspace folder', async () => {
		// Setup
		mockedFileSystemModule.realpath.mockImplementation((path: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void) => callback(null, path as string));
		vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/path/to/workspace-folder1'), index: 0 }];

		// Run
		const result = await resolveToSymbolicPath('/path/to/workspace-folder1/subfolder/file.txt');

		// Assert
		expect(result).toBe('/path/to/workspace-folder1/subfolder/file.txt');
	});

	it('Should return the symbolic path if a vscode workspace folder resolves to contain it', async () => {
		// Setup
		mockedFileSystemModule.realpath.mockImplementation((path: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void) => callback(null, (path as string).replace('symbolic', 'workspace')));
		vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/path/to/symbolic-folder1'), index: 0 }];

		// Run
		const result = await resolveToSymbolicPath('/path/to/workspace-folder1/subfolder/file.txt');

		// Assert
		expect(result).toBe('/path/to/symbolic-folder1/subfolder/file.txt');
	});

	it('Should return the symbolic path if the vscode workspace folder resolves to be contained within it', async () => {
		// Setup
		mockedFileSystemModule.realpath.mockImplementation((path: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void) => callback(null, (path as string).replace('symbolic', 'workspace')));
		vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/path/to/symbolic-folder/dir'), index: 0 }];

		// Run
		const result = await resolveToSymbolicPath('/path/to/workspace-folder');

		// Assert
		expect(result).toBe('/path/to/symbolic-folder');
	});

	it('Should return the original path if the vscode workspace folder resolves to be contained within it, when it was unable to find the path correspondence', async () => {
		// Setup
		mockedFileSystemModule.realpath.mockImplementation((path: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void) => {
			path = path as string;
			callback(null, path === '/symbolic-folder/path/to/dir' ? path.replace('symbolic', 'workspace') : path);
		});
		vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/symbolic-folder/path/to/dir'), index: 0 }];

		// Run
		const result = await resolveToSymbolicPath('/workspace-folder/path');

		// Assert
		expect(result).toBe('/workspace-folder/path');
	});

	it('Should return the original path if it is unrelated to the vscode workspace folders', async () => {
		// Setup
		mockedFileSystemModule.realpath.mockImplementation((path: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void) => callback(null, (path as string).replace('symbolic', 'workspace')));
		vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/path/to/symbolic-folder/dir'), index: 0 }];

		// Run
		const result = await resolveToSymbolicPath('/an/unrelated/directory');

		// Assert
		expect(result).toBe('/an/unrelated/directory');
	});

	it('Should return the original path if vscode is not running in a workspace', async () => {
		// Setup
		vscode.workspace.workspaceFolders = undefined;

		// Run
		const result = await resolveToSymbolicPath('/a/b');

		// Assert
		expect(result).toBe('/a/b');
	});
});

describe('doesFileExist', () => {
	it('Should return TRUE when the file exists', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(null));

		// Run
		const result = await doesFileExist('file.txt');

		// Assert
		expect(result).toBe(true);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, 'file.txt', fs.constants.R_OK, expect.anything());
	});

	it('Should return FALSE when the file doesn\'t exist', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(new Error()));

		// Run
		const result = await doesFileExist('file.txt');

		// Assert
		expect(result).toBe(false);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, 'file.txt', fs.constants.R_OK, expect.anything());
	});
});

describe('abbrevCommit', () => {
	it('Truncates a commit hash to eight characters', () => {
		// Run
		const abbrev = abbrevCommit('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

		// Assert
		expect(abbrev).toBe('1a2b3c4d');
	});

	it('Doesn\'t truncate commit hashes less than eight characters', () => {
		// Run
		const abbrev = abbrevCommit('1a2b3c');

		// Assert
		expect(abbrev).toBe('1a2b3c');
	});
});

describe('abbrevText', () => {
	it('Abbreviates strings longer the 50 characters', () => {
		// Run
		const abbrev = abbrevText('123456789012345678901234567890123456789012345678901234567890', 50);

		// Assert
		expect(abbrev).toBe('1234567890123456789012345678901234567890123456789...');
	});

	it('Keep strings that are 50 characters long', () => {
		// Run
		const abbrev = abbrevText('12345678901234567890123456789012345678901234567890', 50);

		// Assert
		expect(abbrev).toBe('12345678901234567890123456789012345678901234567890');
	});

	it('Abbreviates strings shorter than 50 characters', () => {
		// Run
		const abbrev = abbrevText('1234567890123456789012345678901234567890123456789', 50);

		// Assert
		expect(abbrev).toBe('1234567890123456789012345678901234567890123456789');
	});
});

describe('getRelativeTimeDiff', () => {
	it('Correctly formats single second', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 1);

		// Assert
		expect(diff).toBe('1 second ago');
	});

	it('Correctly formats multiple seconds', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 3);

		// Assert
		expect(diff).toBe('3 seconds ago');
	});

	it('Correctly formats single minute', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 60);

		// Assert
		expect(diff).toBe('1 minute ago');
	});

	it('Correctly formats multiple minutes', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 180);

		// Assert
		expect(diff).toBe('3 minutes ago');
	});

	it('Correctly formats single hour', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 3600);

		// Assert
		expect(diff).toBe('1 hour ago');
	});

	it('Correctly formats multiple hours', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 10800);

		// Assert
		expect(diff).toBe('3 hours ago');
	});

	it('Correctly formats single day', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 86400);

		// Assert
		expect(diff).toBe('1 day ago');
	});

	it('Correctly formats multiple days', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 259200);

		// Assert
		expect(diff).toBe('3 days ago');
	});

	it('Correctly formats single week', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 604800);

		// Assert
		expect(diff).toBe('1 week ago');
	});

	it('Correctly formats multiple weeks', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 1814400);

		// Assert
		expect(diff).toBe('3 weeks ago');
	});

	it('Correctly formats single month', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 2629800);

		// Assert
		expect(diff).toBe('1 month ago');
	});

	it('Correctly formats multiple months', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 7889400);

		// Assert
		expect(diff).toBe('3 months ago');
	});

	it('Correctly formats single year', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 31557600);

		// Assert
		expect(diff).toBe('1 year ago');
	});

	it('Correctly formats multiple years', () => {
		// Run
		const diff = getRelativeTimeDiff(date.now - 94672800);

		// Assert
		expect(diff).toBe('3 years ago');
	});
});

describe('getExtensionVersion', () => {
	it('Should return the extension\'s version number', async () => {
		// Setup
		mockedFileSystemModule.readFile.mockImplementationOnce((_: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, data: string) => void) => callback(null, '{"version":"1.2.3"}'));

		// Run
		const version = await getExtensionVersion(vscode.mocks.extensionContext);

		// Assert
		expect(version).toBe('1.2.3');
		const [path] = mockedFileSystemModule.readFile.mock.calls[0];
		expect(getPathFromStr(path)).toBe('/path/to/extension/package.json');
	});

	it('Should reject if unable to read package.json file', async () => {
		// Setup
		let rejected = false;
		mockedFileSystemModule.readFile.mockImplementationOnce((_: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, data: string) => void) => callback(new Error(), ''));

		// Run
		await getExtensionVersion(vscode.mocks.extensionContext).catch(() => rejected = true);

		// Assert
		expect(rejected).toBe(true);
	});

	it('Should reject if unable to parse package.json file', async () => {
		// Setup
		let rejected = false;
		mockedFileSystemModule.readFile.mockImplementationOnce((_: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, data: string) => void) => callback(null, '{"version":"1.2.3"'));

		// Run
		await getExtensionVersion(vscode.mocks.extensionContext).catch(() => rejected = true);

		// Assert
		expect(rejected).toBe(true);
	});
});

describe('getNonce', () => {
	it('Should generate a nonce 32 characters long', () => {
		// Run
		const nonce = getNonce();

		// Assert
		expect(nonce.length).toBe(32);
	});
});

describe('getRepoName', () => {
	it('Should return entire path if it contains no "/"', () => {
		// Run
		const name = getRepoName('tmp');

		// Asset
		expect(name).toBe('tmp');
	});

	it('Should return entire path if it contains a single trailing "/"', () => {
		// Run
		const name = getRepoName('c:/');

		// Asset
		expect(name).toBe('c:/');
	});

	it('Should return last path segment otherwise', () => {
		// Run
		const name = getRepoName('c:/a/b/c/d');

		// Asset
		expect(name).toBe('d');
	});

	it('Should return last path segment otherwise (with trailing "/")', () => {
		// Run
		const name = getRepoName('c:/a/b/c/d/');

		// Asset
		expect(name).toBe('d');
	});
});

describe('getSortedRepositoryPaths', () => {
	it('Should sort by RepoDropdownOrder.WorkspaceFullPath', () => {
		// Run
		const repoPaths = getSortedRepositoryPaths({
			'/path/to/workspace-1/a': mockRepoState({ workspaceFolderIndex: 1 }),
			'/path/to/workspace-2/c': mockRepoState({ workspaceFolderIndex: 0 }),
			'/path/to/workspace-3/a': mockRepoState({ workspaceFolderIndex: null }),
			'/path/to/workspace-2/b': mockRepoState({ workspaceFolderIndex: 0 }),
			'/path/to/workspace-1/b': mockRepoState({ workspaceFolderIndex: 1 }),
			'/path/to/workspace-1/d': mockRepoState({ workspaceFolderIndex: 1 }),
			'/path/to/workspace-3/b': mockRepoState({ workspaceFolderIndex: null }),
			'/path/to/workspace-3/d': mockRepoState({ workspaceFolderIndex: null }),
			'/path/to/workspace-2/a': mockRepoState({ workspaceFolderIndex: 0 }),
			'/path/to/workspace-1/c': mockRepoState({ workspaceFolderIndex: 1 }),
			'/path/to/workspace-3/c': mockRepoState({ workspaceFolderIndex: null }),
			'/path/to/workspace-2/d': mockRepoState({ workspaceFolderIndex: 0 })
		}, RepoDropdownOrder.WorkspaceFullPath);

		// Assert
		expect(repoPaths).toStrictEqual(['/path/to/workspace-2/a', '/path/to/workspace-2/b', '/path/to/workspace-2/c', '/path/to/workspace-2/d', '/path/to/workspace-1/a', '/path/to/workspace-1/b', '/path/to/workspace-1/c', '/path/to/workspace-1/d', '/path/to/workspace-3/a', '/path/to/workspace-3/b', '/path/to/workspace-3/c', '/path/to/workspace-3/d']);
	});

	it('Should sort by RepoDropdownOrder.FullPath', () => {
		// Run
		const repoPaths = getSortedRepositoryPaths({
			'/path/to/a': mockRepoState({ workspaceFolderIndex: 1 }),
			'/path/to/f': mockRepoState({ workspaceFolderIndex: 2 }),
			'/path/to/D': mockRepoState({ workspaceFolderIndex: 3 }),
			'/path/to/b': mockRepoState({ workspaceFolderIndex: 4 }),
			'/path/to/': mockRepoState({ workspaceFolderIndex: 5 }),
			'/path/to/C': mockRepoState({ workspaceFolderIndex: 6 }),
			'/path/a': mockRepoState({ workspaceFolderIndex: 1 })
		}, RepoDropdownOrder.FullPath);

		// Assert
		expect(repoPaths).toStrictEqual(['/path/a', '/path/to/a', '/path/to/b', '/path/to/C', '/path/to/D', '/path/to/', '/path/to/f']);
	});

	it('Should sort by RepoDropdownOrder.Name', () => {
		// Run
		const repoPaths = getSortedRepositoryPaths({
			'/path/to/a': mockRepoState({ name: null, workspaceFolderIndex: 1 }),
			'/path/to/x': mockRepoState({ name: 'f', workspaceFolderIndex: 2 }),
			'/path/to/y': mockRepoState({ name: 'D', workspaceFolderIndex: 3 }),
			'/path/to/b': mockRepoState({ name: null, workspaceFolderIndex: 4 }),
			'/path/to/z': mockRepoState({ name: '', workspaceFolderIndex: 5 }),
			'/path/to/C': mockRepoState({ name: null, workspaceFolderIndex: 6 }),
			'/path/to/another/A': mockRepoState({ name: null, workspaceFolderIndex: 7 }),
			'/path/a': mockRepoState({ name: null, workspaceFolderIndex: 1 })
		}, RepoDropdownOrder.Name);

		// Assert
		expect(repoPaths).toStrictEqual(['/path/a', '/path/to/a', '/path/to/another/A', '/path/to/b', '/path/to/C', '/path/to/y', '/path/to/z', '/path/to/x']);
	});
});

describe('archive', () => {
	it('Should trigger the creation of the archive (tar)', async () => {
		// Setup
		vscode.window.showSaveDialog.mockResolvedValueOnce(vscode.Uri.file('/archive/file/destination.tar'));
		const spyOnArchive = jest.spyOn(dataSource, 'archive');
		spyOnArchive.mockResolvedValueOnce(null);

		// Run
		const result = await archive('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);

		// Assert
		expect(result).toBe(null);
		expect(spyOnArchive).toBeCalledWith('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/archive/file/destination.tar', 'tar');
	});

	it('Should trigger the creation of the archive (TAR)', async () => {
		// Setup
		vscode.window.showSaveDialog.mockResolvedValueOnce(vscode.Uri.file('/archive/file/destination.TAR'));
		const spyOnArchive = jest.spyOn(dataSource, 'archive');
		spyOnArchive.mockResolvedValueOnce(null);

		// Run
		const result = await archive('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);

		// Assert
		expect(result).toBe(null);
		expect(spyOnArchive).toBeCalledWith('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/archive/file/destination.TAR', 'tar');
	});

	it('Should trigger the creation of the archive (zip)', async () => {
		// Setup
		vscode.window.showSaveDialog.mockResolvedValueOnce(vscode.Uri.file('/archive/file/destination.zip'));
		const spyOnArchive = jest.spyOn(dataSource, 'archive');
		spyOnArchive.mockResolvedValueOnce(null);

		// Run
		const result = await archive('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);

		// Assert
		expect(result).toBe(null);
		expect(spyOnArchive).toBeCalledWith('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/archive/file/destination.zip', 'zip');
	});

	it('Should trigger the creation of the archive (ZIP)', async () => {
		// Setup
		vscode.window.showSaveDialog.mockResolvedValueOnce(vscode.Uri.file('/archive/file/destination.ZIP'));
		const spyOnArchive = jest.spyOn(dataSource, 'archive');
		spyOnArchive.mockResolvedValueOnce(null);

		// Run
		const result = await archive('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);

		// Assert
		expect(result).toBe(null);
		expect(spyOnArchive).toBeCalledWith('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/archive/file/destination.ZIP', 'zip');
	});

	it('Should return an error message when the specified archive destination has an invalid file extension', async () => {
		// Setup
		vscode.window.showSaveDialog.mockResolvedValueOnce(vscode.Uri.file('/archive/file/destination.txt'));

		// Run
		const result = await archive('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);

		// Assert
		expect(result).toBe('Invalid file extension "*.txt". The archive file must have a *.tar or *.zip extension.');
	});

	it('Should return an error message when no file is specified for the archive', async () => {
		// Setup
		vscode.window.showSaveDialog.mockResolvedValueOnce(undefined);

		// Run
		const result = await archive('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);

		// Assert
		expect(result).toBe('No file name was provided for the archive.');
	});

	it('Should return an error message when vscode fails to show the Save Dialog', async () => {
		// Setup
		vscode.window.showSaveDialog.mockRejectedValueOnce(undefined);

		// Run
		const result = await archive('/repo/path', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);

		// Assert
		expect(result).toBe('Visual Studio Code was unable to display the save dialog.');
	});
});

describe('copyFilePathToClipboard', () => {
	it('Appends the relative file path to the repository path, and copies the result to the clipboard', async () => {
		// Setup
		vscode.env.clipboard.writeText.mockResolvedValueOnce(null);

		// Run
		const result = await copyFilePathToClipboard('/a/b', 'c/d.txt', true);

		// Assert
		const receivedArgs: any[] = vscode.env.clipboard.writeText.mock.calls[0];
		expect(result).toBe(null);
		expect(getPathFromStr(receivedArgs[0])).toBe('/a/b/c/d.txt');
	});

	it('Copies the relative file path to the clipboard', async () => {
		// Setup
		vscode.env.clipboard.writeText.mockResolvedValueOnce(null);

		// Run
		const result = await copyFilePathToClipboard('/a/b', 'c/d.txt', false);

		// Assert
		const receivedArgs: any[] = vscode.env.clipboard.writeText.mock.calls[0];
		expect(result).toBe(null);
		expect(getPathFromStr(receivedArgs[0])).toBe('c/d.txt');
	});

	it('Returns an error message when writeText fails', async () => {
		// Setup
		vscode.env.clipboard.writeText.mockRejectedValueOnce(null);

		// Run
		const result = await copyFilePathToClipboard('/a/b', 'c/d.txt', true);

		// Assert
		expect(result).toBe('Visual Studio Code was unable to write to the Clipboard.');
	});
});

describe('copyToClipboard', () => {
	it('Copies text to the clipboard', async () => {
		// Setup
		vscode.env.clipboard.writeText.mockResolvedValueOnce(null);

		// Run
		const result = await copyToClipboard('');

		// Assert
		expect(result).toBe(null);
	});

	it('Returns an error message when writeText fails', async () => {
		// Setup
		vscode.env.clipboard.writeText.mockRejectedValueOnce(null);

		// Run
		const result = await copyToClipboard('');

		// Assert
		expect(result).toBe('Visual Studio Code was unable to write to the Clipboard.');
	});
});

describe('createPullRequest', () => {
	it('Should construct and open a BitBucket Pull Request Creation Url', async () => {
		// Setup
		vscode.env.openExternal.mockResolvedValueOnce(true);

		// Run
		const result = await createPullRequest({
			provider: PullRequestProvider.Bitbucket,
			custom: null,
			hostRootUrl: 'https://bitbucket.org',
			sourceOwner: 'sourceOwner',
			sourceRepo: 'sourceRepo',
			sourceRemote: 'sourceRemote',
			destOwner: 'destOwner',
			destRepo: 'destRepo',
			destBranch: 'destBranch',
			destRemote: 'destRemote',
			destProjectId: 'destProjectId'
		}, 'sourceOwner', 'sourceRepo', 'sourceBranch');

		// Assert
		expect(result).toBe(null);
		expect(vscode.env.openExternal.mock.calls[0][0].toString()).toBe('https://bitbucket.org/sourceOwner/sourceRepo/pull-requests/new?source=sourceOwner/sourceRepo::sourceBranch&dest=destOwner/destRepo::destBranch');
	});

	it('Should construct and open a Custom Providers Pull Request Creation Url', async () => {
		// Setup
		vscode.env.openExternal.mockResolvedValueOnce(true);

		// Run
		const result = await createPullRequest({
			provider: PullRequestProvider.Custom,
			custom: {
				name: 'custom',
				templateUrl: '$1/$2/$3/$4/$5/$6/$8'
			},
			hostRootUrl: 'https://example.com',
			sourceOwner: 'sourceOwner',
			sourceRepo: 'sourceRepo',
			sourceRemote: 'sourceRemote',
			destOwner: 'destOwner',
			destRepo: 'destRepo',
			destBranch: 'destBranch',
			destRemote: 'destRemote',
			destProjectId: 'destProjectId'
		}, 'sourceOwner', 'sourceRepo', 'sourceBranch');

		// Assert
		expect(result).toBe(null);
		expect(vscode.env.openExternal.mock.calls[0][0].toString()).toBe('https://example.com/sourceOwner/sourceRepo/sourceBranch/destOwner/destRepo/destBranch');
	});

	it('Should construct and open a GitHub Pull Request Creation Url', async () => {
		// Setup
		vscode.env.openExternal.mockResolvedValueOnce(true);

		// Run
		const result = await createPullRequest({
			provider: PullRequestProvider.GitHub,
			custom: null,
			hostRootUrl: 'https://github.com',
			sourceOwner: 'sourceOwner',
			sourceRepo: 'sourceRepo',
			sourceRemote: 'sourceRemote',
			destOwner: 'destOwner',
			destRepo: 'destRepo',
			destBranch: 'destBranch',
			destRemote: 'destRemote',
			destProjectId: 'destProjectId'
		}, 'sourceOwner', 'sourceRepo', 'sourceBranch');

		// Assert
		expect(result).toBe(null);
		expect(vscode.env.openExternal.mock.calls[0][0].toString()).toBe('https://github.com/destOwner/destRepo/compare/destBranch...sourceOwner:sourceBranch');
	});

	it('Should construct and open a GitLab Pull Request Creation Url', async () => {
		// Setup
		vscode.env.openExternal.mockResolvedValueOnce(true);

		// Run
		const result = await createPullRequest({
			provider: PullRequestProvider.GitLab,
			custom: null,
			hostRootUrl: 'https://gitlab.com',
			sourceOwner: 'sourceOwner',
			sourceRepo: 'sourceRepo',
			sourceRemote: 'sourceRemote',
			destOwner: 'destOwner',
			destRepo: 'destRepo',
			destBranch: 'destBranch',
			destRemote: 'destRemote',
			destProjectId: 'destProjectId'
		}, 'sourceOwner', 'sourceRepo', 'sourceBranch');

		// Assert
		expect(result).toBe(null);
		expect(vscode.env.openExternal.mock.calls[0][0].toString()).toBe('https://gitlab.com/sourceOwner/sourceRepo/-/merge_requests/new?merge_request[source_branch]=sourceBranch&merge_request[target_branch]=destBranch&merge_request[target_project_id]=destProjectId');
	});

	it('Should construct and open a GitLab Pull Request Creation Url (without destProjectId)', async () => {
		// Setup
		vscode.env.openExternal.mockResolvedValueOnce(true);

		// Run
		const result = await createPullRequest({
			provider: PullRequestProvider.GitLab,
			custom: null,
			hostRootUrl: 'https://gitlab.com',
			sourceOwner: 'sourceOwner',
			sourceRepo: 'sourceRepo',
			sourceRemote: 'sourceRemote',
			destOwner: 'destOwner',
			destRepo: 'destRepo',
			destBranch: 'destBranch',
			destRemote: 'destRemote',
			destProjectId: ''
		}, 'sourceOwner', 'sourceRepo', 'sourceBranch');

		// Assert
		expect(result).toBe(null);
		expect(vscode.env.openExternal.mock.calls[0][0].toString()).toBe('https://gitlab.com/sourceOwner/sourceRepo/-/merge_requests/new?merge_request[source_branch]=sourceBranch&merge_request[target_branch]=destBranch');
	});

	it('Should return an error message if vscode was unable to open the url', async () => {
		// Setup
		vscode.env.openExternal.mockRejectedValueOnce(null);

		// Run
		const result = await createPullRequest({
			provider: PullRequestProvider.GitHub,
			custom: null,
			hostRootUrl: 'https://github.com',
			sourceOwner: 'sourceOwner',
			sourceRepo: 'sourceRepo',
			sourceRemote: 'sourceRemote',
			destOwner: 'destOwner',
			destRepo: 'destRepo',
			destBranch: 'destBranch',
			destRemote: 'destRemote',
			destProjectId: 'destProjectId'
		}, 'sourceOwner', 'sourceRepo', 'sourceBranch');

		// Assert
		expect(result).toBe('Visual Studio Code was unable to open the Pull Request URL: https://github.com/destOwner/destRepo/compare/destBranch...sourceOwner:sourceBranch');
	});
});

describe('openExtensionSettings', () => {
	it('Executes workbench.action.openSettings', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await openExtensionSettings();

		// Assert
		expect(vscode.commands.executeCommand).toHaveBeenCalledWith('workbench.action.openSettings', '@ext:mhutchie.git-graph');
		expect(result).toBe(null);
	});

	it('Returns an error message when executeCommand fails', async () => {
		// Setup
		vscode.commands.executeCommand.mockRejectedValueOnce(null);

		// Run
		const result = await openExtensionSettings();

		// Assert
		expect(result).toBe('Visual Studio Code was unable to open the Git Graph Extension Settings.');
	});
});

describe('openExternalUrl', () => {
	it('Should open the URL via Visual Studio Code', async () => {
		// Setup
		vscode.env.openExternal.mockResolvedValueOnce(true);

		// Run
		const result = await openExternalUrl('https://github.com/mhutchie/vscode-git-graph');

		// Assert
		expect(result).toBe(null);
		expect(vscode.env.openExternal.mock.calls[0][0].toString()).toBe('https://github.com/mhutchie/vscode-git-graph');
	});

	it('Should return an error message if vscode was unable to open the url (vscode.env.openExternal resolves FALSE)', async () => {
		// Setup
		vscode.env.openExternal.mockResolvedValueOnce(false);

		// Run
		const result = await openExternalUrl('https://github.com/mhutchie/vscode-git-graph');

		// Assert
		expect(result).toBe('Visual Studio Code was unable to open the External URL: https://github.com/mhutchie/vscode-git-graph');
	});

	it('Should return an error message if vscode was unable to open the url (vscode.env.openExternal rejects)', async () => {
		// Setup
		vscode.env.openExternal.mockRejectedValueOnce(null);

		// Run
		const result = await openExternalUrl('https://github.com/mhutchie/vscode-git-graph');

		// Assert
		expect(result).toBe('Visual Studio Code was unable to open the External URL: https://github.com/mhutchie/vscode-git-graph');
	});

	it('Should return an error message if vscode was unable to parse the url', async () => {
		// Setup
		const spyOnParse = jest.spyOn(vscode.Uri, 'parse');
		spyOnParse.mockImplementationOnce(() => {
			throw new Error();
		});

		// Run
		const result = await openExternalUrl('https://github.com/mhutchie/vscode-git-graph');

		// Assert
		expect(result).toBe('Visual Studio Code was unable to open the External URL: https://github.com/mhutchie/vscode-git-graph');
		expect(vscode.env.openExternal).not.toHaveBeenCalled();
	});

	it('Should return an error message with a custom type', async () => {
		// Setup
		vscode.env.openExternal.mockRejectedValueOnce(null);

		// Run
		const result = await openExternalUrl('https://github.com/mhutchie/vscode-git-graph', 'Custom URL');

		// Assert
		expect(result).toBe('Visual Studio Code was unable to open the Custom URL: https://github.com/mhutchie/vscode-git-graph');
	});
});

describe('openFile', () => {
	it('Should open the file in vscode (with the user defined ViewColumn)', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(null));
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await openFile('/path/to/repo', 'file.txt');

		// Assert
		const [command, uri, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.open');
		expect(getPathFromUri(uri)).toBe('/path/to/repo/file.txt');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'file.txt'), fs.constants.R_OK, expect.anything());
	});

	it('Should open the file in vscode (in the specified ViewColumn)', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(null));
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await openFile('/path/to/repo', 'file.txt', null, null, vscode.ViewColumn.Beside);

		// Assert
		const [command, uri, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.open');
		expect(getPathFromUri(uri)).toBe('/path/to/repo/file.txt');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Beside
		});
		expect(result).toBe(null);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'file.txt'), fs.constants.R_OK, expect.anything());
	});

	it('Should open a renamed file in vscode', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(new Error()));
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(null));
		vscode.commands.executeCommand.mockResolvedValueOnce(null);
		const spyOnGetNewPathOfRenamedFile = jest.spyOn(dataSource, 'getNewPathOfRenamedFile');
		spyOnGetNewPathOfRenamedFile.mockResolvedValueOnce('renamed-new.txt');

		// Run
		const result = await openFile('/path/to/repo', 'renamed-old.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);

		// Assert
		const [command, uri, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.open');
		expect(getPathFromUri(uri)).toBe('/path/to/repo/renamed-new.txt');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'renamed-old.txt'), fs.constants.R_OK, expect.anything());
		expect(spyOnGetNewPathOfRenamedFile).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'renamed-old.txt');
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(2, path.join('/path/to/repo', 'renamed-new.txt'), fs.constants.R_OK, expect.anything());
	});

	it('Should return an error message if vscode was unable to open the file', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(null));
		vscode.commands.executeCommand.mockRejectedValueOnce(null);

		// Run
		const result = await openFile('/path/to/repo', 'file.txt');

		// Assert
		expect(result).toBe('Visual Studio Code was unable to open file.txt.');
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'file.txt'), fs.constants.R_OK, expect.anything());
	});

	it('Should return an error message if the file doesn\'t exist in the repository', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(new Error()));

		// Run
		const result = await openFile('/path/to/repo', 'deleted.txt');

		// Assert
		expect(result).toBe('The file deleted.txt doesn\'t currently exist in this repository.');
		expect(mockedFileSystemModule.access).toHaveBeenCalledTimes(1);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'deleted.txt'), fs.constants.R_OK, expect.anything());
	});

	it('Should return an error message if the file doesn\'t exist in the repository, and it wasn\'t renamed', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(new Error()));
		const spyOnGetNewPathOfRenamedFile = jest.spyOn(dataSource, 'getNewPathOfRenamedFile');
		spyOnGetNewPathOfRenamedFile.mockResolvedValueOnce(null);

		// Run
		const result = await openFile('/path/to/repo', 'deleted.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);

		// Assert
		expect(result).toBe('The file deleted.txt doesn\'t currently exist in this repository.');
		expect(mockedFileSystemModule.access).toHaveBeenCalledTimes(1);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'deleted.txt'), fs.constants.R_OK, expect.anything());
		expect(spyOnGetNewPathOfRenamedFile).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'deleted.txt');
	});

	it('Should return an error message if the file doesn\'t exist in the repository, and it was renamed', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(new Error()));
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(new Error()));
		const spyOnGetNewPathOfRenamedFile = jest.spyOn(dataSource, 'getNewPathOfRenamedFile');
		spyOnGetNewPathOfRenamedFile.mockResolvedValueOnce('renamed-new.txt');

		// Run
		const result = await openFile('/path/to/repo', 'renamed-old.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource);

		// Assert
		expect(result).toBe('The file renamed-old.txt doesn\'t currently exist in this repository.');
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'renamed-old.txt'), fs.constants.R_OK, expect.anything());
		expect(spyOnGetNewPathOfRenamedFile).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'renamed-old.txt');
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(2, path.join('/path/to/repo', 'renamed-new.txt'), fs.constants.R_OK, expect.anything());
	});
});

describe('viewDiff', () => {
	it('Should load the vscode diff view (single commit, file added)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/added.txt', 'subfolder/added.txt', GitFileStatus.Added);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/added.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '/path/to/repo', false));
		expect(rightUri.toString()).toBe(expectedValueGitGraphUri('subfolder/added.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true));
		expect(title).toBe('added.txt (Added in 1a2b3c4d)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (single commit, file modified)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/modified.txt', 'subfolder/modified.txt', GitFileStatus.Modified);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '/path/to/repo', true));
		expect(rightUri.toString()).toBe(expectedValueGitGraphUri('subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true));
		expect(title).toBe('modified.txt (1a2b3c4d^  1a2b3c4d)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (single commit, file deleted)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/deleted.txt', 'subfolder/deleted.txt', GitFileStatus.Deleted);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/deleted.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '/path/to/repo', true));
		expect(rightUri.toString()).toBe(expectedValueGitGraphUri('subfolder/deleted.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', false));
		expect(title).toBe('deleted.txt (Deleted in 1a2b3c4d)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (between commits, file added)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', 'subfolder/added.txt', 'subfolder/added.txt', GitFileStatus.Added);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/added.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', false));
		expect(rightUri.toString()).toBe(expectedValueGitGraphUri('subfolder/added.txt', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', '/path/to/repo', true));
		expect(title).toBe('added.txt (Added between 1a2b3c4d & a1b2c3d4)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (between commits, file modified)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', 'subfolder/modified.txt', 'subfolder/modified.txt', GitFileStatus.Modified);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true));
		expect(rightUri.toString()).toBe(expectedValueGitGraphUri('subfolder/modified.txt', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', '/path/to/repo', true));
		expect(title).toBe('modified.txt (1a2b3c4d  a1b2c3d4)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (between commits, file deleted)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', 'subfolder/deleted.txt', 'subfolder/deleted.txt', GitFileStatus.Deleted);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/deleted.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true));
		expect(rightUri.toString()).toBe(expectedValueGitGraphUri('subfolder/deleted.txt', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', '/path/to/repo', false));
		expect(title).toBe('deleted.txt (Deleted between 1a2b3c4d & a1b2c3d4)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (between commit and uncommitted changes, file added)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', UNCOMMITTED, 'subfolder/added.txt', 'subfolder/added.txt', GitFileStatus.Added);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/added.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', false));
		expect(getPathFromUri(rightUri)).toBe('/path/to/repo/subfolder/added.txt');
		expect(title).toBe('added.txt (Added between 1a2b3c4d & Present)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (between commit and uncommitted changes, file modified)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', UNCOMMITTED, 'subfolder/modified.txt', 'subfolder/modified.txt', GitFileStatus.Modified);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true));
		expect(getPathFromUri(rightUri)).toBe('/path/to/repo/subfolder/modified.txt');
		expect(title).toBe('modified.txt (1a2b3c4d  Present)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (between commit and uncommitted changes, file deleted)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', UNCOMMITTED, 'subfolder/deleted.txt', 'subfolder/deleted.txt', GitFileStatus.Deleted);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/deleted.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true));
		expect(rightUri.toString()).toBe(expectedValueGitGraphUri('subfolder/deleted.txt', '*', '/path/to/repo', false));
		expect(title).toBe('deleted.txt (Deleted between 1a2b3c4d & Present)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (uncommitted changes, file added)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', UNCOMMITTED, UNCOMMITTED, 'subfolder/added.txt', 'subfolder/added.txt', GitFileStatus.Added);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/added.txt', 'HEAD', '/path/to/repo', false));
		expect(getPathFromUri(rightUri)).toBe('/path/to/repo/subfolder/added.txt');
		expect(title).toBe('added.txt (Uncommitted)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (uncommitted changes, file modified)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', UNCOMMITTED, UNCOMMITTED, 'subfolder/modified.txt', 'subfolder/modified.txt', GitFileStatus.Modified);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/modified.txt', 'HEAD', '/path/to/repo', true));
		expect(getPathFromUri(rightUri)).toBe('/path/to/repo/subfolder/modified.txt');
		expect(title).toBe('modified.txt (Uncommitted)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should load the vscode diff view (uncommitted changes, file deleted)', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', UNCOMMITTED, UNCOMMITTED, 'subfolder/deleted.txt', 'subfolder/deleted.txt', GitFileStatus.Deleted);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/deleted.txt', 'HEAD', '/path/to/repo', true));
		expect(rightUri.toString()).toBe(expectedValueGitGraphUri('subfolder/deleted.txt', '*', '/path/to/repo', false));
		expect(title).toBe('deleted.txt (Uncommitted)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should return an error message when vscode was unable to load the diff view', async () => {
		// Setup
		vscode.commands.executeCommand.mockRejectedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/modified.txt', 'subfolder/modified.txt', GitFileStatus.Modified);

		// Assert
		expect(result).toBe('Visual Studio Code was unable to load the diff editor for subfolder/modified.txt.');
	});

	it('Should open an untracked file in vscode', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(null));
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiff('/path/to/repo', UNCOMMITTED, UNCOMMITTED, 'subfolder/untracked.txt', 'subfolder/untracked.txt', GitFileStatus.Untracked);

		// Assert
		const [command, uri, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.open');
		expect(getPathFromUri(uri)).toBe('/path/to/repo/subfolder/untracked.txt');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'subfolder/untracked.txt'), fs.constants.R_OK, expect.anything());
	});
});

describe('viewDiffWithWorkingFile', () => {
	it('Should load the vscode diff view (modified file)', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(null));
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiffWithWorkingFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/modified.txt', dataSource);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true));
		expect(getPathFromUri(rightUri)).toBe('/path/to/repo/subfolder/modified.txt');
		expect(title).toBe('modified.txt (1a2b3c4d  Present)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'subfolder/modified.txt'), fs.constants.R_OK, expect.anything());
	});

	it('Should load the vscode diff view (renamed file)', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(new Error()));
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(null));
		vscode.commands.executeCommand.mockResolvedValueOnce(null);
		const spyOnGetNewPathOfRenamedFile = jest.spyOn(dataSource, 'getNewPathOfRenamedFile');
		spyOnGetNewPathOfRenamedFile.mockResolvedValueOnce('subfolder/renamed-new.txt');

		// Run
		const result = await viewDiffWithWorkingFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/renamed-old.txt', dataSource);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/renamed-old.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true));
		expect(getPathFromUri(rightUri)).toBe('/path/to/repo/subfolder/renamed-new.txt');
		expect(title).toBe('renamed-new.txt (1a2b3c4d  Present)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'subfolder/renamed-old.txt'), fs.constants.R_OK, expect.anything());
		expect(spyOnGetNewPathOfRenamedFile).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/renamed-old.txt');
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(2, path.join('/path/to/repo', 'subfolder/renamed-new.txt'), fs.constants.R_OK, expect.anything());
	});

	it('Should load the vscode diff view (deleted file)', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(new Error()));
		vscode.commands.executeCommand.mockResolvedValueOnce(null);
		const spyOnGetNewPathOfRenamedFile = jest.spyOn(dataSource, 'getNewPathOfRenamedFile');
		spyOnGetNewPathOfRenamedFile.mockResolvedValueOnce(null);

		// Run
		const result = await viewDiffWithWorkingFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/deleted.txt', dataSource);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/deleted.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true));
		expect(rightUri.toString()).toBe(expectedValueGitGraphUri('subfolder/deleted.txt', '*', '/path/to/repo', false));
		expect(title).toBe('deleted.txt (Deleted between 1a2b3c4d & Present)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
		expect(mockedFileSystemModule.access).toHaveBeenCalledTimes(1);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'subfolder/deleted.txt'), fs.constants.R_OK, expect.anything());
	});

	it('Should load the vscode diff view (renamed and deleted file)', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(new Error()));
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(new Error()));
		vscode.commands.executeCommand.mockResolvedValueOnce(null);
		const spyOnGetNewPathOfRenamedFile = jest.spyOn(dataSource, 'getNewPathOfRenamedFile');
		spyOnGetNewPathOfRenamedFile.mockResolvedValueOnce('subfolder/renamed-new.txt');

		// Run
		const result = await viewDiffWithWorkingFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/renamed-old.txt', dataSource);

		// Assert
		const [command, leftUri, rightUri, title, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.diff');
		expect(leftUri.toString()).toBe(expectedValueGitGraphUri('subfolder/renamed-old.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true));
		expect(rightUri.toString()).toBe(expectedValueGitGraphUri('subfolder/renamed-old.txt', '*', '/path/to/repo', false));
		expect(title).toBe('renamed-old.txt (Deleted between 1a2b3c4d & Present)');
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'subfolder/renamed-old.txt'), fs.constants.R_OK, expect.anything());
		expect(spyOnGetNewPathOfRenamedFile).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/renamed-old.txt');
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(2, path.join('/path/to/repo', 'subfolder/renamed-new.txt'), fs.constants.R_OK, expect.anything());
	});

	it('Should return an error message when vscode was unable to load the diff view', async () => {
		// Setup
		mockedFileSystemModule.access.mockImplementationOnce((_1: fs.PathLike, _2: number | undefined, callback: (err: NodeJS.ErrnoException | null) => void) => callback(null));
		vscode.commands.executeCommand.mockRejectedValueOnce(null);

		// Run
		const result = await viewDiffWithWorkingFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/modified.txt', dataSource);

		// Assert
		expect(result).toBe('Visual Studio Code was unable to load the diff editor for subfolder/modified.txt.');
		expect(mockedFileSystemModule.access).toHaveBeenNthCalledWith(1, path.join('/path/to/repo', 'subfolder/modified.txt'), fs.constants.R_OK, expect.anything());
	});
});

describe('viewFileAtRevision', () => {
	it('Should open the file in vscode', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewFileAtRevision('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/file.txt');

		// Assert
		const [command, uri, config] = vscode.commands.executeCommand.mock.calls[0];
		expect(command).toBe('vscode.open');
		expect(uri.toString()).toBe(expectedValueGitGraphUri('subfolder/file.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '/path/to/repo', true).replace('file.txt', '1a2b3c4d: file.txt'));
		expect(config).toStrictEqual({
			preview: true,
			viewColumn: vscode.ViewColumn.Active
		});
		expect(result).toBe(null);
	});

	it('Should return an error message if vscode was unable to open the file', async () => {
		// Setup
		vscode.commands.executeCommand.mockRejectedValueOnce(null);

		// Run
		const result = await viewFileAtRevision('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subfolder/file.txt');

		// Assert
		expect(result).toBe('Visual Studio Code was unable to open subfolder/file.txt at commit 1a2b3c4d.');
	});
});

describe('viewScm', () => {
	it('Executes workbench.view.scm', async () => {
		// Setup
		vscode.commands.executeCommand.mockResolvedValueOnce(null);

		// Run
		const result = await viewScm();

		// Assert
		expect(vscode.commands.executeCommand).toHaveBeenCalledWith('workbench.view.scm');
		expect(result).toBe(null);
	});

	it('Returns an error message when executeCommand fails', async () => {
		// Setup
		vscode.commands.executeCommand.mockRejectedValueOnce(null);

		// Run
		const result = await viewScm();

		// Assert
		expect(result).toBe('Visual Studio Code was unable to open the Source Control View.');
	});
});

describe('openGitTerminal', () => {
	let ostype: string | undefined, path: string | undefined, platform: NodeJS.Platform;
	beforeEach(() => {
		ostype = process.env.OSTYPE;
		path = process.env.PATH;
		platform = process.platform;
		process.env.OSTYPE = 'x';
		process.env.PATH = '/path/to/executable';
		Object.defineProperty(process, 'platform', { value: 'y' });
	});
	afterEach(() => {
		process.env.OSTYPE = ostype;
		process.env.PATH = path;
		Object.defineProperty(process, 'platform', { value: platform });
	});

	it('Should open a new terminal', () => {
		// Run
		openGitTerminal('/path/to/repo', '/path/to/git/git', null, 'Name');

		// Assert
		expect(vscode.window.createTerminal).toHaveBeenCalledWith({
			cwd: '/path/to/repo',
			env: {
				PATH: '/path/to/executable:/path/to/git'
			},
			name: 'Git Graph: Name'
		});
		expect(terminal.sendText).toHaveBeenCalledTimes(0);
		expect(terminal.show).toHaveBeenCalled();
	});

	it('Should open a new terminal and run the git command', () => {
		// Run
		openGitTerminal('/path/to/repo', '/path/to/git/git', 'rebase', 'Name');

		// Assert
		expect(vscode.window.createTerminal).toHaveBeenCalledWith({
			cwd: '/path/to/repo',
			env: {
				PATH: '/path/to/executable:/path/to/git'
			},
			name: 'Git Graph: Name'
		});
		expect(terminal.sendText).toHaveBeenCalledWith('git rebase');
		expect(terminal.show).toHaveBeenCalled();
	});

	it('Should open a new terminal and run the git command (with initially empty PATH)', () => {
		// Setup
		process.env.PATH = '';

		// Run
		openGitTerminal('/path/to/repo', '/path/to/git/git', 'rebase', 'Name');

		// Assert
		expect(vscode.window.createTerminal).toHaveBeenCalledWith({
			cwd: '/path/to/repo',
			env: {
				PATH: '/path/to/git'
			},
			name: 'Git Graph: Name'
		});
		expect(terminal.sendText).toHaveBeenCalledWith('git rebase');
		expect(terminal.show).toHaveBeenCalled();
	});

	it('Should open a new terminal and run the git command (with specific shell path)', () => {
		// Setup
		vscode.mockExtensionSettingReturnValue('integratedTerminalShell', '/path/to/shell');

		// Run
		openGitTerminal('/path/to/repo', '/path/to/git/git', 'rebase', 'Name');

		// Assert
		expect(vscode.window.createTerminal).toHaveBeenCalledWith({
			cwd: '/path/to/repo',
			env: {
				PATH: '/path/to/executable:/path/to/git'
			},
			name: 'Git Graph: Name',
			shellPath: '/path/to/shell'
		});
		expect(terminal.sendText).toHaveBeenCalledWith('git rebase');
		expect(terminal.show).toHaveBeenCalled();
	});

	it('Should open a new terminal and run the git command (platform: win32)', () => {
		// Setup
		Object.defineProperty(process, 'platform', { value: 'win32' });

		// Run
		openGitTerminal('/path/to/repo', '/path/to/git/git', 'rebase', 'Name');

		// Assert
		expect(vscode.window.createTerminal).toHaveBeenCalledWith({
			cwd: '/path/to/repo',
			env: {
				PATH: '/path/to/executable;/path/to/git'
			},
			name: 'Git Graph: Name'
		});
		expect(terminal.sendText).toHaveBeenCalledWith('git rebase');
		expect(terminal.show).toHaveBeenCalled();
	});

	it('Should open a new terminal and run the git command (ostype: cygwin)', () => {
		// Setup
		process.env.OSTYPE = 'cygwin';

		// Run
		openGitTerminal('/path/to/repo', '/path/to/git/git', 'rebase', 'Name');

		// Assert
		expect(vscode.window.createTerminal).toHaveBeenCalledWith({
			cwd: '/path/to/repo',
			env: {
				PATH: '/path/to/executable;/path/to/git'
			},
			name: 'Git Graph: Name'
		});
		expect(terminal.sendText).toHaveBeenCalledWith('git rebase');
		expect(terminal.show).toHaveBeenCalled();
	});

	it('Should open a new terminal and run the git command (ostype: msys)', () => {
		// Setup
		process.env.OSTYPE = 'msys';

		// Run
		openGitTerminal('/path/to/repo', '/path/to/git/git', 'rebase', 'Name');

		// Assert
		expect(vscode.window.createTerminal).toHaveBeenCalledWith({
			cwd: '/path/to/repo',
			env: {
				PATH: '/path/to/executable;/path/to/git'
			},
			name: 'Git Graph: Name'
		});
		expect(terminal.sendText).toHaveBeenCalledWith('git rebase');
		expect(terminal.show).toHaveBeenCalled();
	});
});

describe('showInformationMessage', () => {
	it('Should show an information message (resolves)', async () => {
		// Setup
		vscode.window.showInformationMessage.mockResolvedValueOnce(null);

		// Run
		await showInformationMessage('Message');

		// Assert
		expect(vscode.window.showInformationMessage).toBeCalledWith('Message');
	});

	it('Should show an information message (rejects)', async () => {
		// Setup
		vscode.window.showInformationMessage.mockRejectedValueOnce(null);

		// Run
		await showInformationMessage('Message');

		// Assert
		expect(vscode.window.showInformationMessage).toBeCalledWith('Message');
	});
});

describe('showErrorMessage', () => {
	it('Should show an error message (resolves)', async () => {
		// Setup
		vscode.window.showErrorMessage.mockResolvedValueOnce(null);

		// Run
		await showErrorMessage('Message');

		// Assert
		expect(vscode.window.showErrorMessage).toBeCalledWith('Message');
	});

	it('Should show an error message (rejects)', async () => {
		// Setup
		vscode.window.showErrorMessage.mockRejectedValueOnce(null);

		// Run
		await showErrorMessage('Message');

		// Assert
		expect(vscode.window.showErrorMessage).toBeCalledWith('Message');
	});
});

describe('evalPromises', () => {
	it('Should evaluate promises in parallel (one item in array)', async () => {
		// Run
		const result = await evalPromises([1], 2, (x) => Promise.resolve(x * 2));

		// Assert
		expect(result).toStrictEqual([2]);
	});

	it('Should evaluate promises in parallel (one item in array that rejects)', async () => {
		// Setup
		let rejected = false;

		// Run
		await evalPromises([1], 2, (x) => Promise.reject(x * 2)).catch(() => rejected = true);

		// Assert
		expect(rejected).toBe(true);
	});

	it('Should evaluate promises in parallel (empty array)', async () => {
		// Run
		const result = await evalPromises([], 2, (x) => Promise.resolve(x * 2));

		// Assert
		expect(result).toStrictEqual([]);
	});

	it('Should evaluate promises in parallel', async () => {
		// Run
		const result = await evalPromises([1, 2, 3, 4], 2, (x) => Promise.resolve(x * 2));

		// Assert
		expect(result).toStrictEqual([2, 4, 6, 8]);
	});

	it('Should evaluate promises in parallel that reject', async () => {
		// Setup
		let rejected = false;

		// Run
		await evalPromises([1, 2, 3, 4], 2, (x) => Promise.reject(x * 2)).catch(() => rejected = true);

		// Assert
		expect(rejected).toBe(true);
	});

	it('Should evaluate promises in parallel (first rejects)', async () => {
		// Setup
		const prom1 = new Promise((_, reject) => setTimeout(reject, 1));
		const prom2 = prom1.catch(() => 1);

		// Run
		const result = await evalPromises([1, 2, 3, 4], 2, (x) => x === 1 ? prom1 : prom2).catch(() => -1);

		// Assert
		expect(result).toBe(-1);
	});
});

describe('resolveSpawnOutput', () => {
	it('Should resolve child process promise only once (error event first)', async () => {
		// Setup
		mockSpyOnSpawn(spyOnSpawn, (onCallbacks, stderrOnCallbacks, stdoutOnCallbacks) => {
			stdoutOnCallbacks['close']();
			stderrOnCallbacks['close']();
			onCallbacks['error']('error');
			onCallbacks['exit'](0);
		});

		// Run
		const result = await resolveSpawnOutput(cp.spawn('/path/to/git', ['arg0', 'arg1']));

		// Assert
		expect(result).toStrictEqual([
			{ code: -1, error: 'error' },
			expect.any(Buffer),
			''
		]);
	});

	it('Should resolve child process promise only once (exit event first)', async () => {
		// Setup
		mockSpyOnSpawn(spyOnSpawn, (onCallbacks, stderrOnCallbacks, stdoutOnCallbacks) => {
			stdoutOnCallbacks['close']();
			stderrOnCallbacks['close']();
			onCallbacks['exit'](1);
			onCallbacks['error']('error');
		});

		// Run
		const result = await resolveSpawnOutput(cp.spawn('/path/to/git', ['arg0', 'arg1']));

		// Assert
		expect(result).toStrictEqual([
			{ code: 1, error: null },
			expect.any(Buffer),
			''
		]);
	});
});

describe('findGit', () => {
	let onDidChangeGitExecutable: EventEmitter<GitExecutable>, extensionState: ExtensionState, platform: NodeJS.Platform;
	beforeAll(() => {
		onDidChangeGitExecutable = new EventEmitter<GitExecutable>();
	});
	afterAll(() => {
		onDidChangeGitExecutable.dispose();
	});
	beforeEach(() => {
		extensionState = new ExtensionState(extensionContext, onDidChangeGitExecutable.subscribe);
		platform = process.platform;
		Object.defineProperty(process, 'platform', { value: 'y' });
	});
	afterEach(() => {
		extensionState.dispose();
		Object.defineProperty(process, 'platform', { value: platform });
	});

	it('Should use the last known Git executable path if it still exists', async () => {
		// Setup
		jest.spyOn(extensionState, 'getLastKnownGitPath').mockReturnValueOnce('/path/to/git');
		mockSpawnGitVersionSuccessOnce();

		// Run
		const result = await findGit(extensionState);

		// Assert
		expect(result).toStrictEqual({
			path: '/path/to/git',
			version: '1.2.3'
		});
		expect(spyOnSpawn).toHaveBeenCalledWith('/path/to/git', ['--version']);
	});

	it('Should use the users git.path if the last known Git executable path no longer exists', async () => {
		// Setup
		jest.spyOn(extensionState, 'getLastKnownGitPath').mockReturnValueOnce('/path/to/not-git');
		vscode.mockExtensionSettingReturnValue('path', '/path/to/git');
		mockSpawnGitVersionThrowingErrorOnce();
		mockSpawnGitVersionSuccessOnce();

		// Run
		const result = await findGit(extensionState);

		// Assert
		expect(result).toStrictEqual({
			path: '/path/to/git',
			version: '1.2.3'
		});
		expect(spyOnSpawn).toHaveBeenCalledWith('/path/to/git', ['--version']);
	});

	it('Should use the users git.path if there is no last known Git executable path', async () => {
		// Setup
		jest.spyOn(extensionState, 'getLastKnownGitPath').mockReturnValueOnce(null);
		vscode.mockExtensionSettingReturnValue('path', '/path/to/git');
		mockSpawnGitVersionSuccessOnce();

		// Run
		const result = await findGit(extensionState);

		// Assert
		expect(result).toStrictEqual({
			path: '/path/to/git',
			version: '1.2.3'
		});
		expect(spyOnSpawn).toHaveBeenCalledWith('/path/to/git', ['--version']);
	});

	describe('process.platform === \'darwin\'', () => {
		let spyOnExec: jest.SpyInstance;
		beforeEach(() => {
			jest.spyOn(extensionState, 'getLastKnownGitPath').mockReturnValueOnce(null);
			vscode.mockExtensionSettingReturnValue('path', null);
			Object.defineProperty(process, 'platform', { value: 'darwin' });
			spyOnExec = jest.spyOn(cp, 'exec');
		});

		it('Should find and return the Git executable using "which git"', async () => {
			// Setup
			spyOnExec.mockImplementationOnce((command: string, callback: (error: Error | null, stdout: string, stderr: string) => void) => {
				expect(command).toBe('which git');
				callback(null, '/path/to/git', '');
			});
			mockSpawnGitVersionSuccessOnce();

			// Run
			const result = await findGit(extensionState);

			// Assert
			expect(result).toStrictEqual({
				path: '/path/to/git',
				version: '1.2.3'
			});
		});

		it('Should find and return the Git executable using when XCode & Git are installed', async () => {
			// Setup
			spyOnExec.mockImplementationOnce((command: string, callback: (error: Error | null, stdout: string, stderr: string) => void) => {
				expect(command).toBe('which git');
				callback(null, '/usr/bin/git', '');
			});
			spyOnExec.mockImplementationOnce((command: string, callback: (error: Error | null) => void) => {
				expect(command).toBe('xcode-select -p');
				callback(null);
			});
			mockSpawnGitVersionSuccessOnce();

			// Run
			const result = await findGit(extensionState);

			// Assert
			expect(result).toStrictEqual({
				path: '/usr/bin/git',
				version: '1.2.3'
			});
		});

		it('Should reject when "which git" throws an error', async () => {
			// Setup
			let rejected = false;
			spyOnExec.mockImplementationOnce((command: string, callback: (error: Error | null, stdout: string, stderr: string) => void) => {
				expect(command).toBe('which git');
				callback(new Error(), '', '');
			});

			// Run
			await findGit(extensionState).catch(() => rejected = true);

			// Assert
			expect(rejected).toBe(true);
		});

		it('Should reject when "which git" succeeds, but failed to get Git executable', async () => {
			// Setup
			let rejected = false;
			spyOnExec.mockImplementationOnce((command: string, callback: (error: Error | null, stdout: string, stderr: string) => void) => {
				expect(command).toBe('which git');
				callback(null, '/path/to/git', '');
			});
			mockSpawnGitVersionThrowingErrorOnce();

			// Run
			await findGit(extensionState).catch(() => rejected = true);

			// Assert
			expect(rejected).toBe(true);
		});

		it('Should reject when "xcode-select -p" fails with exit code 2', async () => {
			// Setup
			let rejected = false;
			spyOnExec.mockImplementationOnce((command: string, callback: (error: Error | null, stdout: string, stderr: string) => void) => {
				expect(command).toBe('which git');
				callback(null, '/usr/bin/git', '');
			});
			spyOnExec.mockImplementationOnce((command: string, callback: (error: Error | null) => void) => {
				expect(command).toBe('xcode-select -p');
				callback(null);
			});
			mockSpawnGitVersionThrowingErrorOnce();

			// Run
			await findGit(extensionState).catch(() => rejected = true);

			// Assert
			expect(rejected).toBe(true);
		});

		it('Should reject when "xcode-select -p" succeeds, but failed to get Git executable', async () => {
			// Setup
			let rejected = false;
			spyOnExec.mockImplementationOnce((command: string, callback: (error: Error | null, stdout: string, stderr: string) => void) => {
				expect(command).toBe('which git');
				callback(null, '/usr/bin/git', '');
			});
			spyOnExec.mockImplementationOnce((command: string, callback: (error: Error | null) => void) => {
				expect(command).toBe('xcode-select -p');
				callback({ code: 2 } as any);
			});

			// Run
			await findGit(extensionState).catch(() => rejected = true);

			// Assert
			expect(rejected).toBe(true);
		});
	});

	describe('process.platform === \'win32\'', () => {
		let programW6432: string | undefined, programFilesX86: string | undefined, programFiles: string | undefined, localAppData: string | undefined, envPath: string | undefined;
		beforeEach(() => {
			jest.spyOn(extensionState, 'getLastKnownGitPath').mockReturnValueOnce(null);
			vscode.mockExtensionSettingReturnValue('path', []);
			programW6432 = process.env['ProgramW6432'];
			programFilesX86 = process.env['ProgramFiles(x86)'];
			programFiles = process.env['ProgramFiles'];
			localAppData = process.env['LocalAppData'];
			envPath = process.env['PATH'];
			Object.defineProperty(process, 'platform', { value: 'win32' });
		});
		afterEach(() => {
			process.env['ProgramW6432'] = programW6432;
			process.env['ProgramFiles(x86)'] = programFilesX86;
			process.env['ProgramFiles'] = programFiles;
			process.env['LocalAppData'] = localAppData;
			process.env['PATH'] = envPath;
		});

		it('Should find Git in ProgramW6432', async () => {
			// Setup
			process.env['ProgramW6432'] = 'c:/path/to/ProgramW6432';
			mockSpawnGitVersionSuccessOnce();

			// Run
			const result = await findGit(extensionState);

			// Assert
			expect(getPathFromStr(result.path)).toBe('c:/path/to/ProgramW6432/Git/cmd/git.exe');
			expect(result.version).toBe('1.2.3');
		});

		it('Should find Git in ProgramFiles(x86)', async () => {
			// Setup
			process.env['ProgramFiles(x86)'] = 'c:/path/to/ProgramFilesX86';
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionSuccessOnce();

			// Run
			const result = await findGit(extensionState);

			// Assert
			expect(getPathFromStr(result.path)).toBe('c:/path/to/ProgramFilesX86/Git/cmd/git.exe');
			expect(result.version).toBe('1.2.3');
		});

		it('Should find Git in ProgramFiles', async () => {
			// Setup
			process.env['ProgramFiles'] = 'c:/path/to/ProgramFiles';
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionSuccessOnce();

			// Run
			const result = await findGit(extensionState);

			// Assert
			expect(getPathFromStr(result.path)).toBe('c:/path/to/ProgramFiles/Git/cmd/git.exe');
			expect(result.version).toBe('1.2.3');
		});

		it('Should find Git in LocalAppData', async () => {
			// Setup
			process.env['LocalAppData'] = 'c:/path/to/LocalAppData';
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionSuccessOnce();

			// Run
			const result = await findGit(extensionState);

			// Assert
			expect(getPathFromStr(result.path)).toBe('c:/path/to/LocalAppData/Programs/Git/cmd/git.exe');
			expect(result.version).toBe('1.2.3');
		});

		it('Should find Git in PATH (isFile)', async () => {
			// Setup
			process.env['PATH'] = 'c:/path/to/git-dir';
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockedFileSystemModule.stat.mockImplementation((statPath: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, stats: fs.Stats) => void) => {
				callback(null, { isFile: () => getPathFromStr(statPath as string) === 'c:/path/to/git-dir/git.exe', isSymbolicLink: () => false } as any);
			});
			mockSpawnGitVersionSuccessOnce();

			// Run
			const result = await findGit(extensionState);

			// Assert
			expect(getPathFromStr(result.path)).toBe('c:/path/to/git-dir/git.exe');
			expect(result.version).toBe('1.2.3');
		});

		it('Should find Git in PATH (isSymbolicLink)', async () => {
			// Setup
			delete process.env['LocalAppData'];
			process.env['PATH'] = 'c:/path/to/git-dir';
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockedFileSystemModule.stat.mockImplementation((statPath: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, stats: fs.Stats) => void) => {
				callback(null, { isFile: () => false, isSymbolicLink: () => getPathFromStr(statPath as string) === 'c:/path/to/git-dir/git.exe' } as any);
			});
			mockSpawnGitVersionSuccessOnce();

			// Run
			const result = await findGit(extensionState);

			// Assert
			expect(getPathFromStr(result.path)).toBe('c:/path/to/git-dir/git.exe');
			expect(result.version).toBe('1.2.3');
		});

		it('Should find Git in CWD', async () => {
			// Setup
			delete process.env['PATH'];
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			const gitPath = getPathFromStr(path.join(process.cwd(), 'git.exe'));
			mockedFileSystemModule.stat.mockImplementation((statPath: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, stats: fs.Stats) => void) => {
				callback(null, { isFile: () => getPathFromStr(statPath as string) === gitPath, isSymbolicLink: () => false } as any);
			});
			mockSpawnGitVersionSuccessOnce();

			// Run
			const result = await findGit(extensionState);

			// Assert
			expect(getPathFromStr(result.path)).toBe(gitPath);
			expect(result.version).toBe('1.2.3');
		});

		it('Should reject when Git executable not in PATH', async () => {
			// Setup
			let rejected = false;
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockSpawnGitVersionThrowingErrorOnce();
			mockedFileSystemModule.stat.mockImplementation((_: fs.PathLike, callback: (err: NodeJS.ErrnoException | null, stats: fs.Stats) => void) => {
				callback(null, { isFile: () => false, isSymbolicLink: () => false } as any);
			});

			// Run
			await findGit(extensionState).catch(() => rejected = true);

			// Assert
			expect(rejected).toBe(true);
		});
	});

	describe('process.platform === \'unknown\'', () => {
		beforeEach(() => {
			jest.spyOn(extensionState, 'getLastKnownGitPath').mockReturnValueOnce(null);
			vscode.mockExtensionSettingReturnValue('path', null);
			Object.defineProperty(process, 'platform', { value: 'unknown' });
		});

		it('Should return the Git executable', async () => {
			// Setup
			mockSpawnGitVersionSuccessOnce();

			// Run
			const result = await findGit(extensionState);

			// Assert
			expect(result).toStrictEqual({
				path: 'git',
				version: '1.2.3'
			});
		});

		it('Should reject when the Git executable doesn\'t exist', async () => {
			// Setup
			let rejected = false;
			mockSpawnGitVersionThrowingErrorOnce();

			// Run
			await findGit(extensionState).catch(() => rejected = true);

			// Assert
			expect(rejected).toBe(true);
		});
	});
});

describe('getGitExecutable', () => {
	it('Should return the git version information', async () => {
		// Setup
		mockSpawnGitVersionSuccessOnce();

		// Run
		const result = await getGitExecutable('/path/to/git');

		// Assert
		expect(result).toStrictEqual({
			path: '/path/to/git',
			version: '1.2.3'
		});
	});

	it('Should reject when an error is thrown', async () => {
		// Setup
		let rejected = false;
		mockSpawnGitVersionThrowingErrorOnce();

		// Run
		await getGitExecutable('/path/to/git').catch(() => rejected = true);

		// Assert
		expect(rejected).toBe(true);
	});

	it('Should reject when the command exits with a non-zero exit code', async () => {
		// Setup
		let rejected = false;
		mockSpyOnSpawn(spyOnSpawn, (onCallbacks, stderrOnCallbacks, stdoutOnCallbacks) => {
			stdoutOnCallbacks['close']();
			stderrOnCallbacks['close']();
			onCallbacks['exit'](1);
		});

		// Run
		await getGitExecutable('/path/to/git').catch(() => rejected = true);

		// Assert
		expect(rejected).toBe(true);
	});

	it('Should reject when the command exits with a signal', async () => {
		// Setup
		let rejected = false;
		mockSpyOnSpawn(spyOnSpawn, (onCallbacks, stderrOnCallbacks, stdoutOnCallbacks) => {
			stdoutOnCallbacks['close']();
			stderrOnCallbacks['close']();
			onCallbacks['exit'](null, 'signal');
		});

		// Run
		await getGitExecutable('/path/to/git').catch(() => rejected = true);

		// Assert
		expect(rejected).toBe(true);
	});
});

describe('getGitExecutableFromPaths', () => {
	it('Should return the git version information from the first valid path (all valid)', async () => {
		// Setup
		mockSpawnGitVersionSuccessOnce();

		// Run
		const result = await getGitExecutableFromPaths(['/path/to/first/git', '/path/to/second/git']);

		// Assert
		expect(result).toStrictEqual({
			path: '/path/to/first/git',
			version: '1.2.3'
		});
		expect(spyOnSpawn).toBeCalledTimes(1);
	});

	it('Should return the git version information from the first valid path (first invalid)', async () => {
		// Setup
		mockSpawnGitVersionThrowingErrorOnce();
		mockSpawnGitVersionSuccessOnce();

		// Run
		const result = await getGitExecutableFromPaths(['/path/to/first/git', '/path/to/second/git']);

		// Assert
		expect(result).toStrictEqual({
			path: '/path/to/second/git',
			version: '1.2.3'
		});
		expect(spyOnSpawn).toBeCalledTimes(2);
	});

	it('Should reject when none of the provided paths are valid Git executables', async () => {
		// Setup
		let rejected = false;
		mockSpawnGitVersionThrowingErrorOnce();
		mockSpawnGitVersionThrowingErrorOnce();

		// Run
		await getGitExecutableFromPaths(['/path/to/first/git', '/path/to/second/git']).catch(() => rejected = true);

		// Assert
		expect(rejected).toBe(true);
		expect(spyOnSpawn).toBeCalledTimes(2);
	});

	it('Should reject when no paths are provided', async () => {
		// Setup
		let rejected = false;

		// Run
		await getGitExecutableFromPaths([]).catch(() => rejected = true);

		// Assert
		expect(rejected).toBe(true);
		expect(spyOnSpawn).toBeCalledTimes(0);
	});
});

describe('doesVersionMeetRequirement', () => {
	it('Should correctly determine major newer', () => {
		// Run
		const result = doesVersionMeetRequirement('2.7.8.windows.0', GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe(true);
	});

	it('Should correctly determine major older', () => {
		// Run
		const result = doesVersionMeetRequirement('0.7.8.windows.0', GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe(false);
	});

	it('Should correctly determine minor newer', () => {
		// Run
		const result = doesVersionMeetRequirement('1.8.8 (Apple Git-122.3)', GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe(true);
	});

	it('Should correctly determine minor older', () => {
		// Run
		const result = doesVersionMeetRequirement('1.6.8 (Apple Git-122.3)', GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe(false);
	});

	it('Should correctly determine patch newer', () => {
		// Run
		const result = doesVersionMeetRequirement('1.7.9', GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe(true);
	});

	it('Should correctly determine patch older', () => {
		// Run
		const result = doesVersionMeetRequirement('1.7.7', GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe(false);
	});

	it('Should correctly determine same version', () => {
		// Run
		const result = doesVersionMeetRequirement('1.7.8', GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe(true);
	});

	it('Should correctly determine major newer if missing patch version', () => {
		// Run
		const result = doesVersionMeetRequirement('2.7', GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe(true);
	});

	it('Should correctly determine major newer if missing minor & patch versions', () => {
		// Run
		const result = doesVersionMeetRequirement('2', GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe(true);
	});

	it('Should only use the valid portion of the version number to compute the result', () => {
		// Run
		const result1 = doesVersionMeetRequirement('1.7..8-windows.0', GitVersionRequirement.TagDetails);

		// Assert
		expect(result1).toBe(false);

		// Run
		const result2 = doesVersionMeetRequirement('1.8..7-windows.0', GitVersionRequirement.TagDetails);

		// Assert
		expect(result2).toBe(true);
	});

	it('Should return TRUE if executable version is invalid', () => {
		// Run
		const result = doesVersionMeetRequirement('a1.7.7', GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe(true);
	});
});

describe('constructIncompatibleGitVersionMessage', () => {
	it('Should return the constructed message', () => {
		// Run
		const result = constructIncompatibleGitVersionMessage({ version: '1.7.7', path: '' }, GitVersionRequirement.TagDetails);

		// Assert
		expect(result).toBe('A newer version of Git (>= 1.7.8) is required for this feature. Git 1.7.7 is currently installed. Please install a newer version of Git to use this feature.');
	});
});

function expectedValueGitGraphUri(filePath: string, commit: string, repo: string, exists: boolean) {
	const extIndex = filePath.indexOf('.', filePath.lastIndexOf('/') + 1);
	const extension = exists && extIndex > -1 ? filePath.substring(extIndex) : '';
	return 'git-graph://file' + extension + '?' + Buffer.from(JSON.stringify({ filePath: filePath, commit: commit, repo: repo, exists: exists })).toString('base64');
}
-e 

================================================================================
// FILE: ./tests/repoManager.test.ts
================================================================================
import './mocks/date';
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });
jest.mock('fs');
jest.mock('../src/dataSource');
jest.mock('../src/extensionState');
jest.mock('../src/logger');
jest.mock('../src/utils/bufferedQueue');

import * as fs from 'fs';
import { ConfigurationChangeEvent } from 'vscode';
import { DataSource } from '../src/dataSource';
import { ExtensionState } from '../src/extensionState';
import { Logger } from '../src/logger';
import { ExternalRepoConfig, RepoChangeEvent, RepoManager } from '../src/repoManager';
import * as utils from '../src/utils';
import * as bufferedQueue from '../src/utils/bufferedQueue';
import { EventEmitter } from '../src/utils/event';
import { BooleanOverride, FileViewType, GitRepoSet, GitRepoState, PullRequestProvider, RepoCommitOrdering } from '../src/types';

import { waitForExpect } from './helpers/expectations';
import { mockRepoState } from './helpers/utils';

let onDidChangeConfiguration: EventEmitter<ConfigurationChangeEvent>;
let onDidChangeGitExecutable: EventEmitter<utils.GitExecutable>;
let logger: Logger;
let dataSource: DataSource;
let extensionState: ExtensionState;
let spyOnGetRepos: jest.SpyInstance, spyOnGetIgnoredRepos: jest.SpyInstance, spyOnSetIgnoredRepos: jest.SpyInstance, spyOnSaveRepos: jest.SpyInstance, spyOnTransferRepo: jest.SpyInstance, spyOnRepoRoot: jest.SpyInstance, spyOnGetSubmodules: jest.SpyInstance, spyOnLog: jest.SpyInstance, spyOnMkdir: jest.SpyInstance, spyOnReaddir: jest.SpyInstance, spyOnReadFile: jest.SpyInstance, spyOnStat: jest.SpyInstance, spyOnWriteFile: jest.SpyInstance;

beforeAll(() => {
	onDidChangeConfiguration = new EventEmitter<ConfigurationChangeEvent>();
	onDidChangeGitExecutable = new EventEmitter<utils.GitExecutable>();
	logger = new Logger();
	dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);
	extensionState = new ExtensionState(vscode.mocks.extensionContext, onDidChangeGitExecutable.subscribe);
	spyOnGetRepos = jest.spyOn(extensionState, 'getRepos');
	spyOnGetIgnoredRepos = jest.spyOn(extensionState, 'getIgnoredRepos');
	spyOnSetIgnoredRepos = jest.spyOn(extensionState, 'setIgnoredRepos');
	spyOnSaveRepos = jest.spyOn(extensionState, 'saveRepos');
	spyOnTransferRepo = jest.spyOn(extensionState, 'transferRepo');
	spyOnRepoRoot = jest.spyOn(dataSource, 'repoRoot');
	spyOnGetSubmodules = jest.spyOn(dataSource, 'getSubmodules');
	spyOnLog = jest.spyOn(logger, 'log');
	spyOnMkdir = jest.spyOn(fs, 'mkdir');
	spyOnReaddir = jest.spyOn(fs, 'readdir');
	spyOnReadFile = jest.spyOn(fs, 'readFile');
	spyOnStat = jest.spyOn(fs, 'stat');
	spyOnWriteFile = jest.spyOn(fs, 'writeFile');

	spyOnReadFile.mockImplementation((_: string, callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void) => {
		callback(new Error(), Buffer.alloc(0));
	});

	jest.spyOn(bufferedQueue, 'BufferedQueue').mockImplementation(<T>(onItem: (item: T) => Promise<boolean>, onChanges: () => void) => {
		const realBufferedQueue = jest.requireActual('../src/utils/bufferedQueue');
		return new realBufferedQueue.BufferedQueue(onItem, onChanges, 1);
	});
});

afterAll(() => {
	extensionState.dispose();
	dataSource.dispose();
	logger.dispose();
	onDidChangeConfiguration.dispose();
	onDidChangeGitExecutable.dispose();
});

describe('RepoManager', () => {
	it('Should construct a RepoManager, and be disposed', async () => {
		// Run
		const repoManager = await constructRepoManagerAndWaitUntilStarted([], []);

		// Assert
		expect(repoManager['disposables']).toHaveLength(8);
		expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('**/.vscode/vscode-git-graph.json');

		// Run
		repoManager.dispose();

		// Assert
		expect(repoManager['disposables']).toHaveLength(0);
	});

	describe('onDidChangeWorkspaceFolders', () => {
		it('Should add repositories contained within an added workspace folder', async () => {
			// Setup
			let emitOnDidChangeWorkspaceFolders: (event: { added: { uri: vscode.Uri }[], removed: { uri: vscode.Uri }[] }) => Promise<void>;
			vscode.workspace.onDidChangeWorkspaceFolders.mockImplementationOnce((listener) => {
				emitOnDidChangeWorkspaceFolders = listener as () => Promise<void>;
				return { dispose: jest.fn() };
			});
			const repoManager = await constructRepoManagerAndWaitUntilStarted([], []);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockRepositoryWithNoSubmodules();

			// Run
			vscode.workspace.workspaceFolders = [{ uri: vscode.Uri.file('/path/to/workspace-folder1'), index: 0 }];
			await emitOnDidChangeWorkspaceFolders!({ added: [{ uri: vscode.Uri.file('/path/to/workspace-folder1') }], removed: [] });

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
					},
					numRepos: 1,
					loadRepo: null
				}
			]);
			expect(spyOnLog).toHaveBeenCalledWith('Added new repo: /path/to/workspace-folder1');
			expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('/path/to/workspace-folder1/**');

			// Teardown
			repoManager.dispose();
		});

		it('Should add repositories contained within an added workspace folder (unable to find workspaceFolderIndex)', async () => {
			// Setup
			let emitOnDidChangeWorkspaceFolders: (event: { added: { uri: vscode.Uri }[], removed: { uri: vscode.Uri }[] }) => Promise<void>;
			vscode.workspace.onDidChangeWorkspaceFolders.mockImplementationOnce((listener) => {
				emitOnDidChangeWorkspaceFolders = listener as () => Promise<void>;
				return { dispose: jest.fn() };
			});
			const repoManager = await constructRepoManagerAndWaitUntilStarted([], []);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockRepositoryWithNoSubmodules();

			// Run
			await emitOnDidChangeWorkspaceFolders!({ added: [{ uri: vscode.Uri.file('/path/to/workspace-folder1') }], removed: [] });

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: null })
			});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: null })
					},
					numRepos: 1,
					loadRepo: null
				}
			]);
			expect(spyOnLog).toHaveBeenCalledWith('Added new repo: /path/to/workspace-folder1');
			expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('/path/to/workspace-folder1/**');

			// Teardown
			repoManager.dispose();
		});

		it('Should not emit a repo event when no repositories were contained within an added workspace folder', async () => {
			// Setup
			let emitOnDidChangeWorkspaceFolders: (event: { added: { uri: vscode.Uri }[], removed: { uri: vscode.Uri }[] }) => Promise<void>;
			vscode.workspace.onDidChangeWorkspaceFolders.mockImplementationOnce((listener) => {
				emitOnDidChangeWorkspaceFolders = listener as () => Promise<void>;
				return { dispose: jest.fn() };
			});
			const repoManager = await constructRepoManagerAndWaitUntilStarted([], []);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockDirectoryThatsNotRepository();

			// Run
			await emitOnDidChangeWorkspaceFolders!({ added: [{ uri: vscode.Uri.file('/path/to/workspace-folder1') }], removed: [] });

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({});
			expect(onDidChangeReposEvents).toStrictEqual([]);

			// Teardown
			repoManager.dispose();
		});

		it('Should remove repositories contained within a removed workspace folder', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			let emitOnDidChangeWorkspaceFolders: (event: { added: { uri: vscode.Uri }[], removed: { uri: vscode.Uri }[] }) => Promise<void>;
			vscode.workspace.onDidChangeWorkspaceFolders.mockImplementationOnce((listener) => {
				emitOnDidChangeWorkspaceFolders = listener as () => Promise<void>;
				return { dispose: jest.fn() };
			});
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1', '/path/to/workspace-folder2'],
				['/path/to/workspace-folder1', '/path/to/workspace-folder2', '/path/to/workspace-folder2/submodule']
			);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			await emitOnDidChangeWorkspaceFolders!({ added: [], removed: [{ uri: vscode.Uri.file('/path/to/workspace-folder2') }] });

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
					},
					numRepos: 1,
					loadRepo: null
				}
			]);
			expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder2');

			// Teardown
			repoManager.dispose();
		});

		it('Should not emit a repo event when no repositories were contained within a removed workspace folder', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			let emitOnDidChangeWorkspaceFolders: (event: { added: { uri: vscode.Uri }[], removed: { uri: vscode.Uri }[] }) => Promise<void>;
			vscode.workspace.onDidChangeWorkspaceFolders.mockImplementationOnce((listener) => {
				emitOnDidChangeWorkspaceFolders = listener as () => Promise<void>;
				return { dispose: jest.fn() };
			});
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1', '/path/to/workspace-folder2'],
				['/path/to/workspace-folder1']
			);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			await emitOnDidChangeWorkspaceFolders!({ added: [], removed: [{ uri: vscode.Uri.file('/path/to/workspace-folder2') }] });

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([]);

			// Teardown
			repoManager.dispose();
		});

		it('Should update all repositories workspaceFolderIndex\'s when workspace folders have been reordered', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			let emitOnDidChangeWorkspaceFolders: (event: { added: { uri: vscode.Uri }[], removed: { uri: vscode.Uri }[] }) => Promise<void>;
			vscode.workspace.onDidChangeWorkspaceFolders.mockImplementationOnce((listener) => {
				emitOnDidChangeWorkspaceFolders = listener as () => Promise<void>;
				return { dispose: jest.fn() };
			});
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1', '/path/to/workspace-folder2', '/path/to/workspace-folder3'],
				['/path/to/workspace-folder1', '/path/to/workspace-folder2', '/path/to/workspace-folder3']
			);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder2': mockRepoState({ workspaceFolderIndex: 1 }),
				'/path/to/workspace-folder3': mockRepoState({ workspaceFolderIndex: 2 })
			});

			// Run
			vscode.workspace.workspaceFolders = [
				{ uri: vscode.Uri.file('/path/to/workspace-folder1'), index: 0 },
				{ uri: vscode.Uri.file('/path/to/workspace-folder3'), index: 1 },
				{ uri: vscode.Uri.file('/path/to/workspace-folder2'), index: 2 }
			];
			await emitOnDidChangeWorkspaceFolders!({ added: [], removed: [] });

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder2': mockRepoState({ workspaceFolderIndex: 2 }),
				'/path/to/workspace-folder3': mockRepoState({ workspaceFolderIndex: 1 })
			});
			expect(spyOnSaveRepos).toHaveBeenCalledWith({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder2': mockRepoState({ workspaceFolderIndex: 2 }),
				'/path/to/workspace-folder3': mockRepoState({ workspaceFolderIndex: 1 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 }),
						'/path/to/workspace-folder2': mockRepoState({ workspaceFolderIndex: 2 }),
						'/path/to/workspace-folder3': mockRepoState({ workspaceFolderIndex: 1 })
					},
					numRepos: 3,
					loadRepo: null
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should not emit repo events is no changes occurred', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			let emitOnDidChangeWorkspaceFolders: (event: { added: { uri: vscode.Uri }[], removed: { uri: vscode.Uri }[] }) => Promise<void>;
			vscode.workspace.onDidChangeWorkspaceFolders.mockImplementationOnce((listener) => {
				emitOnDidChangeWorkspaceFolders = listener as () => Promise<void>;
				return { dispose: jest.fn() };
			});
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1', '/path/to/workspace-folder2'],
				['/path/to/workspace-folder1', '/path/to/workspace-folder2']
			);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			await emitOnDidChangeWorkspaceFolders!({ added: [], removed: [] });

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder2': mockRepoState({ workspaceFolderIndex: 1 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([]);

			// Teardown
			repoManager.dispose();
		});
	});

	describe('maxDepthOfRepoSearchChanged', () => {
		it('Should not trigger a workspace search if the value hasn\'t increased', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);

			const spyOnSearchWorkspaceForRepos = jest.spyOn(repoManager, 'searchWorkspaceForRepos');

			// Run
			vscode.mockExtensionSettingReturnValue('maxDepthOfRepoSearch', 0);
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.maxDepthOfRepoSearch'
			});

			// Assert
			expect(spyOnSearchWorkspaceForRepos).toHaveBeenCalledTimes(0);

			// Teardown
			repoManager.dispose();
		});

		it('Should not be triggered when other extension settings are changed', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);

			const spyOnSearchWorkspaceForRepos = jest.spyOn(repoManager, 'searchWorkspaceForRepos');

			// Run
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.date.type'
			});

			// Assert
			expect(spyOnSearchWorkspaceForRepos).toHaveBeenCalledTimes(0);

			// Teardown
			repoManager.dispose();
		});
	});

	describe('startupTasks', () => {
		it('Should run startup tasks', async () => {
			// Setup
			mockRepositoryWithNoSubmodules(); // Exists: /path/to/workspace-folder1/repo1
			mockDirectoryThatsNotRepository(); // Removed: Re/path/to/workspace-folder1/repo2
			mockRepositoryWithNoSubmodules(); // Exists: /path/to/another
			mockDirectoryThatsNotRepository(); // Not Repo: /path/to/workspace-folder1
			mockRepositoryWithNoSubmodules(); // New: /path/to/workspace-folder3

			// Run
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1', '/path/to/another/workspace-folder', '/path/to/workspace-folder3'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo2', '/path/to/workspace-folder4', '/path/to/another']
			);

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/another': mockRepoState({ workspaceFolderIndex: 1 }),
				'/path/to/workspace-folder3': mockRepoState({ workspaceFolderIndex: 2 })
			});
			expect(spyOnSaveRepos).toHaveBeenCalledTimes(4);
			expect(spyOnSaveRepos).toHaveBeenCalledWith({
				'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/another': mockRepoState({ workspaceFolderIndex: 1 }),
				'/path/to/workspace-folder3': mockRepoState({ workspaceFolderIndex: 2 })
			});
			expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('/path/to/workspace-folder1/**');
			expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('/path/to/another/workspace-folder/**');
			expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('/path/to/workspace-folder3/**');

			// Run
			repoManager.dispose();
		});

		it('Should run startup tasks (calls saveRepos when updateReposWorkspaceFolderIndex makes changes)', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();

			// Run
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				{
					'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: null })
				}
			);

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(spyOnSaveRepos).toHaveBeenCalledWith({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('/path/to/workspace-folder1/**');

			// Run
			repoManager.dispose();
		});

		it('Should run startup tasks (doesn\'t call saveRepos when updateReposWorkspaceFolderIndex doesn\'t make changes)', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();

			// Run
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				{
					'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
				}
			);

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(spyOnSaveRepos).not.toHaveBeenCalled();
			expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('/path/to/workspace-folder1/**');

			// Run
			repoManager.dispose();
		});

		it('Should run startup tasks (doesn\'t call sendRepos when checkReposExist makes changes)', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			mockDirectoryThatsNotRepository();

			// Run
			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			const repoManager = constructRepoManager(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1']
			);
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			await waitForRepoManagerToStart();

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {},
					numRepos: 0,
					loadRepo: null
				}
			]);
			expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('/path/to/workspace-folder1/**');

			// Run
			repoManager.dispose();
		});

		it('Should run startup tasks (calls sendRepos when checkReposExist doesn\'t make changes)', async () => {
			// Setup
			mockDirectoryThatsNotRepository();

			// Run
			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			const repoManager = constructRepoManager(
				['/path/to/workspace-folder1'],
				[]
			);
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			await waitForRepoManagerToStart();

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {},
					numRepos: 0,
					loadRepo: null
				}
			]);
			expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalledWith('/path/to/workspace-folder1/**');

			// Run
			repoManager.dispose();
		});
	});

	describe('removeReposNotInWorkspace', () => {
		it('Should remove repositories that aren\'t in the workspace', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();

			// Run
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1', '/path/to/workspace-folder2']
			);

			// Assert
			expect(spyOnSaveRepos).toHaveBeenCalledWith({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder2');

			// Teardown
			repoManager.dispose();
		});

		it('Should remove all repositories when no workspace folders exist', async () => {
			// Run
			const repoManager = await constructRepoManagerAndWaitUntilStarted(undefined, ['/path/to/workspace-folder1', '/path/to/workspace-folder2']);

			// Assert
			expect(spyOnSaveRepos).toHaveBeenCalledWith({});
			expect(repoManager.getRepos()).toStrictEqual({});
			expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder1');
			expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder2');

			// Teardown
			repoManager.dispose();
		});

		it('Shouldn\'t remove repositories that are within a workspace folder', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();

			// Run
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo']);

			// Assert
			await waitForExpect(() => {
				expect(spyOnRepoRoot).toHaveBeenCalledTimes(2);
				expect(spyOnRepoRoot).toHaveBeenCalledWith('/path/to/workspace-folder1/repo');
				expect(spyOnRepoRoot).toHaveBeenCalledWith('/path/to/workspace-folder1');
				expect(repoManager.getRepos()).toStrictEqual({
					'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
				});
			});

			// Teardown
			repoManager.dispose();
		});

		it('Shouldn\'t remove repositories that contain a workspace folder', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();

			// Run
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to']);

			// Assert
			expect(spyOnRepoRoot).toHaveBeenCalledTimes(1);
			expect(spyOnRepoRoot).toHaveBeenCalledWith('/path/to');
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to': mockRepoState({ workspaceFolderIndex: 0 })
			});

			// Teardown
			repoManager.dispose();
		});
	});

	describe('registerRepo', () => {
		it('Should register a new repository', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1', '/path/to/workspace-folder2'], []);

			mockRepositoryWithNoSubmodules();
			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			const result = await repoManager.registerRepo('/path/to/workspace-folder2/repo', false);

			// Assert
			expect(spyOnRepoRoot).toHaveBeenCalledWith('/path/to/workspace-folder2/repo');
			expect(result).toStrictEqual({
				root: '/path/to/workspace-folder2/repo',
				error: null
			});
			expect(spyOnLog).toHaveBeenCalledWith('Added new repo: /path/to/workspace-folder2/repo');
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder2/repo': mockRepoState({ workspaceFolderIndex: 1 })
					},
					numRepos: 1,
					loadRepo: null
				}
			]);
			expect(spyOnReadFile).toHaveBeenCalledTimes(1);
			expect(utils.getPathFromStr(spyOnReadFile.mock.calls[0][0])).toStrictEqual('/path/to/workspace-folder2/repo/.vscode/vscode-git-graph.json');

			// Teardown
			repoManager.dispose();
		});

		it('Should register a new repository (loading it upon registration)', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);

			mockRepositoryWithNoSubmodules();

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			const result = await repoManager.registerRepo('/path/to/workspace-folder1/repo', true);

			// Assert
			expect(spyOnRepoRoot).toHaveBeenCalledWith('/path/to/workspace-folder1/repo');
			expect(result).toStrictEqual({
				root: '/path/to/workspace-folder1/repo',
				error: null
			});
			expect(spyOnLog).toHaveBeenCalledWith('Added new repo: /path/to/workspace-folder1/repo');
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
					},
					numRepos: 1,
					loadRepo: '/path/to/workspace-folder1/repo'
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should register a new repository (removing it from the ignored repositories)', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], [], ['/path/to/workspace-folder1/repo']);

			mockRepositoryWithNoSubmodules();

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			const result = await repoManager.registerRepo('/path/to/workspace-folder1/repo', true);

			// Assert
			expect(spyOnRepoRoot).toHaveBeenCalledWith('/path/to/workspace-folder1/repo');
			expect(result).toStrictEqual({
				root: '/path/to/workspace-folder1/repo',
				error: null
			});
			expect(spyOnSetIgnoredRepos).toHaveBeenCalledWith([]);
			expect(spyOnLog).toHaveBeenCalledWith('Added new repo: /path/to/workspace-folder1/repo');
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
					},
					numRepos: 1,
					loadRepo: '/path/to/workspace-folder1/repo'
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should register a new repository (should only update the workspaceFolderIndex for the repository that was added)', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1', '/path/to/workspace-folder2'], ['/path/to/workspace-folder1']);
			repoManager['repos']['/path/to/workspace-folder1'].workspaceFolderIndex = null;

			mockRepositoryWithNoSubmodules();
			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			await repoManager.registerRepo('/path/to/workspace-folder2/repo', false);

			// Assert
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: null }),
						'/path/to/workspace-folder2/repo': mockRepoState({ workspaceFolderIndex: 1 })
					},
					numRepos: 2,
					loadRepo: null
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should return an error message when the path being registered is not a Git repository', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);

			mockDirectoryThatsNotRepository();

			// Run
			const result = await repoManager.registerRepo('/path/to/workspace-folder1', false);

			// Assert
			expect(spyOnRepoRoot).toHaveBeenCalledWith('/path/to/workspace-folder1');
			expect(result).toStrictEqual({
				root: null,
				error: 'The folder "/path/to/workspace-folder1" is not a Git repository.'
			});

			// Teardown
			repoManager.dispose();
		});

		it('Should return an error message when the path being registered is contained within a known Git repository', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1']);

			spyOnRepoRoot.mockResolvedValueOnce('/path/to/workspace-folder1');

			// Run
			const result = await repoManager.registerRepo('/path/to/workspace-folder1/subdirectory', false);

			// Assert
			expect(spyOnRepoRoot).toHaveBeenCalledWith('/path/to/workspace-folder1/subdirectory');
			expect(result).toStrictEqual({
				root: null,
				error: 'The folder "/path/to/workspace-folder1/subdirectory" is contained within the known repository "/path/to/workspace-folder1".'
			});

			// Teardown
			repoManager.dispose();
		});
	});

	describe('ignoreRepo', () => {
		it('Should ignore the repository and return TRUE, when the repository is known', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1']);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			const result = repoManager.ignoreRepo('/path/to/workspace-folder1');

			// Assert
			expect(result).toBe(true);
			expect(spyOnSetIgnoredRepos).toHaveBeenCalledWith(['/path/to/workspace-folder1']);
			expect(repoManager.getRepos()).toStrictEqual({});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {},
					numRepos: 0,
					loadRepo: null
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should ignore the repository and return TRUE, when the repository is known (without creating duplicates in the list of ignored repositories)', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1'], ['/path/to/workspace-folder1']);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			const result = repoManager.ignoreRepo('/path/to/workspace-folder1');

			// Assert
			expect(result).toBe(true);
			expect(spyOnSetIgnoredRepos).toHaveBeenCalledWith(['/path/to/workspace-folder1']);
			expect(repoManager.getRepos()).toStrictEqual({});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {},
					numRepos: 0,
					loadRepo: null
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should return FALSE, when the repository is unknown', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);

			// Run
			const result = repoManager.ignoreRepo('/path/to/workspace-folder1');

			// Assert
			expect(result).toBe(false);

			// Teardown
			repoManager.dispose();
		});
	});

	describe('getRepos', () => {
		it('Should get the set of repositories', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo2', '/path/to/workspace-folder1/repo1']
			);

			// Run
			const result = repoManager.getRepos();

			// Assert
			expect(result).toStrictEqual({
				'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder1/repo2': mockRepoState({ workspaceFolderIndex: 0 })
			});

			// Teardown
			repoManager.dispose();
		});
	});

	describe('getNumRepos', () => {
		it('Should get the number of repositories', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo2', '/path/to/workspace-folder1/repo1']
			);

			// Run
			const result = repoManager.getNumRepos();

			// Assert
			expect(result).toStrictEqual(2);

			// Teardown
			repoManager.dispose();
		});
	});

	describe('getRepoContainingFile', () => {
		it('Should return the path of the repository that contains the file', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo2']
			);

			// Run
			const result = repoManager.getRepoContainingFile('/path/to/workspace-folder1/repo2/file.txt');

			// Assert
			expect(result).toBe('/path/to/workspace-folder1/repo2');

			// Teardown
			repoManager.dispose();
		});

		it('Should return the path of the closest repository that contains the file', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo1/subrepo']
			);

			// Run
			const result = repoManager.getRepoContainingFile('/path/to/workspace-folder1/repo1/subrepo/file.txt');

			// Assert
			expect(result).toBe('/path/to/workspace-folder1/repo1/subrepo');

			// Teardown
			repoManager.dispose();
		});
	});

	describe('getKnownRepo', () => {
		it('Should return the path of the repository matching the specified path', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo2']
			);

			// Run
			const result = await repoManager.getKnownRepo('/path/to/workspace-folder1/repo1');

			// Assert
			expect(result).toBe('/path/to/workspace-folder1/repo1');

			// Teardown
			repoManager.dispose();
		});

		it('Should return the path of the repository matching the specified path (resolving symbolic path components)', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/sym-repo1', '/path/to/workspace-folder1/sym-repo2']
			);

			const spyOnRealPath = jest.spyOn(utils, 'realpath');
			spyOnRealPath.mockResolvedValueOnce('/path/to/workspace-folder1/repo2');
			spyOnRealPath.mockResolvedValueOnce('/path/to/workspace-folder1/repo1');
			spyOnRealPath.mockResolvedValueOnce('/path/to/workspace-folder1/repo2');

			// Run
			const result = await repoManager.getKnownRepo('/path/to/workspace-folder1/repo2');

			// Assert
			expect(result).toBe('/path/to/workspace-folder1/sym-repo2');

			// Teardown
			repoManager.dispose();
		});

		it('Should return NULL if no repository matches the specified path', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo2']
			);

			const spyOnRealPath = jest.spyOn(utils, 'realpath');
			spyOnRealPath.mockResolvedValueOnce('/path/to/workspace-folder1/repo3');
			spyOnRealPath.mockResolvedValueOnce('/path/to/workspace-folder1/repo1');
			spyOnRealPath.mockResolvedValueOnce('/path/to/workspace-folder1/repo2');

			// Run
			const result = await repoManager.getKnownRepo('/path/to/workspace-folder1/repo3');

			// Assert
			expect(result).toBe(null);

			// Teardown
			repoManager.dispose();
		});
	});

	describe('isKnownRepo', () => {
		it('Should return TRUE when the repository is known', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo']);

			// Run
			const result = repoManager.isKnownRepo('/path/to/workspace-folder1/repo');

			// Assert
			expect(result).toBe(true);

			// Teardown
			repoManager.dispose();
		});

		it('Should return FALSE when the repository is not known', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo']);

			// Run
			const result = repoManager.isKnownRepo('/path/to/workspace-folder1/other-repo');

			// Assert
			expect(result).toBe(false);

			// Teardown
			repoManager.dispose();
		});
	});

	describe('checkReposExist', () => {
		it('Should remove any repositories that no longer exist', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo2']
			);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockRepository();
			mockDirectoryThatsNotRepository();

			// Run
			const result = await repoManager.checkReposExist();

			// Assert
			expect(result).toBe(true);
			expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder1/repo2');
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 })
					},
					numRepos: 1,
					loadRepo: null
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should transfer any repository state if the path to the repository changes', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1', '/path/to/workspace-folder2'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo2']
			);

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder1/repo2': mockRepoState({ workspaceFolderIndex: 0 })
			});

			// Setup
			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockRepository();
			mockRepository((path) => path.replace('workspace-folder1', 'workspace-folder2'));

			// Run
			const result = await repoManager.checkReposExist();

			// Assert
			expect(result).toBe(true);
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder2/repo2': mockRepoState({ workspaceFolderIndex: 1 })
			});
			expect(spyOnSaveRepos).toHaveBeenCalledWith({
				'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder2/repo2': mockRepoState({ workspaceFolderIndex: 1 })
			});
			expect(spyOnTransferRepo).toHaveBeenCalledWith('/path/to/workspace-folder1/repo2', '/path/to/workspace-folder2/repo2');
			expect(spyOnLog).toHaveBeenCalledWith('Transferred repo state: /path/to/workspace-folder1/repo2 -> /path/to/workspace-folder2/repo2');
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 }),
						'/path/to/workspace-folder2/repo2': mockRepoState({ workspaceFolderIndex: 1 })
					},
					numRepos: 2,
					loadRepo: null
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should return FALSE when no changes are made (all repositories still exist)', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo2']
			);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockRepository();
			mockRepository();

			// Run
			const result = await repoManager.checkReposExist();

			// Assert
			expect(result).toBe(false);
			expect(spyOnLog).not.toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder1/repo2');
			expect(onDidChangeReposEvents).toHaveLength(0);

			// Teardown
			repoManager.dispose();
		});

		it('Should return gracefully when an exception occurs', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1', '/path/to/workspace-folder2'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo2', '/path/to/workspace-folder1/repo3']
			);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockRepository((path) => path.replace('workspace-folder1', 'workspace-folder2'));
			mockRepository((path) => path.replace('workspace-folder1', 'workspace-folder2'));
			mockRepository((path) => path.replace('workspace-folder1', 'workspace-folder2'));
			spyOnTransferRepo.mockImplementationOnce(() => { });
			spyOnTransferRepo.mockImplementationOnce(() => { throw new Error(); });

			// Run
			const result = await repoManager.checkReposExist();

			// Assert
			expect(result).toBe(true);
			expect(spyOnSaveRepos).toHaveBeenCalledWith({
				'/path/to/workspace-folder2/repo1': mockRepoState({ workspaceFolderIndex: 1 }),
				'/path/to/workspace-folder2/repo2': mockRepoState({ workspaceFolderIndex: 1 }),
				'/path/to/workspace-folder1/repo3': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder2/repo1': mockRepoState({ workspaceFolderIndex: 1 }),
						'/path/to/workspace-folder2/repo2': mockRepoState({ workspaceFolderIndex: 1 }),
						'/path/to/workspace-folder1/repo3': mockRepoState({ workspaceFolderIndex: 0 })
					},
					numRepos: 3,
					loadRepo: null
				}
			]);

			// Teardown
			repoManager.dispose();
		});
	});

	describe('setRepoState', () => {
		it('Should set the state of the repository', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo2']
			);

			const newRepoState = {
				cdvDivider: 0.75,
				cdvHeight: 300,
				columnWidths: null,
				commitOrdering: RepoCommitOrdering.Default,
				fileViewType: FileViewType.Default,
				hideRemotes: [],
				includeCommitsMentionedByReflogs: BooleanOverride.Default,
				issueLinkingConfig: null,
				lastImportAt: 0,
				name: null,
				onlyFollowFirstParent: BooleanOverride.Default,
				onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
				onRepoLoadShowSpecificBranches: null,
				pullRequestConfig: null,
				showRemoteBranches: true,
				showRemoteBranchesV2: BooleanOverride.Default,
				showStashes: BooleanOverride.Default,
				showTags: BooleanOverride.Default,
				workspaceFolderIndex: 0
			};

			// Run
			repoManager.setRepoState('/path/to/workspace-folder1/repo2', newRepoState);

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder1/repo2': newRepoState
			});
			expect(spyOnSaveRepos).toHaveBeenCalledWith({
				'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder1/repo2': newRepoState
			});

			// Teardown
			repoManager.dispose();
		});
	});

	describe('searchWorkspaceForRepos', () => {
		it('Should add repositories that are detected in the workspace', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockRepositoryWithNoSubmodules();

			// Run
			const result = await repoManager.searchWorkspaceForRepos();

			// Assert
			expect(result).toBe(true);
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1': mockRepoState({ workspaceFolderIndex: 0 })
					},
					numRepos: 1,
					loadRepo: null
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should add repositories that are detected in subfolders of the workspace', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockDirectoryThatsNotRepository();
			mockFsReaddirOnce(null, ['repo', '.git', 'file.txt']);
			mockFsStatOnce(null, true);
			mockFsStatOnce(null, false);
			mockRepositoryWithNoSubmodules();

			// Run
			vscode.mockExtensionSettingReturnValue('maxDepthOfRepoSearch', 1);
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.maxDepthOfRepoSearch'
			});
			await waitForExpect(() => expect(spyOnLog).toHaveBeenCalledWith('Added new repo: /path/to/workspace-folder1/repo'));

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
					},
					numRepos: 1,
					loadRepo: null
				}
			]);
			expect(spyOnReaddir).toHaveBeenCalledTimes(1);
			expect(spyOnReaddir).toHaveBeenCalledWith('/path/to/workspace-folder1', expect.anything());
			expect(spyOnStat).toHaveBeenCalledTimes(2);
			expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/repo', expect.anything());
			expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/file.txt', expect.anything());

			// Teardown
			repoManager.dispose();
		});

		it('Should halt recursion when fs.readdir returns an error', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockDirectoryThatsNotRepository();
			mockFsReaddirOnce(new Error(), []);
			spyOnLog.mockClear();

			// Run
			vscode.mockExtensionSettingReturnValue('maxDepthOfRepoSearch', 1);
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.maxDepthOfRepoSearch'
			});
			await waitForExpect(() => expect(spyOnLog).toHaveBeenCalledWith('Completed searching workspace for new repos'));

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({});
			expect(onDidChangeReposEvents).toStrictEqual([]);
			expect(spyOnReaddir).toHaveBeenCalledTimes(1);
			expect(spyOnReaddir).toHaveBeenCalledWith('/path/to/workspace-folder1', expect.anything());
			expect(spyOnStat).toHaveBeenCalledTimes(0);

			// Teardown
			repoManager.dispose();
		});

		it('Should halt recursion when fs.stat returns an error', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			mockDirectoryThatsNotRepository();
			mockFsReaddirOnce(null, ['repo', '.git', 'file.txt']);
			mockFsStatOnce(new Error(), true);
			mockFsStatOnce(null, false);
			spyOnLog.mockClear();

			// Run
			vscode.mockExtensionSettingReturnValue('maxDepthOfRepoSearch', 1);
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.maxDepthOfRepoSearch'
			});
			await waitForExpect(() => expect(spyOnLog).toHaveBeenCalledWith('Completed searching workspace for new repos'));

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({});
			expect(onDidChangeReposEvents).toStrictEqual([]);
			expect(spyOnReaddir).toHaveBeenCalledTimes(1);
			expect(spyOnReaddir).toHaveBeenCalledWith('/path/to/workspace-folder1', expect.anything());
			expect(spyOnStat).toHaveBeenCalledTimes(2);
			expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/repo', expect.anything());
			expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/file.txt', expect.anything());

			// Teardown
			repoManager.dispose();
		});

		it('Should halt recursion when repoRoot call rejects', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);

			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));
			spyOnRepoRoot.mockRejectedValueOnce(null);
			spyOnLog.mockClear();

			// Run
			vscode.mockExtensionSettingReturnValue('maxDepthOfRepoSearch', 1);
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.maxDepthOfRepoSearch'
			});
			await waitForExpect(() => expect(spyOnLog).toHaveBeenCalledWith('Completed searching workspace for new repos'));

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({});
			expect(onDidChangeReposEvents).toStrictEqual([]);
			expect(spyOnReaddir).toHaveBeenCalledTimes(0);
			expect(spyOnStat).toHaveBeenCalledTimes(0);

			// Teardown
			repoManager.dispose();
		});
	});

	describe('checkReposForNewSubmodules', () => {
		it('Should add any new submodules', async () => {
			// Setup
			mockRepositoryWithSubmodules(['/path/to/workspace-folder1/repo/submodule1', '/path/to/workspace-folder1/repo/submodule2']);
			mockRepositoryWithNoSubmodules();
			spyOnGetSubmodules.mockResolvedValueOnce([]);
			mockDirectoryThatsNotRepository();

			// Run
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo', '/path/to/workspace-folder1/repo/submodule1']
			);

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder1/repo/submodule1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder1/repo/submodule2': mockRepoState({ workspaceFolderIndex: 0 })
			});

			// Teardown
			repoManager.dispose();
		});

		it('Shouldn\'t add any submodules that are already known', async () => {
			// Setup
			mockRepositoryWithSubmodules(['/path/to/workspace-folder1/repo/submodule1', '/path/to/workspace-folder1/repo/submodule2']);
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();

			// Run
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo', '/path/to/workspace-folder1/repo/submodule1', '/path/to/workspace-folder1/repo/submodule2']
			);

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder1/repo/submodule1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder1/repo/submodule2': mockRepoState({ workspaceFolderIndex: 0 })
			});

			// Teardown
			repoManager.dispose();
		});

		it('Shouldn\'t add any submodules that have been ignored', async () => {
			// Setup
			mockRepositoryWithSubmodules(['/path/to/workspace-folder1/repo/submodule1', '/path/to/workspace-folder1/repo/submodule2']);
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();

			// Run
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo', '/path/to/workspace-folder1/repo/submodule1'], ['/path/to/workspace-folder1/repo/submodule2']);

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder1/repo/submodule1': mockRepoState({ workspaceFolderIndex: 0 })
			});

			// Teardown
			repoManager.dispose();
		});
	});

	describe('onWatcherCreate', () => {
		let repoManager: RepoManager;
		let emitOnDidCreate: (e: vscode.Uri) => any;
		let onDidChangeReposEvents: RepoChangeEvent[];
		let spyOnEnqueue: jest.SpyInstance;

		beforeEach(async () => {
			mockDirectoryThatsNotRepository();
			repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);
			emitOnDidCreate = (<jest.Mock<any, any>>repoManager['folderWatchers']['/path/to/workspace-folder1'].onDidCreate).mock.calls[0][0];
			onDidChangeReposEvents = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			spyOnEnqueue = jest.spyOn(repoManager['onWatcherCreateQueue'], 'enqueue');
		});

		afterEach(() => {
			repoManager.dispose();
		});

		it('Should add a repository when a repository is added', async () => {
			// Setup
			mockFsStatOnce(null, true);
			mockRepositoryWithNoSubmodules();

			// Run
			emitOnDidCreate(vscode.Uri.file('/path/to/workspace-folder1/repo'));

			// Assert
			expect(spyOnEnqueue).toHaveBeenCalledWith('/path/to/workspace-folder1/repo');
			await waitForExpect(() => {
				expect(repoManager['onWatcherCreateQueue']['queue']).toStrictEqual([]);
				expect(repoManager['onWatcherCreateQueue']['processing']).toBe(false);
				expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/repo', expect.anything());
				expect(spyOnLog).toHaveBeenCalledWith('Added new repo: /path/to/workspace-folder1/repo');
				expect(repoManager.getRepos()).toStrictEqual({
					'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
				});
				expect(onDidChangeReposEvents).toStrictEqual([
					{
						repos: {
							'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
						},
						numRepos: 1,
						loadRepo: null
					}
				]);
			});
		});

		it('Should add a repository when a .git directory is added', async () => {
			// Setup
			mockFsStatOnce(null, true);
			mockRepositoryWithNoSubmodules();

			// Run
			emitOnDidCreate(vscode.Uri.file('/path/to/workspace-folder1/repo/.git'));

			// Assert
			expect(spyOnEnqueue).toHaveBeenCalledWith('/path/to/workspace-folder1/repo');
			await waitForExpect(() => {
				expect(repoManager['onWatcherCreateQueue']['queue']).toStrictEqual([]);
				expect(repoManager['onWatcherCreateQueue']['processing']).toBe(false);
				expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/repo', expect.anything());
				expect(spyOnLog).toHaveBeenCalledWith('Added new repo: /path/to/workspace-folder1/repo');
				expect(repoManager.getRepos()).toStrictEqual({
					'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
				});
				expect(onDidChangeReposEvents).toStrictEqual([
					{
						repos: {
							'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
						},
						numRepos: 1,
						loadRepo: null
					}
				]);
			});
		});

		it('Should not proceed to add repositories when the directory added is within .git', () => {
			// Run
			emitOnDidCreate(vscode.Uri.file('/path/to/workspace-folder1/repo/.git/folder'));

			// Assert
			expect(spyOnEnqueue).not.toHaveBeenCalled();
		});

		it('Shouldn\'t add a repository when a file is added', async () => {
			// Setup
			mockFsStatOnce(null, false);

			// Run
			emitOnDidCreate(vscode.Uri.file('/path/to/workspace-folder1/repo'));

			// Assert
			expect(spyOnEnqueue).toHaveBeenCalledWith('/path/to/workspace-folder1/repo');
			await waitForExpect(() => {
				expect(repoManager['onWatcherCreateQueue']['queue']).toStrictEqual([]);
				expect(repoManager['onWatcherCreateQueue']['processing']).toBe(false);
				expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/repo', expect.anything());
				expect(repoManager.getRepos()).toStrictEqual({});
				expect(onDidChangeReposEvents).toStrictEqual([]);
			});
		});

		it('Shouldn\'t add a repository when a directory is added, but it doesn\'t contain any repositories', async () => {
			// Setup
			mockFsStatOnce(null, true);
			mockDirectoryThatsNotRepository();

			// Run
			emitOnDidCreate(vscode.Uri.file('/path/to/workspace-folder1/repo'));

			// Assert
			expect(spyOnEnqueue).toHaveBeenCalledWith('/path/to/workspace-folder1/repo');
			await waitForExpect(() => {
				expect(repoManager['onWatcherCreateQueue']['queue']).toStrictEqual([]);
				expect(repoManager['onWatcherCreateQueue']['processing']).toBe(false);
				expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/repo', expect.anything());
				expect(repoManager.getRepos()).toStrictEqual({});
				expect(onDidChangeReposEvents).toStrictEqual([]);
			});
		});
	});

	describe('onWatcherChange', () => {
		let repoManager: RepoManager;
		let emitOnDidChange: (e: vscode.Uri) => any;
		let onDidChangeReposEvents: RepoChangeEvent[];
		let spyOnEnqueue: jest.SpyInstance;

		beforeEach(async () => {
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo']);

			emitOnDidChange = (<jest.Mock<any, any>>repoManager['folderWatchers']['/path/to/workspace-folder1'].onDidChange).mock.calls[0][0];
			onDidChangeReposEvents = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			spyOnEnqueue = jest.spyOn(repoManager['onWatcherChangeQueue'], 'enqueue');
		});

		afterEach(() => {
			repoManager.dispose();
		});

		it('Should remove a repository when a repository is deleted', async () => {
			// Setup
			mockFsStatOnce(new Error(), true);

			// Run
			emitOnDidChange(vscode.Uri.file('/path/to/workspace-folder1/repo'));

			// Assert
			expect(spyOnEnqueue).toHaveBeenCalledWith('/path/to/workspace-folder1/repo');
			await waitForExpect(() => {
				expect(repoManager['onWatcherChangeQueue']['queue']).toStrictEqual([]);
				expect(repoManager['onWatcherChangeQueue']['processing']).toBe(false);
				expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/repo', expect.anything());
				expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder1/repo');
				expect(repoManager.getRepos()).toStrictEqual({});
				expect(onDidChangeReposEvents).toStrictEqual([
					{
						repos: {},
						numRepos: 0,
						loadRepo: null
					}
				]);
			});
		});

		it('Should remove a repository when a .git directory is deleted', async () => {
			// Setup
			mockFsStatOnce(new Error(), true);

			// Run
			emitOnDidChange(vscode.Uri.file('/path/to/workspace-folder1/repo/.git'));

			// Assert
			expect(spyOnEnqueue).toHaveBeenCalledWith('/path/to/workspace-folder1/repo');
			await waitForExpect(() => {
				expect(repoManager['onWatcherChangeQueue']['queue']).toStrictEqual([]);
				expect(repoManager['onWatcherChangeQueue']['processing']).toBe(false);
				expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/repo', expect.anything());
				expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder1/repo');
				expect(repoManager.getRepos()).toStrictEqual({});
				expect(onDidChangeReposEvents).toStrictEqual([
					{
						repos: {},
						numRepos: 0,
						loadRepo: null
					}
				]);
			});
		});

		it('Should not proceed to remove a repository when the directory removed is within .git', () => {
			// Run
			emitOnDidChange(vscode.Uri.file('/path/to/workspace-folder1/repo/.git/folder'));

			// Assert
			expect(spyOnEnqueue).not.toHaveBeenCalled();
		});

		it('Shouldn\'t remove a repository when a repository isn\'t deleted', async () => {
			// Setup
			mockFsStatOnce(null, true);

			// Run
			emitOnDidChange(vscode.Uri.file('/path/to/workspace-folder1/repo'));

			// Assert
			expect(spyOnEnqueue).toHaveBeenCalledWith('/path/to/workspace-folder1/repo');
			await waitForExpect(() => {
				expect(repoManager['onWatcherChangeQueue']['queue']).toStrictEqual([]);
				expect(repoManager['onWatcherChangeQueue']['processing']).toBe(false);
				expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/repo', expect.anything());
				expect(repoManager.getRepos()).toStrictEqual({
					'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
				});
				expect(onDidChangeReposEvents).toStrictEqual([]);
			});
		});

		it('Shouldn\'t remove a repository when a directory is removed, but it doesn\'t contain any repositories', async () => {
			// Setup
			mockFsStatOnce(new Error(), true);

			// Run
			emitOnDidChange(vscode.Uri.file('/path/to/workspace-folder1/dir/repo'));

			// Assert
			expect(spyOnEnqueue).toHaveBeenCalledWith('/path/to/workspace-folder1/dir/repo');
			await waitForExpect(() => {
				expect(repoManager['onWatcherChangeQueue']['queue']).toStrictEqual([]);
				expect(repoManager['onWatcherChangeQueue']['processing']).toBe(false);
				expect(spyOnStat).toHaveBeenCalledWith('/path/to/workspace-folder1/dir/repo', expect.anything());
				expect(repoManager.getRepos()).toStrictEqual({
					'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
				});
				expect(onDidChangeReposEvents).toStrictEqual([]);
			});
		});
	});

	describe('onWatcherDelete', () => {
		it('Should delete repositories within a deleted directory', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/dir/repo1', '/path/to/workspace-folder1/dir/repo2', '/path/to/workspace-folder1/repo3']
			);

			const emitOnDidDelete = (<jest.Mock<any, any>>repoManager['folderWatchers']['/path/to/workspace-folder1'].onDidDelete).mock.calls[0][0];
			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			emitOnDidDelete(vscode.Uri.file('/path/to/workspace-folder1/dir'));

			// Assert
			expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder1/dir/repo1');
			expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder1/dir/repo2');
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo3': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1/repo3': mockRepoState({ workspaceFolderIndex: 0 })
					},
					numRepos: 1,
					loadRepo: null
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should delete repositories within a deleted repository', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo1', '/path/to/workspace-folder1/repo1/submodule', '/path/to/workspace-folder1/repo2']
			);

			const emitOnDidDelete = (<jest.Mock<any, any>>repoManager['folderWatchers']['/path/to/workspace-folder1'].onDidDelete).mock.calls[0][0];
			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			emitOnDidDelete(vscode.Uri.file('/path/to/workspace-folder1/repo1/.git'));

			// Assert
			expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder1/repo1');
			expect(spyOnLog).toHaveBeenCalledWith('Removed repo: /path/to/workspace-folder1/repo1/submodule');
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo2': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([
				{
					repos: {
						'/path/to/workspace-folder1/repo2': mockRepoState({ workspaceFolderIndex: 0 })
					},
					numRepos: 1,
					loadRepo: null
				}
			]);

			// Teardown
			repoManager.dispose();
		});

		it('Should not proceed to remove repositories if the deleted URI is within .git', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/dir/repo1', '/path/to/workspace-folder1/dir/repo1/.git/folder/repo'] // Not realistic, this is used to observe the control flow for this test case
			);

			const emitOnDidDelete = (<jest.Mock<any, any>>repoManager['folderWatchers']['/path/to/workspace-folder1'].onDidDelete).mock.calls[0][0];
			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			emitOnDidDelete(vscode.Uri.file('/path/to/workspace-folder1/dir/repo1/.git/folder'));

			// Assert
			expect(spyOnLog).not.toHaveBeenCalledWith('/path/to/workspace-folder1/dir/repo1/.git/folder/repo');
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/dir/repo1': mockRepoState({ workspaceFolderIndex: 0 }),
				'/path/to/workspace-folder1/dir/repo1/.git/folder/repo': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([]);

			// Teardown
			repoManager.dispose();
		});

		it('Should not remove any repository if the deleted directory doesn\'t contain any repositories', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);

			const emitOnDidDelete = (<jest.Mock<any, any>>repoManager['folderWatchers']['/path/to/workspace-folder1'].onDidDelete).mock.calls[0][0];
			const onDidChangeReposEvents: RepoChangeEvent[] = [];
			repoManager.onDidChangeRepos((event) => onDidChangeReposEvents.push(event));

			// Run
			emitOnDidDelete(vscode.Uri.file('/path/to/workspace-folder1/dir'));

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo1': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(onDidChangeReposEvents).toStrictEqual([]);

			// Teardown
			repoManager.dispose();
		});
	});

	describe('checkRepoForNewConfig', () => {
		describe('apply config', () => {
			const testApplyField = <K extends keyof GitRepoState, L extends keyof ExternalRepoConfig.File>(stateKey: K, stateValue: GitRepoState[K], fileKey: L, fileValue: ExternalRepoConfig.File[L]) => async () => {
				// Setup
				mockDirectoryThatsNotRepository();
				const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);
				mockRepositoryWithNoSubmodules();
				const file: ExternalRepoConfig.File = {
					exportedAt: 1587559258000
				};
				file[fileKey] = fileValue;
				mockFsReadFileOnce(null, file);

				// Run
				await repoManager.registerRepo('/path/to/workspace-folder1/repo', false);

				// Assert
				const expected: GitRepoSet = {
					'/path/to/workspace-folder1/repo': {
						cdvDivider: 0.5,
						cdvHeight: 250,
						columnWidths: null,
						commitOrdering: RepoCommitOrdering.Default,
						fileViewType: FileViewType.Default,
						hideRemotes: [],
						includeCommitsMentionedByReflogs: BooleanOverride.Default,
						issueLinkingConfig: null,
						lastImportAt: 1587559258000,
						name: null,
						onlyFollowFirstParent: BooleanOverride.Default,
						onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
						onRepoLoadShowSpecificBranches: null,
						pullRequestConfig: null,
						showRemoteBranches: true,
						showRemoteBranchesV2: BooleanOverride.Default,
						showStashes: BooleanOverride.Default,
						showTags: BooleanOverride.Default,
						workspaceFolderIndex: 0
					}
				};
				expected['/path/to/workspace-folder1/repo'][stateKey] = stateValue;
				expect(repoManager.getRepos()).toStrictEqual(expected);
				expect(spyOnSaveRepos).toHaveBeenCalledWith(expected);
				expect(vscode.window.showInformationMessage).toHaveBeenCalledTimes(0);

				// Teardown
				repoManager.dispose();
			};

			describe('commitOrdering', () => {
				it('Should import RepoCommitOrdering.Date correctly', testApplyField('commitOrdering', RepoCommitOrdering.Date, 'commitOrdering', RepoCommitOrdering.Date));
				it('Should import RepoCommitOrdering.AuthorDate correctly', testApplyField('commitOrdering', RepoCommitOrdering.AuthorDate, 'commitOrdering', RepoCommitOrdering.AuthorDate));
				it('Should import RepoCommitOrdering.Topological correctly', testApplyField('commitOrdering', RepoCommitOrdering.Topological, 'commitOrdering', RepoCommitOrdering.Topological));
			});

			describe('fileViewType', () => {
				it('Should import FileViewType.Tree correctly', testApplyField('fileViewType', FileViewType.Tree, 'fileViewType', ExternalRepoConfig.FileViewType.Tree));
				it('Should import FileViewType.List correctly', testApplyField('fileViewType', FileViewType.List, 'fileViewType', ExternalRepoConfig.FileViewType.List));
			});

			describe('hideRemotes', () => {
				it('Should import hideRemotes correctly', testApplyField('hideRemotes', ['origin'], 'hideRemotes', ['origin']));
			});

			describe('includeCommitsMentionedByReflogs', () => {
				it('Should import BooleanOverride.Enabled correctly', testApplyField('includeCommitsMentionedByReflogs', BooleanOverride.Enabled, 'includeCommitsMentionedByReflogs', true));
				it('Should import BooleanOverride.Disabled correctly', testApplyField('includeCommitsMentionedByReflogs', BooleanOverride.Disabled, 'includeCommitsMentionedByReflogs', false));
			});

			describe('issueLinkingConfig', () => {
				it('Should import issueLinkingConfig correctly', testApplyField('issueLinkingConfig', { issue: 'x', url: 'y' }, 'issueLinkingConfig', { issue: 'x', url: 'y' }));
			});

			describe('name', () => {
				it('Should import name correctly', testApplyField('name', 'Name', 'name', 'Name'));
			});

			describe('onlyFollowFirstParent', () => {
				it('Should import BooleanOverride.Enabled correctly', testApplyField('onlyFollowFirstParent', BooleanOverride.Enabled, 'onlyFollowFirstParent', true));
				it('Should import BooleanOverride.Disabled correctly', testApplyField('onlyFollowFirstParent', BooleanOverride.Disabled, 'onlyFollowFirstParent', false));
			});

			describe('onRepoLoadShowCheckedOutBranch', () => {
				it('Should import BooleanOverride.Enabled correctly', testApplyField('onRepoLoadShowCheckedOutBranch', BooleanOverride.Enabled, 'onRepoLoadShowCheckedOutBranch', true));
				it('Should import BooleanOverride.Disabled correctly', testApplyField('onRepoLoadShowCheckedOutBranch', BooleanOverride.Disabled, 'onRepoLoadShowCheckedOutBranch', false));
			});

			describe('onRepoLoadShowSpecificBranches', () => {
				it('Should import onRepoLoadShowSpecificBranches correctly', testApplyField('onRepoLoadShowSpecificBranches', ['master'], 'onRepoLoadShowSpecificBranches', ['master']));
			});

			describe('pullRequestConfig', () => {
				it('Should import a Bitbucket config correctly', testApplyField(
					'pullRequestConfig', { provider: PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' },
					'pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' }
				));

				it('Should import a Custom config correctly', testApplyField(
					'pullRequestConfig', { provider: PullRequestProvider.Custom, custom: { name: 'Name', templateUrl: '$1/$2/$3/$4/$5/$6/$8' }, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' },
					'pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Custom, custom: { name: 'Name', templateUrl: '$1/$2/$3/$4/$5/$6/$8' }, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' }
				));

				it('Should import a GitHub config correctly', testApplyField(
					'pullRequestConfig', { provider: PullRequestProvider.GitHub, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' },
					'pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.GitHub, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' }
				));

				it('Should import a GitLab config correctly', testApplyField(
					'pullRequestConfig', { provider: PullRequestProvider.GitLab, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' },
					'pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.GitLab, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' }
				));

				it('Should import a GitHub config with no destination remote correctly', testApplyField(
					'pullRequestConfig', { provider: PullRequestProvider.GitHub, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: null, destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' },
					'pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.GitHub, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: null, destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' }
				));
			});

			describe('showRemoteBranches', () => {
				it('Should import BooleanOverride.Enabled correctly', testApplyField('showRemoteBranchesV2', BooleanOverride.Enabled, 'showRemoteBranches', true));
				it('Should import BooleanOverride.Disabled correctly', testApplyField('showRemoteBranchesV2', BooleanOverride.Disabled, 'showRemoteBranches', false));
			});

			describe('showStashes', () => {
				it('Should import BooleanOverride.Enabled correctly', testApplyField('showStashes', BooleanOverride.Enabled, 'showStashes', true));
				it('Should import BooleanOverride.Disabled correctly', testApplyField('showStashes', BooleanOverride.Disabled, 'showStashes', false));
			});

			describe('showTags', () => {
				it('Should import BooleanOverride.Enabled correctly', testApplyField('showTags', BooleanOverride.Enabled, 'showTags', true));
				it('Should import BooleanOverride.Disabled correctly', testApplyField('showTags', BooleanOverride.Disabled, 'showTags', false));
			});
		});

		describe('validation', () => {
			const testValidationOfField = (fileKey: string, fileValue: any) => async () => {
				// Setup
				mockDirectoryThatsNotRepository();
				const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);
				mockRepositoryWithNoSubmodules();
				const file: any = {
					exportedAt: 1587559258000
				};
				file[fileKey] = fileValue;
				mockFsReadFileOnce(null, file);
				vscode.window.showErrorMessage.mockResolvedValueOnce(null);

				// Run
				await repoManager.registerRepo('/path/to/workspace-folder1/repo', false);

				// Assert
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('The value for "' + fileKey + '" in the configuration file "/path/to/workspace-folder1/repo/.vscode/vscode-git-graph.json" is invalid.');

				// Teardown
				repoManager.dispose();
			};

			it('Should display a validation error when "commitOrdering" is invalid', testValidationOfField('commitOrdering', 'invalid'));
			it('Should display a validation error when "fileViewType" is invalid', testValidationOfField('fileViewType', 'invalid'));
			it('Should display a validation error when "hideRemotes" is invalid (not an array)', testValidationOfField('hideRemotes', 'invalid'));
			it('Should display a validation error when "hideRemotes" is invalid (array doesn\'t contain strings)', testValidationOfField('hideRemotes', ['origin', 5]));
			it('Should display a validation error when "includeCommitsMentionedByReflogs" is invalid', testValidationOfField('includeCommitsMentionedByReflogs', 'invalid'));
			it('Should display a validation error when "issueLinkingConfig" is invalid (not an object)', testValidationOfField('issueLinkingConfig', 'invalid'));
			it('Should display a validation error when "issueLinkingConfig" is invalid (null)', testValidationOfField('issueLinkingConfig', null));
			it('Should display a validation error when "issueLinkingConfig" is invalid (no issue)', testValidationOfField('issueLinkingConfig', { url: 'x' }));
			it('Should display a validation error when "issueLinkingConfig" is invalid (no url)', testValidationOfField('issueLinkingConfig', { issue: 'x' }));
			it('Should display a validation error when "name" is invalid', testValidationOfField('name', 5));
			it('Should display a validation error when "onlyFollowFirstParent" is invalid', testValidationOfField('onlyFollowFirstParent', 'invalid'));
			it('Should display a validation error when "onRepoLoadShowCheckedOutBranch" is invalid', testValidationOfField('onRepoLoadShowCheckedOutBranch', 'invalid'));
			it('Should display a validation error when "onRepoLoadShowSpecificBranches" is invalid (not an array)', testValidationOfField('onRepoLoadShowSpecificBranches', 'invalid'));
			it('Should display a validation error when "onRepoLoadShowSpecificBranches" is invalid (array doesn\'t contain strings)', testValidationOfField('onRepoLoadShowSpecificBranches', ['master', 5]));
			it('Should display a validation error when "pullRequestConfig" is invalid (not an object)', testValidationOfField('pullRequestConfig', 'invalid'));
			it('Should display a validation error when "pullRequestConfig" is invalid (null)', testValidationOfField('pullRequestConfig', null));
			it('Should display a validation error when "pullRequestConfig" is invalid (unknown provider)', testValidationOfField('pullRequestConfig', { provider: 'invalid' }));
			it('Should display a validation error when "pullRequestConfig" is invalid (no custom provider config)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Custom }));
			it('Should display a validation error when "pullRequestConfig" is invalid (custom provider config is null)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Custom, custom: null }));
			it('Should display a validation error when "pullRequestConfig" is invalid (custom provider config is missing name)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Custom, custom: { templateUrl: 'x' } }));
			it('Should display a validation error when "pullRequestConfig" is invalid (custom provider config is missing templateUrl)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Custom, custom: { name: 'x' } }));
			it('Should display a validation error when "pullRequestConfig" is invalid (no hostRootUrl)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null }));
			it('Should display a validation error when "pullRequestConfig" is invalid (no sourceRemote)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a' }));
			it('Should display a validation error when "pullRequestConfig" is invalid (no sourceOwner)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b' }));
			it('Should display a validation error when "pullRequestConfig" is invalid (no sourceRepo)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c' }));
			it('Should display a validation error when "pullRequestConfig" is invalid (no destRemote)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd' }));
			it('Should display a validation error when "pullRequestConfig" is invalid (no destOwner)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e' }));
			it('Should display a validation error when "pullRequestConfig" is invalid (no destRepo)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: null, destOwner: 'f' }));
			it('Should display a validation error when "pullRequestConfig" is invalid (no destProjectId)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g' }));
			it('Should display a validation error when "pullRequestConfig" is invalid (no destBranch)', testValidationOfField('pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h' }));
			it('Should display a validation error when "showRemoteBranches" is invalid', testValidationOfField('showRemoteBranches', 'invalid'));
			it('Should display a validation error when "showStashes" is invalid', testValidationOfField('showStashes', 'invalid'));
			it('Should display a validation error when "showTags" is invalid', testValidationOfField('showTags', 'invalid'));
		});

		it('Shouldn\'t proceed with processing config if it couldn\'t be parsed', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);
			const spyOnIsKnownRepo = jest.spyOn(repoManager, 'isKnownRepo');
			mockRepositoryWithNoSubmodules();
			mockFsReadFileOnce(null, '{');

			// Run
			await repoManager.registerRepo('/path/to/workspace-folder1/repo', false);

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(spyOnIsKnownRepo).toHaveBeenCalledTimes(1);

			// Teardown
			repoManager.dispose();
		});

		it('Shouldn\'t proceed with processing config if it isn\'t an object', async () => {
			// Setup
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], []);
			const spyOnIsKnownRepo = jest.spyOn(repoManager, 'isKnownRepo');
			mockRepositoryWithNoSubmodules();
			mockFsReadFileOnce(null, 'true');

			// Run
			await repoManager.registerRepo('/path/to/workspace-folder1/repo', false);

			// Assert
			expect(repoManager.getRepos()).toStrictEqual({
				'/path/to/workspace-folder1/repo': mockRepoState({ workspaceFolderIndex: 0 })
			});
			expect(spyOnIsKnownRepo).toHaveBeenCalledTimes(1);

			// Teardown
			repoManager.dispose();
		});
	});

	describe('onConfigWatcherCreateOrChange', () => {
		it('Should import the repository configuration when the file is created', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);
			const emitOnDidCreate = (<jest.Mock<any, any>>repoManager['configWatcher'].onDidCreate).mock.calls[0][0];
			const spyOnBufferedQueueEnqueue = jest.spyOn(repoManager['checkRepoConfigQueue'], 'enqueue');
			mockFsReadFileOnce(null, {
				showTags: true,
				exportedAt: 1587559258000
			});
			vscode.window.showInformationMessage.mockResolvedValueOnce('Yes');
			vscode.window.showInformationMessage.mockResolvedValueOnce(null);

			// Run
			emitOnDidCreate(vscode.Uri.file('/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json'));

			// Assert
			await waitForExpect(() => expect(vscode.window.showInformationMessage).toHaveBeenCalledTimes(2));
			expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('A newer Git Graph Repository Configuration File has been detected for the repository "repo1". Would you like to override your current repository configuration with the new changes?', 'Yes', 'No');
			expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Git Graph Repository Configuration was successfully imported for the repository "repo1".');
			expect(spyOnBufferedQueueEnqueue).toHaveBeenCalledWith('/path/to/workspace-folder1/repo1');
		});

		it('Should import the repository configuration when the file is changed', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);
			repoManager['repos']['/path/to/workspace-folder1/repo1'].name = 'Old Name';
			const emitOnDidChange = (<jest.Mock<any, any>>repoManager['configWatcher'].onDidChange).mock.calls[0][0];
			const spyOnBufferedQueueEnqueue = jest.spyOn(repoManager['checkRepoConfigQueue'], 'enqueue');
			mockFsReadFileOnce(null, {
				name: 'Name',
				exportedAt: 1587559258000
			});
			vscode.window.showInformationMessage.mockResolvedValueOnce('Yes');
			vscode.window.showInformationMessage.mockResolvedValueOnce(null);

			// Run
			emitOnDidChange(vscode.Uri.file('/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json'));

			// Assert
			await waitForExpect(() => expect(vscode.window.showInformationMessage).toHaveBeenCalledTimes(2));
			expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('A newer Git Graph Repository Configuration File has been detected for the repository "Old Name". Would you like to override your current repository configuration with the new changes?', 'Yes', 'No');
			expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Git Graph Repository Configuration was successfully imported for the repository "Name".');
			expect(spyOnBufferedQueueEnqueue).toHaveBeenCalledWith('/path/to/workspace-folder1/repo1');
		});

		it('Shouldn\'t import the repository configuration when user responds "No"', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);
			const emitOnDidChange = (<jest.Mock<any, any>>repoManager['configWatcher'].onDidChange).mock.calls[0][0];
			const spyOnIsKnownRepo = jest.spyOn(repoManager, 'isKnownRepo');
			mockFsReadFileOnce(null, {
				name: 'Name',
				exportedAt: 1587559258000
			});
			vscode.window.showInformationMessage.mockResolvedValueOnce('No');
			spyOnSaveRepos.mockClear();

			// Run
			emitOnDidChange(vscode.Uri.file('/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json'));

			// Assert
			await waitForExpect(() => expect(spyOnIsKnownRepo).toHaveBeenCalledWith('/path/to/workspace-folder1/repo1'));
			const repoState = repoManager.getRepos()['/path/to/workspace-folder1/repo1'];
			expect(repoState.name).toBe(null);
			expect(repoState.lastImportAt).toBe(1587559258000);
			expect(spyOnSaveRepos).toHaveBeenCalledTimes(1);
		});

		it('Shouldn\'t import the repository configuration when user cancels the modal', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);
			const emitOnDidChange = (<jest.Mock<any, any>>repoManager['configWatcher'].onDidChange).mock.calls[0][0];
			const spyOnIsKnownRepo = jest.spyOn(repoManager, 'isKnownRepo');
			mockFsReadFileOnce(null, {
				name: 'Name',
				exportedAt: 1587559258000
			});
			vscode.window.showInformationMessage.mockResolvedValueOnce(undefined);
			spyOnSaveRepos.mockClear();

			// Run
			emitOnDidChange(vscode.Uri.file('/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json'));

			// Assert
			await waitForExpect(() => expect(spyOnIsKnownRepo).toHaveBeenCalledWith('/path/to/workspace-folder1/repo1'));
			expect(spyOnSaveRepos).not.toHaveBeenCalled();
		});

		it('Shouldn\'t import the repository configuration when it is not for a known repository', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);
			repoManager['repos']['/path/to/workspace-folder1/repo1'].name = 'Old Name';
			const emitOnDidChange = (<jest.Mock<any, any>>repoManager['configWatcher'].onDidChange).mock.calls[0][0];
			const spyOnBufferedQueueEnqueue = jest.spyOn(repoManager['checkRepoConfigQueue'], 'enqueue');

			// Run
			emitOnDidChange(vscode.Uri.file('/path/to/workspace-folder1/repo2/.vscode/vscode-git-graph.json'));

			// Assert
			expect(spyOnBufferedQueueEnqueue).not.toHaveBeenCalled();
		});
	});

	describe('exportRepoConfig', () => {
		it('Should export the repository configuration', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			mockWriteExternalConfigFileOnce();
			vscode.window.showInformationMessage.mockResolvedValueOnce(null);
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);
			spyOnSaveRepos.mockClear();

			// Run
			const result = await repoManager.exportRepoConfig('/path/to/workspace-folder1/repo1');

			// Assert
			expect(result).toBe(null);
			expect(utils.getPathFromStr(spyOnMkdir.mock.calls[0][0])).toBe('/path/to/workspace-folder1/repo1/.vscode');
			expect(utils.getPathFromStr(spyOnWriteFile.mock.calls[0][0])).toBe('/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json');
			expect(JSON.parse(spyOnWriteFile.mock.calls[0][1])).toStrictEqual({
				'exportedAt': 1587559258000
			});
			expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Successfully exported the Git Graph Repository Configuration to "/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json".');
			expect(spyOnSaveRepos).toHaveBeenCalledWith({
				'/path/to/workspace-folder1/repo1': {
					cdvDivider: 0.5,
					cdvHeight: 250,
					columnWidths: null,
					commitOrdering: RepoCommitOrdering.Default,
					fileViewType: FileViewType.Default,
					hideRemotes: [],
					includeCommitsMentionedByReflogs: BooleanOverride.Default,
					issueLinkingConfig: null,
					lastImportAt: 1587559258000,
					name: null,
					onlyFollowFirstParent: BooleanOverride.Default,
					onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
					onRepoLoadShowSpecificBranches: null,
					pullRequestConfig: null,
					showRemoteBranches: true,
					showRemoteBranchesV2: BooleanOverride.Default,
					showStashes: BooleanOverride.Default,
					showTags: BooleanOverride.Default,
					workspaceFolderIndex: 0
				}
			});

			// Teardown
			repoManager.dispose();
		});

		it('Should export the repository configuration, but not save the state change if the repository no longer exist', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			mockWriteExternalConfigFileOnce();
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);
			vscode.window.showInformationMessage.mockImplementationOnce(() => {
				delete repoManager['repos']['/path/to/workspace-folder1/repo1'];
				return Promise.resolve();
			});
			spyOnSaveRepos.mockClear();

			// Run
			const result = await repoManager.exportRepoConfig('/path/to/workspace-folder1/repo1');

			// Assert
			expect(result).toBe(null);
			expect(utils.getPathFromStr(spyOnMkdir.mock.calls[0][0])).toBe('/path/to/workspace-folder1/repo1/.vscode');
			expect(utils.getPathFromStr(spyOnWriteFile.mock.calls[0][0])).toBe('/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json');
			expect(JSON.parse(spyOnWriteFile.mock.calls[0][1])).toStrictEqual({
				'exportedAt': 1587559258000
			});
			expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Successfully exported the Git Graph Repository Configuration to "/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json".');
			expect(spyOnSaveRepos).not.toHaveBeenCalled();

			// Teardown
			repoManager.dispose();
		});

		it('Should export the repository configuration (when .vscode already exists)', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			mockFsMkdirOnce({ code: 'EEXIST' } as NodeJS.ErrnoException);
			mockFsWriteFileOnce(null);
			vscode.window.showInformationMessage.mockResolvedValueOnce(null);
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);
			spyOnSaveRepos.mockClear();

			// Run
			const result = await repoManager.exportRepoConfig('/path/to/workspace-folder1/repo1');

			// Assert
			expect(result).toBe(null);
			expect(utils.getPathFromStr(spyOnMkdir.mock.calls[0][0])).toBe('/path/to/workspace-folder1/repo1/.vscode');
			expect(utils.getPathFromStr(spyOnWriteFile.mock.calls[0][0])).toBe('/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json');
			expect(JSON.parse(spyOnWriteFile.mock.calls[0][1])).toStrictEqual({
				'exportedAt': 1587559258000
			});
			expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Successfully exported the Git Graph Repository Configuration to "/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json".');
			expect(spyOnSaveRepos).toHaveBeenCalledWith({
				'/path/to/workspace-folder1/repo1': {
					cdvDivider: 0.5,
					cdvHeight: 250,
					columnWidths: null,
					commitOrdering: RepoCommitOrdering.Default,
					fileViewType: FileViewType.Default,
					hideRemotes: [],
					includeCommitsMentionedByReflogs: BooleanOverride.Default,
					issueLinkingConfig: null,
					lastImportAt: 1587559258000,
					name: null,
					onlyFollowFirstParent: BooleanOverride.Default,
					onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
					onRepoLoadShowSpecificBranches: null,
					pullRequestConfig: null,
					showRemoteBranches: true,
					showRemoteBranchesV2: BooleanOverride.Default,
					showStashes: BooleanOverride.Default,
					showTags: BooleanOverride.Default,
					workspaceFolderIndex: 0
				}
			});

			// Teardown
			repoManager.dispose();
		});

		it('Should return an error message when .vscode can\'t be created', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			mockFsMkdirOnce(new Error());
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);
			spyOnSaveRepos.mockClear();

			// Run
			const result = await repoManager.exportRepoConfig('/path/to/workspace-folder1/repo1');

			// Assert
			expect(result).toBe('An unexpected error occurred while checking if the "/path/to/workspace-folder1/repo1/.vscode" directory exists. This directory is used to store the Git Graph Repository Configuration file.');
			expect(spyOnSaveRepos).not.toHaveBeenCalled();

			// Teardown
			repoManager.dispose();
		});

		it('Should return an error message when the file can\'t be written', async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			mockFsMkdirOnce(null);
			mockFsWriteFileOnce(new Error());
			const repoManager = await constructRepoManagerAndWaitUntilStarted(['/path/to/workspace-folder1'], ['/path/to/workspace-folder1/repo1']);
			spyOnSaveRepos.mockClear();

			// Run
			const result = await repoManager.exportRepoConfig('/path/to/workspace-folder1/repo1');

			// Assert
			expect(result).toBe('Failed to write the Git Graph Repository Configuration File to "/path/to/workspace-folder1/repo1/.vscode/vscode-git-graph.json".');
			expect(spyOnSaveRepos).not.toHaveBeenCalled();

			// Teardown
			repoManager.dispose();
		});

		const testExportField = <K extends keyof GitRepoState, L extends keyof ExternalRepoConfig.File>(stateKey: K, stateValue: GitRepoState[K], fileKey: L, fileValue: ExternalRepoConfig.File[L]) => async () => {
			// Setup
			mockRepositoryWithNoSubmodules();
			mockDirectoryThatsNotRepository();
			mockWriteExternalConfigFileOnce();
			vscode.window.showInformationMessage.mockResolvedValueOnce(null);
			const repoManager = await constructRepoManagerAndWaitUntilStarted(
				['/path/to/workspace-folder1'],
				['/path/to/workspace-folder1/repo1']
			);
			repoManager.getRepos()['/path/to/workspace-folder1/repo1'][stateKey] = stateValue;

			// Run
			await repoManager.exportRepoConfig('/path/to/workspace-folder1/repo1');

			// Assert
			const expected: any = {};
			expected[fileKey] = fileValue;
			expected['exportedAt'] = 1587559258000;
			expect(JSON.parse(spyOnWriteFile.mock.calls[0][1])).toStrictEqual(expected);

			// Teardown
			repoManager.dispose();
		};

		describe('commitOrdering', () => {
			it('Should export RepoCommitOrdering.Date correctly', testExportField('commitOrdering', RepoCommitOrdering.Date, 'commitOrdering', RepoCommitOrdering.Date));
			it('Should export RepoCommitOrdering.AuthorDate correctly', testExportField('commitOrdering', RepoCommitOrdering.AuthorDate, 'commitOrdering', RepoCommitOrdering.AuthorDate));
			it('Should export RepoCommitOrdering.Topological correctly', testExportField('commitOrdering', RepoCommitOrdering.Topological, 'commitOrdering', RepoCommitOrdering.Topological));
		});

		describe('fileViewType', () => {
			it('Should export FileViewType.Tree correctly', testExportField('fileViewType', FileViewType.Tree, 'fileViewType', ExternalRepoConfig.FileViewType.Tree));
			it('Should export FileViewType.List correctly', testExportField('fileViewType', FileViewType.List, 'fileViewType', ExternalRepoConfig.FileViewType.List));
		});

		describe('hideRemotes', () => {
			it('Should export hideRemotes correctly', testExportField('hideRemotes', ['origin'], 'hideRemotes', ['origin']));
		});

		describe('includeCommitsMentionedByReflogs', () => {
			it('Should export BooleanOverride.Enabled correctly', testExportField('includeCommitsMentionedByReflogs', BooleanOverride.Enabled, 'includeCommitsMentionedByReflogs', true));
			it('Should export BooleanOverride.Disabled correctly', testExportField('includeCommitsMentionedByReflogs', BooleanOverride.Disabled, 'includeCommitsMentionedByReflogs', false));
		});

		describe('issueLinkingConfig', () => {
			it('Should export issueLinkingConfig correctly', testExportField('issueLinkingConfig', { issue: 'x', url: 'y' }, 'issueLinkingConfig', { issue: 'x', url: 'y' }));
		});

		describe('name', () => {
			it('Should export name correctly', testExportField('name', 'Name', 'name', 'Name'));
		});

		describe('onlyFollowFirstParent', () => {
			it('Should export BooleanOverride.Enabled correctly', testExportField('onlyFollowFirstParent', BooleanOverride.Enabled, 'onlyFollowFirstParent', true));
			it('Should export BooleanOverride.Disabled correctly', testExportField('onlyFollowFirstParent', BooleanOverride.Disabled, 'onlyFollowFirstParent', false));
		});

		describe('onRepoLoadShowCheckedOutBranch', () => {
			it('Should export BooleanOverride.Enabled correctly', testExportField('onRepoLoadShowCheckedOutBranch', BooleanOverride.Enabled, 'onRepoLoadShowCheckedOutBranch', true));
			it('Should export BooleanOverride.Disabled correctly', testExportField('onRepoLoadShowCheckedOutBranch', BooleanOverride.Disabled, 'onRepoLoadShowCheckedOutBranch', false));
		});

		describe('onRepoLoadShowSpecificBranches', () => {
			it('Should export onRepoLoadShowSpecificBranches correctly', testExportField('onRepoLoadShowSpecificBranches', ['master'], 'onRepoLoadShowSpecificBranches', ['master']));
		});

		describe('pullRequestConfig', () => {
			it('Should export a Bitbucket config correctly', testExportField(
				'pullRequestConfig', { provider: PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' },
				'pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Bitbucket, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' }
			));

			it('Should export a Custom config correctly', testExportField(
				'pullRequestConfig', { provider: PullRequestProvider.Custom, custom: { name: 'Name', templateUrl: '$1/$2/$3/$4/$5/$6/$8' }, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' },
				'pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.Custom, custom: { name: 'Name', templateUrl: '$1/$2/$3/$4/$5/$6/$8' }, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' }
			));

			it('Should export a GitHub config correctly', testExportField(
				'pullRequestConfig', { provider: PullRequestProvider.GitHub, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' },
				'pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.GitHub, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' }
			));

			it('Should export a GitLab config correctly', testExportField(
				'pullRequestConfig', { provider: PullRequestProvider.GitLab, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' },
				'pullRequestConfig', { provider: ExternalRepoConfig.PullRequestProvider.GitLab, custom: null, hostRootUrl: 'a', sourceRemote: 'b', sourceOwner: 'c', sourceRepo: 'd', destRemote: 'e', destOwner: 'f', destRepo: 'g', destProjectId: 'h', destBranch: 'i' }
			));
		});

		describe('showRemoteBranches', () => {
			it('Should export BooleanOverride.Enabled correctly', testExportField('showRemoteBranchesV2', BooleanOverride.Enabled, 'showRemoteBranches', true));
			it('Should export BooleanOverride.Disabled correctly', testExportField('showRemoteBranchesV2', BooleanOverride.Disabled, 'showRemoteBranches', false));
		});

		describe('showStashes', () => {
			it('Should export BooleanOverride.Enabled correctly', testExportField('showStashes', BooleanOverride.Enabled, 'showStashes', true));
			it('Should export BooleanOverride.Disabled correctly', testExportField('showStashes', BooleanOverride.Disabled, 'showStashes', false));
		});

		describe('showTags', () => {
			it('Should export BooleanOverride.Enabled correctly', testExportField('showTags', BooleanOverride.Enabled, 'showTags', true));
			it('Should export BooleanOverride.Disabled correctly', testExportField('showTags', BooleanOverride.Disabled, 'showTags', false));
		});
	});
});

function mockRepository(generateRootPath?: (path: string) => string) {
	spyOnRepoRoot.mockImplementationOnce((path) => Promise.resolve(generateRootPath ? generateRootPath(path) : path));
}

function mockRepositoryWithSubmodules(submodules: string[]) {
	mockRepository();
	spyOnGetSubmodules.mockResolvedValueOnce(submodules);
}

function mockRepositoryWithNoSubmodules() {
	mockRepositoryWithSubmodules([]);
}

function mockDirectoryThatsNotRepository() {
	spyOnRepoRoot.mockResolvedValueOnce(null);
}

function mockFsReaddirOnce(err: NodeJS.ErrnoException | null, files: string[]) {
	spyOnReaddir.mockImplementationOnce((_: string, callback: (err: NodeJS.ErrnoException | null, files: string[]) => void) => {
		callback(err, files);
	});
}

function mockFsStatOnce(err: NodeJS.ErrnoException | null, isDirectory: boolean) {
	spyOnStat.mockImplementationOnce((_: string, callback: (err: NodeJS.ErrnoException | null, stats: fs.Stats) => void) => {
		callback(err, { isDirectory: () => isDirectory } as any as fs.Stats);
	});
}

function mockFsMkdirOnce(err: NodeJS.ErrnoException | null) {
	spyOnMkdir.mockImplementationOnce((_: string, callback: (err: NodeJS.ErrnoException | null) => void) => {
		callback(err);
	});
}

function mockFsReadFileOnce(err: NodeJS.ErrnoException | null, data: string | object) {
	spyOnReadFile.mockImplementationOnce((_: string, callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void) => {
		callback(err, Buffer.from(typeof data === 'string' ? data : JSON.stringify(data)));
	});
}

function mockFsWriteFileOnce(err: NodeJS.ErrnoException | null) {
	spyOnWriteFile.mockImplementationOnce((_1: string, _2: any, callback: (err: NodeJS.ErrnoException | null) => void) => {
		callback(err);
	});
}

function mockWriteExternalConfigFileOnce() {
	mockFsMkdirOnce(null);
	mockFsWriteFileOnce(null);
}

function constructRepoManager(workspaceFolders: string[] | undefined, repos: string[] | GitRepoSet, ignoreRepos: string[] = []) {
	let repoSet: GitRepoSet = {};
	if (Array.isArray(repos)) {
		repos.forEach((repo) => repoSet[repo] = mockRepoState());
	} else {
		repoSet = Object.assign({}, repos);
	}

	spyOnGetRepos.mockReturnValueOnce(repoSet);

	spyOnGetIgnoredRepos.mockReturnValueOnce(ignoreRepos);

	vscode.mockExtensionSettingReturnValue('maxDepthOfRepoSearch', 0);

	vscode.workspace.workspaceFolders = workspaceFolders
		? workspaceFolders.map((path, index) => ({ uri: vscode.Uri.file(path), index: index }))
		: undefined;

	return new RepoManager(dataSource, extensionState, onDidChangeConfiguration.subscribe, logger);
}

function waitForRepoManagerToStart() {
	return waitForExpect(() => expect(spyOnLog).toHaveBeenCalledWith('Completed searching workspace for new repos'));
}

async function constructRepoManagerAndWaitUntilStarted(workspaceFolders: string[] | undefined, repos: string[] | GitRepoSet, ignoreRepos: string[] = []) {
	const repoManager = constructRepoManager(workspaceFolders, repos, ignoreRepos);
	await waitForRepoManagerToStart();
	return repoManager;
}
-e 

================================================================================
// FILE: ./tests/dataSource.test.ts
================================================================================
import * as date from './mocks/date';
import { mockSpyOnSpawn } from './mocks/spawn';
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });
jest.mock('../src/askpass/askpassManager');
jest.mock('../src/logger');

import * as cp from 'child_process';
import * as fs from 'fs';
import * as iconv from 'iconv-lite';
import * as path from 'path';
import { ConfigurationChangeEvent } from 'vscode';
import { DataSource, GitConfigKey } from '../src/dataSource';
import { Logger } from '../src/logger';
import { CommitOrdering, GitConfigLocation, GitPushBranchMode, GitResetMode, GitSignature, GitSignatureStatus, MergeActionOn, RebaseActionOn, TagType } from '../src/types';
import * as utils from '../src/utils';
import { EventEmitter } from '../src/utils/event';

import { waitForExpect } from './helpers/expectations';

const workspaceConfiguration = vscode.mocks.workspaceConfiguration;
let onDidChangeConfiguration: EventEmitter<ConfigurationChangeEvent>;
let onDidChangeGitExecutable: EventEmitter<utils.GitExecutable>;
let logger: Logger;
let spyOnSpawn: jest.SpyInstance, spyOnLog: jest.SpyInstance, spyOnLogError: jest.SpyInstance;

beforeAll(() => {
	onDidChangeConfiguration = new EventEmitter<ConfigurationChangeEvent>();
	onDidChangeGitExecutable = new EventEmitter<utils.GitExecutable>();
	logger = new Logger();
	jest.spyOn(path, 'normalize').mockImplementation((p) => p);
	spyOnSpawn = jest.spyOn(cp, 'spawn');
	spyOnLog = jest.spyOn(logger, 'log');
	spyOnLogError = jest.spyOn(logger, 'logError');
});

afterAll(() => {
	logger.dispose();
	onDidChangeConfiguration.dispose();
	onDidChangeGitExecutable.dispose();
});

describe('DataSource', () => {
	let dataSource: DataSource;
	beforeEach(() => {
		dataSource = new DataSource({ path: '/path/to/git', version: '2.25.0' }, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);
	});
	afterEach(() => {
		dataSource.dispose();
	});

	const mockGitSuccessOnce = (stdout?: string, stderr?: string) => {
		mockSpyOnSpawn(spyOnSpawn, (onCallbacks, stderrOnCallbacks, stdoutOnCallbacks) => {
			if (stdout) {
				stdoutOnCallbacks['data'](Buffer.from(stdout));
			}
			stdoutOnCallbacks['close']();
			if (stderr) {
				stderrOnCallbacks['data'](Buffer.from(stderr));
			}
			stderrOnCallbacks['close']();
			onCallbacks['exit'](0);
		});
	};

	const mockGitThrowingErrorOnce = (errorMessage?: string) => {
		mockSpyOnSpawn(spyOnSpawn, (onCallbacks, stderrOnCallbacks, stdoutOnCallbacks) => {
			stdoutOnCallbacks['close']();
			stderrOnCallbacks['data']((errorMessage || 'error message') + '\n');
			stderrOnCallbacks['close']();
			onCallbacks['exit'](1);
		});
	};

	describe('isGitExecutableUnknown', () => {
		it('Should return FALSE when the Git executable is known', () => {
			// Run
			const result = dataSource.isGitExecutableUnknown();

			// Assert
			expect(result).toBe(false);
		});

		it('Should return TRUE when the Git executable is unknown', () => {
			// Setup
			dataSource.dispose();
			dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);

			// Run
			const result = dataSource.isGitExecutableUnknown();

			// Assert
			expect(result).toBe(true);
		});

		it('Should return TRUE after a Git executable becomes known', () => {
			// Setup
			dataSource.dispose();
			dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);

			// Run
			const result1 = dataSource.isGitExecutableUnknown();

			// Assert
			expect(result1).toBe(true);

			// Run
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '2.25.0' });
			const result2 = dataSource.isGitExecutableUnknown();

			// Assert
			expect(result2).toBe(false);
			expect(dataSource['gitExecutable']).toStrictEqual({ path: '/path/to/git', version: '2.25.0' });
		});
	});

	describe('setGitExecutable', () => {
		it('Should set gitExecutableSupportsGpgInfo to FALSE when there is no Git executable', () => {
			// Run
			dataSource.dispose();
			dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);

			// Assert
			expect(dataSource['gitExecutableSupportsGpgInfo']).toBe(false);
		});

		it('Should set gitExecutableSupportsGpgInfo to FALSE when the Git executable is older than 2.4.0', () => {
			// Run
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '2.3.0' });

			// Assert
			expect(dataSource['gitExecutableSupportsGpgInfo']).toBe(false);
		});

		it('Should set gitExecutableSupportsGpgInfo to TRUE when the Git executable is at least 2.4.0', () => {
			// Run
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '2.4.0' });

			// Assert
			expect(dataSource['gitExecutableSupportsGpgInfo']).toBe(true);
		});
	});

	describe('getRepoInfo', () => {
		it('Should return the repository info', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n' +
				'  remotes/origin/HEAD\n' +
				'  remotes/origin/develop\n' +
				'  remotes/origin/master\n'
			);
			mockGitSuccessOnce('origin\n');
			mockGitSuccessOnce(
				'98adab72e57a098a45cc36e43a6c0fda95c44f8bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbb30d6d4d14462e09515df02a8635e83b4278c8b1 26970361eca306caa6d6bed3baf022dbd8fa404cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbrefs/stash@{0}XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1592306634XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbWIP on develop: b30d6d4 y\n' +
				'0fc3e571c275213de2b3bca9c85e852323056121XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb9157723d0856bd828800ff185ee72658ee51d19f d45009bc4224537e97b0e52883ea7ae657928fcf 9d81ce0a6cf64b6651bacd7a6c3a6ca90fd63235XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbrefs/stash@{1}XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1592135134XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbWIP on master: 9157723 y\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);

			// Run
			const result = await dataSource.getRepoInfo('/path/to/repo', true, true, []);

			// Assert
			expect(result).toStrictEqual({
				branches: ['develop', 'master', 'remotes/origin/HEAD', 'remotes/origin/develop', 'remotes/origin/master'],
				head: 'develop',
				remotes: ['origin'],
				stashes: [
					{
						author: 'Test Author',
						baseHash: 'b30d6d4d14462e09515df02a8635e83b4278c8b1',
						date: 1592306634,
						email: 'test@mhutchie.com',
						hash: '98adab72e57a098a45cc36e43a6c0fda95c44f8b',
						message: 'WIP on develop: b30d6d4 y',
						selector: 'refs/stash@{0}',
						untrackedFilesHash: null
					},
					{
						author: 'Test Author',
						baseHash: '9157723d0856bd828800ff185ee72658ee51d19f',
						date: 1592135134,
						email: 'test@mhutchie.com',
						hash: '0fc3e571c275213de2b3bca9c85e852323056121',
						message: 'WIP on master: 9157723 y',
						selector: 'refs/stash@{1}',
						untrackedFilesHash: '9d81ce0a6cf64b6651bacd7a6c3a6ca90fd63235'
					}
				],
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-a', '--no-color'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reflog', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%gDXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', 'refs/stash', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the repository info (when showRemoteBranches is FALSE)', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n'
			);
			mockGitSuccessOnce('origin\n');
			mockGitSuccessOnce('\n');
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);

			// Run
			const result = await dataSource.getRepoInfo('/path/to/repo', false, true, []);

			// Assert
			expect(result).toStrictEqual({
				branches: ['develop', 'master'],
				head: 'develop',
				remotes: ['origin'],
				stashes: [],
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '--no-color'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reflog', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%gDXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', 'refs/stash', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the repository info (using git-graph.date.type)', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n'
			);
			mockGitSuccessOnce('origin\n');
			mockGitSuccessOnce('\n');
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('date.type', 'Commit Date');
			vscode.mockExtensionSettingReturnValue('repository.useMailmap', false);
			vscode.mockExtensionSettingReturnValue('repository.commits.showSignatureStatus', false);

			// Run
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.date.type'
			});
			const result = await dataSource.getRepoInfo('/path/to/repo', false, true, []);

			// Assert
			expect(result).toStrictEqual({
				branches: ['develop', 'master'],
				head: 'develop',
				remotes: ['origin'],
				stashes: [],
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '--no-color'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reflog', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%gDXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', 'refs/stash', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the repository info (using git-graph.dateType)', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n'
			);
			mockGitSuccessOnce('origin\n');
			mockGitSuccessOnce('\n');
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('date.type', 'Commit Date');
			vscode.mockExtensionSettingReturnValue('repository.useMailmap', false);
			vscode.mockExtensionSettingReturnValue('repository.commits.showSignatureStatus', false);

			// Run
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.dateType'
			});
			const result = await dataSource.getRepoInfo('/path/to/repo', false, true, []);

			// Assert
			expect(result).toStrictEqual({
				branches: ['develop', 'master'],
				head: 'develop',
				remotes: ['origin'],
				stashes: [],
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '--no-color'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reflog', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%gDXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', 'refs/stash', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the repository info (using git-graph.repository.useMailmap)', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n'
			);
			mockGitSuccessOnce('origin\n');
			mockGitSuccessOnce('\n');
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('date.type', 'Author Date');
			vscode.mockExtensionSettingReturnValue('repository.useMailmap', true);
			vscode.mockExtensionSettingReturnValue('repository.commits.showSignatureStatus', false);

			// Run
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.repository.useMailmap'
			});
			const result = await dataSource.getRepoInfo('/path/to/repo', false, true, []);

			// Assert
			expect(result).toStrictEqual({
				branches: ['develop', 'master'],
				head: 'develop',
				remotes: ['origin'],
				stashes: [],
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '--no-color'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reflog', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%gDXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aNXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aEXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', 'refs/stash', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the repository info (using git-graph.useMailmap)', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n'
			);
			mockGitSuccessOnce('origin\n');
			mockGitSuccessOnce('\n');
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('date.type', 'Author Date');
			vscode.mockExtensionSettingReturnValue('useMailmap', true);
			vscode.mockExtensionSettingReturnValue('repository.commits.showSignatureStatus', false);

			// Run
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.useMailmap'
			});
			const result = await dataSource.getRepoInfo('/path/to/repo', false, true, []);

			// Assert
			expect(result).toStrictEqual({
				branches: ['develop', 'master'],
				head: 'develop',
				remotes: ['origin'],
				stashes: [],
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '--no-color'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reflog', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%gDXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aNXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aEXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', 'refs/stash', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the repository info (showStashes is FALSE)', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n'
			);
			mockGitSuccessOnce('origin\n');

			// Run
			const result = await dataSource.getRepoInfo('/path/to/repo', true, false, []);

			// Assert
			expect(result).toStrictEqual({
				branches: ['develop', 'master'],
				head: 'develop',
				remotes: ['origin'],
				stashes: [],
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-a', '--no-color'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toHaveBeenCalledTimes(2);
		});

		it('Should return the repository info (hidden remote and an invalid branch)', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n' +
				'  (invalid branch)\n' +
				'  remotes/origin/develop\n' +
				'  remotes/origin/master\n'
			);
			mockGitSuccessOnce('origin\n');
			mockGitSuccessOnce('\n');
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);

			// Run
			const result = await dataSource.getRepoInfo('/path/to/repo', true, true, ['origin']);

			// Assert
			expect(result).toStrictEqual({
				branches: ['develop', 'master'],
				head: 'develop',
				remotes: ['origin'],
				stashes: [],
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-a', '--no-color'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reflog', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%gDXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', 'refs/stash', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the repository info (excluding remote heads)', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n' +
				'  remotes/origin/HEAD\n' +
				'  remotes/origin/develop\n' +
				'  remotes/origin/master\n'
			);
			mockGitSuccessOnce('origin\n');
			mockGitSuccessOnce('\n');
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', false);

			// Run
			const result = await dataSource.getRepoInfo('/path/to/repo', true, true, []);

			// Assert
			expect(result).toStrictEqual({
				branches: ['develop', 'master', 'remotes/origin/develop', 'remotes/origin/master'],
				head: 'develop',
				remotes: ['origin'],
				stashes: [],
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-a', '--no-color'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reflog', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%gDXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', 'refs/stash', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (when getting branches)', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce('origin\n');
			mockGitSuccessOnce('\n');
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);

			// Run
			const result = await dataSource.getRepoInfo('/path/to/repo', true, true, []);

			// Assert
			expect(result).toStrictEqual({
				branches: [],
				head: null,
				remotes: [],
				stashes: [],
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when getting remotes)', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n'
			);
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce('\n');
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);

			// Run
			const result = await dataSource.getRepoInfo('/path/to/repo', true, true, []);

			// Assert
			expect(result).toStrictEqual({
				branches: [],
				head: null,
				remotes: [],
				stashes: [],
				error: 'error message'
			});
		});

		it('Should return no stashes when when getting stashes throws an error', async () => {
			// Setup
			mockGitSuccessOnce(
				'* develop\n' +
				'  master\n'
			);
			mockGitSuccessOnce('origin\n');
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);

			// Run
			const result = await dataSource.getRepoInfo('/path/to/repo', true, true, []);

			// Assert
			expect(result).toStrictEqual({
				branches: ['develop', 'master'],
				head: 'develop',
				remotes: ['origin'],
				stashes: [],
				error: null
			});
		});
	});

	describe('getCommits', () => {
		it('Should return the commits (show all branches)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/remotes/origin/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/other-remote/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/tags/tag2\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [
							{ name: 'origin/HEAD', remote: 'origin' },
							{ name: 'origin/master', remote: 'origin' },
							{ name: 'other-remote/master', remote: null }
						],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1', 'tag2'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (master & develop branches)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/remotes/origin/feature\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', ['master', 'develop'], 300, true, true, false, false, CommitOrdering.AuthorDate, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--author-date-order', 'master', 'develop', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (no more commits)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 2, true, true, false, false, CommitOrdering.Topological, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: [],
				moreCommitsAvailable: true,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=3', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--topo-order', '--branches', '--tags', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (HEAD is not in the commits)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toHaveBeenCalledTimes(2);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (showUncommittedChanges === FALSE)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', false);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toHaveBeenCalledTimes(2);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (showUntrackedFiles === FALSE)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', false);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (1)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=no', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (showTags === FALSE)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, false, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (showCommitsOnlyReferencedByTags === FALSE)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', false);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (showRemoteBranches === FALSE)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, false, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '--heads', '--tags', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (includeCommitsMentionedByReflogs === TRUE)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/remotes/origin/feature\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, true, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--reflog', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (onlyFollowFirstParent === TRUE)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/remotes/origin/feature\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, true, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--first-parent', '--branches', '--tags', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (showRemoteHeads === FALSE)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/remotes/origin/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/other-remote/HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/other-remote/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', false);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [
							{ name: 'origin/master', remote: 'origin' },
							{ name: 'other-remote/master', remote: null }
						],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (hiding the remote branches from a hidden remote)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/remotes/origin/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/other-remote/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin', 'other-remote'], ['other-remote'], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--glob=refs/remotes/origin', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (stash returned in git log commits)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbWIP\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c HEAD\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/remotes/origin/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], [
				{
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					baseHash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
					untrackedFilesHash: '5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f',
					selector: 'refs/stash@{0}',
					author: 'Test Stash Author',
					email: 'test-stash@mhutchie.com',
					date: 1587559258,
					message: 'WIP'
				}
			]);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'WIP',
						heads: [],
						tags: [],
						remotes: [],
						stash: {
							baseHash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
							selector: 'refs/stash@{0}',
							untrackedFilesHash: '5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f'
						}
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['master', 'develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (stashes are based on different commits returned by git log)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], [
				{
					hash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					baseHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					untrackedFilesHash: '5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f',
					selector: 'refs/stash@{0}',
					author: 'Test Stash Author',
					email: 'test-stash@mhutchie.com',
					date: 1587559258,
					message: 'WIP 1'
				},
				{
					hash: 'b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3',
					baseHash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
					untrackedFilesHash: '6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a',
					selector: 'refs/stash@{1}',
					author: 'Test Stash Author',
					email: 'test-stash@mhutchie.com',
					date: 1587559258,
					message: 'WIP 2'
				}
			]);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: 'Test Stash Author',
						email: 'test-stash@mhutchie.com',
						date: 1587559258,
						message: 'WIP 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: {
							baseHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							selector: 'refs/stash@{0}',
							untrackedFilesHash: '5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f'
						}
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: 'b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Stash Author',
						email: 'test-stash@mhutchie.com',
						date: 1587559258,
						message: 'WIP 2',
						heads: [],
						tags: [],
						remotes: [],
						stash: {
							baseHash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
							selector: 'refs/stash@{1}',
							untrackedFilesHash: '6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a'
						}
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: [],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (stashes are based on a commit returned by git log)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], [
				{
					hash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					baseHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					untrackedFilesHash: '5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f',
					selector: 'refs/stash@{0}',
					author: 'Test Stash Author',
					email: 'test-stash@mhutchie.com',
					date: 1587559261,
					message: 'WIP 1'
				},
				{
					hash: 'b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3',
					baseHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					untrackedFilesHash: '6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a',
					selector: 'refs/stash@{1}',
					author: 'Test Stash Author',
					email: 'test-stash@mhutchie.com',
					date: 1587559260,
					message: 'WIP 2'
				}
			]);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: 'Test Stash Author',
						email: 'test-stash@mhutchie.com',
						date: 1587559261,
						message: 'WIP 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: {
							baseHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							selector: 'refs/stash@{0}',
							untrackedFilesHash: '5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f'
						}
					},
					{
						hash: 'b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: 'Test Stash Author',
						email: 'test-stash@mhutchie.com',
						date: 1587559260,
						message: 'WIP 2',
						heads: [],
						tags: [],
						remotes: [],
						stash: {
							baseHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							selector: 'refs/stash@{1}',
							untrackedFilesHash: '6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a'
						}
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: [],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (stash isn\'t based on a commit returned by git log)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], [
				{
					hash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					baseHash: '6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a',
					untrackedFilesHash: '5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f',
					selector: 'refs/stash@{0}',
					author: 'Test Stash Author',
					email: 'test-stash@mhutchie.com',
					date: 1587559258,
					message: 'WIP 1'
				}
			]);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: [],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', '6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commits (no uncommitted changes)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce('');
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return no commits (when in an empty repository)', async () => {
			// Setup
			mockGitSuccessOnce('\n');
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [],
				head: null,
				tags: [],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toHaveBeenCalledTimes(2);
		});

		it('Should return the commits (ignoring invalid show-ref records)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/invalid/master\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/remotes/origin/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/other-remote/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			mockGitSuccessOnce(
				'M modified.txt\n' +
				'?? untracked.txt\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);
			vscode.mockExtensionSettingReturnValue('repository.showUncommittedChanges', true);
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);
			date.setCurrentTime(1587559259);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [
					{
						hash: '*',
						parents: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						author: '*',
						email: '',
						date: 1587559259,
						message: 'Uncommitted Changes (2)',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					},
					{
						hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						parents: ['2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559258,
						message: 'Commit Message 3',
						heads: ['master'],
						tags: [],
						remotes: [{ name: 'origin/master', remote: 'origin' }, { name: 'other-remote/master', remote: null }],
						stash: null
					},
					{
						hash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						parents: ['3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d'],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559257,
						message: 'Commit Message 2',
						heads: ['develop'],
						tags: [{ name: 'tag1', annotated: true }],
						remotes: [],
						stash: null
					},
					{
						hash: '3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						parents: [],
						author: 'Test Name',
						email: 'test@mhutchie.com',
						date: 1587559256,
						message: 'Commit Message 1',
						heads: [],
						tags: [],
						remotes: [],
						stash: null
					}
				],
				head: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				tags: ['tag1'],
				moreCommitsAvailable: false,
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--max-count=301', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%s', '--date-order', '--branches', '--tags', '--remotes', 'HEAD', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show-ref', '-d', '--head'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '--untracked-files=all', '--porcelain'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (when thrown by git log)', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b HEAD\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/heads/master\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/heads/develop\n' +
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e refs/heads/feature\n' +
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b refs/remotes/origin/master\n' +
				'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 refs/tags/tag1\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c refs/tags/tag1^{}\n'
			);
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [],
				head: null,
				tags: [],
				moreCommitsAvailable: false,
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by git show-ref)', async () => {
			// Setup
			mockGitSuccessOnce(
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 3\n' +
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3cXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559257XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 2\n' +
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4dXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest NameXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559256XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message 1\n'
			);
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.showCommitsOnlyReferencedByTags', true);
			vscode.mockExtensionSettingReturnValue('repository.showRemoteHeads', true);

			// Run
			const result = await dataSource.getCommits('/path/to/repo', null, 300, true, true, false, false, CommitOrdering.Date, ['origin'], [], []);

			// Assert
			expect(result).toStrictEqual({
				commits: [],
				head: null,
				tags: [],
				moreCommitsAvailable: false,
				error: 'error message'
			});
		});
	});

	describe('getConfig', () => {
		it('Should return the config values', async () => {
			// Setup
			mockGitSuccessOnce(
				'user.name\nLocal Name\0' +
				'diff.tool\nabc\0' +
				'diff.guitool\ndef\0' +
				'remote.pushdefault\norigin\0'
			);
			mockGitSuccessOnce(
				'user.name\nLocal Name\0' +
				'user.email\nunused@mhutchie.com\0' +
				'user.email\nlocal@mhutchie.com\0' +
				'remote.origin.url\nhttps://github.com/mhutchie/vscode-git-graph.git\0' +
				'remote.origin.pushurl\nhttps://github.com/mhutchie/vscode-git-graph-push.git\0' +
				'remote.origin.fetch\n+refs/heads/*:refs/remotes/origin/*\0' +
				'branch.master.remote\norigin\0' +
				'branch.master.pushremote\norigin2\0' +
				'branch.master.other\norigin3\0' +
				'branch.develop.pushremote\norigin\0' +
				'branch.develop.remote\norigin2\0' +
				'branch.branch1.remote\norigin\0' +
				'branch.branch2.pushremote\norigin\0'
			);
			mockGitSuccessOnce(
				'user.name\nGlobal Name\0' +
				'user.email\nglobal@mhutchie.com\0'
			);

			// Run
			const result = await dataSource.getConfig('/path/to/repo', ['origin']);

			// Assert
			expect(result).toStrictEqual({
				config: {
					branches: {
						master: {
							pushRemote: 'origin2',
							remote: 'origin'
						},
						develop: {
							pushRemote: 'origin',
							remote: 'origin2'
						},
						branch1: {
							pushRemote: null,
							remote: 'origin'
						},
						branch2: {
							pushRemote: 'origin',
							remote: null
						}
					},
					diffTool: 'abc',
					guiDiffTool: 'def',
					pushDefault: 'origin',
					remotes: [
						{
							name: 'origin',
							url: 'https://github.com/mhutchie/vscode-git-graph.git',
							pushUrl: 'https://github.com/mhutchie/vscode-git-graph-push.git'
						}
					],
					user: {
						name: {
							local: 'Local Name',
							global: 'Global Name'
						},
						email: {
							local: 'local@mhutchie.com',
							global: 'global@mhutchie.com'
						}
					}
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes', '--local'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes', '--global'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the config values', async () => {
			// Setup
			mockGitSuccessOnce(
				'diff.tool\nabc\0' +
				'diff.guitool\ndef\0'
			);
			mockGitSuccessOnce(
				'user.email\nlocal@mhutchie.com\0' +
				'remote.origin.url\nhttps://github.com/mhutchie/vscode-git-graph.git\0'
			);
			mockGitSuccessOnce(
				'user.name\nGlobal Name\0'
			);

			// Run
			const result = await dataSource.getConfig('/path/to/repo', ['origin']);

			// Assert
			expect(result).toStrictEqual({
				config: {
					branches: {},
					diffTool: 'abc',
					guiDiffTool: 'def',
					pushDefault: null,
					remotes: [
						{
							name: 'origin',
							url: 'https://github.com/mhutchie/vscode-git-graph.git',
							pushUrl: null
						}
					],
					user: {
						name: {
							local: null,
							global: 'Global Name'
						},
						email: {
							local: 'local@mhutchie.com',
							global: null
						}
					}
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes', '--local'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes', '--global'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return NULL values when the config variables aren\'t set', async () => {
			// Setup
			mockGitSuccessOnce(
				'other.setting\nvalue\0'
			);
			mockGitSuccessOnce(
				'other.setting\nvalue\0'
			);
			mockGitSuccessOnce(
				'other.setting\nvalue\0'
			);

			// Run
			const result = await dataSource.getConfig('/path/to/repo', []);

			// Assert
			expect(result).toStrictEqual({
				config: {
					branches: {},
					diffTool: null,
					guiDiffTool: null,
					pushDefault: null,
					remotes: [],
					user: {
						name: {
							local: null,
							global: null
						},
						email: {
							local: null,
							global: null
						}
					}
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes', '--local'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes', '--global'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the repositories settings (ignoring Git exception when either the global or local .gitconfig file doesn\'t exist)', async () => {
			// Setup
			mockGitSuccessOnce(
				'user.name\nLocal Name\0' +
				'diff.tool\nabc\0' +
				'diff.guitool\ndef\0'
			);
			mockGitSuccessOnce(
				'user.name\nLocal\r\nMultiline\nName\0' +
				'user.email\nunused@mhutchie.com\0' +
				'user.email\nlocal@mhutchie.com\0' +
				'remote.origin.url\nhttps://github.com/mhutchie/vscode-git-graph.git\0' +
				'remote.origin.pushurl\nhttps://github.com/mhutchie/vscode-git-graph-push.git\0' +
				'remote.origin.fetch\n+refs/heads/*:refs/remotes/origin/*\0'
			);
			mockGitThrowingErrorOnce('fatal: unable to read config file \'c:/users/michael/.gitconfig\': no such file or directory');

			// Run
			const result = await dataSource.getConfig('/path/to/repo', ['origin']);

			// Assert
			expect(result).toStrictEqual({
				config: {
					branches: {},
					diffTool: 'abc',
					guiDiffTool: 'def',
					pushDefault: null,
					remotes: [
						{
							name: 'origin',
							url: 'https://github.com/mhutchie/vscode-git-graph.git',
							pushUrl: 'https://github.com/mhutchie/vscode-git-graph-push.git'
						}
					],
					user: {
						name: {
							local: 'Local\nMultiline\nName',
							global: null
						},
						email: {
							local: 'local@mhutchie.com',
							global: null
						}
					}
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes', '--local'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['--no-pager', 'config', '--list', '-z', '--includes', '--global'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			mockGitThrowingErrorOnce();
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getConfig('/path/to/repo', []);

			// Assert
			expect(result).toStrictEqual({
				config: null,
				error: 'error message'
			});
		});

		it('Should return an error message indicating an unexpected error occurred', async () => {
			// Setup
			const error = new Error();
			mockGitSuccessOnce(
				'user.name\nLocal Name\0' +
				'diff.tool\nabc\0' +
				'diff.guitool\ndef\0'
			);
			mockGitSuccessOnce(
				'user.name\nLocal Name\0' +
				'user.email\nunused@mhutchie.com\0' +
				'user.email\nlocal@mhutchie.com\0' +
				'remote.origin.url\nhttps://github.com/mhutchie/vscode-git-graph.git\0' +
				'remote.origin.pushurl\nhttps://github.com/mhutchie/vscode-git-graph-push.git\0' +
				'remote.origin.fetch\n+refs/heads/*:refs/remotes/origin/*\0'
			);
			spyOnSpawn.mockImplementationOnce(() => {
				throw error;
			});

			// Run
			const result = await dataSource.getConfig('/path/to/repo', ['origin']);

			// Assert
			expect(result).toStrictEqual({
				config: null,
				error: 'An unexpected error occurred while spawning the Git child process.'
			});
		});
	});

	describe('getCommitDetails', () => {
		it('Should return the commit details', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parents: ['a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2'],
					author: 'Test Author',
					authorEmail: 'test-author@mhutchie.com',
					authorDate: 1587559258,
					committer: 'Test Committer',
					committerEmail: 'test-committer@mhutchie.com',
					committerDate: 1587559259,
					signature: null,
					body: 'Commit Message.\nSecond Line.',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: 2,
							deletions: 3,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'show', '--quiet', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cnXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ceXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%B'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commit details (commit doesn\'t have parents)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parents: [],
					author: 'Test Author',
					authorEmail: 'test-author@mhutchie.com',
					authorDate: 1587559258,
					committer: 'Test Committer',
					committerEmail: 'test-committer@mhutchie.com',
					committerDate: 1587559259,
					signature: null,
					body: 'Commit Message.\nSecond Line.',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: 2,
							deletions: 3,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'show', '--quiet', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cnXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ceXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%B'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-tree', '--name-status', '-r', '--root', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-tree', '--numstat', '-r', '--root', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commit details (using git-graph.repository.commits.showSignatureStatus)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbGXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest Signer <test-signer@mhutchie.com> XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb0123456789ABCDEFXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			vscode.mockExtensionSettingReturnValue('date.type', 'Author Date');
			vscode.mockExtensionSettingReturnValue('repository.useMailmap', false);
			vscode.mockExtensionSettingReturnValue('repository.commits.showSignatureStatus', true);
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '2.4.0' });

			// Run
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.repository.commits.showSignatureStatus'
			});
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parents: ['a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2'],
					author: 'Test Author',
					authorEmail: 'test-author@mhutchie.com',
					authorDate: 1587559258,
					committer: 'Test Committer',
					committerEmail: 'test-committer@mhutchie.com',
					committerDate: 1587559259,
					signature: {
						key: '0123456789ABCDEF',
						signer: 'Test Signer <test-signer@mhutchie.com>',
						status: 'G'
					},
					body: 'Commit Message.\nSecond Line.',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: 2,
							deletions: 3,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'show', '--quiet', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cnXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ceXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%G?XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%GSXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%GKXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%B'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commit details (using git-graph.showSignatureStatus)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbGXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest Signer <test-signer@mhutchie.com> XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb0123456789ABCDEFXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			vscode.mockExtensionSettingReturnValue('date.type', 'Author Date');
			vscode.mockExtensionSettingReturnValue('repository.useMailmap', false);
			vscode.mockExtensionSettingReturnValue('showSignatureStatus', true);
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '2.4.0' });

			// Run
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.showSignatureStatus'
			});
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parents: ['a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2'],
					author: 'Test Author',
					authorEmail: 'test-author@mhutchie.com',
					authorDate: 1587559258,
					committer: 'Test Committer',
					committerEmail: 'test-committer@mhutchie.com',
					committerDate: 1587559259,
					signature: {
						key: '0123456789ABCDEF',
						signer: 'Test Signer <test-signer@mhutchie.com>',
						status: 'G'
					},
					body: 'Commit Message.\nSecond Line.',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: 2,
							deletions: 3,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'show', '--quiet', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cnXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ceXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%G?XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%GSXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%GKXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%B'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commit details (without signature status) when Git is older than 2.4.0', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			vscode.mockExtensionSettingReturnValue('date.type', 'Author Date');
			vscode.mockExtensionSettingReturnValue('repository.useMailmap', false);
			vscode.mockExtensionSettingReturnValue('repository.commits.showSignatureStatus', true);
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '2.3.0' });

			// Run
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parents: ['a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2'],
					author: 'Test Author',
					authorEmail: 'test-author@mhutchie.com',
					authorDate: 1587559258,
					committer: 'Test Committer',
					committerEmail: 'test-committer@mhutchie.com',
					committerDate: 1587559259,
					signature: null,
					body: 'Commit Message.\nSecond Line.',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: 2,
							deletions: 3,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'show', '--quiet', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cnXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ceXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%B'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commit details (using git-graph.repository.useMailmap)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			vscode.mockExtensionSettingReturnValue('date.type', 'Author Date');
			vscode.mockExtensionSettingReturnValue('repository.useMailmap', true);
			vscode.mockExtensionSettingReturnValue('repository.commits.showSignatureStatus', false);

			// Run
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.repository.useMailmap'
			});
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parents: ['a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2'],
					author: 'Test Author',
					authorEmail: 'test-author@mhutchie.com',
					authorDate: 1587559258,
					committer: 'Test Committer',
					committerEmail: 'test-committer@mhutchie.com',
					committerDate: 1587559259,
					signature: null,
					body: 'Commit Message.\nSecond Line.',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: 2,
							deletions: 3,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'show', '--quiet', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aNXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aEXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cNXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cEXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%B'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commit details (handling unknown Git file status returned by git diff --name-status)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'X', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parents: ['a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2'],
					author: 'Test Author',
					authorEmail: 'test-author@mhutchie.com',
					authorDate: 1587559258,
					committer: 'Test Committer',
					committerEmail: 'test-committer@mhutchie.com',
					committerDate: 1587559259,
					signature: null,
					body: 'Commit Message.\nSecond Line.',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'show', '--quiet', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cnXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ceXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%B'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commit details (handling unexpected response format returned by git diff --numstat)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parents: ['a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2'],
					author: 'Test Author',
					authorEmail: 'test-author@mhutchie.com',
					authorDate: 1587559258,
					committer: 'Test Committer',
					committerEmail: 'test-committer@mhutchie.com',
					committerDate: 1587559259,
					signature: null,
					body: 'Commit Message.\nSecond Line.',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: null,
							deletions: null,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: null,
							deletions: null,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'show', '--quiet', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cnXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ceXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%B'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (when thrown by git show)', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by git diff-tree --name-status)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by git diff-tree --numstat)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getCommitDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});
	});

	describe('getStashDetails', () => {
		it('Should return the stash details', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getStashDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', {
				selector: 'refs/stash@{0}',
				baseHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
				untrackedFilesHash: null
			});

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parents: ['a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', 'b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3'],
					author: 'Test Author',
					authorEmail: 'test-author@mhutchie.com',
					authorDate: 1587559258,
					committer: 'Test Committer',
					committerEmail: 'test-committer@mhutchie.com',
					committerDate: 1587559259,
					signature: null,
					body: 'Commit Message.\nSecond Line.',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: 2,
							deletions: 3,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'show', '--quiet', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cnXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ceXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%B'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the stash details (including untracked files)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3 c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4', 'D', 'dir/other-deleted.txt', 'A', 'dir/added.txt', ''].join('\0'));
			mockGitSuccessOnce(['c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4', '0	0	dir/other-deleted.txt', '4	0	dir/added.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getStashDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', {
				selector: 'refs/stash@{0}',
				baseHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
				untrackedFilesHash: 'c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4'
			});

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					parents: ['a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', 'b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3', 'c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4'],
					author: 'Test Author',
					authorEmail: 'test-author@mhutchie.com',
					authorDate: 1587559258,
					committer: 'Test Committer',
					committerEmail: 'test-committer@mhutchie.com',
					committerDate: 1587559259,
					signature: null,
					body: 'Commit Message.\nSecond Line.',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: 2,
							deletions: 3,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						},
						{
							additions: 4,
							deletions: 0,
							newFilePath: 'dir/added.txt',
							oldFilePath: 'dir/added.txt',
							type: 'U'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'show', '--quiet', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--format=%HXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%PXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%anXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%aeXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%atXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%cnXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ceXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%ctXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%B'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-tree', '--name-status', '-r', '--root', '--find-renames', '--diff-filter=AMDR', '-z', 'c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-tree', '--numstat', '-r', '--root', '--find-renames', '--diff-filter=AMDR', '-z', 'c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (when thrown by git show)', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getStashDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', {
				selector: 'refs/stash@{0}',
				baseHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
				untrackedFilesHash: null
			});

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by git diff-tree --name-status)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getStashDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', {
				selector: 'refs/stash@{0}',
				baseHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
				untrackedFilesHash: null
			});

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by git diff-tree --numstat)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getStashDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', {
				selector: 'refs/stash@{0}',
				baseHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
				untrackedFilesHash: null
			});

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by untracked git diff-tree --name-status)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce(['c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4', '0	0	dir/other-deleted.txt', '4	0	dir/added.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getStashDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', {
				selector: 'refs/stash@{0}',
				baseHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
				untrackedFilesHash: 'c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4'
			});

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by untracked git diff-tree --numstat)', async () => {
			// Setup
			mockGitSuccessOnce('1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2bXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPba1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2 b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest AuthorXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-author@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest CommitterXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest-committer@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559259XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbCommit Message.\r\nSecond Line.');
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4', 'D', 'dir/other-deleted.txt', 'A', 'dir/added.txt', ''].join('\0'));
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getStashDetails('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', {
				selector: 'refs/stash@{0}',
				baseHash: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
				untrackedFilesHash: 'c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4'
			});

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});
	});

	describe('getUncommittedDetails', () => {
		it('Should return the uncommitted changes', async () => {
			// Setup
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce([' D dir/deleted.txt', 'M  dir/modified.txt', 'R  dir/renamed-new.txt', 'dir/renamed-old.txt', '?? untracked.txt'].join('\0'));
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);

			// Run
			const result = await dataSource.getUncommittedDetails('/path/to/repo');

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: utils.UNCOMMITTED,
					parents: [],
					author: '',
					authorEmail: '',
					authorDate: 0,
					committer: '',
					committerEmail: '',
					committerDate: 0,
					signature: null,
					body: '',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: 2,
							deletions: 3,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						},
						{
							additions: null,
							deletions: null,
							newFilePath: 'untracked.txt',
							oldFilePath: 'untracked.txt',
							type: 'U'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '-s', '--untracked-files=all', '--porcelain', '-z'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the uncommitted changes (showUntrackedFiles === FALSE)', async () => {
			// Setup
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce([' D dir/deleted.txt', 'M  dir/modified.txt', 'R  dir/renamed-new.txt', 'dir/renamed-old.txt'].join('\0'));
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', false);

			// Run
			const result = await dataSource.getUncommittedDetails('/path/to/repo');

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: utils.UNCOMMITTED,
					parents: [],
					author: '',
					authorEmail: '',
					authorDate: 0,
					committer: '',
					committerEmail: '',
					committerDate: 0,
					signature: null,
					body: '',
					fileChanges: [
						{
							additions: 0,
							deletions: 0,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						},
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: 2,
							deletions: 3,
							newFilePath: 'dir/renamed-new.txt',
							oldFilePath: 'dir/renamed-old.txt',
							type: 'R'
						}
					]
				},
				error: null
			});
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '-s', '--untracked-files=no', '--porcelain', '-z'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the uncommitted changes (halting invalid git status response)', async () => {
			// Setup
			mockGitSuccessOnce(['M', 'dir/modified.txt', ''].join('\0'));
			mockGitSuccessOnce(['1	1	dir/modified.txt', '1	1	modified.txt', ''].join('\0'));
			mockGitSuccessOnce([' D dir/deleted.txt', ' D ', 'M  dir/modified.txt', '?? untracked.txt'].join('\0'));
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);

			// Run
			const result = await dataSource.getUncommittedDetails('/path/to/repo');

			// Assert
			expect(result).toStrictEqual({
				commitDetails: {
					hash: utils.UNCOMMITTED,
					parents: [],
					author: '',
					authorEmail: '',
					authorDate: 0,
					committer: '',
					committerEmail: '',
					committerDate: 0,
					signature: null,
					body: '',
					fileChanges: [
						{
							additions: 1,
							deletions: 1,
							newFilePath: 'dir/modified.txt',
							oldFilePath: 'dir/modified.txt',
							type: 'M'
						},
						{
							additions: null,
							deletions: null,
							newFilePath: 'dir/deleted.txt',
							oldFilePath: 'dir/deleted.txt',
							type: 'D'
						}
					]
				},
				error: null
			});
		});

		it('Should return an error message thrown by git (when thrown by git diff --name-status)', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce([' D dir/deleted.txt', 'M  dir/modified.txt', 'R  dir/renamed-new.txt', 'dir/renamed-old.txt', '?? untracked.txt'].join('\0'));
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);

			// Run
			const result = await dataSource.getUncommittedDetails('/path/to/repo');

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by git diff --numstat)', async () => {
			// Setup
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce([' D dir/deleted.txt', 'M  dir/modified.txt', 'R  dir/renamed-new.txt', 'dir/renamed-old.txt', '?? untracked.txt'].join('\0'));
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);

			// Run
			const result = await dataSource.getUncommittedDetails('/path/to/repo');

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by git status)', async () => {
			// Setup
			mockGitSuccessOnce(['D', 'dir/deleted.txt', 'M', 'dir/modified.txt', 'R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitSuccessOnce(['0	0	dir/deleted.txt', '1	1	dir/modified.txt', '2	3	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getUncommittedDetails('/path/to/repo');

			// Assert
			expect(result).toStrictEqual({
				commitDetails: null,
				error: 'error message'
			});
		});
	});

	describe('getCommitComparison', () => {
		it('Should return the commit comparison (between a commit and the uncommitted changes)', async () => {
			// Setup
			mockGitSuccessOnce(['M', 'dir/modified.txt', 'R051', 'dir/renamed-old.txt', 'dir/renamed-new.txt', 'A', 'added.txt', ''].join('\0'));
			mockGitSuccessOnce(['1	1	dir/modified.txt', '1	2	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', '2	0	added.txt', ''].join('\0'));
			mockGitSuccessOnce(['MM dir/modified.txt', 'A  added.txt', '?? untracked.txt'].join('\0'));
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);

			// Run
			const result = await dataSource.getCommitComparison('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', utils.UNCOMMITTED);

			// Assert
			expect(result).toStrictEqual({
				fileChanges: [
					{
						additions: 1,
						deletions: 1,
						newFilePath: 'dir/modified.txt',
						oldFilePath: 'dir/modified.txt',
						type: 'M'
					},
					{
						additions: 1,
						deletions: 2,
						newFilePath: 'dir/renamed-new.txt',
						oldFilePath: 'dir/renamed-old.txt',
						type: 'R'
					},
					{
						additions: 2,
						deletions: 0,
						newFilePath: 'added.txt',
						oldFilePath: 'added.txt',
						type: 'A'
					},
					{
						additions: null,
						deletions: null,
						newFilePath: 'untracked.txt',
						oldFilePath: 'untracked.txt',
						type: 'U'
					}
				],
				error: null
			});
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['status', '-s', '--untracked-files=all', '--porcelain', '-z'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the commit comparison (between two commits)', async () => {
			// Setup
			mockGitSuccessOnce(['M', 'dir/modified.txt', 'R051', 'dir/renamed-old.txt', 'dir/renamed-new.txt', 'A', 'added.txt', ''].join('\0'));
			mockGitSuccessOnce(['1	1	dir/modified.txt', '1	2	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', '2	0	added.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getCommitComparison('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2');

			// Assert
			expect(result).toStrictEqual({
				fileChanges: [
					{
						additions: 1,
						deletions: 1,
						newFilePath: 'dir/modified.txt',
						oldFilePath: 'dir/modified.txt',
						type: 'M'
					},
					{
						additions: 1,
						deletions: 2,
						newFilePath: 'dir/renamed-new.txt',
						oldFilePath: 'dir/renamed-old.txt',
						type: 'R'
					},
					{
						additions: 2,
						deletions: 0,
						newFilePath: 'added.txt',
						oldFilePath: 'added.txt',
						type: 'A'
					}
				],
				error: null
			});
			expect(spyOnSpawn).toBeCalledTimes(2);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--numstat', '--find-renames', '--diff-filter=AMDR', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (when thrown by git diff --name-status)', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce(['1	1	dir/modified.txt', '1	2	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', '2	0	added.txt', ''].join('\0'));
			mockGitSuccessOnce(['MM dir/modified.txt', 'A  added.txt', '?? untracked.txt'].join('\0'));
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);

			// Run
			const result = await dataSource.getCommitComparison('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', utils.UNCOMMITTED);

			// Assert
			expect(result).toStrictEqual({
				fileChanges: [],
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by git diff --numstat)', async () => {
			// Setup
			mockGitSuccessOnce(['M', 'dir/modified.txt', 'R051', 'dir/renamed-old.txt', 'dir/renamed-new.txt', 'A', 'added.txt', ''].join('\0'));
			mockGitThrowingErrorOnce();
			mockGitSuccessOnce(['MM dir/modified.txt', 'A  added.txt', '?? untracked.txt'].join('\0'));
			vscode.mockExtensionSettingReturnValue('repository.showUntrackedFiles', true);

			// Run
			const result = await dataSource.getCommitComparison('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', utils.UNCOMMITTED);

			// Assert
			expect(result).toStrictEqual({
				fileChanges: [],
				error: 'error message'
			});
		});

		it('Should return an error message thrown by git (when thrown by git status)', async () => {
			// Setup
			mockGitSuccessOnce(['M', 'dir/modified.txt', 'R051', 'dir/renamed-old.txt', 'dir/renamed-new.txt', 'A', 'added.txt', ''].join('\0'));
			mockGitSuccessOnce(['1	1	dir/modified.txt', '1	2	', 'dir/renamed-old.txt', 'dir/renamed-new.txt', '2	0	added.txt', ''].join('\0'));
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getCommitComparison('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', utils.UNCOMMITTED);

			expect(result).toStrictEqual({
				fileChanges: [],
				error: 'error message'
			});
		});
	});

	describe('getCommitFile', () => {
		it('Should return the file contents', async () => {
			// Setup
			mockGitSuccessOnce('File contents.\n');
			vscode.mockExtensionSettingReturnValue('fileEncoding', 'cp1252');
			const spyOnDecode = jest.spyOn(iconv, 'decode');

			// Run
			const result = await dataSource.getCommitFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subdirectory/file.txt');

			// Assert
			expect(result.toString()).toBe('File contents.\n');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b:subdirectory/file.txt'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(vscode.workspace.getConfiguration).toHaveBeenCalledWith('git-graph', {
				scheme: 'file',
				authority: '',
				path: '/path/to/repo',
				query: '',
				fragment: ''
			});
			expect(spyOnDecode).toBeCalledWith(expect.anything(), 'cp1252');
		});

		it('Should return the file contents (falling back to utf8 if the encoding is unknown)', async () => {
			// Setup
			mockGitSuccessOnce('File contents.\n');
			vscode.mockExtensionSettingReturnValue('fileEncoding', 'xyz');
			const spyOnDecode = jest.spyOn(iconv, 'decode');

			// Run
			const result = await dataSource.getCommitFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subdirectory/file.txt');

			// Assert
			expect(result.toString()).toBe('File contents.\n');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b:subdirectory/file.txt'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(vscode.workspace.getConfiguration).toHaveBeenCalledWith('git-graph', {
				scheme: 'file',
				authority: '',
				path: '/path/to/repo',
				query: '',
				fragment: ''
			});
			expect(spyOnDecode).toBeCalledWith(expect.anything(), 'utf8');
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			let errorMessage = null;

			// Run
			await dataSource.getCommitFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'subdirectory/file.txt').catch((error) => errorMessage = error);

			// Assert
			expect(errorMessage).toBe('error message');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['show', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b:subdirectory/file.txt'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});
	});

	describe('getCommitSubject', () => {
		it('Return the commit subject of a commit', async () => {
			// Setup
			mockGitSuccessOnce('A commit  message.\n');

			// Run
			const result = await dataSource.getCommitSubject('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe('A commit message.');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['-c', 'log.showSignature=false', 'log', '--format=%s', '-n', '1', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return NULL when git threw an error', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getCommitSubject('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe(null);
		});
	});

	describe('getRemoteUrl', () => {
		it('Should return the url of the remote', async () => {
			// Setup
			mockGitSuccessOnce('https://github.com/mhutchie/vscode-git-graph.git\n');

			// Run
			const result = await dataSource.getRemoteUrl('/path/to/repo', 'origin');

			// Assert
			expect(result).toBe('https://github.com/mhutchie/vscode-git-graph.git');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['config', '--get', 'remote.origin.url'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return NULL when git threw an error', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getRemoteUrl('/path/to/repo', 'origin');

			// Assert
			expect(result).toBe(null);
		});
	});

	describe('getNewPathOfRenamedFile', () => {
		it('Should return the new path of a file that was renamed', async () => {
			// Setup
			mockGitSuccessOnce(['R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getNewPathOfRenamedFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'dir/renamed-old.txt');

			// Assert
			expect(result).toBe('dir/renamed-new.txt');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=R', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return NULL when a file wasn\'t renamed', async () => {
			// Setup
			mockGitSuccessOnce(['R100', 'dir/renamed-old.txt', 'dir/renamed-new.txt', ''].join('\0'));

			// Run
			const result = await dataSource.getNewPathOfRenamedFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'dir/deleted.txt');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=R', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return NULL when git threw an error', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getNewPathOfRenamedFile('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'dir/deleted.txt');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff', '--name-status', '--find-renames', '--diff-filter=R', '-z', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});
	});

	describe('getTagDetails', () => {
		it('Should return the tag\'s details', async () => {
			// Setup
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '1.7.8' });
			mockGitSuccessOnce('79e88e142b378f41dfd1f82d94209a7a411384edXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest TaggerXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb<test@mhutchie.com>XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbsubject1\r\nsubject2\n\nbody1\nbody2\n\n');

			// Run
			const result = await dataSource.getTagDetails('/path/to/repo', 'tag-name');

			// Assert
			expect(result).toStrictEqual({
				details: {
					hash: '79e88e142b378f41dfd1f82d94209a7a411384ed',
					taggerName: 'Test Tagger',
					taggerEmail: 'test@mhutchie.com',
					taggerDate: 1587559258,
					message: 'subject1\nsubject2\n\nbody1\nbody2',
					signature: null
				},
				error: null
			});
			expect(spyOnSpawn).toHaveBeenCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['for-each-ref', 'refs/tags/tag-name', '--format=%(objectname)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggername)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggeremail)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggerdate:unix)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents:signature)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents)'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the tag\'s details (when email isn\'t enclosed by <>)', async () => {
			// Setup
			mockGitSuccessOnce('79e88e142b378f41dfd1f82d94209a7a411384edXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest TaggerXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtest@mhutchie.comXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbtag-message\n');

			// Run
			const result = await dataSource.getTagDetails('/path/to/repo', 'tag-name');

			// Assert
			expect(result).toStrictEqual({
				details: {
					hash: '79e88e142b378f41dfd1f82d94209a7a411384ed',
					taggerName: 'Test Tagger',
					taggerEmail: 'test@mhutchie.com',
					taggerDate: 1587559258,
					message: 'tag-message',
					signature: null
				},
				error: null
			});
			expect(spyOnSpawn).toHaveBeenCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['for-each-ref', 'refs/tags/tag-name', '--format=%(objectname)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggername)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggeremail)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggerdate:unix)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents:signature)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents)'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the tag\'s details (contents contains separator)', async () => {
			// Setup
			mockGitSuccessOnce('79e88e142b378f41dfd1f82d94209a7a411384edXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest TaggerXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb<test@mhutchie.com>XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbsubject1\r\nsubject2\n\nbody1 XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%\nbody2\n\n');

			// Run
			const result = await dataSource.getTagDetails('/path/to/repo', 'tag-name');

			// Assert
			expect(result).toStrictEqual({
				details: {
					hash: '79e88e142b378f41dfd1f82d94209a7a411384ed',
					taggerName: 'Test Tagger',
					taggerEmail: 'test@mhutchie.com',
					taggerDate: 1587559258,
					message: 'subject1\nsubject2\n\nbody1 XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%\nbody2',
					signature: null
				},
				error: null
			});
			expect(spyOnSpawn).toHaveBeenCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['for-each-ref', 'refs/tags/tag-name', '--format=%(objectname)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggername)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggeremail)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggerdate:unix)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents:signature)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents)'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return the "Incompatible Git Version" error message when viewing tag details and Git is older than 1.7.8', async () => {
			// Setup
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '1.7.7' });

			// Run
			const result = await dataSource.getTagDetails('/path/to/repo', 'tag-name');

			// Assert
			expect(result).toStrictEqual({
				details: null,
				error: 'A newer version of Git (>= 1.7.8) is required for retrieving Tag Details. Git 1.7.7 is currently installed. Please install a newer version of Git to use this feature.'
			});
			expect(spyOnSpawn).toHaveBeenCalledTimes(0);
		});

		it('Should return the "Unable to Find Git" error message when no Git executable is known', async () => {
			// Setup
			dataSource.dispose();
			dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);

			// Run
			const result = await dataSource.getTagDetails('/path/to/repo', 'tag-name');

			// Assert
			expect(result).toStrictEqual({
				details: null,
				error: 'Unable to find a Git executable. Either: Set the Visual Studio Code Setting "git.path" to the path and filename of an existing Git executable, or install Git and restart Visual Studio Code.'
			});
			expect(spyOnSpawn).toHaveBeenCalledTimes(0);
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getTagDetails('/path/to/repo', 'tag-name');

			// Assert
			expect(result).toStrictEqual({
				details: null,
				error: 'error message'
			});
			expect(spyOnSpawn).toHaveBeenCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['for-each-ref', 'refs/tags/tag-name', '--format=%(objectname)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggername)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggeremail)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggerdate:unix)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents:signature)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents)'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		describe('getTagSignature', () => {
			const testParsingGpgStatus = (signatureRecord: string, trustLevel: string, expected: GitSignature) => async () => {
				// Setup
				mockGitSuccessOnce('79e88e142b378f41dfd1f82d94209a7a411384edXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest TaggerXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb<test@mhutchie.com>XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb-----BEGIN PGP SIGNATURE-----\n\n-----END PGP SIGNATURE-----\nXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbsubject1\r\nsubject2\n\nbody1\nbody2\n-----BEGIN PGP SIGNATURE-----\n\n-----END PGP SIGNATURE-----\n\n');
				mockGitSuccessOnce('', '[GNUPG:] NEWSIG\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] SIG_ID abcdefghijklmnopqrstuvwxyza 2021-04-10 1618040201\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n' + signatureRecord + '[GNUPG:] VALIDSIG ABCDEF1234567890ABCDEF1234567890ABCDEF12 2021-04-10 1618040201 0 4 0 1 8 00 ABCDEF1234567890ABCDEF1234567890ABCDEF12\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] ' + trustLevel + ' 0 pgp\r\n[GNUPG:] VERIFICATION_COMPLIANCE_MODE 23\r\n');

				// Run
				const result = await dataSource.getTagDetails('/path/to/repo', 'tag-name');

				// Assert
				expect(result).toStrictEqual({
					details: {
						hash: '79e88e142b378f41dfd1f82d94209a7a411384ed',
						taggerName: 'Test Tagger',
						taggerEmail: 'test@mhutchie.com',
						taggerDate: 1587559258,
						message: 'subject1\nsubject2\n\nbody1\nbody2',
						signature: expected
					},
					error: null
				});
				expect(spyOnSpawn).toHaveBeenCalledTimes(2);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['for-each-ref', 'refs/tags/tag-name', '--format=%(objectname)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggername)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggeremail)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggerdate:unix)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents:signature)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents)'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['verify-tag', '--raw', 'refs/tags/tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			};

			it('Should parse and return a GOODSIG', testParsingGpgStatus('[GNUPG:] GOODSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n', 'TRUST_ULTIMATE', {
				key: '1234567890ABCDEF',
				signer: 'Tagger Name <tagger@mhutchie.com>',
				status: GitSignatureStatus.GoodAndValid
			}));

			it('Should parse and return a BADSIG', testParsingGpgStatus('[GNUPG:] BADSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n', 'TRUST_ULTIMATE', {
				key: '1234567890ABCDEF',
				signer: 'Tagger Name <tagger@mhutchie.com>',
				status: GitSignatureStatus.Bad
			}));

			it('Should parse and return an ERRSIG', testParsingGpgStatus('[GNUPG:] ERRSIG 1234567890ABCDEF 0 1 2 3 4\n', 'TRUST_ULTIMATE', {
				key: '1234567890ABCDEF',
				signer: '',
				status: GitSignatureStatus.CannotBeChecked
			}));

			it('Should parse and return an EXPSIG', testParsingGpgStatus('[GNUPG:] EXPSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n', 'TRUST_ULTIMATE', {
				key: '1234567890ABCDEF',
				signer: 'Tagger Name <tagger@mhutchie.com>',
				status: GitSignatureStatus.GoodButExpired
			}));

			it('Should parse and return an EXPKEYSIG', testParsingGpgStatus('[GNUPG:] EXPKEYSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n', 'TRUST_ULTIMATE', {
				key: '1234567890ABCDEF',
				signer: 'Tagger Name <tagger@mhutchie.com>',
				status: GitSignatureStatus.GoodButMadeByExpiredKey
			}));

			it('Should parse and return a REVKEYSIG', testParsingGpgStatus('[GNUPG:] REVKEYSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n', 'TRUST_ULTIMATE', {
				key: '1234567890ABCDEF',
				signer: 'Tagger Name <tagger@mhutchie.com>',
				status: GitSignatureStatus.GoodButMadeByRevokedKey
			}));

			it('Should parse TRUST_UNDEFINED, and apply it to a GOODSIG', testParsingGpgStatus('[GNUPG:] GOODSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n', 'TRUST_UNDEFINED', {
				key: '1234567890ABCDEF',
				signer: 'Tagger Name <tagger@mhutchie.com>',
				status: GitSignatureStatus.GoodWithUnknownValidity
			}));

			it('Should parse TRUST_NEVER, and apply it to a GOODSIG', testParsingGpgStatus('[GNUPG:] GOODSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n', 'TRUST_NEVER', {
				key: '1234567890ABCDEF',
				signer: 'Tagger Name <tagger@mhutchie.com>',
				status: GitSignatureStatus.GoodWithUnknownValidity
			}));

			it('Should parse TRUST_UNDEFINED, and NOT apply it to a BADSIG', testParsingGpgStatus('[GNUPG:] BADSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n', 'TRUST_UNDEFINED', {
				key: '1234567890ABCDEF',
				signer: 'Tagger Name <tagger@mhutchie.com>',
				status: GitSignatureStatus.Bad
			}));

			it('Should return a signature with status GitSignatureStatus.CannotBeChecked when no signature can be parsed', testParsingGpgStatus('', 'TRUST_ULTIMATE', {
				key: '',
				signer: '',
				status: GitSignatureStatus.CannotBeChecked
			}));

			it('Should return a signature with status GitSignatureStatus.CannotBeChecked when multiple exclusive statuses exist', testParsingGpgStatus(
				'[GNUPG:] GOODSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n[GNUPG:] BADSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n',
				'TRUST_ULTIMATE',
				{
					key: '',
					signer: '',
					status: GitSignatureStatus.CannotBeChecked
				}
			));

			it('Should ignore records that don\'t start with "[GNUPG:]"', testParsingGpgStatus(
				'[XYZ] GOODSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n[GNUPG:] BADSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\n',
				'TRUST_ULTIMATE',
				{
					key: '1234567890ABCDEF',
					signer: 'Tagger Name <tagger@mhutchie.com>',
					status: GitSignatureStatus.Bad
				}
			));

			it('Should parse signatures from stdout when there is not content on stderr (for compatibility - normally output is on stderr)', async () => {
				// Setup
				mockGitSuccessOnce('79e88e142b378f41dfd1f82d94209a7a411384edXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest TaggerXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb<test@mhutchie.com>XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb-----BEGIN PGP SIGNATURE-----\n\n-----END PGP SIGNATURE-----\nXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbsubject1\r\nsubject2\n\nbody1\nbody2\n-----BEGIN PGP SIGNATURE-----\n\n-----END PGP SIGNATURE-----\n\n');
				mockGitSuccessOnce('[GNUPG:] NEWSIG\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] SIG_ID abcdefghijklmnopqrstuvwxyza 2021-04-10 1618040201\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] GOODSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\r\n[GNUPG:] VALIDSIG ABCDEF1234567890ABCDEF1234567890ABCDEF12 2021-04-10 1618040201 0 4 0 1 8 00 ABCDEF1234567890ABCDEF1234567890ABCDEF12\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] TRUST_ULTIMATE 0 pgp\r\n[GNUPG:] VERIFICATION_COMPLIANCE_MODE 23\r\n');

				// Run
				const result = await dataSource.getTagDetails('/path/to/repo', 'tag-name');

				// Assert
				expect(result).toStrictEqual({
					details: {
						hash: '79e88e142b378f41dfd1f82d94209a7a411384ed',
						taggerName: 'Test Tagger',
						taggerEmail: 'test@mhutchie.com',
						taggerDate: 1587559258,
						message: 'subject1\nsubject2\n\nbody1\nbody2',
						signature: {
							key: '1234567890ABCDEF',
							signer: 'Tagger Name <tagger@mhutchie.com>',
							status: GitSignatureStatus.GoodAndValid
						}
					},
					error: null
				});
				expect(spyOnSpawn).toHaveBeenCalledTimes(2);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['for-each-ref', 'refs/tags/tag-name', '--format=%(objectname)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggername)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggeremail)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggerdate:unix)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents:signature)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents)'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['verify-tag', '--raw', 'refs/tags/tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			});

			it('Should parse signatures from stderr, when both stdout & stderr have content (for compatibility - normally output is on stderr)', async () => {
				// Setup
				mockGitSuccessOnce('79e88e142b378f41dfd1f82d94209a7a411384edXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest TaggerXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb<test@mhutchie.com>XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb-----BEGIN PGP SIGNATURE-----\n\n-----END PGP SIGNATURE-----\nXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbsubject1\r\nsubject2\n\nbody1\nbody2\n-----BEGIN PGP SIGNATURE-----\n\n-----END PGP SIGNATURE-----\n\n');
				mockGitSuccessOnce(
					'[GNUPG:] NEWSIG\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] SIG_ID abcdefghijklmnopqrstuvwxyza 2021-04-10 1618040201\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] GOODSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\r\n[GNUPG:] VALIDSIG ABCDEF1234567890ABCDEF1234567890ABCDEF12 2021-04-10 1618040201 0 4 0 1 8 00 ABCDEF1234567890ABCDEF1234567890ABCDEF12\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] TRUST_ULTIMATE 0 pgp\r\n[GNUPG:] VERIFICATION_COMPLIANCE_MODE 23\r\n',
					'[GNUPG:] NEWSIG\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] SIG_ID abcdefghijklmnopqrstuvwxyza 2021-04-10 1618040201\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] BADSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>\r\n[GNUPG:] VALIDSIG ABCDEF1234567890ABCDEF1234567890ABCDEF12 2021-04-10 1618040201 0 4 0 1 8 00 ABCDEF1234567890ABCDEF1234567890ABCDEF12\r\n[GNUPG:] KEY_CONSIDERED ABCDEF1234567890ABCDEF1234567890ABCDEF12 0\r\n[GNUPG:] TRUST_ULTIMATE 0 pgp\r\n[GNUPG:] VERIFICATION_COMPLIANCE_MODE 23\r\n'
				);

				// Run
				const result = await dataSource.getTagDetails('/path/to/repo', 'tag-name');

				// Assert
				expect(result).toStrictEqual({
					details: {
						hash: '79e88e142b378f41dfd1f82d94209a7a411384ed',
						taggerName: 'Test Tagger',
						taggerEmail: 'test@mhutchie.com',
						taggerDate: 1587559258,
						message: 'subject1\nsubject2\n\nbody1\nbody2',
						signature: {
							key: '1234567890ABCDEF',
							signer: 'Tagger Name <tagger@mhutchie.com>',
							status: GitSignatureStatus.Bad
						}
					},
					error: null
				});
				expect(spyOnSpawn).toHaveBeenCalledTimes(2);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['for-each-ref', 'refs/tags/tag-name', '--format=%(objectname)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggername)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggeremail)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggerdate:unix)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents:signature)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents)'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['verify-tag', '--raw', 'refs/tags/tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			});

			it('Should ignore the Git exit code when parsing signatures', async () => {
				// Setup
				mockGitSuccessOnce('79e88e142b378f41dfd1f82d94209a7a411384edXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbTest TaggerXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb<test@mhutchie.com>XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb1587559258XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb-----BEGIN PGP SIGNATURE-----\n\n-----END PGP SIGNATURE-----\nXX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPbsubject1\r\nsubject2\n\nbody1\nbody2\n-----BEGIN PGP SIGNATURE-----\n\n-----END PGP SIGNATURE-----\n\n');
				mockGitThrowingErrorOnce('[GNUPG:] BADSIG 1234567890ABCDEF Tagger Name <tagger@mhutchie.com>');

				// Run
				const result = await dataSource.getTagDetails('/path/to/repo', 'tag-name');

				// Assert
				expect(result).toStrictEqual({
					details: {
						hash: '79e88e142b378f41dfd1f82d94209a7a411384ed',
						taggerName: 'Test Tagger',
						taggerEmail: 'test@mhutchie.com',
						taggerDate: 1587559258,
						message: 'subject1\nsubject2\n\nbody1\nbody2',
						signature: {
							key: '1234567890ABCDEF',
							signer: 'Tagger Name <tagger@mhutchie.com>',
							status: GitSignatureStatus.Bad
						}
					},
					error: null
				});
				expect(spyOnSpawn).toHaveBeenCalledTimes(2);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['for-each-ref', 'refs/tags/tag-name', '--format=%(objectname)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggername)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggeremail)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(taggerdate:unix)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents:signature)XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb%(contents)'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['verify-tag', '--raw', 'refs/tags/tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			});
		});
	});

	describe('getSubmodules', () => {
		let platform: NodeJS.Platform;
		beforeEach(() => {
			platform = process.platform;
			Object.defineProperty(process, 'platform', { value: 'not-windows' });
		});
		afterEach(() => {
			Object.defineProperty(process, 'platform', { value: platform });
		});

		it('Should return no submodules if no .gitmodules file exists', async () => {
			// Setup
			const spyOnReadFile = jest.spyOn(fs, 'readFile');
			spyOnReadFile.mockImplementationOnce((...args) => ((args as unknown) as [fs.PathLike, any, (err: NodeJS.ErrnoException | null, data: Buffer) => void])[2](new Error(), Buffer.alloc(0)));

			// Run
			const result = await dataSource.getSubmodules('/path/to/repo');

			// Assert
			expect(result).toStrictEqual([]);
			const [path, options] = spyOnReadFile.mock.calls[0];
			expect(utils.getPathFromStr(path as string)).toBe('/path/to/repo/.gitmodules');
			expect(options).toStrictEqual({ encoding: 'utf8' });
		});

		it('Should return the submodules when a .gitmodules file exists', async () => {
			// Setup
			const spyOnReadFile = jest.spyOn(fs, 'readFile');
			spyOnReadFile.mockImplementationOnce((...args) => ((args as unknown) as [fs.PathLike, any, (err: NodeJS.ErrnoException | null, data: string) => void])[2](null,
				'[submodule "folder/vscode-git-graph-1"]\n' +
				'	path = folder/vscode-git-graph-1\n' +
				'	url = https://github.com/mhutchie/vscode-git-graph\n' +
				'[submodule "folder/vscode-git-graph-2"]\n' +
				'	path = folder/vscode-git-graph-2\n' +
				'	url = https://github.com/mhutchie/vscode-git-graph\n' +
				'[submodule "folder/vscode-git-graph-3"]\n' +
				'	path = folder/vscode-git-graph-3\n' +
				'	url = https://github.com/mhutchie/vscode-git-graph\n'
			));
			mockGitSuccessOnce('/path/to/repo/folder/vscode-git-graph-1');
			mockGitSuccessOnce('/path/to/repo/folder/vscode-git-graph-2');
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.getSubmodules('/path/to/repo');

			// Assert
			expect(result).toStrictEqual(['/path/to/repo/folder/vscode-git-graph-1', '/path/to/repo/folder/vscode-git-graph-2']);
			const [path, options] = spyOnReadFile.mock.calls[0];
			expect(utils.getPathFromStr(path as string)).toBe('/path/to/repo/.gitmodules');
			expect(options).toStrictEqual({ encoding: 'utf8' });
		});
	});

	describe('repoRoot', () => {
		let platform: NodeJS.Platform;
		beforeEach(() => {
			platform = process.platform;
			Object.defineProperty(process, 'platform', { value: 'not-windows' });
		});
		afterEach(() => {
			Object.defineProperty(process, 'platform', { value: platform });
		});

		it('Should return the same directory when called from the root of the repository', async () => {
			// Setup
			mockGitSuccessOnce('/path/to/repo/root');

			// Run
			const result = await dataSource.repoRoot('/path/to/repo/root');

			// Assert
			expect(result).toBe('/path/to/repo/root');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rev-parse', '--show-toplevel'], expect.objectContaining({ cwd: '/path/to/repo/root' }));
		});

		it('Should return the same directory when called from the a path resolving to the root of the repository', async () => {
			// Setup
			mockGitSuccessOnce('/path/to/repo/root');
			jest.spyOn(utils, 'realpath').mockResolvedValueOnce('/path/to/repo/root');

			// Run
			const result = await dataSource.repoRoot('/path/to/symbolic-repo/root');

			// Assert
			expect(result).toBe('/path/to/symbolic-repo/root');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rev-parse', '--show-toplevel'], expect.objectContaining({ cwd: '/path/to/symbolic-repo/root' }));
		});

		it('Should return the root directory when called from a subdirectory of the repository', async () => {
			// Setup
			mockGitSuccessOnce('/path/to/repo/root');

			// Run
			const result = await dataSource.repoRoot('/path/to/repo/root/subdirectory');

			// Assert
			expect(result).toBe('/path/to/repo/root');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rev-parse', '--show-toplevel'], expect.objectContaining({ cwd: '/path/to/repo/root/subdirectory' }));
		});

		it('Should return the symbolic directory when called from a subdirectory of the repository', async () => {
			// Setup
			mockGitSuccessOnce('/path/to/repo/root');
			jest.spyOn(utils, 'realpath').mockResolvedValueOnce('/path/to/repo/root/subdirectory').mockResolvedValueOnce('/path/to/repo/root');

			// Run
			const result = await dataSource.repoRoot('/path/to/symbolic-repo/root/subdirectory');

			// Assert
			expect(result).toBe('/path/to/symbolic-repo/root');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rev-parse', '--show-toplevel'], expect.objectContaining({ cwd: '/path/to/symbolic-repo/root/subdirectory' }));
		});

		it('Should return the canonical root directory when failed to find match', async () => {
			// Setup
			mockGitSuccessOnce('/other-path');
			jest.spyOn(utils, 'realpath').mockResolvedValueOnce('/another-path');

			// Run
			const result = await dataSource.repoRoot('/path');

			// Assert
			expect(result).toBe('/other-path');
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rev-parse', '--show-toplevel'], expect.objectContaining({ cwd: '/path' }));
		});

		describe('Windows Mapped Network Drive Resolution', () => {
			it('Should not alter non-network share drives', async () => {
				// Setup
				mockGitSuccessOnce('c:/path/to/repo/root');
				Object.defineProperty(process, 'platform', { value: 'win32' });
				const spyOnRealpath = jest.spyOn(utils, 'realpath');

				// Run
				const result = await dataSource.repoRoot('c:/path/to/repo/root');

				// Assert
				expect(result).toBe('c:/path/to/repo/root');
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rev-parse', '--show-toplevel'], expect.objectContaining({ cwd: 'c:/path/to/repo/root' }));
				expect(spyOnRealpath).toHaveBeenCalledTimes(0);
			});

			it('Should resolve the UNC Path Prefix of a path on a network share', async () => {
				// Setup
				mockGitSuccessOnce('//network/drive/path/to/repo/root');
				Object.defineProperty(process, 'platform', { value: 'win32' });
				const spyOnRealpath = jest.spyOn(utils, 'realpath');
				spyOnRealpath.mockResolvedValueOnce('//network/drive/');

				// Run
				const result = await dataSource.repoRoot('a:/path/to/repo/root');

				// Assert
				expect(result).toBe('a:/path/to/repo/root');
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rev-parse', '--show-toplevel'], expect.objectContaining({ cwd: 'a:/path/to/repo/root' }));
				expect(spyOnRealpath).toBeCalledWith('a:/', true);
			});

			it('Should resolve the UNC Path Prefix of a path on a network share (when native realpath doesn\'t return a trailing slash)', async () => {
				// Setup
				mockGitSuccessOnce('//network/drive/path/to/repo/root');
				Object.defineProperty(process, 'platform', { value: 'win32' });
				const spyOnRealpath = jest.spyOn(utils, 'realpath');
				spyOnRealpath.mockResolvedValueOnce('//network/drive');

				// Run
				const result = await dataSource.repoRoot('a:/path/to/repo/root');

				// Assert
				expect(result).toBe('a:/path/to/repo/root');
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rev-parse', '--show-toplevel'], expect.objectContaining({ cwd: 'a:/path/to/repo/root' }));
				expect(spyOnRealpath).toBeCalledWith('a:/', true);
			});

			it('Should not adjust the path if the native realpath can\'t resolve the Mapped Network Drive Letter', async () => {
				// Setup
				mockGitSuccessOnce('//network/drive/path/to/repo/root');
				Object.defineProperty(process, 'platform', { value: 'win32' });
				const spyOnRealpath = jest.spyOn(utils, 'realpath');
				spyOnRealpath.mockResolvedValueOnce('a:/');

				// Run
				const result = await dataSource.repoRoot('a:/path/to/repo/root');

				// Assert
				expect(result).toBe('//network/drive/path/to/repo/root');
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rev-parse', '--show-toplevel'], expect.objectContaining({ cwd: 'a:/path/to/repo/root' }));
				expect(spyOnRealpath).toBeCalledWith('a:/', true);
			});

			it('Should not adjust the path if the native realpath resolves the Mapped Network Drive Letter to a different UNC Path Prefix', async () => {
				// Setup
				mockGitSuccessOnce('//network/drive/path/to/repo/root');
				Object.defineProperty(process, 'platform', { value: 'win32' });
				const spyOnRealpath = jest.spyOn(utils, 'realpath');
				spyOnRealpath.mockResolvedValueOnce('//other/network/drive/');

				// Run
				const result = await dataSource.repoRoot('a:/path/to/repo/root');

				// Assert
				expect(result).toBe('//network/drive/path/to/repo/root');
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rev-parse', '--show-toplevel'], expect.objectContaining({ cwd: 'a:/path/to/repo/root' }));
				expect(spyOnRealpath).toBeCalledWith('a:/', true);
			});
		});

		it('Should return NULL when git threw an error', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.repoRoot('/path/to/repo/root');

			// Assert
			expect(result).toBe(null);
		});
	});

	describe('addRemote', () => {
		it('Should add a remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.addRemote('/path/to/repo', 'origin', 'https://github.com/mhutchie/vscode-git-graph.git', null, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'add', 'origin', 'https://github.com/mhutchie/vscode-git-graph.git'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should add a remote (with a push url)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.addRemote('/path/to/repo', 'origin', 'https://github.com/mhutchie/vscode-git-graph.git', 'https://github.com/mhutchie/vscode-git-graph.git', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(2);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'add', 'origin', 'https://github.com/mhutchie/vscode-git-graph.git'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'set-url', 'origin', '--push', 'https://github.com/mhutchie/vscode-git-graph.git'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should add and fetch a remote', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.addRemote('/path/to/repo', 'origin', 'https://github.com/mhutchie/vscode-git-graph.git', null, true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(2);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'add', 'origin', 'https://github.com/mhutchie/vscode-git-graph.git'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['fetch', 'origin'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (when adding the remote)', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.addRemote('/path/to/repo', 'origin', 'https://github.com/mhutchie/vscode-git-graph.git', null, false);

			// Assert
			expect(result).toBe('error message');
		});

		it('Should return an error message thrown by git (when adding the push url)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.addRemote('/path/to/repo', 'origin', 'https://github.com/mhutchie/vscode-git-graph.git', 'https://github.com/mhutchie/vscode-git-graph.git', true);

			// Assert
			expect(result).toBe('error message');
			expect(spyOnSpawn).toBeCalledTimes(2);
		});
	});

	describe('deleteRemote', () => {
		it('Should delete a remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.deleteRemote('/path/to/repo', 'origin');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'remove', 'origin'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.deleteRemote('/path/to/repo', 'origin');

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('editRemote', () => {
		it('Should rename a remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.editRemote('/path/to/repo', 'old-origin', 'new-origin', '', '', null, null);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'rename', 'old-origin', 'new-origin'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should delete the url of a remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.editRemote('/path/to/repo', 'origin', 'origin', 'https://github.com/mhutchie/vscode-git-graph.git', null, null, null);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'set-url', 'origin', '--delete', 'https://github.com/mhutchie/vscode-git-graph.git'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should add a url to the remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.editRemote('/path/to/repo', 'origin', 'origin', null, 'https://github.com/mhutchie/vscode-git-graph.git', null, null);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'set-url', 'origin', '--add', 'https://github.com/mhutchie/vscode-git-graph.git'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should update the url of a the remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.editRemote('/path/to/repo', 'origin', 'origin', 'https://github.com/mhutchie/vscode-git-graph-old.git', 'https://github.com/mhutchie/vscode-git-graph-new.git', null, null);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'set-url', 'origin', 'https://github.com/mhutchie/vscode-git-graph-new.git', 'https://github.com/mhutchie/vscode-git-graph-old.git'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should delete the push url of a remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.editRemote('/path/to/repo', 'origin', 'origin', null, null, 'https://github.com/mhutchie/vscode-git-graph.git', null);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'set-url', '--push', 'origin', '--delete', 'https://github.com/mhutchie/vscode-git-graph.git'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should add a push url to the remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.editRemote('/path/to/repo', 'origin', 'origin', null, null, null, 'https://github.com/mhutchie/vscode-git-graph.git');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'set-url', '--push', 'origin', '--add', 'https://github.com/mhutchie/vscode-git-graph.git'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should update the push url of a the remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.editRemote('/path/to/repo', 'origin', 'origin', null, null, 'https://github.com/mhutchie/vscode-git-graph-old.git', 'https://github.com/mhutchie/vscode-git-graph-new.git');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'set-url', '--push', 'origin', 'https://github.com/mhutchie/vscode-git-graph-new.git', 'https://github.com/mhutchie/vscode-git-graph-old.git'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (when renaming a remote)', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.editRemote('/path/to/repo', 'old-origin', 'new-origin', '', '', null, null);

			// Assert
			expect(result).toBe('error message');
		});

		it('Should return an error message thrown by git (when adding a url)', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.editRemote('/path/to/repo', 'origin', 'origin', null, 'https://github.com/mhutchie/vscode-git-graph.git', null, null);

			// Assert
			expect(result).toBe('error message');
		});

		it('Should return an error message thrown by git (when adding a push url)', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.editRemote('/path/to/repo', 'origin', 'origin', null, null, null, 'https://github.com/mhutchie/vscode-git-graph.git');

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('pruneRemote', () => {
		it('Should prune a remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pruneRemote('/path/to/repo', 'origin');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['remote', 'prune', 'origin'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.pruneRemote('/path/to/repo', 'origin');

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('addTag', () => {
		it('Should add a lightweight tag to a commit', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.addTag('/path/to/repo', 'tag-name', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', TagType.Lightweight, '', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['tag', 'tag-name', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should add an annotated tag to a commit', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.tags', false);

			// Run
			const result = await dataSource.addTag('/path/to/repo', 'tag-name', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', TagType.Annotated, 'message', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['tag', '-a', 'tag-name', '-m', 'message', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should add a signed tag to a commit', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.tags', true);

			// Run
			const result = await dataSource.addTag('/path/to/repo', 'tag-name', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', TagType.Annotated, 'message', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['tag', '-s', 'tag-name', '-m', 'message', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should force add a tag to a commit', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.tags', false);

			// Run
			const result = await dataSource.addTag('/path/to/repo', 'tag-name', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', TagType.Annotated, 'message', true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['tag', '-f', '-a', 'tag-name', '-m', 'message', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.tags', false);

			// Run
			const result = await dataSource.addTag('/path/to/repo', 'tag-name', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', TagType.Lightweight, '', false);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('deleteTag', () => {
		it('Should delete a tag', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.deleteTag('/path/to/repo', 'tag-name', null);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['tag', '-d', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should delete a tag (also on a remote)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.deleteTag('/path/to/repo', 'tag-name', 'origin');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', '--delete', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['tag', '-d', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (when deleting a tag)', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.deleteTag('/path/to/repo', 'tag-name', null);

			// Assert
			expect(result).toBe('error message');
		});

		it('Should return an error message thrown by git (when deleting a tag also on a remote)', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.deleteTag('/path/to/repo', 'tag-name', 'origin');

			// Assert
			expect(result).toBe('error message');
			expect(spyOnSpawn).toBeCalledTimes(1);
		});
	});

	describe('fetch', () => {
		it('Should fetch all remotes', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.fetch('/path/to/repo', null, false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['fetch', '--all'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should fetch a specific remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.fetch('/path/to/repo', 'origin', false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['fetch', 'origin'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should fetch and prune all remotes', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.fetch('/path/to/repo', null, true, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['fetch', '--all', '--prune'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should fetch and prune all remotes (and prune tags)', async () => {
			// Setup
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '2.17.0' });
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.fetch('/path/to/repo', null, true, true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['fetch', '--all', '--prune', '--prune-tags'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.fetch('/path/to/repo', null, false, false);

			// Assert
			expect(result).toBe('error message');
		});

		it('Should return an error message when pruning tags, but pruning is not enabled (all remotes)', async () => {
			// Setup

			// Run
			const result = await dataSource.fetch('/path/to/repo', null, false, true);

			// Assert
			expect(result).toBe('In order to Prune Tags, pruning must also be enabled when fetching from remote(s).');
		});

		it('Should return an error message when pruning tags, but pruning is not enabled (specific remote)', async () => {
			// Setup

			// Run
			const result = await dataSource.fetch('/path/to/repo', 'origin', false, true);

			// Assert
			expect(result).toBe('In order to Prune Tags, pruning must also be enabled when fetching from a remote.');
		});

		it('Should return an error message when pruning tags when no Git executable is known', async () => {
			// Setup
			dataSource.dispose();
			dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);

			// Run
			const result = await dataSource.fetch('/path/to/repo', null, true, true);

			// Assert
			expect(result).toBe('Unable to find a Git executable. Either: Set the Visual Studio Code Setting "git.path" to the path and filename of an existing Git executable, or install Git and restart Visual Studio Code.');
		});

		it('Should return the "Incompatible Git Version" error message when pruning tags and Git is older than 2.17.0', async () => {
			// Setup
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '2.16.1' });

			// Run
			const result = await dataSource.fetch('/path/to/repo', null, true, true);

			// Assert
			expect(result).toBe('A newer version of Git (>= 2.17.0) is required for pruning tags when fetching. Git 2.16.1 is currently installed. Please install a newer version of Git to use this feature.');
		});
	});

	describe('pushBranch', () => {
		it('Should push a branch to the remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushBranch('/path/to/repo', 'master', 'origin', false, GitPushBranchMode.Normal);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'master'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should push a branch to the remote and set upstream', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushBranch('/path/to/repo', 'master', 'origin', true, GitPushBranchMode.Normal);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'master', '--set-upstream'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should force push a branch to the remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushBranch('/path/to/repo', 'master', 'origin', false, GitPushBranchMode.Force);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'master', '--force'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should force (with lease) push a branch to the remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushBranch('/path/to/repo', 'master', 'origin', false, GitPushBranchMode.ForceWithLease);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'master', '--force-with-lease'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.pushBranch('/path/to/repo', 'master', 'origin', false, GitPushBranchMode.Normal);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('pushBranchToMultipleRemotes', () => {
		it('Should push a branch to one remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushBranchToMultipleRemotes('/path/to/repo', 'master', ['origin'], false, GitPushBranchMode.Normal);

			// Assert
			expect(result).toStrictEqual([null]);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'master'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should push a branch to multiple remotes', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushBranchToMultipleRemotes('/path/to/repo', 'master', ['origin', 'other-origin'], false, GitPushBranchMode.Force);

			// Assert
			expect(result).toStrictEqual([null, null]);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'master', '--force'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'other-origin', 'master', '--force'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should push a branch to multiple remotes, stopping if an error occurs', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.pushBranchToMultipleRemotes('/path/to/repo', 'master', ['origin', 'other-origin', 'another-origin'], true, GitPushBranchMode.Normal);

			// Assert
			expect(result).toStrictEqual([null, 'error message']);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'master', '--set-upstream'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'other-origin', 'master', '--set-upstream'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error when no remotes are specified', async () => {
			// Run
			const result = await dataSource.pushBranchToMultipleRemotes('/path/to/repo', 'master', [], false, GitPushBranchMode.Normal);

			// Assert
			expect(result).toStrictEqual(['No remote(s) were specified to push the branch master to.']);
		});
	});

	describe('pushTag', () => {
		it('Should push a tag to one remote', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushTag('/path/to/repo', 'tag-name', ['origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual([null]);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should push a tag to multiple remotes', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushTag('/path/to/repo', 'tag-name', ['origin', 'other-origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual([null, null]);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'other-origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		describe('Should check that the commit exists on each remote the tag is being pushed to', () => {
			it('Commit exists on all remotes', async () => {
				// Setup
				mockGitSuccessOnce(
					'  origin/master\n' +
					'  other-origin/master\n'
				);
				mockGitSuccessOnce();
				mockGitSuccessOnce();

				// Run
				const result = await dataSource.pushTag('/path/to/repo', 'tag-name', ['origin', 'other-origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false);

				// Assert
				expect(result).toStrictEqual([null, null]);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-r', '--no-color', '--contains=1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'other-origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			});

			it('Commit exists on one remote', async () => {
				// Setup
				mockGitSuccessOnce(
					'  origin/master\n'
				);

				// Run
				const result = await dataSource.pushTag('/path/to/repo', 'tag-name', ['origin', 'other-origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false);

				// Assert
				expect(result).toStrictEqual(['VSCODE_GIT_GRAPH:PUSH_TAG:COMMIT_NOT_ON_REMOTE:[\"other-origin\"]']);
				expect(spyOnSpawn).toHaveBeenCalledTimes(1);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-r', '--no-color', '--contains=1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			});

			it('Commit doesn\'t exist on any remote', async () => {
				// Setup
				mockGitSuccessOnce('');

				// Run
				const result = await dataSource.pushTag('/path/to/repo', 'tag-name', ['origin', 'other-origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false);

				// Assert
				expect(result).toStrictEqual(['VSCODE_GIT_GRAPH:PUSH_TAG:COMMIT_NOT_ON_REMOTE:[\"origin\",\"other-origin\"]']);
				expect(spyOnSpawn).toHaveBeenCalledTimes(1);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-r', '--no-color', '--contains=1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			});

			it('Handles remote branches with symbolic references', async () => {
				// Setup
				mockGitSuccessOnce(
					'  origin/HEAD -> origin/master\n' +
					'  other-origin/master\n'
				);
				mockGitSuccessOnce();
				mockGitSuccessOnce();

				// Run
				const result = await dataSource.pushTag('/path/to/repo', 'tag-name', ['origin', 'other-origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false);

				// Assert
				expect(result).toStrictEqual([null, null]);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-r', '--no-color', '--contains=1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'other-origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			});

			it('Handles remote names that contain slashes', async () => {
				// Setup
				mockGitSuccessOnce(
					'  origin/master\n' +
					'  other/origin/master\n'
				);
				mockGitSuccessOnce();
				mockGitSuccessOnce();

				// Run
				const result = await dataSource.pushTag('/path/to/repo', 'tag-name', ['origin', 'other/origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false);

				// Assert
				expect(result).toStrictEqual([null, null]);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-r', '--no-color', '--contains=1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'other/origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			});

			it('Ignores records that aren\'t branches in the git branch output', async () => {
				// Setup
				mockGitSuccessOnce(
					'  (invalid branch)\n' +
					'  other-origin/master\n'
				);

				// Run
				const result = await dataSource.pushTag('/path/to/repo', 'tag-name', ['origin', 'other-origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false);

				// Assert
				expect(result).toStrictEqual(['VSCODE_GIT_GRAPH:PUSH_TAG:COMMIT_NOT_ON_REMOTE:[\"origin\"]']);
				expect(spyOnSpawn).toHaveBeenCalledTimes(1);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-r', '--no-color', '--contains=1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			});

			it('Ignores when Git throws an exception', async () => {
				// Setup
				mockGitThrowingErrorOnce();
				mockGitSuccessOnce();
				mockGitSuccessOnce();

				// Run
				const result = await dataSource.pushTag('/path/to/repo', 'tag-name', ['origin', 'other-origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false);

				// Assert
				expect(result).toStrictEqual([null, null]);
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-r', '--no-color', '--contains=1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
				expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'other-origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			});
		});

		it('Should push a tag to multiple remotes, stopping if an error occurs', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.pushTag('/path/to/repo', 'tag-name', ['origin', 'other-origin', 'another-origin'], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual([null, 'error message']);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'other-origin', 'tag-name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error when no remotes are specified', async () => {
			// Run
			const result = await dataSource.pushTag('/path/to/repo', 'tag-name', [], '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(result).toStrictEqual(['No remote(s) were specified to push the tag tag-name to.']);
		});
	});

	describe('checkoutBranch', () => {
		it('Should checkout a local branch', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.checkoutBranch('/path/to/repo', 'master', null);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['checkout', 'master'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should checkout a remote branch', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.checkoutBranch('/path/to/repo', 'master', 'origin/master');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['checkout', '-b', 'master', 'origin/master'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.checkoutBranch('/path/to/repo', 'master', null);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('createBranch', () => {
		it('Should create a branch at a commit', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.createBranch('/path/to/repo', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false, false);

			// Assert
			expect(result).toStrictEqual([null]);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should create a branch at a commit, and check it out', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.createBranch('/path/to/repo', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true, false);

			// Assert
			expect(result).toStrictEqual([null]);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['checkout', '-b', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should force create a branch at a commit', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.createBranch('/path/to/repo', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false, true);

			// Assert
			expect(result).toStrictEqual([null]);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-f', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should force create a branch at a commit, and check it out', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.createBranch('/path/to/repo', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true, true);

			// Assert
			expect(result).toStrictEqual([null, null]);
			expect(spyOnSpawn).toBeCalledTimes(2);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-f', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['checkout', 'develop'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.createBranch('/path/to/repo', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', false, false);

			// Assert
			expect(result).toStrictEqual(['error message']);
		});

		it('Should return an error message thrown by git when creating a branch, and not proceed to check out the force-created branch', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.createBranch('/path/to/repo', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true, true);

			// Assert
			expect(result).toStrictEqual(['error message']);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-f', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git when checking out a force-created branch', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.createBranch('/path/to/repo', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true, true);

			// Assert
			expect(result).toStrictEqual([null, 'error message']);
			expect(spyOnSpawn).toBeCalledTimes(2);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-f', 'develop', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['checkout', 'develop'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});
	});

	describe('deleteBranch', () => {
		it('Should delete the branch', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.deleteBranch('/path/to/repo', 'master', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-d', 'master'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should force delete the branch', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.deleteBranch('/path/to/repo', 'master', true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-D', 'master'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.deleteBranch('/path/to/repo', 'master', false);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('deleteRemoteBranch', () => {
		it('Should delete the remote branch', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.deleteRemoteBranch('/path/to/repo', 'develop', 'origin');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', '--delete', 'develop'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should delete the remote tracking branch if the branch is no longer on the remote', async () => {
			// Setup
			mockGitThrowingErrorOnce('remote ref does not exist');
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.deleteRemoteBranch('/path/to/repo', 'develop', 'origin');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['push', 'origin', '--delete', 'develop'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-d', '-r', 'origin/develop'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (while deleting the branch on the remote)', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.deleteRemoteBranch('/path/to/repo', 'develop', 'origin');

			// Assert
			expect(result).toBe('error message');
		});

		it('Should return an error message thrown by git (while deleting the remote tracking branch)', async () => {
			// Setup
			mockGitThrowingErrorOnce('remote ref does not exist');
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.deleteRemoteBranch('/path/to/repo', 'develop', 'origin');

			// Assert
			expect(result).toBe('Branch does not exist on the remote, deleting the remote tracking branch origin/develop.\nerror message');
		});
	});

	describe('fetchIntoLocalBranch', () => {
		it('Should fetch a remote branch into a local branch', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.fetchIntoLocalBranch('/path/to/repo', 'origin', 'master', 'develop', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['fetch', 'origin', 'master:develop'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should (force) fetch a remote branch into a local branch', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.fetchIntoLocalBranch('/path/to/repo', 'origin', 'master', 'develop', true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['fetch', '-f', 'origin', 'master:develop'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.fetchIntoLocalBranch('/path/to/repo', 'origin', 'master', 'develop', false);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('pullBranch', () => {
		it('Should pull a remote branch into the current branch', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['pull', 'origin', 'master'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should pull a remote branch into the current branch (always creating a new commit)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', true, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['pull', 'origin', 'master', '--no-ff'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should pull a remote branch into the current branch (signing the new commit)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', true);

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', true, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['pull', 'origin', 'master', '--no-ff', '-S'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should pull a remote branch into the current branch (squash and staged changes exist)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 f592752b794040422c9d3b884f15564e6143954b 0000000000000000000000000000000000000000 M      README.md');
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);
			vscode.mockExtensionSettingReturnValue('dialog.pullBranch.squashMessageFormat', 'Default');

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', false, true);

			// Assert
			expect(result).toBe(null);
			expect(workspaceConfiguration.get).toBeCalledTimes(3);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashMessageFormat', expect.anything());
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['pull', 'origin', 'master', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['commit', '-m', 'Merge branch \'origin/master\''], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should pull a remote branch into the current branch (squash and staged changes exist, signing merge commit)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 f592752b794040422c9d3b884f15564e6143954b 0000000000000000000000000000000000000000 M      README.md');
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', true);
			vscode.mockExtensionSettingReturnValue('dialog.pullBranch.squashMessageFormat', 'Default');

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', false, true);

			// Assert
			expect(result).toBe(null);
			expect(workspaceConfiguration.get).toBeCalledTimes(3);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.pullBranch.squashMessageFormat', expect.anything());
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['pull', 'origin', 'master', '--squash', '-S'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['commit', '-S', '-m', 'Merge branch \'origin/master\''], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should pull a remote branch into the current branch (squash and no staged changes)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', false, true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(2);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['pull', 'origin', 'master', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should pull a remote branch into the current branch (squash and when diff-index fails)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', false, true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(2);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['pull', 'origin', 'master', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should pull a remote branch into the current branch (ignore create new commit when squashing)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 f592752b794040422c9d3b884f15564e6143954b 0000000000000000000000000000000000000000 M      README.md');
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);
			vscode.mockExtensionSettingReturnValue('dialog.pullBranch.squashMessageFormat', 'Default');

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', true, true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['pull', 'origin', 'master', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['commit', '-m', 'Merge branch \'origin/master\''], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should pull a remote branch into the current branch (squash and staged changes exist, dialog.pullBranch.squashMessageFormat === "Git SQUASH_MSG")', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 f592752b794040422c9d3b884f15564e6143954b 0000000000000000000000000000000000000000 M      README.md');
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);
			vscode.mockExtensionSettingReturnValue('dialog.pullBranch.squashMessageFormat', 'Git SQUASH_MSG');

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', false, true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['pull', 'origin', 'master', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['commit', '--no-edit'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (when pull fails)', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', false, true);

			// Assert
			expect(result).toBe('error message');
			expect(spyOnSpawn).toBeCalledTimes(1);
		});

		it('Should return an error message thrown by git (when commit fails)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 f592752b794040422c9d3b884f15564e6143954b 0000000000000000000000000000000000000000 M      README.md');
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);
			vscode.mockExtensionSettingReturnValue('dialog.pullBranch.squashMessageFormat', 'Default');

			// Run
			const result = await dataSource.pullBranch('/path/to/repo', 'master', 'origin', false, true);

			// Assert
			expect(result).toBe('error message');
			expect(spyOnSpawn).toBeCalledTimes(3);
		});
	});

	describe('renameBranch', () => {
		it('Should rename a branch', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.renameBranch('/path/to/repo', 'old-master', 'new-master');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['branch', '-m', 'old-master', 'new-master'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.renameBranch('/path/to/repo', 'old-master', 'new-master');

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('merge', () => {
		it('Should merge a branch into the current branch', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, false, false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a branch into the current branch (always creating a new commit)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, true, false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop', '--no-ff'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a branch into the current branch (signing the new commit)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', true);

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, true, false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop', '--no-ff', '-S'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a branch into the current branch (squash and staged changes exist)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 f592752b794040422c9d3b884f15564e6143954b 0000000000000000000000000000000000000000 M      README.md');
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);
			vscode.mockExtensionSettingReturnValue('dialog.merge.squashMessageFormat', 'Default');

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, false, true, false);

			// Assert
			expect(result).toBe(null);
			expect(workspaceConfiguration.get).toBeCalledTimes(3);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashMessageFormat', expect.anything());
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['commit', '-m', 'Merge branch \'develop\''], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a remote-tracking branch into the current branch (squash and staged changes exist)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 f592752b794040422c9d3b884f15564e6143954b 0000000000000000000000000000000000000000 M      README.md');
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);
			vscode.mockExtensionSettingReturnValue('dialog.merge.squashMessageFormat', 'Default');

			// Run
			const result = await dataSource.merge('/path/to/repo', 'origin/develop', MergeActionOn.RemoteTrackingBranch, false, true, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'origin/develop', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['commit', '-m', 'Merge remote-tracking branch \'origin/develop\''], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a commit into the current branch (squash and staged changes exist)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b 0000000000000000000000000000000000000000 M      README.md');
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);
			vscode.mockExtensionSettingReturnValue('dialog.merge.squashMessageFormat', 'Default');

			// Run
			const result = await dataSource.merge('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', MergeActionOn.Commit, false, true, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['commit', '-m', 'Merge commit \'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b\''], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a branch into the current branch (squash and staged changes exist, signing merge commit)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 f592752b794040422c9d3b884f15564e6143954b 0000000000000000000000000000000000000000 M      README.md');
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', true);
			vscode.mockExtensionSettingReturnValue('dialog.merge.squashMessageFormat', 'Default');

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, false, true, false);

			// Assert
			expect(result).toBe(null);
			expect(workspaceConfiguration.get).toBeCalledTimes(3);
			expect(workspaceConfiguration.get).toBeCalledWith('dialog.merge.squashMessageFormat', expect.anything());
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop', '--squash', '-S'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['commit', '-S', '-m', 'Merge branch \'develop\''], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a branch into the current branch (squash and staged changes exist, dialog.merge.squashMessageFormat === "Git SQUASH_MSG")', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 f592752b794040422c9d3b884f15564e6143954b 0000000000000000000000000000000000000000 M      README.md');
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);
			vscode.mockExtensionSettingReturnValue('dialog.merge.squashMessageFormat', 'Git SQUASH_MSG');

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, false, true, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['commit', '--no-edit'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a branch into the current branch (squash and no staged changes)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, false, true, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(2);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a branch into the current branch (without committing)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, false, false, true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop', '--no-commit'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a branch into the current branch (squash without committing)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, false, true, true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop', '--squash', '--no-commit'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should merge a branch into the current branch (ignore create new commit when squashing)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, true, true, true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledTimes(1);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop', '--squash', '--no-commit'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git (when merge fails)', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, false, true, false);

			// Assert
			expect(result).toBe('error message');
			expect(spyOnSpawn).toBeCalledTimes(1);
		});

		it('Should return an error message thrown by git (when commit fails)', async () => {
			// Setup
			mockGitSuccessOnce();
			mockGitSuccessOnce(':100644 100644 f592752b794040422c9d3b884f15564e6143954b 0000000000000000000000000000000000000000 M      README.md');
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.merge('/path/to/repo', 'develop', MergeActionOn.Branch, false, true, false);

			// Assert
			expect(result).toBe('error message');
			expect(spyOnSpawn).toBeCalledTimes(3);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['merge', 'develop', '--squash'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['diff-index', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['commit', '-m', 'Merge branch \'develop\''], expect.objectContaining({ cwd: '/path/to/repo' }));
		});
	});

	describe('rebase', () => {
		it('Should rebase the current branch on a branch', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.rebase('/path/to/repo', 'develop', RebaseActionOn.Branch, false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rebase', 'develop'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should rebase the current branch on a branch (ignoring date)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.rebase('/path/to/repo', 'develop', RebaseActionOn.Branch, true, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rebase', 'develop', '--ignore-date'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should rebase the current branch on a branch (signing the new commits)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', true);

			// Run
			const result = await dataSource.rebase('/path/to/repo', 'develop', RebaseActionOn.Branch, false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rebase', 'develop', '-S'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.rebase('/path/to/repo', 'develop', RebaseActionOn.Branch, false, false);

			// Assert
			expect(result).toBe('error message');
		});

		it('Should launch the interactive rebase of the current branch on a branch in a terminal', async () => {
			// Setup
			jest.useFakeTimers();
			const spyOnOpenGitTerminal = jest.spyOn(utils, 'openGitTerminal');
			spyOnOpenGitTerminal.mockReturnValueOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const resultPromise = dataSource.rebase('/path/to/repo', 'develop', RebaseActionOn.Branch, false, true);

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 1000);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();
			const result = await resultPromise;

			// Assert
			expect(result).toBe(null);
			expect(spyOnOpenGitTerminal).toBeCalledWith('/path/to/repo', '/path/to/git', 'rebase --interactive develop', 'Rebase on "develop"');
		});

		it('Should launch the interactive rebase of the current branch on a commit in a terminal', async () => {
			// Setup
			jest.useFakeTimers();
			const spyOnOpenGitTerminal = jest.spyOn(utils, 'openGitTerminal');
			spyOnOpenGitTerminal.mockReturnValueOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const resultPromise = dataSource.rebase('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', RebaseActionOn.Commit, false, true);

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 1000);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();
			const result = await resultPromise;

			// Assert
			expect(result).toBe(null);
			expect(spyOnOpenGitTerminal).toBeCalledWith('/path/to/repo', '/path/to/git', 'rebase --interactive 1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'Rebase on "1a2b3c4d"');
		});

		it('Should launch the interactive rebase of the current branch on a branch in a terminal (signing the new commits)', async () => {
			// Setup
			jest.useFakeTimers();
			const spyOnOpenGitTerminal = jest.spyOn(utils, 'openGitTerminal');
			spyOnOpenGitTerminal.mockReturnValueOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', true);

			// Run
			const resultPromise = dataSource.rebase('/path/to/repo', 'develop', RebaseActionOn.Branch, false, true);

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 1000);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();
			const result = await resultPromise;

			// Assert
			expect(result).toBe(null);
			expect(spyOnOpenGitTerminal).toBeCalledWith('/path/to/repo', '/path/to/git', 'rebase --interactive -S develop', 'Rebase on "develop"');
		});

		it('Should return the "Unable to Find Git" error message when no git executable is known', async () => {
			// Setup
			dataSource.dispose();
			dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.rebase('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', RebaseActionOn.Commit, false, true);

			// Assert
			expect(result).toBe('Unable to find a Git executable. Either: Set the Visual Studio Code Setting "git.path" to the path and filename of an existing Git executable, or install Git and restart Visual Studio Code.');
		});
	});

	describe('archive', () => {
		it('Should create a *.tar archive of a ref', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.archive('/path/to/repo', 'master', '/path/to/output/file.tar', 'tar');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['archive', '--format=tar', '-o', '/path/to/output/file.tar', 'master'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should create a *.zip archive of a ref', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.archive('/path/to/repo', 'master', '/path/to/output/file.zip', 'zip');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['archive', '--format=zip', '-o', '/path/to/output/file.zip', 'master'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.archive('/path/to/repo', 'master', '/path/to/output/file.tar', 'tar');

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('checkoutCommit', () => {
		it('Should checkout a commit', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.checkoutCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['checkout', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.checkoutCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('cherrypickCommit', () => {
		it('Should cherrypick a commit (with a single parent)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.cherrypickCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 0, false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['cherry-pick', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should cherrypick a commit (with multiple parents)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.cherrypickCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 2, false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['cherry-pick', '-m', '2', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should record origin when cherry picking a commit', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.cherrypickCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 0, true, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['cherry-pick', '-x', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should cherrypick a commit (signing the new commit)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', true);

			// Run
			const result = await dataSource.cherrypickCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 0, false, false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['cherry-pick', '-S', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should not commit the cherrypick of a commit', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.cherrypickCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 0, false, true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['cherry-pick', '--no-commit', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.cherrypickCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 0, false, false);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('dropCommit', () => {
		it('Should drop a commit', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.dropCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rebase', '--onto', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should drop a commit (signing any new commits)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', true);

			// Run
			const result = await dataSource.dropCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['rebase', '-S', '--onto', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.dropCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('resetToCommit', () => {
		it('Should perform a hard reset to a commit', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.resetToCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitResetMode.Hard);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reset', '--hard', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should perform a hard reset to a commit', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.resetToCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitResetMode.Mixed);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reset', '--mixed', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should perform a hard reset to a commit', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.resetToCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitResetMode.Soft);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['reset', '--soft', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.resetToCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitResetMode.Hard);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('revertCommit', () => {
		it('Should revert a commit (with a single parent)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.revertCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 0);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['revert', '--no-edit', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should revert a commit (with multiple parents)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.revertCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 2);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['revert', '--no-edit', '-m', '2', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should revert a commit (signing the new commit)', async () => {
			// Setup
			mockGitSuccessOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', true);

			// Run
			const result = await dataSource.revertCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 0);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['revert', '--no-edit', '-S', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();
			vscode.mockExtensionSettingReturnValue('repository.sign.commits', false);

			// Run
			const result = await dataSource.revertCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 2);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('setConfigValue', () => {
		it('Should set a global config value', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.setConfigValue('/path/to/repo', GitConfigKey.UserName, 'Test User Name', GitConfigLocation.Global);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['config', '--global', 'user.name', 'Test User Name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should set a local config value', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.setConfigValue('/path/to/repo', GitConfigKey.UserName, 'Test User Name', GitConfigLocation.Local);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['config', '--local', 'user.name', 'Test User Name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should set a system config value', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.setConfigValue('/path/to/repo', GitConfigKey.UserName, 'Test User Name', GitConfigLocation.System);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['config', '--system', 'user.name', 'Test User Name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.setConfigValue('/path/to/repo', GitConfigKey.UserName, 'Test User Name', GitConfigLocation.Global);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('unsetConfigValue', () => {
		it('Should unset a global config value', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.unsetConfigValue('/path/to/repo', GitConfigKey.UserName, GitConfigLocation.Global);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['config', '--global', '--unset-all', 'user.name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should unset a local config value', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.unsetConfigValue('/path/to/repo', GitConfigKey.UserName, GitConfigLocation.Local);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['config', '--local', '--unset-all', 'user.name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should unset a system config value', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.unsetConfigValue('/path/to/repo', GitConfigKey.UserName, GitConfigLocation.System);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['config', '--system', '--unset-all', 'user.name'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.unsetConfigValue('/path/to/repo', GitConfigKey.UserName, GitConfigLocation.Global);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('cleanUntrackedFiles', () => {
		it('Should clean untracked files', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.cleanUntrackedFiles('/path/to/repo', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['clean', '-f'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should clean untracked files and directories', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.cleanUntrackedFiles('/path/to/repo', true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['clean', '-fd'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.cleanUntrackedFiles('/path/to/repo', false);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('resetFileToRevision', () => {
		it('Should reset file to revision', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.resetFileToRevision('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'path/to/file');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['checkout', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '--', 'path/to/file'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.resetFileToRevision('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', 'path/to/file');

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('applyStash', () => {
		it('Should apply a stash', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.applyStash('/path/to/repo', 'refs/stash@{0}', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['stash', 'apply', 'refs/stash@{0}'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should apply a stash and reinstate the index', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.applyStash('/path/to/repo', 'refs/stash@{0}', true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['stash', 'apply', '--index', 'refs/stash@{0}'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.applyStash('/path/to/repo', 'refs/stash@{0}', false);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('branchFromStash', () => {
		it('Should create a branch from a stash', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.branchFromStash('/path/to/repo', 'refs/stash@{0}', 'stash-branch');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['stash', 'branch', 'stash-branch', 'refs/stash@{0}'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.branchFromStash('/path/to/repo', 'refs/stash@{0}', 'stash-branch');

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('dropStash', () => {
		it('Should drop a stash', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.dropStash('/path/to/repo', 'refs/stash@{0}');

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['stash', 'drop', 'refs/stash@{0}'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.dropStash('/path/to/repo', 'refs/stash@{0}');

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('popStash', () => {
		it('Should pop a stash', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.popStash('/path/to/repo', 'refs/stash@{0}', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['stash', 'pop', 'refs/stash@{0}'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should pop a stash and reinstate the index', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.popStash('/path/to/repo', 'refs/stash@{0}', true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['stash', 'pop', '--index', 'refs/stash@{0}'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.popStash('/path/to/repo', 'refs/stash@{0}', false);

			// Assert
			expect(result).toBe('error message');
		});
	});

	describe('pushStash', () => {
		it('Should push the uncommitted changes to a stash', async () => {
			// Setup
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '2.13.2' });
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushStash('/path/to/repo', '', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['stash', 'push'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should push the uncommitted changes to a stash, and set the message', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushStash('/path/to/repo', 'Stash Message', false);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['stash', 'push', '--message', 'Stash Message'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should push the uncommitted changes (and untracked files) to a stash', async () => {
			// Setup
			mockGitSuccessOnce();

			// Run
			const result = await dataSource.pushStash('/path/to/repo', '', true);

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['stash', 'push', '--include-untracked'], expect.objectContaining({ cwd: '/path/to/repo' }));
		});

		it('Should return an error message thrown by git', async () => {
			// Setup
			mockGitThrowingErrorOnce();

			// Run
			const result = await dataSource.pushStash('/path/to/repo', '', false);

			// Assert
			expect(result).toBe('error message');
		});

		it('Should return the "Unable to Find Git" error message when no git executable is known', async () => {
			// Setup
			dataSource.dispose();
			dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);

			// Run
			const result = await dataSource.pushStash('/path/to/repo', '', false);

			// Assert
			expect(result).toBe('Unable to find a Git executable. Either: Set the Visual Studio Code Setting "git.path" to the path and filename of an existing Git executable, or install Git and restart Visual Studio Code.');
		});

		it('Should return the "Incompatible Git Version" error message when Git is older than 2.13.2', async () => {
			// Setup
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '2.13.1' });

			// Run
			const result = await dataSource.pushStash('/path/to/repo', '', false);

			// Assert
			expect(result).toBe('A newer version of Git (>= 2.13.2) is required for this feature. Git 2.13.1 is currently installed. Please install a newer version of Git to use this feature.');
		});
	});

	describe('openExternalDirDiff', () => {
		it('Should launch a gui directory diff (for one commit)', async () => {
			// Setup
			jest.useFakeTimers();
			mockGitSuccessOnce();

			// Run
			const resultPromise = dataSource.openExternalDirDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', true);

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 1500);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();
			const result = await resultPromise;

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['difftool', '--dir-diff', '-g', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^..1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnLog).toHaveBeenCalledWith('External diff tool is being opened (1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^..1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b)');
			await waitForExpect(() => expect(spyOnLog).toHaveBeenCalledWith('External diff tool has exited (1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b^..1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b)'));
		});

		it('Should launch a gui directory diff (between two commits)', async () => {
			// Setup
			jest.useFakeTimers();
			mockGitSuccessOnce();

			// Run
			const resultPromise = dataSource.openExternalDirDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c', true);

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 1500);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();
			const result = await resultPromise;

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['difftool', '--dir-diff', '-g', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b..2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnLog).toHaveBeenCalledWith('External diff tool is being opened (1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b..2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c)');
			await waitForExpect(() => expect(spyOnLog).toHaveBeenCalledWith('External diff tool has exited (1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b..2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c)'));
		});

		it('Should launch a gui directory diff (for uncommitted changes)', async () => {
			// Setup
			jest.useFakeTimers();
			mockGitSuccessOnce();

			// Run
			const resultPromise = dataSource.openExternalDirDiff('/path/to/repo', utils.UNCOMMITTED, utils.UNCOMMITTED, true);

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 1500);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();
			const result = await resultPromise;

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['difftool', '--dir-diff', '-g', 'HEAD'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnLog).toHaveBeenCalledWith('External diff tool is being opened (HEAD)');
			await waitForExpect(() => expect(spyOnLog).toHaveBeenCalledWith('External diff tool has exited (HEAD)'));
		});

		it('Should launch a gui directory diff (between a commit and the uncommitted changes)', async () => {
			// Setup
			jest.useFakeTimers();
			mockGitSuccessOnce();

			// Run
			const resultPromise = dataSource.openExternalDirDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', utils.UNCOMMITTED, true);

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 1500);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();
			const result = await resultPromise;

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['difftool', '--dir-diff', '-g', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnLog).toHaveBeenCalledWith('External diff tool is being opened (1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b)');
			await waitForExpect(() => expect(spyOnLog).toHaveBeenCalledWith('External diff tool has exited (1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b)'));
		});

		it('Should launch a directory diff in a terminal (between two commits)', async () => {
			// Setup
			jest.useFakeTimers();
			const spyOnOpenGitTerminal = jest.spyOn(utils, 'openGitTerminal');
			spyOnOpenGitTerminal.mockReturnValueOnce();

			// Run
			const resultPromise = dataSource.openExternalDirDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c', false);

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 1500);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();
			const result = await resultPromise;

			// Assert
			expect(result).toBe(null);
			expect(spyOnOpenGitTerminal).toBeCalledWith('/path/to/repo', '/path/to/git', 'difftool --dir-diff 1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b..2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c', 'Open External Directory Diff');
		});

		it('Should return the "Unable to Find Git" error message when no git executable is known', async () => {
			// Setup
			dataSource.dispose();
			dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);

			// Run
			const result = await dataSource.openExternalDirDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c', true);

			// Assert
			expect(result).toBe('Unable to find a Git executable. Either: Set the Visual Studio Code Setting "git.path" to the path and filename of an existing Git executable, or install Git and restart Visual Studio Code.');
		});

		it('Should display the error message when the diff tool doesn\'t exit successfully', async () => {
			// Setup
			jest.useFakeTimers();
			mockGitThrowingErrorOnce('line1\nline2\nline3');
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			const resultPromise = dataSource.openExternalDirDiff('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', utils.UNCOMMITTED, true);

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 1500);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();
			const result = await resultPromise;

			// Assert
			expect(result).toBe(null);
			expect(spyOnSpawn).toBeCalledWith('/path/to/git', ['difftool', '--dir-diff', '-g', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'], expect.objectContaining({ cwd: '/path/to/repo' }));
			expect(spyOnLog).toHaveBeenCalledWith('External diff tool is being opened (1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b)');
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('External diff tool has exited (1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b)');
				expect(spyOnLogError).toBeCalledWith('line1 line2 line3');
				expect(vscode.window.showErrorMessage).toBeCalledWith('line1 line2 line3');
			});
		});
	});

	describe('onDidChangeConfiguration', () => {
		it('Should not trigger Git command formats to be regenerated if they are unaffected by the change', () => {
			// Setup
			const spyOnGenerateGitCommandFormats = jest.spyOn(dataSource as any, 'generateGitCommandFormats');

			// Run
			onDidChangeConfiguration.emit({
				affectsConfiguration: (section) => section === 'git-graph.commitDetailsView.autoCenter'
			});

			// Assert
			expect(spyOnGenerateGitCommandFormats).toHaveBeenCalledTimes(0);
		});
	});

	describe('spawn other error cases', () => {
		it('Should return the "Unable to Find Git" error message when no git executable is known', async () => {
			// Setup
			dataSource.dispose();
			dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);

			// Run
			const result = await dataSource.checkoutCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe('Unable to find a Git executable. Either: Set the Visual Studio Code Setting "git.path" to the path and filename of an existing Git executable, or install Git and restart Visual Studio Code.');
		});

		it('Should resolve child process promise only once with cp error', async () => {
			// Setup
			mockSpyOnSpawn(spyOnSpawn, (onCallbacks, stderrOnCallbacks, stdoutOnCallbacks) => {
				stdoutOnCallbacks['close']();
				stderrOnCallbacks['close']();
				onCallbacks['error'](new Error('error message\r\nsecond line'));
				onCallbacks['exit'](0);
			});

			// Run
			const result = await dataSource.checkoutCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe('error message\nsecond line');
		});

		it('Should return an empty error message thrown by git', async () => {
			// Setup
			mockSpyOnSpawn(spyOnSpawn, (onCallbacks, stderrOnCallbacks, stdoutOnCallbacks) => {
				stdoutOnCallbacks['close']();
				stderrOnCallbacks['close']();
				onCallbacks['exit'](1);
			});

			// Run
			const result = await dataSource.checkoutCommit('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe('');
		});
	});
});
-e 

================================================================================
// FILE: ./tests/mocks/spawn.ts
================================================================================
type OnCallbacks = { [event: string]: (...args: any[]) => void };

export function mockSpyOnSpawn(spyOnSpawn: jest.SpyInstance, callback: (onCallbacks: OnCallbacks, stderrOnCallbacks: OnCallbacks, stdoutOnCallbacks: OnCallbacks) => void) {
	spyOnSpawn.mockImplementationOnce(() => {
		let onCallbacks: OnCallbacks = {}, stderrOnCallbacks: OnCallbacks = {}, stdoutOnCallbacks: OnCallbacks = {};
		setTimeout(() => {
			callback(onCallbacks, stderrOnCallbacks, stdoutOnCallbacks);
		}, 1);
		return {
			on: (event: string, callback: (...args: any[]) => void) => onCallbacks[event] = callback,
			stderr: {
				on: (event: string, callback: (...args: any[]) => void) => stderrOnCallbacks[event] = callback
			},
			stdout: {
				on: (event: string, callback: (...args: any[]) => void) => stdoutOnCallbacks[event] = callback
			}
		};
	});
}
-e 

================================================================================
// FILE: ./tests/mocks/date.ts
================================================================================
const RealDate = Date;
const InitialNow = 1587559258;

export let now = InitialNow;

class MockDate extends RealDate {
	constructor(now: number) {
		super(now);
	}

	public getFullYear() {
		return this.getUTCFullYear();
	}

	public getMonth() {
		return this.getUTCMonth();
	}

	public getDate() {
		return this.getUTCDate();
	}

	public getHours() {
		return this.getUTCHours();
	}

	public getMinutes() {
		return this.getUTCMinutes();
	}

	public getSeconds() {
		return this.getUTCSeconds();
	}

	public getMilliseconds() {
		return this.getUTCMilliseconds();
	}
}

beforeEach(() => {
	// Reset now to its initial value
	now = InitialNow;

	// Override Date
	Date = class extends RealDate {
		constructor() {
			super();
			return new MockDate(now * 1000);
		}
	} as DateConstructor;
});

afterEach(() => {
	Date = RealDate;
});

export function setCurrentTime(newNow: number) {
	now = newNow;
}
-e 

================================================================================
// FILE: ./tests/mocks/vscode.ts
================================================================================
import * as vscode from 'vscode';
import { RequestMessage, ResponseMessage, Writeable } from '../../src/types';


/* Mocks */

const mockedExtensionSettingValues: { [section: string]: any } = {};
const mockedCommands: { [command: string]: (...args: any[]) => any } = {};

interface WebviewPanelMocks {
	messages: ResponseMessage[],
	panel: {
		onDidChangeViewState: (e: vscode.WebviewPanelOnDidChangeViewStateEvent) => any,
		onDidDispose: (e: void) => any,
		setVisibility: (visible: boolean) => void,
		webview: {
			onDidReceiveMessage: (msg: RequestMessage) => void
		}
	}
}

let mockedWebviews: { panel: vscode.WebviewPanel, mocks: WebviewPanelMocks }[] = [];

export const mocks = {
	extensionContext: {
		asAbsolutePath: jest.fn(),
		extensionPath: '/path/to/extension',
		globalState: {
			get: jest.fn(),
			update: jest.fn()
		},
		globalStoragePath: '/path/to/globalStorage',
		logPath: '/path/to/logs',
		storagePath: '/path/to/storage',
		subscriptions: [],
		workspaceState: {
			get: jest.fn(),
			update: jest.fn()
		}
	},
	outputChannel: {
		appendLine: jest.fn(),
		dispose: jest.fn()
	},
	statusBarItem: {
		text: '',
		tooltip: '',
		command: '',
		show: jest.fn(),
		hide: jest.fn(),
		dispose: jest.fn()
	},
	terminal: {
		sendText: jest.fn(),
		show: jest.fn()
	},
	workspaceConfiguration: {
		get: jest.fn((section: string, defaultValue?: any) => {
			return typeof mockedExtensionSettingValues[section] !== 'undefined'
				? mockedExtensionSettingValues[section]
				: defaultValue;
		}),
		inspect: jest.fn((section: string) => ({
			workspaceValue: mockedExtensionSettingValues[section],
			globalValue: mockedExtensionSettingValues[section]
		}))
	}
};


/* Visual Studio Code API Mocks */

export const commands = {
	executeCommand: jest.fn((command: string, ...rest: any[]) => mockedCommands[command](...rest)),
	registerCommand: jest.fn((command: string, callback: (...args: any[]) => any) => {
		mockedCommands[command] = callback;
		return {
			dispose: () => {
				delete mockedCommands[command];
			}
		};
	})
};

export const env = {
	clipboard: {
		writeText: jest.fn()
	},
	openExternal: jest.fn()
};

export const EventEmitter = jest.fn(() => ({
	dispose: jest.fn(),
	event: jest.fn()
}));

export class Uri implements vscode.Uri {
	public readonly scheme: string;
	public readonly authority: string;
	public readonly path: string;
	public readonly query: string;
	public readonly fragment: string;

	protected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string) {
		this.scheme = scheme;
		this.authority = authority || '';
		this.path = path || '';
		this.query = query || '';
		this.fragment = fragment || '';
	}

	get fsPath() {
		return this.path;
	}

	public with(change: { scheme?: string | undefined; authority?: string | undefined; path?: string | undefined; query?: string | undefined; fragment?: string | undefined; }): vscode.Uri {
		return new Uri(change.scheme || this.scheme, change.authority || this.authority, change.path || this.path, change.query || this.query, change.fragment || this.fragment);
	}

	public toString() {
		return this.scheme + '://' + this.path + (this.query ? '?' + this.query : '') + (this.fragment ? '#' + this.fragment : '');
	}

	public toJSON() {
		return this;
	}

	public static file(path: string) {
		return new Uri('file', '', path);
	}

	public static parse(path: string) {
		const comps = path.match(/([a-z]+):\/\/([^?#]+)(\?([^#]+)|())(#(.+)|())/)!;
		return new Uri(comps[1], '', comps[2], comps[4], comps[6]);
	}
}

export enum StatusBarAlignment {
	Left = 1,
	Right = 2
}

export let version = '1.51.0';

export enum ViewColumn {
	Active = -1,
	Beside = -2,
	One = 1,
	Two = 2,
	Three = 3,
	Four = 4,
	Five = 5,
	Six = 6,
	Seven = 7,
	Eight = 8,
	Nine = 9
}

export const window = {
	activeTextEditor: undefined as any,
	createOutputChannel: jest.fn(() => mocks.outputChannel),
	createStatusBarItem: jest.fn(() => mocks.statusBarItem),
	createWebviewPanel: jest.fn(createWebviewPanel),
	createTerminal: jest.fn(() => mocks.terminal),
	showErrorMessage: jest.fn(),
	showInformationMessage: jest.fn(),
	showOpenDialog: jest.fn(),
	showQuickPick: jest.fn(),
	showSaveDialog: jest.fn()
};

export const workspace = {
	createFileSystemWatcher: jest.fn(() => ({
		onDidCreate: jest.fn(),
		onDidChange: jest.fn(),
		onDidDelete: jest.fn(),
		dispose: jest.fn()
	})),
	getConfiguration: jest.fn(() => mocks.workspaceConfiguration),
	onDidChangeWorkspaceFolders: jest.fn((_: () => Promise<void>) => ({ dispose: jest.fn() })),
	onDidCloseTextDocument: jest.fn((_: () => void) => ({ dispose: jest.fn() })),
	workspaceFolders: <{ uri: Uri, index: number }[] | undefined>undefined
};

function createWebviewPanel(viewType: string, title: string, _showOptions: ViewColumn | { viewColumn: ViewColumn, preserveFocus?: boolean }, _options?: vscode.WebviewPanelOptions & vscode.WebviewOptions) {
	const mocks: WebviewPanelMocks = {
		messages: [],
		panel: {
			onDidChangeViewState: () => { },
			onDidDispose: () => { },
			setVisibility: (visible) => {
				webviewPanel.visible = visible;
				mocks.panel.onDidChangeViewState({ webviewPanel: webviewPanel });
			},
			webview: {
				onDidReceiveMessage: () => { }
			}
		}
	};

	const webviewPanel: Writeable<vscode.WebviewPanel> = {
		active: true,
		dispose: jest.fn(),
		iconPath: undefined,
		onDidChangeViewState: jest.fn((onDidChangeViewState) => {
			mocks.panel.onDidChangeViewState = onDidChangeViewState;
			return { dispose: jest.fn() };
		}),
		onDidDispose: jest.fn((onDidDispose) => {
			mocks.panel.onDidDispose = onDidDispose;
			return { dispose: jest.fn() };
		}),
		options: {},
		reveal: jest.fn((_viewColumn?: ViewColumn, _preserveFocus?: boolean) => { }),
		title: title,
		visible: true,
		viewType: viewType,
		webview: {
			asWebviewUri: jest.fn((uri: Uri) => uri.with({ scheme: 'vscode-webview-resource', path: 'file//' + uri.path.replace(/\\/g, '/') })),
			cspSource: 'vscode-webview-resource:',
			html: '',
			onDidReceiveMessage: jest.fn((onDidReceiveMessage) => {
				mocks.panel.webview.onDidReceiveMessage = onDidReceiveMessage;
				return { dispose: jest.fn() };
			}),
			options: {},
			postMessage: jest.fn((msg) => {
				mocks.messages.push(msg);
				return Promise.resolve(true);
			})
		}
	};

	mockedWebviews.push({ panel: webviewPanel, mocks: mocks });
	return webviewPanel;
}


/* Utilities */

beforeEach(() => {
	jest.clearAllMocks();

	window.activeTextEditor = {
		document: {
			uri: Uri.file('/path/to/workspace-folder/active-file.txt')
		},
		viewColumn: ViewColumn.One
	};

	// Clear any mocked extension setting values before each test
	Object.keys(mockedExtensionSettingValues).forEach((section) => {
		delete mockedExtensionSettingValues[section];
	});

	mockedWebviews = [];

	version = '1.51.0';
});

export function mockExtensionSettingReturnValue(section: string, value: any) {
	mockedExtensionSettingValues[section] = value;
}

export function mockVscodeVersion(newVersion: string) {
	version = newVersion;
}

export function getMockedWebviewPanel(i: number) {
	return mockedWebviews[i];
}
-e 

================================================================================
// FILE: ./tests/extensionState.test.ts
================================================================================
import './mocks/date';
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });
jest.mock('fs');

import * as fs from 'fs';
import { ExtensionState } from '../src/extensionState';
import { BooleanOverride, FileViewType, GitGraphViewGlobalState, GitGraphViewWorkspaceState, GitRepoState, RepoCommitOrdering } from '../src/types';
import { GitExecutable } from '../src/utils';
import { EventEmitter } from '../src/utils/event';

let extensionContext = vscode.mocks.extensionContext;
let workspaceConfiguration = vscode.mocks.workspaceConfiguration;
let onDidChangeGitExecutable: EventEmitter<GitExecutable>;

beforeAll(() => {
	onDidChangeGitExecutable = new EventEmitter<GitExecutable>();
});

afterAll(() => {
	onDidChangeGitExecutable.dispose();
});

describe('ExtensionState', () => {
	let extensionState: ExtensionState;
	beforeEach(() => {
		extensionState = new ExtensionState(extensionContext, onDidChangeGitExecutable.subscribe);
	});
	afterEach(() => {
		extensionState.dispose();
	});

	describe('GitExecutable Change Event Processing', () => {
		it('Should subscribe to GitExecutable change events', () => {
			// Assert
			expect(onDidChangeGitExecutable['listeners']).toHaveLength(1);
		});

		it('Should unsubscribe from GitExecutable change events after disposal', () => {
			// Run
			extensionState.dispose();

			// Assert
			expect(onDidChangeGitExecutable['listeners']).toHaveLength(0);
		});

		it('Should save the last known git executable path received from GitExecutable change events', () => {
			// Run
			onDidChangeGitExecutable.emit({ path: '/path/to/git', version: '1.2.3' });

			// Assert
			expect(extensionContext.globalState.update).toHaveBeenCalledWith('lastKnownGitPath', '/path/to/git');
		});
	});

	describe('getRepos', () => {
		it('Should return the stored repositories', () => {
			// Setup
			const repoState: GitRepoState = {
				cdvDivider: 0.5,
				cdvHeight: 250,
				columnWidths: null,
				commitOrdering: RepoCommitOrdering.AuthorDate,
				fileViewType: FileViewType.List,
				hideRemotes: [],
				includeCommitsMentionedByReflogs: BooleanOverride.Enabled,
				issueLinkingConfig: null,
				lastImportAt: 0,
				name: 'Custom Name',
				onlyFollowFirstParent: BooleanOverride.Disabled,
				onRepoLoadShowCheckedOutBranch: BooleanOverride.Enabled,
				onRepoLoadShowSpecificBranches: ['master'],
				pullRequestConfig: null,
				showRemoteBranches: true,
				showRemoteBranchesV2: BooleanOverride.Enabled,
				showStashes: BooleanOverride.Enabled,
				showTags: BooleanOverride.Enabled,
				workspaceFolderIndex: 0
			};
			extensionContext.workspaceState.get.mockReturnValueOnce({
				'/path/to/repo': repoState
			});

			// Run
			const result = extensionState.getRepos();

			// Assert
			expect(result).toStrictEqual({
				'/path/to/repo': repoState
			});
		});

		it('Should assign missing repository state variables to their default values', () => {
			// Setup
			extensionContext.workspaceState.get.mockReturnValueOnce({
				'/path/to/repo': {
					columnWidths: null,
					hideRemotes: []
				}
			});

			// Run
			const result = extensionState.getRepos();

			// Assert
			expect(result).toStrictEqual({
				'/path/to/repo': {
					cdvDivider: 0.5,
					cdvHeight: 250,
					columnWidths: null,
					commitOrdering: RepoCommitOrdering.Default,
					fileViewType: FileViewType.Default,
					hideRemotes: [],
					includeCommitsMentionedByReflogs: BooleanOverride.Default,
					issueLinkingConfig: null,
					lastImportAt: 0,
					name: null,
					onlyFollowFirstParent: BooleanOverride.Default,
					onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
					onRepoLoadShowSpecificBranches: null,
					pullRequestConfig: null,
					showRemoteBranches: true,
					showRemoteBranchesV2: BooleanOverride.Default,
					showStashes: BooleanOverride.Default,
					showTags: BooleanOverride.Default,
					workspaceFolderIndex: null
				}
			});
		});

		it('Should migrate showRemoteBranches = TRUE from boolean to enum (repository.showRemoteBranches = TRUE)', () => {
			// Setup
			extensionContext.workspaceState.get.mockReturnValueOnce({
				'/path/to/repo': {
					showRemoteBranches: true
				}
			});
			vscode.mockExtensionSettingReturnValue('repository.showRemoteBranches', true);

			// Run
			const result = extensionState.getRepos();

			// Assert
			expect(result).toStrictEqual({
				'/path/to/repo': {
					cdvDivider: 0.5,
					cdvHeight: 250,
					columnWidths: null,
					commitOrdering: RepoCommitOrdering.Default,
					fileViewType: FileViewType.Default,
					hideRemotes: [],
					includeCommitsMentionedByReflogs: BooleanOverride.Default,
					issueLinkingConfig: null,
					lastImportAt: 0,
					name: null,
					onlyFollowFirstParent: BooleanOverride.Default,
					onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
					onRepoLoadShowSpecificBranches: null,
					pullRequestConfig: null,
					showRemoteBranches: true,
					showRemoteBranchesV2: BooleanOverride.Default,
					showStashes: BooleanOverride.Default,
					showTags: BooleanOverride.Default,
					workspaceFolderIndex: null
				}
			});
		});

		it('Should migrate showRemoteBranches = FALSE from boolean to enum (repository.showRemoteBranches = TRUE)', () => {
			// Setup
			extensionContext.workspaceState.get.mockReturnValueOnce({
				'/path/to/repo': {
					showRemoteBranches: false
				}
			});
			vscode.mockExtensionSettingReturnValue('repository.showRemoteBranches', true);

			// Run
			const result = extensionState.getRepos();

			// Assert
			expect(result).toStrictEqual({
				'/path/to/repo': {
					cdvDivider: 0.5,
					cdvHeight: 250,
					columnWidths: null,
					commitOrdering: RepoCommitOrdering.Default,
					fileViewType: FileViewType.Default,
					hideRemotes: [],
					includeCommitsMentionedByReflogs: BooleanOverride.Default,
					issueLinkingConfig: null,
					lastImportAt: 0,
					name: null,
					onlyFollowFirstParent: BooleanOverride.Default,
					onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
					onRepoLoadShowSpecificBranches: null,
					pullRequestConfig: null,
					showRemoteBranches: false,
					showRemoteBranchesV2: BooleanOverride.Disabled,
					showStashes: BooleanOverride.Default,
					showTags: BooleanOverride.Default,
					workspaceFolderIndex: null
				}
			});
		});

		it('Should migrate showRemoteBranches = FALSE from boolean to enum (repository.showRemoteBranches = FALSE)', () => {
			// Setup
			extensionContext.workspaceState.get.mockReturnValueOnce({
				'/path/to/repo': {
					showRemoteBranches: false
				}
			});
			vscode.mockExtensionSettingReturnValue('repository.showRemoteBranches', false);

			// Run
			const result = extensionState.getRepos();

			// Assert
			expect(result).toStrictEqual({
				'/path/to/repo': {
					cdvDivider: 0.5,
					cdvHeight: 250,
					columnWidths: null,
					commitOrdering: RepoCommitOrdering.Default,
					fileViewType: FileViewType.Default,
					hideRemotes: [],
					includeCommitsMentionedByReflogs: BooleanOverride.Default,
					issueLinkingConfig: null,
					lastImportAt: 0,
					name: null,
					onlyFollowFirstParent: BooleanOverride.Default,
					onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
					onRepoLoadShowSpecificBranches: null,
					pullRequestConfig: null,
					showRemoteBranches: false,
					showRemoteBranchesV2: BooleanOverride.Default,
					showStashes: BooleanOverride.Default,
					showTags: BooleanOverride.Default,
					workspaceFolderIndex: null
				}
			});
		});

		it('Should migrate showRemoteBranches = TRUE from boolean to enum (repository.showRemoteBranches = FALSE)', () => {
			// Setup
			extensionContext.workspaceState.get.mockReturnValueOnce({
				'/path/to/repo': {
					showRemoteBranches: true
				}
			});
			vscode.mockExtensionSettingReturnValue('repository.showRemoteBranches', false);

			// Run
			const result = extensionState.getRepos();

			// Assert
			expect(result).toStrictEqual({
				'/path/to/repo': {
					cdvDivider: 0.5,
					cdvHeight: 250,
					columnWidths: null,
					commitOrdering: RepoCommitOrdering.Default,
					fileViewType: FileViewType.Default,
					hideRemotes: [],
					includeCommitsMentionedByReflogs: BooleanOverride.Default,
					issueLinkingConfig: null,
					lastImportAt: 0,
					name: null,
					onlyFollowFirstParent: BooleanOverride.Default,
					onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
					onRepoLoadShowSpecificBranches: null,
					pullRequestConfig: null,
					showRemoteBranches: true,
					showRemoteBranchesV2: BooleanOverride.Enabled,
					showStashes: BooleanOverride.Default,
					showTags: BooleanOverride.Default,
					workspaceFolderIndex: null
				}
			});
		});

		it('Should migrate multiple showRemoteBranches from boolean to enum (repository.showRemoteBranches = TRUE)', () => {
			// Setup
			extensionContext.workspaceState.get.mockReturnValueOnce({
				'/path/to/repo-1': {
					showRemoteBranches: true
				},
				'/path/to/repo-2': {
					showRemoteBranches: false
				}
			});
			vscode.mockExtensionSettingReturnValue('repository.showRemoteBranches', true);

			// Run
			const result = extensionState.getRepos();

			// Assert
			expect(result).toStrictEqual({
				'/path/to/repo-1': {
					cdvDivider: 0.5,
					cdvHeight: 250,
					columnWidths: null,
					commitOrdering: RepoCommitOrdering.Default,
					fileViewType: FileViewType.Default,
					hideRemotes: [],
					includeCommitsMentionedByReflogs: BooleanOverride.Default,
					issueLinkingConfig: null,
					lastImportAt: 0,
					name: null,
					onlyFollowFirstParent: BooleanOverride.Default,
					onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
					onRepoLoadShowSpecificBranches: null,
					pullRequestConfig: null,
					showRemoteBranches: true,
					showRemoteBranchesV2: BooleanOverride.Default,
					showStashes: BooleanOverride.Default,
					showTags: BooleanOverride.Default,
					workspaceFolderIndex: null
				},
				'/path/to/repo-2': {
					cdvDivider: 0.5,
					cdvHeight: 250,
					columnWidths: null,
					commitOrdering: RepoCommitOrdering.Default,
					fileViewType: FileViewType.Default,
					hideRemotes: [],
					includeCommitsMentionedByReflogs: BooleanOverride.Default,
					issueLinkingConfig: null,
					lastImportAt: 0,
					name: null,
					onlyFollowFirstParent: BooleanOverride.Default,
					onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
					onRepoLoadShowSpecificBranches: null,
					pullRequestConfig: null,
					showRemoteBranches: false,
					showRemoteBranchesV2: BooleanOverride.Disabled,
					showStashes: BooleanOverride.Default,
					showTags: BooleanOverride.Default,
					workspaceFolderIndex: null
				}
			});
			expect(workspaceConfiguration.get).toHaveBeenCalledTimes(1);
		});

		it('Should return the default value if it is not defined', () => {
			// Setup
			extensionContext.workspaceState.get.mockImplementationOnce((_, defaultValue) => defaultValue);

			// Run
			const result = extensionState.getRepos();

			// Assert
			expect(result).toStrictEqual({});
		});
	});

	describe('saveRepos', () => {
		it('Should store the provided repositories in the workspace state', () => {
			// Setup
			const repos = {};
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			extensionState.saveRepos(repos);

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('repoStates', repos);
		});
	});

	describe('transferRepo', () => {
		it('Should update the last active repo and code reviews with the new repository path', () => {
			// Setup
			extensionContext.workspaceState.get.mockReturnValueOnce('/path/to/repo');
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);
			extensionContext.workspaceState.get.mockReturnValueOnce({
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			});
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			extensionState.transferRepo('/path/to/repo', '/new/path/to/repo');

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenNthCalledWith(1, 'lastActiveRepo', '/new/path/to/repo');
			expect(extensionContext.workspaceState.update).toHaveBeenNthCalledWith(2, 'codeReviews', {
				'/new/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			});
		});

		it('Shouldn\'t update the last active repo or code reviews when no match is found with the transfer repository', () => {
			// Setup
			extensionContext.workspaceState.get.mockReturnValueOnce('/path/to/repo');
			extensionContext.workspaceState.get.mockReturnValueOnce({
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			});

			// Run
			extensionState.transferRepo('/path/to/repo1', '/new/path/to/repo');

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledTimes(0);
		});
	});

	describe('getGlobalViewState', () => {
		it('Should return the stored global view state', () => {
			// Setup
			const globalViewState: GitGraphViewGlobalState = {
				alwaysAcceptCheckoutCommit: true,
				issueLinkingConfig: null,
				pushTagSkipRemoteCheck: false
			};
			extensionContext.globalState.get.mockReturnValueOnce(globalViewState);

			// Run
			const result = extensionState.getGlobalViewState();

			// Assert
			expect(extensionContext.globalState.get).toHaveBeenCalledWith('globalViewState', expect.anything());
			expect(result).toStrictEqual(globalViewState);
		});

		it('Should assign missing global view state variables to their default values', () => {
			// Setup
			extensionContext.globalState.get.mockReturnValueOnce({
				issueLinkingConfig: null
			});

			// Run
			const result = extensionState.getGlobalViewState();

			// Assert
			expect(extensionContext.globalState.get).toHaveBeenCalledWith('globalViewState', expect.anything());
			expect(result).toStrictEqual({
				alwaysAcceptCheckoutCommit: false,
				issueLinkingConfig: null,
				pushTagSkipRemoteCheck: false
			});
		});

		it('Should return the default global view state if it is not defined', () => {
			// Setup
			extensionContext.globalState.get.mockImplementationOnce((_, defaultValue) => defaultValue);

			// Run
			const result = extensionState.getGlobalViewState();

			// Assert
			expect(extensionContext.globalState.get).toHaveBeenCalledWith('globalViewState', expect.anything());
			expect(result).toStrictEqual({
				alwaysAcceptCheckoutCommit: false,
				issueLinkingConfig: null,
				pushTagSkipRemoteCheck: false
			});
		});
	});

	describe('setGlobalViewState', () => {
		it('Should successfully store the global view state', async () => {
			// Setup
			const globalViewState: GitGraphViewGlobalState = {
				alwaysAcceptCheckoutCommit: true,
				issueLinkingConfig: null,
				pushTagSkipRemoteCheck: false
			};
			extensionContext.globalState.update.mockResolvedValueOnce(null);

			// Run
			const result = await extensionState.setGlobalViewState(globalViewState);

			// Assert
			expect(extensionContext.globalState.update).toHaveBeenCalledWith('globalViewState', globalViewState);
			expect(result).toBe(null);
		});

		it('Should return an error message when vscode is unable to store the global view state', async () => {
			// Setup
			const globalViewState: GitGraphViewGlobalState = {
				alwaysAcceptCheckoutCommit: true,
				issueLinkingConfig: null,
				pushTagSkipRemoteCheck: false
			};
			extensionContext.globalState.update.mockRejectedValueOnce(null);

			// Run
			const result = await extensionState.setGlobalViewState(globalViewState);

			// Assert
			expect(extensionContext.globalState.update).toHaveBeenCalledWith('globalViewState', globalViewState);
			expect(result).toBe('Visual Studio Code was unable to save the Git Graph Global State Memento.');
		});
	});

	describe('getWorkspaceViewState', () => {
		it('Should return the stored workspace view state', () => {
			// Setup
			const workspaceViewState: GitGraphViewWorkspaceState = {
				findIsCaseSensitive: true,
				findIsRegex: false,
				findOpenCommitDetailsView: true
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(workspaceViewState);

			// Run
			const result = extensionState.getWorkspaceViewState();

			// Assert
			expect(extensionContext.workspaceState.get).toHaveBeenCalledWith('workspaceViewState', expect.anything());
			expect(result).toStrictEqual(workspaceViewState);
		});

		it('Should assign missing workspace view state variables to their default values', () => {
			// Setup
			extensionContext.workspaceState.get.mockReturnValueOnce({
				findIsCaseSensitive: true,
				findIsRegex: false
			});

			// Run
			const result = extensionState.getWorkspaceViewState();

			// Assert
			expect(extensionContext.workspaceState.get).toHaveBeenCalledWith('workspaceViewState', expect.anything());
			expect(result).toStrictEqual({
				findIsCaseSensitive: true,
				findIsRegex: false,
				findOpenCommitDetailsView: false
			});
		});

		it('Should return the default workspace view state if it is not defined', () => {
			// Setup
			extensionContext.workspaceState.get.mockImplementationOnce((_, defaultValue) => defaultValue);

			// Run
			const result = extensionState.getWorkspaceViewState();

			// Assert
			expect(extensionContext.workspaceState.get).toHaveBeenCalledWith('workspaceViewState', expect.anything());
			expect(result).toStrictEqual({
				findIsCaseSensitive: false,
				findIsRegex: false,
				findOpenCommitDetailsView: false
			});
		});
	});

	describe('setWorkspaceViewState', () => {
		it('Should successfully store the workspace view state', async () => {
			// Setup
			const workspaceViewState: GitGraphViewWorkspaceState = {
				findIsCaseSensitive: true,
				findIsRegex: false,
				findOpenCommitDetailsView: true
			};
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			const result = await extensionState.setWorkspaceViewState(workspaceViewState);

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('workspaceViewState', workspaceViewState);
			expect(result).toBe(null);
		});

		it('Should return an error message when vscode is unable to store the workspace view state', async () => {
			// Setup
			const workspaceViewState: GitGraphViewWorkspaceState = {
				findIsCaseSensitive: true,
				findIsRegex: false,
				findOpenCommitDetailsView: true
			};
			extensionContext.workspaceState.update.mockRejectedValueOnce(null);

			// Run
			const result = await extensionState.setWorkspaceViewState(workspaceViewState);

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('workspaceViewState', workspaceViewState);
			expect(result).toBe('Visual Studio Code was unable to save the Git Graph Workspace State Memento.');
		});
	});

	describe('getIgnoredRepos', () => {
		it('Should return the stored ignored repositories', () => {
			// Setup
			const ignoredRepos = ['/ignored-repo1'];
			extensionContext.workspaceState.get.mockReturnValueOnce(ignoredRepos);

			// Run
			const result = extensionState.getIgnoredRepos();

			// Assert
			expect(extensionContext.workspaceState.get).toHaveBeenCalledWith('ignoredRepos', []);
			expect(result).toBe(ignoredRepos);
		});

		it('Should return the default value if not defined', () => {
			// Setup
			extensionContext.workspaceState.get.mockImplementationOnce((_, defaultValue) => defaultValue);

			// Run
			const result = extensionState.getIgnoredRepos();

			// Assert
			expect(extensionContext.workspaceState.get).toHaveBeenCalledWith('ignoredRepos', []);
			expect(result).toStrictEqual([]);
		});
	});

	describe('setIgnoredRepos', () => {
		it('Should successfully store the ignored repositories', async () => {
			// Setup
			const ignoreRepos = ['/path/to/ignore'];
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			const result = await extensionState.setIgnoredRepos(ignoreRepos);

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('ignoredRepos', ignoreRepos);
			expect(result).toBe(null);
		});

		it('Should return an error message when vscode is unable to store the ignored repositories', async () => {
			// Setup
			const ignoreRepos = ['/path/to/ignore'];
			extensionContext.workspaceState.update.mockRejectedValueOnce(null);

			// Run
			const result = await extensionState.setIgnoredRepos(ignoreRepos);

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('ignoredRepos', ignoreRepos);
			expect(result).toBe('Visual Studio Code was unable to save the Git Graph Workspace State Memento.');
		});
	});

	describe('getLastActiveRepo', () => {
		it('Should return the stored last active repository', () => {
			// Setup
			extensionContext.workspaceState.get.mockReturnValueOnce('/last/active/repo');

			// Run
			const result = extensionState.getLastActiveRepo();

			// Assert
			expect(extensionContext.workspaceState.get).toHaveBeenCalledWith('lastActiveRepo', null);
			expect(result).toBe('/last/active/repo');
		});

		it('Should return the default value if not defined', () => {
			// Setup
			extensionContext.workspaceState.get.mockImplementationOnce((_, defaultValue) => defaultValue);

			// Run
			const result = extensionState.getLastActiveRepo();

			// Assert
			expect(extensionContext.workspaceState.get).toHaveBeenCalledWith('lastActiveRepo', null);
			expect(result).toBe(null);
		});
	});

	describe('setLastActiveRepo', () => {
		it('Should store the last active repository', () => {
			// Setup
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			extensionState.setLastActiveRepo('/path/to/repo');

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('lastActiveRepo', '/path/to/repo');
		});
	});

	describe('getLastKnownGitPath', () => {
		it('Should return the stored last active repository', () => {
			// Setup
			extensionContext.globalState.get.mockReturnValueOnce('/path/to/git');

			// Run
			const result = extensionState.getLastKnownGitPath();

			// Assert
			expect(extensionContext.globalState.get).toHaveBeenCalledWith('lastKnownGitPath', null);
			expect(result).toBe('/path/to/git');
		});

		it('Should return the default value if not defined', () => {
			// Setup
			extensionContext.globalState.get.mockImplementationOnce((_, defaultValue) => defaultValue);

			// Run
			const result = extensionState.getLastKnownGitPath();

			// Assert
			expect(extensionContext.globalState.get).toHaveBeenCalledWith('lastKnownGitPath', null);
			expect(result).toBe(null);
		});
	});

	describe('isAvatarStorageAvailable', () => {
		it('Should return TRUE if the avatar storage folder existed on startup', () => {
			// Setup
			const spyOnStat = jest.spyOn(fs, 'stat');
			spyOnStat.mockImplementationOnce((_, callback) => callback(null, {} as fs.Stats));
			const extensionState = new ExtensionState(extensionContext, onDidChangeGitExecutable.subscribe);

			// Run
			const result = extensionState.isAvatarStorageAvailable();

			// Assert
			expect(spyOnStat.mock.calls[0][0]).toBe('/path/to/globalStorage/avatars');
			expect(result).toBe(true);

			// Teardown
			extensionState.dispose();
		});

		it('Should return TRUE if the avatar storage folder was successfully created', () => {
			// Setup
			jest.spyOn(fs, 'stat').mockImplementationOnce((_, callback) => callback(new Error(), {} as fs.Stats));
			const spyOnMkdir = jest.spyOn(fs, 'mkdir');
			spyOnMkdir.mockImplementation((_, callback) => callback(null));
			const extensionState = new ExtensionState(extensionContext, onDidChangeGitExecutable.subscribe);

			// Run
			const result = extensionState.isAvatarStorageAvailable();

			// Assert
			expect(spyOnMkdir.mock.calls[0][0]).toBe('/path/to/globalStorage');
			expect(spyOnMkdir.mock.calls[1][0]).toBe('/path/to/globalStorage/avatars');
			expect(result).toBe(true);

			// Teardown
			extensionState.dispose();
		});

		it('Should return TRUE if the avatar storage folder was created after the initial stat check', () => {
			// Setup
			jest.spyOn(fs, 'stat').mockImplementationOnce((_, callback) => callback(new Error(), {} as fs.Stats));
			const spyOnMkdir = jest.spyOn(fs, 'mkdir');
			spyOnMkdir.mockImplementation((_, callback) => callback({ code: 'EEXIST' } as NodeJS.ErrnoException));
			const extensionState = new ExtensionState(extensionContext, onDidChangeGitExecutable.subscribe);

			// Run
			const result = extensionState.isAvatarStorageAvailable();

			// Assert
			expect(spyOnMkdir.mock.calls[0][0]).toBe('/path/to/globalStorage');
			expect(spyOnMkdir.mock.calls[1][0]).toBe('/path/to/globalStorage/avatars');
			expect(result).toBe(true);

			// Teardown
			extensionState.dispose();
		});

		it('Should return FALSE if the avatar storage folder could not be created', () => {
			// Setup
			jest.spyOn(fs, 'stat').mockImplementationOnce((_, callback) => callback(new Error(), {} as fs.Stats));
			const spyOnMkdir = jest.spyOn(fs, 'mkdir');
			spyOnMkdir.mockImplementation((_, callback) => callback({} as NodeJS.ErrnoException));
			const extensionState = new ExtensionState(extensionContext, onDidChangeGitExecutable.subscribe);

			// Run
			const result = extensionState.isAvatarStorageAvailable();

			// Assert
			expect(spyOnMkdir.mock.calls[0][0]).toBe('/path/to/globalStorage');
			expect(spyOnMkdir.mock.calls[1][0]).toBe('/path/to/globalStorage/avatars');
			expect(result).toBe(false);

			// Teardown
			extensionState.dispose();
		});
	});

	describe('getAvatarStoragePath', () => {
		it('Should return the avatar storage path', () => {
			// Run
			const result = extensionState.getAvatarStoragePath();

			// Assert
			expect(result).toBe('/path/to/globalStorage/avatars');
		});
	});

	describe('getAvatarCache', () => {
		it('Should return the stored avatar cache', () => {
			// Setup
			const cache = {};
			extensionContext.globalState.get.mockReturnValueOnce(cache);

			// Run
			const result = extensionState.getAvatarCache();

			// Assert
			expect(extensionContext.globalState.get).toHaveBeenCalledWith('avatarCache', {});
			expect(result).toBe(cache);
		});

		it('Should return the default value if not defined', () => {
			// Setup
			extensionContext.globalState.get.mockImplementationOnce((_, defaultValue) => defaultValue);

			// Run
			const result = extensionState.getAvatarCache();

			// Assert
			expect(extensionContext.globalState.get).toHaveBeenCalledWith('avatarCache', {});
			expect(result).toStrictEqual({});
		});
	});

	describe('saveAvatar', () => {
		it('Should save the avatar to the avatar cache', () => {
			// Setup
			const avatar = { image: 'name.jpg', timestamp: 0, identicon: false };
			extensionContext.globalState.get.mockReturnValueOnce({});
			extensionContext.globalState.update.mockResolvedValueOnce(null);

			// Run
			extensionState.saveAvatar('test@example.com', avatar);

			// Assert
			expect(extensionContext.globalState.update).toHaveBeenCalledWith('avatarCache', { 'test@example.com': avatar });
		});
	});

	describe('removeAvatarFromCache', () => {
		it('Should remove an avatar from the cache', () => {
			// Setup
			const avatar = { image: 'name.jpg', timestamp: 0, identicon: false };
			extensionContext.globalState.get.mockReturnValueOnce({
				'test1@example.com': avatar,
				'test2@example.com': avatar
			});
			extensionContext.globalState.update.mockResolvedValueOnce(null);

			// Run
			extensionState.removeAvatarFromCache('test1@example.com');

			// Assert
			expect(extensionContext.globalState.update).toHaveBeenCalledWith('avatarCache', { 'test2@example.com': avatar });
		});
	});

	describe('clearAvatarCache', () => {
		let spyOnReaddir: jest.SpyInstance, spyOnUnlink: jest.SpyInstance;
		beforeAll(() => {
			spyOnReaddir = jest.spyOn(fs, 'readdir');
			spyOnUnlink = jest.spyOn(fs, 'unlink');
		});

		it('Should clear all avatars from the cache and delete all avatars that are currently stored on the file system', async () => {
			// Setup
			extensionContext.globalState.update.mockResolvedValueOnce(null);
			spyOnReaddir.mockImplementationOnce((_, callback) => callback(null, ['file1.jpg', 'file2.jpg']));
			spyOnUnlink.mockImplementationOnce((_, callback) => callback(null));
			spyOnUnlink.mockImplementationOnce((_, callback) => callback(null));

			// Run
			const result = await extensionState.clearAvatarCache();

			// Assert
			expect(result).toBeNull();
			expect(extensionContext.globalState.update).toHaveBeenCalledWith('avatarCache', {});
			expect(spyOnReaddir).toHaveBeenCalledTimes(1);
			expect(spyOnReaddir).toHaveBeenNthCalledWith(1, '/path/to/globalStorage/avatars', expect.anything());
			expect(spyOnUnlink).toHaveBeenCalledTimes(2);
			expect(spyOnUnlink).toHaveBeenNthCalledWith(1, '/path/to/globalStorage/avatars/file1.jpg', expect.anything());
			expect(spyOnUnlink).toHaveBeenNthCalledWith(2, '/path/to/globalStorage/avatars/file2.jpg', expect.anything());
		});

		it('Should skip deleting avatars on the file system if they could not be listed from the file system', async () => {
			// Setup
			extensionContext.globalState.update.mockResolvedValueOnce(null);
			spyOnReaddir.mockImplementationOnce((_, callback) => callback(new Error(), ['file1.jpg', 'file2.jpg']));

			// Run
			const result = await extensionState.clearAvatarCache();

			// Assert
			expect(result).toBeNull();
			expect(extensionContext.globalState.update).toHaveBeenCalledWith('avatarCache', {});
			expect(spyOnReaddir).toHaveBeenCalledTimes(1);
			expect(spyOnReaddir).toHaveBeenNthCalledWith(1, '/path/to/globalStorage/avatars', expect.anything());
			expect(spyOnUnlink).toHaveBeenCalledTimes(0);
		});

		it('Shouldn\'t delete avatars on the file system if globalState.update rejects, and return the error message', async () => {
			// Setup
			extensionContext.globalState.update.mockRejectedValueOnce(null);

			// Run
			const result = await extensionState.clearAvatarCache();

			// Assert
			expect(result).toBe('Visual Studio Code was unable to save the Git Graph Global State Memento.');
			expect(extensionContext.globalState.update).toHaveBeenCalledWith('avatarCache', {});
			expect(spyOnReaddir).not.toHaveBeenCalled();
		});
	});

	describe('startCodeReview', () => {
		it('Should store the code review (in a repository with no prior code reviews)', async () => {
			// Setup
			const codeReviews = {};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			const result = await extensionState.startCodeReview('/path/to/repo', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', ['file2.txt', 'file3.txt'], 'file1.txt');

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			});
			expect(result).toStrictEqual({
				codeReview: {
					id: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
					lastActive: 1587559258000,
					lastViewedFile: 'file1.txt',
					remainingFiles: ['file2.txt', 'file3.txt']
				},
				error: null
			});
		});

		it('Should store the code review (in a repository with a prior code review)', async () => {
			// Setup
			const codeReviews = {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			const result = await extensionState.startCodeReview('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', ['file5.txt', 'file6.txt'], 'file4.txt');

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					},
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: 1587559258000,
						lastViewedFile: 'file4.txt',
						remainingFiles: ['file5.txt', 'file6.txt']
					}
				}
			});
			expect(result).toStrictEqual({
				codeReview: {
					id: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					lastActive: 1587559258000,
					lastViewedFile: 'file4.txt',
					remainingFiles: ['file5.txt', 'file6.txt']
				},
				error: null
			});
		});

		it('Should return an error message when vscode is unable to store the code reviews', async () => {
			// Setup
			const codeReviews = {};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);
			extensionContext.workspaceState.update.mockRejectedValueOnce(null);

			// Run
			const result = await extensionState.startCodeReview('/path/to/repo', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2', ['file2.txt', 'file3.txt'], 'file1.txt');

			// Assert
			expect(result.error).toBe('Visual Studio Code was unable to save the Git Graph Workspace State Memento.');
		});
	});

	describe('endCodeReview', () => {
		it('Should store the updated code reviews, without the code review that was ended (no more code reviews in repo)', async () => {
			// Setup
			const codeReviews = {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			const result = await extensionState.endCodeReview('/path/to/repo', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2');

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {});
			expect(result).toBe(null);
		});

		it('Should store the updated code reviews, without the code review that was ended (more code reviews in repo)', async () => {
			// Setup
			const codeReviews = {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					},
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: 1587559258000,
						lastViewedFile: 'file4.txt',
						remainingFiles: ['file5.txt', 'file6.txt']
					}
				}
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			const result = await extensionState.endCodeReview('/path/to/repo', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2');

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {
				'/path/to/repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: 1587559258000,
						lastViewedFile: 'file4.txt',
						remainingFiles: ['file5.txt', 'file6.txt']
					}
				}
			});
			expect(result).toBe(null);
		});

		it('Should not make changes to the stored code reviews if the code review that was ended no longer exists', async () => {
			// Setup
			const codeReviews = {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			const result = await extensionState.endCodeReview('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			});
			expect(result).toBe(null);
		});

		it('Should return an error message when vscode is unable to store the code reviews', async () => {
			// Setup
			const codeReviews = {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);
			extensionContext.workspaceState.update.mockRejectedValueOnce(null);

			// Run
			const result = await extensionState.endCodeReview('/path/to/repo', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2');

			// Assert
			expect(result).toBe('Visual Studio Code was unable to save the Git Graph Workspace State Memento.');
		});
	});

	describe('getCodeReview', () => {
		it('Should return the code review, and update its last active timestamp', () => {
			// Setup
			const codeReviews = {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559257000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			const result = extensionState.getCodeReview('/path/to/repo', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2');

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			});
			expect(result).toStrictEqual({
				id: 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2',
				lastActive: 1587559258000,
				lastViewedFile: 'file1.txt',
				remainingFiles: ['file2.txt', 'file3.txt']
			});
		});

		it('Should return NULL if no code review could be found in the specified repository', () => {
			// Setup
			const codeReviews = {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559257000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);

			// Run
			const result = extensionState.getCodeReview('/path/to/repo1', 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2');

			// Assert
			expect(result).toBe(null);
		});

		it('Should return NULL if no code review could be found with the specified id', () => {
			// Setup
			const codeReviews = {
				'/path/to/repo': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559257000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);

			// Run
			const result = extensionState.getCodeReview('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');

			// Assert
			expect(result).toBe(null);
		});
	});

	describe('updateCodeReview', () => {
		const repo = '/path/to/repo';
		const id = 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2';
		const startTime = 1587559257000;
		const endTime = startTime + 1000;

		beforeEach(() => {
			const codeReviews = {
				[repo]: {
					[id]: {
						lastActive: startTime,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			};

			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);
		});

		it('Should update the reviewed files and change the last viewed file', async () => {
			// Run
			const result = await extensionState.updateCodeReview(repo, id, ['file3.txt'], 'file2.txt');

			// Asset
			expect(result).toBeNull();
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {
				[repo]: {
					[id]: {
						lastActive: endTime,
						lastViewedFile: 'file2.txt',
						remainingFiles: ['file3.txt']
					}
				}
			});
		});

		it('Should update the reviewed files without changing the last viewed file', async () => {
			// Run
			const result = await extensionState.updateCodeReview(repo, id, ['file3.txt'], null);

			// Assert
			expect(result).toBeNull();
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {
				[repo]: {
					[id]: {
						lastActive: endTime,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file3.txt']
					}
				}
			});
		});

		it('Should update the not reviewed files without changing the last viewed file', async () => {
			// Run
			const result = await extensionState.updateCodeReview(repo, id, ['file2.txt', 'file3.txt', 'file4.txt'], null);

			// Assert
			expect(result).toBeNull();
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {
				[repo]: {
					[id]: {
						lastActive: endTime,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt', 'file4.txt']
					}
				}
			});
		});

		it('Should set the last viewed file', async () => {
			// Run
			const result = await extensionState.updateCodeReview(repo, id, ['file2.txt', 'file3.txt'], 'file2.txt');

			// Assert
			expect(result).toBeNull();
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {
				[repo]: {
					[id]: {
						lastActive: endTime,
						lastViewedFile: 'file2.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			});
		});

		it('Should remove the code review the last file in it has been reviewed', async () => {
			// Run
			const result = await extensionState.updateCodeReview(repo, id, [], null);

			// Assert
			expect(result).toBeNull();
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {});
		});

		it('Shouldn\'t change the state if no code review could be found in the specified repository', async () => {
			// Run
			const result = await extensionState.updateCodeReview(repo + '1', id, ['file3.txt'], null);

			// Assert
			expect(result).toBe('The Code Review could not be found.');
			expect(extensionContext.workspaceState.update).toHaveBeenCalledTimes(0);
		});

		it('Shouldn\'t change the state if no code review could be found with the specified id', async () => {
			// Run
			const result = await extensionState.updateCodeReview(repo, id + '1', ['file3.txt'], null);

			// Assert
			expect(result).toBe('The Code Review could not be found.');
			expect(extensionContext.workspaceState.update).toHaveBeenCalledTimes(0);
		});

		it('Should return an error message when workspaceState.update rejects', async () => {
			// Setup
			extensionContext.workspaceState.update.mockReset();
			extensionContext.workspaceState.update.mockRejectedValueOnce(null);

			// Run
			const result = await extensionState.updateCodeReview(repo, id, ['file3.txt'], 'file2.txt');

			// Asset
			expect(result).toBe('Visual Studio Code was unable to save the Git Graph Workspace State Memento.');
		});
	});

	describe('expireOldCodeReviews', () => {
		it('Should delete all code reviews that have expired', () => {
			// Setup
			const codeReviews = {
				'/path/to/repo1': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					},
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: 0,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				},
				'/path/to/repo2': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 0,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			extensionState.expireOldCodeReviews();

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {
				'/path/to/repo1': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			});
		});

		it('Shouldn\'t make any changes when no repositories have expired', () => {
			// Setup
			const codeReviews = {
				'/path/to/repo1': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					},
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				},
				'/path/to/repo2': {
					'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2': {
						lastActive: 1587559258000,
						lastViewedFile: 'file1.txt',
						remainingFiles: ['file2.txt', 'file3.txt']
					}
				}
			};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);

			// Run
			extensionState.expireOldCodeReviews();

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledTimes(0);
		});
	});

	describe('endAllWorkspaceCodeReviews', () => {
		it('Should store the last active repository', () => {
			// Setup
			extensionContext.workspaceState.update.mockResolvedValueOnce(null);

			// Run
			extensionState.endAllWorkspaceCodeReviews();

			// Assert
			expect(extensionContext.workspaceState.update).toHaveBeenCalledWith('codeReviews', {});
		});
	});

	describe('getCodeReviews', () => {
		it('Should return the stored code reviews', () => {
			// Setup
			const codeReviews = {};
			extensionContext.workspaceState.get.mockReturnValueOnce(codeReviews);

			// Run
			const result = extensionState.getCodeReviews();

			// Assert
			expect(extensionContext.workspaceState.get).toHaveBeenCalledWith('codeReviews', {});
			expect(result).toBe(codeReviews);
		});

		it('Should return the default value if not defined', () => {
			// Setup
			extensionContext.workspaceState.get.mockImplementationOnce((_, defaultValue) => defaultValue);

			// Run
			const result = extensionState.getCodeReviews();

			// Assert
			expect(extensionContext.workspaceState.get).toHaveBeenCalledWith('codeReviews', {});
			expect(result).toStrictEqual({});
		});
	});
});
-e 

================================================================================
// FILE: ./tests/diffDocProvider.test.ts
================================================================================
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });
jest.mock('../src/dataSource');
jest.mock('../src/logger');

import * as path from 'path';
import { ConfigurationChangeEvent } from 'vscode';
import { DataSource } from '../src/dataSource';
import { DiffDocProvider, DiffSide, decodeDiffDocUri, encodeDiffDocUri } from '../src/diffDocProvider';
import { Logger } from '../src/logger';
import { GitFileStatus } from '../src/types';
import { GitExecutable, UNCOMMITTED } from '../src/utils';
import { EventEmitter } from '../src/utils/event';

let onDidChangeConfiguration: EventEmitter<ConfigurationChangeEvent>;
let onDidChangeGitExecutable: EventEmitter<GitExecutable>;
let logger: Logger;
let dataSource: DataSource;

beforeAll(() => {
	onDidChangeConfiguration = new EventEmitter<ConfigurationChangeEvent>();
	onDidChangeGitExecutable = new EventEmitter<GitExecutable>();
	logger = new Logger();
	dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);
});

afterAll(() => {
	dataSource.dispose();
	logger.dispose();
	onDidChangeConfiguration.dispose();
	onDidChangeGitExecutable.dispose();
});

describe('DiffDocProvider', () => {
	it('Should construct a DiffDocProvider, provide a document, and be disposed', async () => {
		// Setup
		const uri = encodeDiffDocUri('/repo', 'path/to/file.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Modified, DiffSide.New);
		jest.spyOn(dataSource, 'getCommitFile').mockResolvedValueOnce('file-contents');

		// Run
		const diffDocProvider = new DiffDocProvider(dataSource);
		const disposables = diffDocProvider['disposables'];
		const docContents = await diffDocProvider.provideTextDocumentContent(uri);

		// Assert
		expect(docContents).toBe('file-contents');
		expect(diffDocProvider['docs'].size).toBe(1);
		expect(diffDocProvider.onDidChange).toBeTruthy();

		// Run
		diffDocProvider.dispose();

		// Assert
		expect(disposables[0].dispose).toHaveBeenCalled();
		expect(disposables[1].dispose).toHaveBeenCalled();
		expect(diffDocProvider['docs'].size).toBe(0);
	});

	it('Should remove a cached document once it is closed', async () => {
		// Setup
		const uri = encodeDiffDocUri('/repo', 'path/to/file.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Modified, DiffSide.New);
		jest.spyOn(dataSource, 'getCommitFile').mockResolvedValueOnce('file-contents');

		let closeTextDocument: (doc: { uri: vscode.Uri }) => void;
		vscode.workspace.onDidCloseTextDocument.mockImplementationOnce((callback: (_: { uri: vscode.Uri }) => void) => {
			closeTextDocument = callback;
			return { dispose: jest.fn() };
		});

		// Run
		const diffDocProvider = new DiffDocProvider(dataSource);
		const docContents = await diffDocProvider.provideTextDocumentContent(uri);

		// Assert
		expect(docContents).toBe('file-contents');
		expect(diffDocProvider['docs'].size).toBe(1);

		// Run
		closeTextDocument!({ uri: uri });

		// Assert
		expect(diffDocProvider['docs'].size).toBe(0);

		// Teardown
		diffDocProvider.dispose();
	});

	it('Should reuse a cached document if it exists', async () => {
		// Setup
		const uri = encodeDiffDocUri('/repo', 'path/to/file.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Modified, DiffSide.New);
		const spyOnGetCommitFile = jest.spyOn(dataSource, 'getCommitFile');
		spyOnGetCommitFile.mockResolvedValueOnce('file-contents');

		// Run
		const diffDocProvider = new DiffDocProvider(dataSource);
		const docContents1 = await diffDocProvider.provideTextDocumentContent(uri);
		const docContents2 = await diffDocProvider.provideTextDocumentContent(uri);

		// Assert
		expect(docContents1).toBe('file-contents');
		expect(docContents2).toBe('file-contents');
		expect(spyOnGetCommitFile).toHaveBeenCalledTimes(1);

		// Teardown
		diffDocProvider.dispose();
	});

	it('Should return an empty document if requested', async () => {
		// Setup
		const uri = encodeDiffDocUri('/repo', 'path/to/file.txt', UNCOMMITTED, GitFileStatus.Deleted, DiffSide.New);

		// Run
		const diffDocProvider = new DiffDocProvider(dataSource);
		const docContents = await diffDocProvider.provideTextDocumentContent(uri);

		// Assert
		expect(docContents).toBe('');

		// Teardown
		diffDocProvider.dispose();
	});

	it('Should display an error message if an error occurred when fetching the file contents from the DataSource, and return an empty document', async () => {
		// Setup
		const uri = encodeDiffDocUri('/repo', 'path/to/file.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Modified, DiffSide.New);
		jest.spyOn(dataSource, 'getCommitFile').mockRejectedValueOnce('error-message');
		vscode.window.showErrorMessage.mockResolvedValue(null);

		// Run
		const diffDocProvider = new DiffDocProvider(dataSource);
		const docContents = await diffDocProvider.provideTextDocumentContent(uri);

		// Assert
		expect(docContents).toBe('');
		expect(vscode.window.showErrorMessage).toBeCalledWith('Unable to retrieve file: error-message');

		// Teardown
		diffDocProvider.dispose();
	});
});

describe('encodeDiffDocUri', () => {
	it('Should return a file URI if requested on uncommitted changes and it is not deleted', () => {
		// Run
		const uri = encodeDiffDocUri('/repo', 'path/to/file.txt', UNCOMMITTED, GitFileStatus.Added, DiffSide.New);

		// Assert
		expect(uri.scheme).toBe('file');
		expect(uri.fsPath).toBe(path.join('/repo', 'path/to/file.txt'));
	});

	it('Should return an empty file URI if requested on a file displayed on the old side of the diff, and it is added', () => {
		// Run
		const uri = encodeDiffDocUri('/repo', 'path/to/file.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Added, DiffSide.Old);

		// Assert
		expect(uri.scheme).toBe('git-graph');
		expect(uri.fsPath).toBe('file');
		expect(uri.query).toBe('eyJmaWxlUGF0aCI6InBhdGgvdG8vZmlsZS50eHQiLCJjb21taXQiOiIxYTJiM2M0ZDVlNmYxYTJiM2M0ZDVlNmYxYTJiM2M0ZDVlNmYxYTJiIiwicmVwbyI6Ii9yZXBvIiwiZXhpc3RzIjpmYWxzZX0=');
	});

	it('Should return an empty file URI if requested on a file displayed on the new side of the diff, and it is deleted', () => {
		// Run
		const uri = encodeDiffDocUri('/repo', 'path/to/file.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Deleted, DiffSide.New);

		// Assert
		expect(uri.scheme).toBe('git-graph');
		expect(uri.fsPath).toBe('file');
		expect(uri.query).toBe('eyJmaWxlUGF0aCI6InBhdGgvdG8vZmlsZS50eHQiLCJjb21taXQiOiIxYTJiM2M0ZDVlNmYxYTJiM2M0ZDVlNmYxYTJiM2M0ZDVlNmYxYTJiIiwicmVwbyI6Ii9yZXBvIiwiZXhpc3RzIjpmYWxzZX0=');
	});

	it('Should return a git-graph URI with the provided file extension', () => {
		// Run
		const uri = encodeDiffDocUri('/repo', 'path/to/file.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Modified, DiffSide.New);

		// Assert
		expect(uri.scheme).toBe('git-graph');
		expect(uri.fsPath).toBe('file.txt');
		expect(uri.query).toBe('eyJmaWxlUGF0aCI6InBhdGgvdG8vZmlsZS50eHQiLCJjb21taXQiOiIxYTJiM2M0ZDVlNmYxYTJiM2M0ZDVlNmYxYTJiM2M0ZDVlNmYxYTJiIiwicmVwbyI6Ii9yZXBvIiwiZXhpc3RzIjp0cnVlfQ==');
	});

	it('Should return a git-graph URI with no file extension when it is not provided', () => {
		// Run
		const uri = encodeDiffDocUri('/repo', 'path/to/file', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Modified, DiffSide.New);

		// Assert
		expect(uri.scheme).toBe('git-graph');
		expect(uri.fsPath).toBe('file');
		expect(uri.query).toBe('eyJmaWxlUGF0aCI6InBhdGgvdG8vZmlsZSIsImNvbW1pdCI6IjFhMmIzYzRkNWU2ZjFhMmIzYzRkNWU2ZjFhMmIzYzRkNWU2ZjFhMmIiLCJyZXBvIjoiL3JlcG8iLCJleGlzdHMiOnRydWV9');
	});
});

describe('decodeDiffDocUri', () => {
	it('Should return the parsed DiffDocUriData from the URI', () => {
		// Run
		const value = decodeDiffDocUri(vscode.Uri.file('file.txt').with({
			scheme: 'git-graph',
			query: 'eyJmaWxlUGF0aCI6InBhdGgvdG8vZmlsZS50eHQiLCJjb21taXQiOiIxYTJiM2M0ZDVlNmYxYTJiM2M0ZDVlNmYxYTJiM2M0ZDVlNmYxYTJiIiwicmVwbyI6Ii9yZXBvIiwiZXhpc3RzIjp0cnVlfQ=='
		}));

		// Assert
		expect(value).toStrictEqual({
			filePath: 'path/to/file.txt',
			commit: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
			repo: '/repo',
			exists: true
		});
	});
});
-e 

================================================================================
// FILE: ./tests/commands.test.ts
================================================================================
import * as date from './mocks/date';
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });
jest.mock('../src/avatarManager');
jest.mock('../src/dataSource');
jest.mock('../src/extensionState');
jest.mock('../src/gitGraphView');
jest.mock('../src/logger');
jest.mock('../src/repoManager');

import * as os from 'os';
import { ConfigurationChangeEvent } from 'vscode';
import { AvatarManager } from '../src/avatarManager';
import { CommandManager } from '../src/commands';
import { DataSource } from '../src/dataSource';
import { DiffSide, encodeDiffDocUri } from '../src/diffDocProvider';
import { ExtensionState } from '../src/extensionState';
import { GitGraphView } from '../src/gitGraphView';
import { Logger } from '../src/logger';
import { RepoManager } from '../src/repoManager';
import { GitFileStatus, RepoDropdownOrder } from '../src/types';
import * as utils from '../src/utils';
import { EventEmitter } from '../src/utils/event';

import { waitForExpect } from './helpers/expectations';
import { mockRepoState } from './helpers/utils';

let onDidChangeConfiguration: EventEmitter<ConfigurationChangeEvent>;
let onDidChangeGitExecutable: EventEmitter<utils.GitExecutable>;
let logger: Logger;
let dataSource: DataSource;
let extensionState: ExtensionState;
let avatarManager: AvatarManager;
let repoManager: RepoManager;
let spyOnGitGraphViewCreateOrShow: jest.SpyInstance, spyOnGetRepos: jest.SpyInstance, spyOnGetKnownRepo: jest.SpyInstance, spyOnRegisterRepo: jest.SpyInstance, spyOnGetCodeReviews: jest.SpyInstance, spyOnEndCodeReview: jest.SpyInstance, spyOnGetCommitSubject: jest.SpyInstance, spyOnLog: jest.SpyInstance, spyOnLogError: jest.SpyInstance;
beforeAll(() => {
	onDidChangeConfiguration = new EventEmitter<ConfigurationChangeEvent>();
	onDidChangeGitExecutable = new EventEmitter<utils.GitExecutable>();
	logger = new Logger();
	dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);
	extensionState = new ExtensionState(vscode.mocks.extensionContext, onDidChangeGitExecutable.subscribe);
	avatarManager = new AvatarManager(dataSource, extensionState, logger);
	repoManager = new RepoManager(dataSource, extensionState, onDidChangeConfiguration.subscribe, logger);
	spyOnGitGraphViewCreateOrShow = jest.spyOn(GitGraphView, 'createOrShow');
	spyOnGetRepos = jest.spyOn(repoManager, 'getRepos');
	spyOnGetKnownRepo = jest.spyOn(repoManager, 'getKnownRepo');
	spyOnRegisterRepo = jest.spyOn(repoManager, 'registerRepo');
	spyOnGetCodeReviews = jest.spyOn(extensionState, 'getCodeReviews');
	spyOnEndCodeReview = jest.spyOn(extensionState, 'endCodeReview');
	spyOnGetCommitSubject = jest.spyOn(dataSource, 'getCommitSubject');
	spyOnLog = jest.spyOn(logger, 'log');
	spyOnLogError = jest.spyOn(logger, 'logError');
});

afterAll(() => {
	repoManager.dispose();
	avatarManager.dispose();
	extensionState.dispose();
	dataSource.dispose();
	logger.dispose();
	onDidChangeConfiguration.dispose();
	onDidChangeGitExecutable.dispose();
});

describe('CommandManager', () => {
	let commandManager: CommandManager;
	beforeEach(() => {
		commandManager = new CommandManager(vscode.mocks.extensionContext, avatarManager, dataSource, extensionState, repoManager, { path: '/path/to/git', version: '2.25.0' }, onDidChangeGitExecutable.subscribe, logger);
	});
	afterEach(() => {
		commandManager.dispose();
	});

	it('Should construct a CommandManager, and be disposed', () => {
		// Assert
		expect(commandManager['disposables']).toHaveLength(11);
		expect(commandManager['gitExecutable']).toStrictEqual({
			path: '/path/to/git',
			version: '2.25.0'
		});

		// Run
		commandManager.dispose();

		// Assert
		expect(commandManager['disposables']).toHaveLength(0);
	});

	it('Should process onDidChangeGitExecutable events', () => {
		// Run
		onDidChangeGitExecutable.emit({
			path: '/path/to/other-git',
			version: '2.26.0'
		});

		// Assert
		expect(commandManager['gitExecutable']).toStrictEqual({
			path: '/path/to/other-git',
			version: '2.26.0'
		});
	});

	describe('git-graph:codiconsSupported', () => {
		it('Should set git-graph:codiconsSupported to TRUE when vscode.version >= 1.42.0', async () => {
			// Setup
			commandManager.dispose();
			vscode.mockVscodeVersion('1.42.0');
			const spyOnExecuteCommand = jest.spyOn(vscode.commands, 'executeCommand');
			vscode.commands.executeCommand.mockResolvedValueOnce(null);

			// Run
			commandManager = new CommandManager(vscode.mocks.extensionContext, avatarManager, dataSource, extensionState, repoManager, { path: '/path/to/git', version: '2.25.0' }, onDidChangeGitExecutable.subscribe, logger);

			// Assert
			await waitForExpect(() => {
				expect(spyOnExecuteCommand).toHaveBeenCalledWith('setContext', 'git-graph:codiconsSupported', true);
				expect(spyOnLog).toHaveBeenCalledWith('Successfully set Visual Studio Code Context "git-graph:codiconsSupported" to "true"');
			});
		});

		it('Should set git-graph:codiconsSupported to FALSE when vscode.version < 1.42.0', async () => {
			// Setup
			commandManager.dispose();
			vscode.mockVscodeVersion('1.41.1');
			const spyOnExecuteCommand = jest.spyOn(vscode.commands, 'executeCommand');
			vscode.commands.executeCommand.mockResolvedValueOnce(null);

			// Run
			commandManager = new CommandManager(vscode.mocks.extensionContext, avatarManager, dataSource, extensionState, repoManager, { path: '/path/to/git', version: '2.25.0' }, onDidChangeGitExecutable.subscribe, logger);

			// Assert
			await waitForExpect(() => {
				expect(spyOnExecuteCommand).toHaveBeenCalledWith('setContext', 'git-graph:codiconsSupported', false);
				expect(spyOnLog).toHaveBeenCalledWith('Successfully set Visual Studio Code Context "git-graph:codiconsSupported" to "false"');
			});
		});

		it('Should log an error message when vscode.commands.executeCommand rejects', async () => {
			// Setup
			commandManager.dispose();
			const spyOnExecuteCommand = jest.spyOn(vscode.commands, 'executeCommand');

			vscode.commands.executeCommand.mockRejectedValueOnce(null);

			// Run
			commandManager = new CommandManager(vscode.mocks.extensionContext, avatarManager, dataSource, extensionState, repoManager, { path: '/path/to/git', version: '2.25.0' }, onDidChangeGitExecutable.subscribe, logger);

			// Assert
			await waitForExpect(() => {
				expect(spyOnExecuteCommand).toHaveBeenCalledWith('setContext', 'git-graph:codiconsSupported', true);
				expect(spyOnLogError).toHaveBeenCalledWith('Failed to set Visual Studio Code Context "git-graph:codiconsSupported" to "true"');
			});
		});

		it('Should log an error message when an exception is thrown', async () => {
			// Setup
			commandManager.dispose();
			const spyOnExecuteCommand = jest.spyOn(vscode.commands, 'executeCommand');
			const spyOnDoesVersionMeetRequirement = jest.spyOn(utils, 'doesVersionMeetRequirement');
			const spyOnLogError = jest.spyOn(logger, 'logError');
			vscode.commands.executeCommand.mockRejectedValueOnce(null);
			spyOnDoesVersionMeetRequirement.mockImplementationOnce(() => {
				throw new Error();
			});

			// Run
			commandManager = new CommandManager(vscode.mocks.extensionContext, avatarManager, dataSource, extensionState, repoManager, { path: '/path/to/git', version: '2.25.0' }, onDidChangeGitExecutable.subscribe, logger);

			// Assert
			await waitForExpect(() => {
				expect(spyOnExecuteCommand).toHaveBeenCalledWith('setContext', 'git-graph:codiconsSupported', true);
				expect(spyOnLogError).toHaveBeenCalledWith('Unable to set Visual Studio Code Context "git-graph:codiconsSupported"');
			});
		});
	});

	describe('git-graph.view', () => {
		it('Should open the Git Graph View', async () => {
			// Setup
			vscode.mockExtensionSettingReturnValue('openToTheRepoOfTheActiveTextEditorDocument', false);

			// Run
			vscode.commands.executeCommand('git-graph.view');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.view');
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);
			});
		});

		it('Should open the Git Graph View to the known repository', async () => {
			// Setup
			spyOnGetKnownRepo.mockResolvedValueOnce('/path/to/workspace-folder/repo');
			vscode.mockExtensionSettingReturnValue('openToTheRepoOfTheActiveTextEditorDocument', false);

			// Run
			vscode.commands.executeCommand('git-graph.view', { rootUri: vscode.Uri.file('/path/to/workspace-folder/repo') });

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.view');
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/workspace-folder/repo' });
			});
		});

		it('Should open the Git Graph View to a newly registered repository', async () => {
			// Setup
			spyOnGetKnownRepo.mockResolvedValueOnce(null);
			spyOnRegisterRepo.mockResolvedValueOnce({ root: '/path/to/workspace-folder/repo', error: null });
			vscode.mockExtensionSettingReturnValue('openToTheRepoOfTheActiveTextEditorDocument', false);

			// Run
			vscode.commands.executeCommand('git-graph.view', { rootUri: vscode.Uri.file('/path/to/workspace-folder/repo') });

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.view');
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/workspace-folder/repo' });
			});
		});

		it('Should open the Git Graph View to the repository containing the active text editor', async () => {
			// Setup
			vscode.window.activeTextEditor = { document: { uri: vscode.Uri.file('/path/to/workspace-folder/active-file.txt') } };
			vscode.mockExtensionSettingReturnValue('openToTheRepoOfTheActiveTextEditorDocument', true);
			jest.spyOn(repoManager, 'getRepoContainingFile').mockReturnValueOnce('/path/to/workspace-folder');

			// Run
			vscode.commands.executeCommand('git-graph.view');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.view');
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/workspace-folder' });
			});
		});
	});

	describe('git-graph.addGitRepository', () => {
		let spyOnIsPathInWorkspace: jest.SpyInstance;
		beforeAll(() => {
			spyOnIsPathInWorkspace = jest.spyOn(utils, 'isPathInWorkspace');
		});

		it('Should register the selected repository', async () => {
			// Setup
			vscode.window.showOpenDialog.mockResolvedValueOnce([vscode.Uri.file('/path/to/workspace-folder/repo')]);
			spyOnIsPathInWorkspace.mockReturnValueOnce(true);
			spyOnRegisterRepo.mockResolvedValueOnce({ root: '/path/to/workspace-folder/repo', error: null });
			vscode.window.showInformationMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.addGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.addGitRepository');
				expect(vscode.window.showOpenDialog).toHaveBeenCalledWith({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false });
				expect(spyOnIsPathInWorkspace).toHaveBeenCalledWith('/path/to/workspace-folder/repo');
				expect(spyOnRegisterRepo).toHaveBeenCalledWith('/path/to/workspace-folder/repo', false);
				expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('The repository "/path/to/workspace-folder/repo" was added to Git Graph.');
			});
		});

		it('Should display the error message returned when registering the selected repository', async () => {
			// Setup
			vscode.window.showOpenDialog.mockResolvedValueOnce([vscode.Uri.file('/path/to/workspace-folder/repo')]);
			spyOnIsPathInWorkspace.mockReturnValueOnce(true);
			spyOnRegisterRepo.mockResolvedValueOnce({ root: null, error: 'The folder "/path/to/workspace-folder/repo" is not a Git repository.' });
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.addGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.addGitRepository');
				expect(vscode.window.showOpenDialog).toHaveBeenCalledWith({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false });
				expect(spyOnIsPathInWorkspace).toHaveBeenCalledWith('/path/to/workspace-folder/repo');
				expect(spyOnRegisterRepo).toHaveBeenCalledWith('/path/to/workspace-folder/repo', false);
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('The folder "/path/to/workspace-folder/repo" is not a Git repository. Therefore it could not be added to Git Graph.');
			});
		});

		it('Should display an error message when the selected repository is not within the workspace', async () => {
			// Setup
			vscode.window.showOpenDialog.mockResolvedValueOnce([vscode.Uri.file('/path/to/non-workspace-folder/repo')]);
			spyOnIsPathInWorkspace.mockReturnValueOnce(false);
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.addGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.addGitRepository');
				expect(vscode.window.showOpenDialog).toHaveBeenCalledWith({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false });
				expect(spyOnIsPathInWorkspace).toHaveBeenCalledWith('/path/to/non-workspace-folder/repo');
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('The folder "/path/to/non-workspace-folder/repo" is not within the opened Visual Studio Code workspace, and therefore could not be added to Git Graph.');
				expect(spyOnRegisterRepo).not.toHaveBeenCalled();
			});
		});

		it('Should not proceed to register a repository when none was selected', async () => {
			// Setup
			vscode.window.showOpenDialog.mockResolvedValueOnce([]);

			// Run
			vscode.commands.executeCommand('git-graph.addGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.addGitRepository');
				expect(vscode.window.showOpenDialog).toHaveBeenCalledWith({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false });
				expect(spyOnIsPathInWorkspace).not.toHaveBeenCalled();
			});
		});

		it('Should handle if showOpenDialog rejects', async () => {
			// Setup
			vscode.window.showOpenDialog.mockRejectedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.addGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.addGitRepository');
				expect(vscode.window.showOpenDialog).toHaveBeenCalledWith({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false });
				expect(spyOnIsPathInWorkspace).not.toHaveBeenCalled();
			});
		});

		it('Should display an error message if no git executable is known', async () => {
			// Setup
			commandManager['gitExecutable'] = null;
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.addGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.addGitRepository');
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith(utils.UNABLE_TO_FIND_GIT_MSG);
			});
		});
	});

	describe('git-graph.removeGitRepository', () => {
		let spyOnIgnoreRepo: jest.SpyInstance;
		beforeAll(() => {
			spyOnIgnoreRepo = jest.spyOn(repoManager, 'ignoreRepo');
		});

		it('Should ignore the selected repository', async () => {
			// Setup
			const repos = {
				'/path/to/repo2': mockRepoState({ name: 'Custom Name', workspaceFolderIndex: 1 }),
				'/path/to/repo1': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			};
			spyOnGetRepos.mockReturnValueOnce(repos);
			vscode.window.showQuickPick.mockResolvedValueOnce({
				label: 'repo1',
				description: '/path/to/repo1'
			});
			spyOnIgnoreRepo.mockReturnValueOnce(true);
			vscode.window.showInformationMessage.mockResolvedValueOnce(null);
			const spyOnGetSortedRepositoryPaths = jest.spyOn(utils, 'getSortedRepositoryPaths');

			// Run
			vscode.commands.executeCommand('git-graph.removeGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.removeGitRepository');
				expect(spyOnGetSortedRepositoryPaths).toHaveBeenCalledWith(repos, RepoDropdownOrder.WorkspaceFullPath);
				expect(vscode.window.showQuickPick).toHaveBeenCalledWith(
					[
						{
							label: 'repo1',
							description: '/path/to/repo1'
						},
						{
							label: 'Custom Name',
							description: '/path/to/repo2'
						}
					],
					{
						placeHolder: 'Select a repository to remove from Git Graph:',
						canPickMany: false
					}
				);
				expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('The repository "repo1" was removed from Git Graph.');
			});
		});

		it('Should display an error message if the selected repository no longer exists', async () => {
			// Setup
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo1': mockRepoState({ name: null, workspaceFolderIndex: 0 }),
				'/path/to/repo2': mockRepoState({ name: 'Custom Name', workspaceFolderIndex: 0 })
			});
			vscode.window.showQuickPick.mockResolvedValueOnce({
				label: 'repo1',
				description: '/path/to/repo1'
			});
			spyOnIgnoreRepo.mockReturnValueOnce(false);
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.removeGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.removeGitRepository');
				expect(vscode.window.showQuickPick).toHaveBeenCalledWith(
					[
						{
							label: 'repo1',
							description: '/path/to/repo1'
						},
						{
							label: 'Custom Name',
							description: '/path/to/repo2'
						}
					],
					{
						placeHolder: 'Select a repository to remove from Git Graph:',
						canPickMany: false
					}
				);
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('The repository "repo1" is not known to Git Graph.');
			});
		});

		it('Shouldn\'t attempt to ignore a repository if none was selected', async () => {
			// Setup
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo1': mockRepoState({ name: null, workspaceFolderIndex: 0 }),
				'/path/to/repo2': mockRepoState({ name: 'Custom Name', workspaceFolderIndex: 0 })
			});
			vscode.window.showQuickPick.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.removeGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.removeGitRepository');
				expect(vscode.window.showQuickPick).toHaveBeenCalledWith(
					[
						{
							label: 'repo1',
							description: '/path/to/repo1'
						},
						{
							label: 'Custom Name',
							description: '/path/to/repo2'
						}
					],
					{
						placeHolder: 'Select a repository to remove from Git Graph:',
						canPickMany: false
					}
				);
				expect(spyOnIgnoreRepo).not.toHaveBeenCalled();
			});
		});

		it('Should handle if showQuickPick rejects', async () => {
			// Setup
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo1': mockRepoState({ name: null, workspaceFolderIndex: 0 }),
				'/path/to/repo2': mockRepoState({ name: 'Custom Name', workspaceFolderIndex: 0 })
			});
			vscode.window.showQuickPick.mockRejectedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.removeGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.removeGitRepository');
				expect(vscode.window.showQuickPick).toHaveBeenCalledWith(
					[
						{
							label: 'repo1',
							description: '/path/to/repo1'
						},
						{
							label: 'Custom Name',
							description: '/path/to/repo2'
						}
					],
					{
						placeHolder: 'Select a repository to remove from Git Graph:',
						canPickMany: false
					}
				);
			});
		});

		it('Should display an error message if no git executable is known', async () => {
			// Setup
			commandManager['gitExecutable'] = null;
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.removeGitRepository');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.removeGitRepository');
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith(utils.UNABLE_TO_FIND_GIT_MSG);
			});
		});
	});

	describe('git-graph.clearAvatarCache', () => {
		let spyOnClearCache: jest.SpyInstance;
		beforeAll(() => {
			spyOnClearCache = jest.spyOn(avatarManager, 'clearCache');
		});

		it('Should clear the avatar cache, and display a success message', async () => {
			// Setup
			spyOnClearCache.mockResolvedValueOnce(null);
			vscode.window.showInformationMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.clearAvatarCache');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.clearAvatarCache');
				expect(spyOnClearCache).toBeCalledTimes(1);
				expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('The Avatar Cache was successfully cleared.');
			});
		});

		it('Should display the error message returned by AvatarManager.clearCache', async () => {
			// Setup
			const errorMessage = 'Visual Studio Code was unable to save the Git Graph Global State Memento.';
			spyOnClearCache.mockResolvedValueOnce(errorMessage);
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.clearAvatarCache');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.clearAvatarCache');
				expect(spyOnClearCache).toBeCalledTimes(1);
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith(errorMessage);
			});
		});

		it('Should display an error message when AvatarManager.clearCache rejects', async () => {
			// Setup
			spyOnClearCache.mockRejectedValueOnce(null);
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.clearAvatarCache');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.clearAvatarCache');
				expect(spyOnClearCache).toBeCalledTimes(1);
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('An unexpected error occurred while running the command "Clear Avatar Cache".');
			});
		});
	});

	describe('git-graph.fetch', () => {
		let spyOnGetLastActiveRepo: jest.SpyInstance;
		beforeAll(() => {
			spyOnGetLastActiveRepo = jest.spyOn(extensionState, 'getLastActiveRepo');
		});

		it('Should display a quick pick to select a repository to open in the Git Graph View (with last active repository first)', async () => {
			// Setup
			const repos = {
				'/path/to/repo3': mockRepoState({ name: null, workspaceFolderIndex: 2 }),
				'/path/to/repo2': mockRepoState({ name: 'Custom Name', workspaceFolderIndex: 1 }),
				'/path/to/repo1': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			};
			spyOnGetRepos.mockReturnValueOnce(repos);
			spyOnGetLastActiveRepo.mockReturnValueOnce('/path/to/repo2');
			vscode.window.showQuickPick.mockResolvedValueOnce({
				label: 'repo1',
				description: '/path/to/repo1'
			});
			const spyOnGetSortedRepositoryPaths = jest.spyOn(utils, 'getSortedRepositoryPaths');

			// Run
			vscode.commands.executeCommand('git-graph.fetch');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.fetch');
				expect(spyOnGetSortedRepositoryPaths).toHaveBeenCalledWith(repos, RepoDropdownOrder.WorkspaceFullPath);
				expect(vscode.window.showQuickPick).toHaveBeenCalledWith(
					[
						{
							label: 'Custom Name',
							description: '/path/to/repo2'
						},
						{
							label: 'repo1',
							description: '/path/to/repo1'
						},
						{
							label: 'repo3',
							description: '/path/to/repo3'
						}
					],
					{
						placeHolder: 'Select the repository you want to open in Git Graph, and fetch from remote(s):',
						canPickMany: false
					}
				);
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/repo1', runCommandOnLoad: 'fetch' });
			});
		});

		it('Should display a quick pick to select a repository to open in the Git Graph View (no last active repository)', async () => {
			// Setup
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo1': mockRepoState({ name: null, workspaceFolderIndex: 0 }),
				'/path/to/repo2': mockRepoState({ name: 'Custom Name', workspaceFolderIndex: 0 })
			});
			spyOnGetLastActiveRepo.mockReturnValueOnce(null);
			vscode.window.showQuickPick.mockResolvedValueOnce({
				label: 'repo1',
				description: '/path/to/repo1'
			});

			// Run
			vscode.commands.executeCommand('git-graph.fetch');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.fetch');
				expect(vscode.window.showQuickPick).toHaveBeenCalledWith(
					[
						{
							label: 'repo1',
							description: '/path/to/repo1'
						},
						{
							label: 'Custom Name',
							description: '/path/to/repo2'
						}
					],
					{
						placeHolder: 'Select the repository you want to open in Git Graph, and fetch from remote(s):',
						canPickMany: false
					}
				);
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/repo1', runCommandOnLoad: 'fetch' });
			});
		});

		it('Should display a quick pick to select a repository to open in the Git Graph View (last active repository is unknown)', async () => {
			// Setup
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo1': mockRepoState({ name: null, workspaceFolderIndex: 0 }),
				'/path/to/repo2': mockRepoState({ name: 'Custom Name', workspaceFolderIndex: 0 })
			});
			spyOnGetLastActiveRepo.mockReturnValueOnce('/path/to/repo3');
			vscode.window.showQuickPick.mockResolvedValueOnce({
				label: 'repo1',
				description: '/path/to/repo1'
			});

			// Run
			vscode.commands.executeCommand('git-graph.fetch');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.fetch');
				expect(vscode.window.showQuickPick).toHaveBeenCalledWith(
					[
						{
							label: 'repo1',
							description: '/path/to/repo1'
						},
						{
							label: 'Custom Name',
							description: '/path/to/repo2'
						}
					],
					{
						placeHolder: 'Select the repository you want to open in Git Graph, and fetch from remote(s):',
						canPickMany: false
					}
				);
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/repo1', runCommandOnLoad: 'fetch' });
			});
		});

		it('Shouldn\'t open the Git Graph View when no item is selected in the quick pick', async () => {
			// Setup
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo1': mockRepoState({ name: null, workspaceFolderIndex: 0 }),
				'/path/to/repo2': mockRepoState({ name: 'Custom Name', workspaceFolderIndex: 0 })
			});
			spyOnGetLastActiveRepo.mockReturnValueOnce('/path/to/repo3');
			vscode.window.showQuickPick.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.fetch');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.fetch');
				expect(vscode.window.showQuickPick).toHaveBeenCalledWith(
					[
						{
							label: 'repo1',
							description: '/path/to/repo1'
						},
						{
							label: 'Custom Name',
							description: '/path/to/repo2'
						}
					],
					{
						placeHolder: 'Select the repository you want to open in Git Graph, and fetch from remote(s):',
						canPickMany: false
					}
				);
				expect(spyOnGitGraphViewCreateOrShow).not.toHaveBeenCalled();
			});
		});

		it('Should display an error message when showQuickPick rejects', async () => {
			// Setup
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo1': mockRepoState({ name: null, workspaceFolderIndex: 0 }),
				'/path/to/repo2': mockRepoState({ name: 'Custom Name', workspaceFolderIndex: 0 })
			});
			spyOnGetLastActiveRepo.mockReturnValueOnce('/path/to/repo2');
			vscode.window.showQuickPick.mockRejectedValueOnce(null);
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.fetch');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.fetch');
				expect(vscode.window.showQuickPick).toHaveBeenCalledWith(
					[
						{
							label: 'Custom Name',
							description: '/path/to/repo2'
						},
						{
							label: 'repo1',
							description: '/path/to/repo1'
						}
					],
					{
						placeHolder: 'Select the repository you want to open in Git Graph, and fetch from remote(s):',
						canPickMany: false
					}
				);
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('An unexpected error occurred while running the command "Fetch from Remote(s)".');
				expect(spyOnGitGraphViewCreateOrShow).not.toHaveBeenCalled();
			});
		});

		it('Should open the Git Graph View immediately when there is only one repository', async () => {
			// Setup
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo1': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			});

			// Run
			vscode.commands.executeCommand('git-graph.fetch');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.fetch');
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, { repo: '/path/to/repo1', runCommandOnLoad: 'fetch' });
			});
		});

		it('Should open the Git Graph View immediately when there are no repositories', async () => {
			// Setup
			spyOnGetRepos.mockReturnValueOnce({});

			// Run
			vscode.commands.executeCommand('git-graph.fetch');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.fetch');
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, null);
			});
		});
	});

	describe('git-graph.endAllWorkspaceCodeReviews', () => {
		it('Should end all workspace code reviews', () => {
			// Setup
			const spyOnEndAllWorkspaceCodeReviews = jest.spyOn(extensionState, 'endAllWorkspaceCodeReviews');
			vscode.window.showInformationMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.endAllWorkspaceCodeReviews');

			// Assert
			expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.endAllWorkspaceCodeReviews');
			expect(spyOnEndAllWorkspaceCodeReviews).toBeCalledTimes(1);
			expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Ended All Code Reviews in Workspace');
		});
	});

	describe('git-graph.endSpecificWorkspaceCodeReview', () => {
		it('Should end the selected code review', async () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({
				'/path/to/repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: (date.now - 5) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					}
				}
			});
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			});
			spyOnGetCommitSubject.mockResolvedValueOnce('Commit Subject');
			vscode.window.showQuickPick.mockImplementationOnce((items: Promise<any[]>, _: any) => items.then((items) => items[0]));
			spyOnEndCodeReview.mockResolvedValueOnce(null);
			vscode.window.showInformationMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.endSpecificWorkspaceCodeReview');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.endSpecificWorkspaceCodeReview');
				expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Successfully ended Code Review "repo: 1a2b3c4d".');
			});
			expect(spyOnGetCommitSubject).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');
			expect(spyOnEndCodeReview).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');
			expect(await vscode.window.showQuickPick.mock.calls[0][0]).toStrictEqual([
				{
					codeReviewRepo: '/path/to/repo',
					codeReviewId: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					label: 'repo: 1a2b3c4d',
					description: '5 seconds ago',
					detail: 'Commit Subject'
				}
			]);
			expect(vscode.window.showQuickPick.mock.calls[0][1]).toStrictEqual({
				placeHolder: 'Select the Code Review you want to end:',
				canPickMany: false
			});
		});

		it('Should display an error message when there are no code reviews', () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({});
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.endSpecificWorkspaceCodeReview');

			// Assert
			expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.endSpecificWorkspaceCodeReview');
			expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('There are no Code Reviews in progress within the current workspace.');
			expect(vscode.window.showQuickPick).not.toHaveBeenCalled();
		});

		it('Shouldn\'t end a code review if no code review was selected', async () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({
				'/path/to/repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: (date.now - 5) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					}
				}
			});
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			});
			spyOnGetCommitSubject.mockResolvedValueOnce('Commit Subject');
			vscode.window.showQuickPick.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.endSpecificWorkspaceCodeReview');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.endSpecificWorkspaceCodeReview');
				expect(vscode.window.showQuickPick).toHaveBeenCalledTimes(1);
				expect(spyOnEndCodeReview).not.toHaveBeenCalled();
			});
		});

		it('Should handle endCodeReview rejecting', async () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({
				'/path/to/repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: (date.now - 5) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					}
				}
			});
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			});
			spyOnGetCommitSubject.mockResolvedValueOnce('Commit Subject');
			vscode.window.showQuickPick.mockImplementationOnce((items: Promise<any[]>, _: any) => items.then((items) => items[0]));
			spyOnEndCodeReview.mockRejectedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.endSpecificWorkspaceCodeReview');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.endSpecificWorkspaceCodeReview');
				expect(vscode.window.showQuickPick).toHaveBeenCalledTimes(1);
				expect(vscode.window.showInformationMessage).not.toHaveBeenCalled();
				expect(vscode.window.showErrorMessage).not.toHaveBeenCalled();
			});
		});

		it('Should display an error message when the code review couldn\'t be ended', async () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({
				'/path/to/repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: (date.now - 5) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					}
				}
			});
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			});
			spyOnGetCommitSubject.mockResolvedValueOnce('Commit Subject');
			vscode.window.showQuickPick.mockImplementationOnce((items: Promise<any[]>, _: any) => items.then((items) => items[0]));
			spyOnEndCodeReview.mockResolvedValueOnce('Visual Studio Code was unable to save the Git Graph Workspace State Memento.');
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.endSpecificWorkspaceCodeReview');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.endSpecificWorkspaceCodeReview');
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('Visual Studio Code was unable to save the Git Graph Workspace State Memento.');
			});
		});

		it('Should display an error message when showQuickPick rejects', async () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({
				'/path/to/repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: (date.now - 5) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					}
				}
			});
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			});
			spyOnGetCommitSubject.mockResolvedValueOnce('Commit Subject');
			vscode.window.showQuickPick.mockRejectedValueOnce(null);
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.endSpecificWorkspaceCodeReview');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.endSpecificWorkspaceCodeReview');
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('An unexpected error occurred while running the command "End a specific Code Review in Workspace...".');
			});
		});
	});

	describe('git-graph.resumeWorkspaceCodeReview', () => {
		it('Should load the selected code review in the Git Graph View (single commit)', async () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({
				'/path/to/repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: (date.now - 10) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					},
					'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c': {
						lastActive: (date.now - 5) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					}
				},
				'/path/to/unknown-repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: (date.now - 10) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					}
				}
			});
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			});
			spyOnGetCommitSubject.mockImplementationOnce((_: string, hash: string) => hash === '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b' ? 'subject-' + hash : null);
			spyOnGetCommitSubject.mockImplementationOnce((_: string, hash: string) => hash === '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b' ? 'subject-' + hash : null);
			vscode.window.showQuickPick.mockImplementationOnce((items: Promise<any[]>, _: any) => items.then((items) => items[0]));

			// Run
			vscode.commands.executeCommand('git-graph.resumeWorkspaceCodeReview');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.resumeWorkspaceCodeReview');
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, {
					repo: '/path/to/repo',
					commitDetails: {
						commitHash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						compareWithHash: null
					}
				});
			});
			expect(spyOnGetCommitSubject).toHaveBeenCalledTimes(2);
			expect(spyOnGetCommitSubject).toHaveBeenCalledWith('/path/to/repo', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b');
			expect(spyOnGetCommitSubject).toHaveBeenCalledWith('/path/to/repo', '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c');
			expect(await vscode.window.showQuickPick.mock.calls[0][0]).toStrictEqual([
				{
					codeReviewRepo: '/path/to/repo',
					codeReviewId: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
					label: 'repo: 2b3c4d5e',
					description: '5 seconds ago',
					detail: '<Unknown Commit Subject>'
				},
				{
					codeReviewRepo: '/path/to/repo',
					codeReviewId: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					label: 'repo: 1a2b3c4d',
					description: '10 seconds ago',
					detail: 'subject-1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'
				}
			]);
			expect(vscode.window.showQuickPick.mock.calls[0][1]).toStrictEqual({
				placeHolder: 'Select the Code Review you want to resume:',
				canPickMany: false
			});
		});

		it('Should load the selected code review in the Git Graph View (commit comparison)', async () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({
				'/path/to/repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b-2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c': {
						lastActive: (date.now - 5) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					}
				}
			});
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			});
			spyOnGetCommitSubject.mockImplementationOnce((_: string, hash: string) => 'subject-' + hash);
			spyOnGetCommitSubject.mockImplementationOnce((_: string, hash: string) => 'subject-' + hash);
			vscode.window.showQuickPick.mockImplementationOnce((items: Promise<any[]>, _: any) => items.then((items) => items[0]));

			// Run
			vscode.commands.executeCommand('git-graph.resumeWorkspaceCodeReview');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.resumeWorkspaceCodeReview');
				expect(spyOnGitGraphViewCreateOrShow).toHaveBeenCalledWith('/path/to/extension', dataSource, extensionState, avatarManager, repoManager, logger, {
					repo: '/path/to/repo',
					commitDetails: {
						commitHash: '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						compareWithHash: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'
					}
				});
			});
			expect(await vscode.window.showQuickPick.mock.calls[0][0]).toStrictEqual([
				{
					codeReviewRepo: '/path/to/repo',
					codeReviewId: '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b-2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
					label: 'repo: 1a2b3c4d  2b3c4d5e',
					description: '5 seconds ago',
					detail: 'subject-1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b  subject-2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'
				}
			]);
			expect(vscode.window.showQuickPick.mock.calls[0][1]).toStrictEqual({
				placeHolder: 'Select the Code Review you want to resume:',
				canPickMany: false
			});
		});

		it('Shouldn\'t load the the Git Graph View if no code review was selected', async () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({
				'/path/to/repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: (date.now - 5) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					}
				}
			});
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			});
			spyOnGetCommitSubject.mockResolvedValueOnce('Commit Subject');
			vscode.window.showQuickPick.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.resumeWorkspaceCodeReview');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.resumeWorkspaceCodeReview');
				expect(vscode.window.showQuickPick).toHaveBeenCalledTimes(1);
				expect(spyOnGitGraphViewCreateOrShow).not.toHaveBeenCalled();
			});
		});

		it('Should display an error message when there are no code reviews', () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({});
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.resumeWorkspaceCodeReview');

			// Assert
			expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.resumeWorkspaceCodeReview');
			expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('There are no Code Reviews in progress within the current workspace.');
			expect(vscode.window.showQuickPick).not.toHaveBeenCalled();
		});

		it('Should display an error message when showQuickPick rejects', async () => {
			// Setup
			spyOnGetCodeReviews.mockReturnValueOnce({
				'/path/to/repo': {
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b': {
						lastActive: (date.now - 5) * 1000,
						lastViewedFile: null,
						remainingFiles: ['file.txt']
					}
				}
			});
			spyOnGetRepos.mockReturnValueOnce({
				'/path/to/repo': mockRepoState({ name: null, workspaceFolderIndex: 0 })
			});
			spyOnGetCommitSubject.mockResolvedValueOnce('Commit Subject');
			vscode.window.showQuickPick.mockRejectedValueOnce(null);
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.resumeWorkspaceCodeReview');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.resumeWorkspaceCodeReview');
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('An unexpected error occurred while running the command "Resume a specific Code Review in Workspace...".');
			});
		});
	});

	describe('git-graph.version', () => {
		let spyOnCopyToClipboard: jest.SpyInstance, spyOnGetExtensionVersion: jest.SpyInstance, spyOnOsType: jest.SpyInstance, spyOnOsArch: jest.SpyInstance, spyOnOsRelease: jest.SpyInstance;
		beforeAll(() => {
			spyOnCopyToClipboard = jest.spyOn(utils, 'copyToClipboard');
			spyOnGetExtensionVersion = jest.spyOn(utils, 'getExtensionVersion');
			spyOnOsType = jest.spyOn(os, 'type');
			spyOnOsArch = jest.spyOn(os, 'arch');
			spyOnOsRelease = jest.spyOn(os, 'release');
		});

		it('Should display the version information, and copy it to the clipboard', async () => {
			// Setup
			spyOnGetExtensionVersion.mockResolvedValueOnce('1.27.0');
			vscode.window.showInformationMessage.mockResolvedValueOnce('Copy');
			spyOnCopyToClipboard.mockResolvedValueOnce(null);
			spyOnOsType.mockReturnValueOnce('X');
			spyOnOsArch.mockReturnValueOnce('Y');
			spyOnOsRelease.mockReturnValueOnce('Z');

			// Run
			vscode.commands.executeCommand('git-graph.version');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.version');
				expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Git Graph: 1.27.0\nVisual Studio Code: 1.51.0\nOS: X Y Z\nGit: 2.25.0', { modal: true }, 'Copy');
				expect(spyOnCopyToClipboard).toHaveBeenCalledWith('Git Graph: 1.27.0\nVisual Studio Code: 1.51.0\nOS: X Y Z\nGit: 2.25.0');
			});
		});

		it('Shouldn\'t copy the version information to the clipboard if the user closes the information message modal', async () => {
			// Setup
			commandManager['gitExecutable'] = null;
			spyOnGetExtensionVersion.mockResolvedValueOnce('1.27.0');
			vscode.window.showInformationMessage.mockResolvedValueOnce('');
			spyOnOsType.mockReturnValueOnce('X');
			spyOnOsArch.mockReturnValueOnce('Y');
			spyOnOsRelease.mockReturnValueOnce('Z');

			// Run
			vscode.commands.executeCommand('git-graph.version');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.version');
				expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Git Graph: 1.27.0\nVisual Studio Code: 1.51.0\nOS: X Y Z\nGit: (none)', { modal: true }, 'Copy');
				expect(spyOnCopyToClipboard).not.toHaveBeenCalled();
			});
		});

		it('Should display an error message when the extension version couldn\'t be retrieved', async () => {
			// Setup
			spyOnGetExtensionVersion.mockRejectedValueOnce(null);
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			vscode.commands.executeCommand('git-graph.version');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.version');
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('An unexpected error occurred while retrieving version information.');
			});
		});

		it('Should display an error message when the version information couldn\'t be copied to the clipboard', async () => {
			// Setup
			spyOnGetExtensionVersion.mockResolvedValueOnce('1.27.0');
			vscode.window.showInformationMessage.mockResolvedValueOnce('Copy');
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);
			spyOnCopyToClipboard.mockResolvedValueOnce('error message');
			spyOnOsType.mockReturnValueOnce('X');
			spyOnOsArch.mockReturnValueOnce('Y');
			spyOnOsRelease.mockReturnValueOnce('Z');

			// Run
			vscode.commands.executeCommand('git-graph.version');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.version');
				expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Git Graph: 1.27.0\nVisual Studio Code: 1.51.0\nOS: X Y Z\nGit: 2.25.0', { modal: true }, 'Copy');
				expect(spyOnCopyToClipboard).toHaveBeenCalledWith('Git Graph: 1.27.0\nVisual Studio Code: 1.51.0\nOS: X Y Z\nGit: 2.25.0');
				expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('error message');
			});
		});

		it('Should handle if showInformationMessage rejects', async () => {
			// Setup
			spyOnGetExtensionVersion.mockResolvedValueOnce('1.27.0');
			vscode.window.showInformationMessage.mockRejectedValueOnce(null);
			spyOnOsType.mockReturnValueOnce('X');
			spyOnOsArch.mockReturnValueOnce('Y');
			spyOnOsRelease.mockReturnValueOnce('Z');

			// Run
			vscode.commands.executeCommand('git-graph.version');

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.version');
				expect(vscode.window.showInformationMessage).toHaveBeenCalledWith('Git Graph: 1.27.0\nVisual Studio Code: 1.51.0\nOS: X Y Z\nGit: 2.25.0', { modal: true }, 'Copy');
				expect(spyOnCopyToClipboard).not.toHaveBeenCalled();
			});
		});
	});

	describe('git-graph.openFile', () => {
		let spyOnOpenFile: jest.SpyInstance;
		beforeAll(() => {
			spyOnOpenFile = jest.spyOn(utils, 'openFile');
		});

		it('Should open the provided file', async () => {
			spyOnOpenFile.mockResolvedValueOnce(null);

			// Run
			await vscode.commands.executeCommand('git-graph.openFile', encodeDiffDocUri('/path/to/repo', 'subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Modified, DiffSide.New));

			// Assert
			expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.openFile');
			expect(spyOnOpenFile).toHaveBeenCalledWith('/path/to/repo', 'subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource, vscode.ViewColumn.Active);
		});

		it('Should open the file of the active text editor', async () => {
			vscode.window.activeTextEditor = { document: { uri: encodeDiffDocUri('/path/to/repo', 'subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Modified, DiffSide.New) } };
			spyOnOpenFile.mockResolvedValueOnce(null);

			// Run
			await vscode.commands.executeCommand('git-graph.openFile');

			// Assert
			expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.openFile');
			expect(spyOnOpenFile).toHaveBeenCalledWith('/path/to/repo', 'subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource, vscode.ViewColumn.Active);
		});

		it('Should display an error message when no URI is provided', async () => {
			vscode.window.activeTextEditor = undefined;
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			await vscode.commands.executeCommand('git-graph.openFile');

			// Assert
			expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.openFile');
			expect(spyOnOpenFile).not.toHaveBeenCalled();
			expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('Unable to Open File: The command was not called with the required arguments.');
		});

		it('Should display an error message when no Git Graph URI is provided', async () => {
			vscode.window.activeTextEditor = { document: { uri: vscode.Uri.file('/path/to/workspace-folder/active-file.txt') } };
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			await vscode.commands.executeCommand('git-graph.openFile');

			// Assert
			expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.openFile');
			expect(spyOnOpenFile).not.toHaveBeenCalled();
			expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('Unable to Open File: The command was not called with the required arguments.');
		});

		it('Should display an error message when the file can\'t be opened', async () => {
			vscode.window.activeTextEditor = { document: { uri: encodeDiffDocUri('/path/to/repo', 'subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', GitFileStatus.Modified, DiffSide.New) } };
			spyOnOpenFile.mockResolvedValueOnce('Error Message');
			vscode.window.showErrorMessage.mockResolvedValueOnce(null);

			// Run
			await vscode.commands.executeCommand('git-graph.openFile');

			// Assert
			expect(spyOnLog).toHaveBeenCalledWith('Command Invoked: git-graph.openFile');
			expect(spyOnOpenFile).toHaveBeenCalledWith('/path/to/repo', 'subfolder/modified.txt', '1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', dataSource, vscode.ViewColumn.Active);
			expect(vscode.window.showErrorMessage).toHaveBeenCalledWith('Unable to Open File: Error Message');
		});
	});
});
-e 

================================================================================
// FILE: ./tests/event.test.ts
================================================================================
import { EventEmitter } from '../src/utils/event';

describe('Event Emitter', () => {
	it('Registers and disposes subscribers', () => {
		// Setup
		const emitter = new EventEmitter<number>();
		const mockSubscriber1 = jest.fn((x: number) => x);
		const mockSubscriber2 = jest.fn((x: number) => x);

		// Run
		emitter.subscribe(mockSubscriber1);
		emitter.subscribe(mockSubscriber2);

		// Assert
		expect(emitter.hasSubscribers()).toBe(true);
		expect(emitter['listeners'].length).toBe(2);

		// Run
		emitter.dispose();

		// Assert
		expect(emitter.hasSubscribers()).toBe(false);
	});

	it('Disposes a specific subscriber', () => {
		// Setup
		const emitter = new EventEmitter<number>();
		const mockSubscriber1 = jest.fn((x: number) => x);
		const mockSubscriber2 = jest.fn((x: number) => x);

		// Run
		const disposable = emitter.subscribe(mockSubscriber1);
		emitter.subscribe(mockSubscriber2);
		disposable.dispose();

		// Assert
		expect(emitter.hasSubscribers()).toBe(true);
		expect(emitter['listeners'].length).toBe(1);
		expect(emitter['listeners'][0]).toBe(mockSubscriber2);

		// Teardown
		emitter.dispose();
	});

	it('Handles duplicate disposes of a specific subscriber', () => {
		// Setup
		const emitter = new EventEmitter<number>();
		const mockSubscriber = jest.fn((x: number) => x);

		// Run
		const disposable = emitter.subscribe(mockSubscriber);
		disposable.dispose();
		disposable.dispose();

		// Assert
		expect(emitter.hasSubscribers()).toBe(false);

		// Teardown
		emitter.dispose();
	});

	it('Calls subscribers when an event is emitted', () => {
		// Setup
		const emitter = new EventEmitter<number>();
		const mockSubscriber1 = jest.fn((x: number) => x);
		const mockSubscriber2 = jest.fn((x: number) => x);

		// Run
		emitter.subscribe(mockSubscriber1);
		emitter.subscribe(mockSubscriber2);
		emitter.emit(5);

		// Assert
		expect(mockSubscriber1).toHaveBeenCalledWith(5);
		expect(mockSubscriber2).toHaveBeenCalledWith(5);

		// Teardown
		emitter.dispose();
	});
});
-e 

================================================================================
// FILE: ./tests/avatarManager.test.ts
================================================================================
import * as date from './mocks/date';
import * as vscode from './mocks/vscode';
jest.mock('vscode', () => vscode, { virtual: true });
jest.mock('fs');
jest.mock('https');
jest.mock('../src/dataSource');
jest.mock('../src/extensionState');
jest.mock('../src/logger');

import * as fs from 'fs';
import { ClientRequest, IncomingMessage } from 'http';
import * as https from 'https';
import { URL } from 'url';
import { ConfigurationChangeEvent } from 'vscode';
import { AvatarEvent, AvatarManager } from '../src/avatarManager';
import { DataSource } from '../src/dataSource';
import { ExtensionState } from '../src/extensionState';
import { Logger } from '../src/logger';
import { GitExecutable } from '../src/utils';
import { EventEmitter } from '../src/utils/event';

import { waitForExpect } from './helpers/expectations';

let onDidChangeConfiguration: EventEmitter<ConfigurationChangeEvent>;
let onDidChangeGitExecutable: EventEmitter<GitExecutable>;
let logger: Logger;
let dataSource: DataSource;
let extensionState: ExtensionState;
let spyOnSaveAvatar: jest.SpyInstance, spyOnRemoveAvatarFromCache: jest.SpyInstance, spyOnHttpsGet: jest.SpyInstance, spyOnWriteFile: jest.SpyInstance, spyOnReadFile: jest.SpyInstance, spyOnLog: jest.SpyInstance, spyOnGetRemoteUrl: jest.SpyInstance;

beforeAll(() => {
	onDidChangeConfiguration = new EventEmitter<ConfigurationChangeEvent>();
	onDidChangeGitExecutable = new EventEmitter<GitExecutable>();
	logger = new Logger();
	dataSource = new DataSource(null, onDidChangeConfiguration.subscribe, onDidChangeGitExecutable.subscribe, logger);
	extensionState = new ExtensionState(vscode.mocks.extensionContext, onDidChangeGitExecutable.subscribe);
	spyOnSaveAvatar = jest.spyOn(extensionState, 'saveAvatar');
	spyOnRemoveAvatarFromCache = jest.spyOn(extensionState, 'removeAvatarFromCache');
	spyOnHttpsGet = jest.spyOn(https, 'get');
	spyOnWriteFile = jest.spyOn(fs, 'writeFile');
	spyOnReadFile = jest.spyOn(fs, 'readFile');
	spyOnLog = jest.spyOn(logger, 'log');
	spyOnGetRemoteUrl = jest.spyOn(dataSource, 'getRemoteUrl');
});

afterAll(() => {
	extensionState.dispose();
	dataSource.dispose();
	logger.dispose();
	onDidChangeConfiguration.dispose();
	onDidChangeGitExecutable.dispose();
});

describe('AvatarManager', () => {
	let avatarManager: AvatarManager;
	beforeEach(() => {
		jest.spyOn(extensionState, 'getAvatarStoragePath').mockReturnValueOnce('/path/to/avatars');
		jest.spyOn(extensionState, 'getAvatarCache').mockReturnValueOnce({
			'user1@mhutchie.com': {
				image: '530a7b02594e057f39179d3bd8b849f0.png',
				timestamp: date.now * 1000,
				identicon: false
			},
			'user2@mhutchie.com': {
				image: '57853c107d1aeaa7da6f3096385cb848.png',
				timestamp: date.now * 1000 - 1209600001,
				identicon: false
			},
			'user3@mhutchie.com': {
				image: 'e36b61e2afd912d3665f1aa92932aa87.png',
				timestamp: date.now * 1000 - 345600001,
				identicon: true
			}
		});
		avatarManager = new AvatarManager(dataSource, extensionState, logger);
		jest.clearAllTimers();
		jest.useRealTimers();
	});
	afterEach(() => {
		avatarManager.dispose();
	});

	it('Should construct an AvatarManager, and be disposed', () => {
		// Assert
		expect(avatarManager['disposables']).toHaveLength(2);

		// Run
		avatarManager.dispose();

		// Assert
		expect(avatarManager['disposables']).toHaveLength(0);
	});

	describe('fetchAvatarImage', () => {
		it('Should trigger the avatar to be emitted when a known avatar is fetched', async () => {
			// Setup
			mockReadFile('binary-image-data');
			const avatarEvents = waitForEvents(avatarManager, 1);

			// Run
			avatarManager.fetchAvatarImage('user1@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

			// Assert
			expect(await avatarEvents).toStrictEqual([{
				email: 'user1@mhutchie.com',
				image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
			}]);
		});

		describe('GitHub', () => {
			it('Should fetch a new avatar from GitHub (HTTPS Remote)', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				mockHttpsResponse(200, '{"author":{"avatar_url":"https://avatar-url"}}');
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'api.github.com',
					path: '/repos/mhutchie/test-repo/commits/1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'avatar-url',
					path: '/&size=162',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should fetch a new avatar from GitHub (SSH Remote)', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('git@github.com:mhutchie/test-repo.git');
				mockHttpsResponse(200, '{"author":{"avatar_url":"https://avatar-url"}}');
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', [
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
					'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
					'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e',
					'5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f',
					'6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a',
					'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'
				]);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'api.github.com',
					path: '/repos/mhutchie/test-repo/commits/2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'avatar-url',
					path: '/&size=162',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should fallback to Gravatar when there is no avatar_url are in the GitHub response', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				mockHttpsResponse(200, '{"author":{}}');
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'api.github.com',
					path: '/repos/mhutchie/test-repo/commits/1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should fallback to Gravatar when an unexpected status code is received from the GitHub API', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				mockHttpsResponse(401, '');
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'api.github.com',
					path: '/repos/mhutchie/test-repo/commits/1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should halt fetching the avatar when the GitHub avatar url request is unsuccessful', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				mockHttpsResponse(200, '{"author":{"avatar_url":"https://avatar-url"}}');
				mockHttpsResponse(404, '');

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(spyOnLog).toHaveBeenCalledWith('Failed to download avatar from GitHub for user4@*****');
				});
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'api.github.com',
					path: '/repos/mhutchie/test-repo/commits/1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'avatar-url',
					path: '/&size=162',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
			});

			it('Should requeue the request when the GitHub API cannot find the commit', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				mockHttpsResponse(422, '', { 'x-ratelimit-remaining': '0', 'x-ratelimit-reset': (date.now + 1).toString() });

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b', '2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['queue']['queue'].length).toBe(1);
					expect(avatarManager['queue']['queue'][0].attempts).toBe(1);
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: [
							'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
							'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c'
						],
						checkAfter: 0,
						attempts: 1
					}
				]);
			});

			it('Should set the GitHub API timeout and requeue the request when the rate limit is reached', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				mockHttpsResponse(403, '', { 'x-ratelimit-remaining': '0', 'x-ratelimit-reset': (date.now + 1).toString() });

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(spyOnLog).toHaveBeenCalledWith('GitHub API Rate Limit Reached - Paused fetching from GitHub until the Rate Limit is reset');
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						checkAfter: (date.now + 1) * 1000,
						attempts: 0
					}
				]);
				expect(avatarManager['githubTimeout']).toBe(1587559259000);
			});

			it('Should set the GitHub API timeout and requeue the request when the API returns a 5xx error', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				mockHttpsResponse(500, '');

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['githubTimeout']).toBe(date.now * 1000 + 600000);
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						checkAfter: date.now * 1000 + 600000,
						attempts: 0
					}
				]);
			});

			it('Should set the GitHub API timeout and requeue the request when there is an HTTPS Client Request Error', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				mockHttpsClientRequestErrorEvent();

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['githubTimeout']).toBe(date.now * 1000 + 300000);
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						checkAfter: date.now * 1000 + 300000,
						attempts: 0
					}
				]);
			});

			it('Should set the GitHub API timeout and requeue the request when there is an HTTPS Incoming Message Error', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				mockHttpsIncomingMessageErrorEvent();

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['githubTimeout']).toBe(date.now * 1000 + 300000);
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						checkAfter: date.now * 1000 + 300000,
						attempts: 0
					}
				]);
			});

			it('Should set the GitHub API timeout and requeue the request once when there are multiple HTTPS Error Events', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				mockHttpsMultipleErrorEvents();

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['githubTimeout']).toBe(date.now * 1000 + 300000);
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						checkAfter: date.now * 1000 + 300000,
						attempts: 0
					}
				]);
			});

			it('Should requeue the request when it\'s before the GitHub API timeout', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
				avatarManager['githubTimeout'] = (date.now + 1) * 1000;

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['queue']['queue']).toStrictEqual([
						{
							email: 'user4@mhutchie.com',
							repo: 'test-repo',
							remote: 'test-remote',
							commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
							checkAfter: 1587559259000,
							attempts: 0
						}
					]);
				});
			});
		});

		describe('GitLab', () => {
			it('Should fetch a new avatar from GitLab (HTTPS Remote)', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://gitlab.com/mhutchie/test-repo.git');
				mockHttpsResponse(200, '[{"avatar_url":"https://avatar-url"}]');
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'gitlab.com',
					path: '/api/v4/users?search=user4@mhutchie.com',
					headers: { 'User-Agent': 'vscode-git-graph', 'Private-Token': 'w87U_3gAxWWaPtFgCcus' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'avatar-url',
					path: '/',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should fetch a new avatar from GitLab (SSH Remote)', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('git@gitlab.com:mhutchie/test-repo.git');
				mockHttpsResponse(200, '[{"avatar_url":"https://avatar-url"}]');
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'gitlab.com',
					path: '/api/v4/users?search=user4@mhutchie.com',
					headers: { 'User-Agent': 'vscode-git-graph', 'Private-Token': 'w87U_3gAxWWaPtFgCcus' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'avatar-url',
					path: '/',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should fallback to Gravatar when no users are in the GitLab response', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://gitlab.com/mhutchie/test-repo.git');
				mockHttpsResponse(200, '[]');
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'gitlab.com',
					path: '/api/v4/users?search=user4@mhutchie.com',
					headers: { 'User-Agent': 'vscode-git-graph', 'Private-Token': 'w87U_3gAxWWaPtFgCcus' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should fallback to Gravatar when an unexpected status code is received from the GitLab API', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://gitlab.com/mhutchie/test-repo.git');
				mockHttpsResponse(401, '');
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'gitlab.com',
					path: '/api/v4/users?search=user4@mhutchie.com',
					headers: { 'User-Agent': 'vscode-git-graph', 'Private-Token': 'w87U_3gAxWWaPtFgCcus' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should halt fetching the avatar when the GitLab avatar url request is unsuccessful', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://gitlab.com/mhutchie/test-repo.git');
				mockHttpsResponse(200, '[{"avatar_url":"https://avatar-url"}]');
				mockHttpsResponse(404, '');

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(spyOnLog).toHaveBeenCalledWith('Failed to download avatar from GitLab for user4@*****');
				});
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'gitlab.com',
					path: '/api/v4/users?search=user4@mhutchie.com',
					headers: { 'User-Agent': 'vscode-git-graph', 'Private-Token': 'w87U_3gAxWWaPtFgCcus' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'avatar-url',
					path: '/',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
			});

			it('Should set the GitLab API timeout and requeue the request when the rate limit is reached', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://gitlab.com/mhutchie/test-repo.git');
				mockHttpsResponse(429, '', { 'ratelimit-remaining': '0', 'ratelimit-reset': (date.now + 1).toString() });

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(spyOnLog).toHaveBeenCalledWith('GitLab API Rate Limit Reached - Paused fetching from GitLab until the Rate Limit is reset');
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						checkAfter: (date.now + 1) * 1000,
						attempts: 0
					}
				]);
				expect(avatarManager['gitLabTimeout']).toBe(1587559259000);
			});

			it('Should set the GitLab API timeout and requeue the request when the API returns a 5xx error', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://gitlab.com/mhutchie/test-repo.git');
				mockHttpsResponse(500, '');

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['gitLabTimeout']).toBe(date.now * 1000 + 600000);
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						checkAfter: date.now * 1000 + 600000,
						attempts: 0
					}
				]);
			});

			it('Should set the GitLab API timeout and requeue the request when there is an HTTPS Client Request Error', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://gitlab.com/mhutchie/test-repo.git');
				mockHttpsClientRequestErrorEvent();

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['gitLabTimeout']).toBe(date.now * 1000 + 300000);
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						checkAfter: date.now * 1000 + 300000,
						attempts: 0
					}
				]);
			});

			it('Should set the GitLab API timeout and requeue the request when there is an HTTPS Incoming Message Error', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://gitlab.com/mhutchie/test-repo.git');
				mockHttpsIncomingMessageErrorEvent();

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['gitLabTimeout']).toBe(date.now * 1000 + 300000);
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						checkAfter: date.now * 1000 + 300000,
						attempts: 0
					}
				]);
			});

			it('Should set the GitLab API timeout and requeue the request once when there are multiple HTTPS Error Events', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://gitlab.com/mhutchie/test-repo.git');
				mockHttpsMultipleErrorEvents();

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['gitLabTimeout']).toBe(date.now * 1000 + 300000);
				});
				expect(avatarManager['queue']['queue']).toStrictEqual([
					{
						email: 'user4@mhutchie.com',
						repo: 'test-repo',
						remote: 'test-remote',
						commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
						checkAfter: date.now * 1000 + 300000,
						attempts: 0
					}
				]);
			});

			it('Should requeue the request when it\'s before the GitLab API timeout', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('https://gitlab.com/mhutchie/test-repo.git');
				avatarManager['gitLabTimeout'] = (date.now + 1) * 1000;

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(avatarManager['queue']['queue']).toStrictEqual([
						{
							email: 'user4@mhutchie.com',
							repo: 'test-repo',
							remote: 'test-remote',
							commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
							checkAfter: 1587559259000,
							attempts: 0
						}
					]);
				});
			});
		});

		describe('Gravatar', () => {
			it('Should fetch a new avatar from Gravatar', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce(null);
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				await waitForExpect(() => {
					expect(spyOnLog).toHaveBeenCalledWith('Saved Avatar for user4@*****');
					expect(spyOnLog).toHaveBeenCalledWith('Sent Avatar for user4@***** to the Git Graph View');
				});
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should fetch an identicon if no avatar can be found on Gravatar', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce(null);
				mockHttpsResponse(404, '');
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=identicon',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: true
				});
			});

			it('Should not save an avatar if it cannot be fetched from Gravatar', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce(null);
				mockHttpsResponse(404, '');
				mockHttpsResponse(500, '');

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				await waitForExpect(() => {
					expect(spyOnLog).toHaveBeenCalledWith('No Avatar could be found for user4@*****');
				});
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=identicon',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
			});

			it('Should fetch an avatar from Gravatar when no remote is specified', async () => {
				// Setup
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', null, ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).not.toHaveBeenCalled();
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should fetch an avatar from Gravatar when the remote hostname is not GitHub or GitLab', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce('http://other-host/mhutchie/test-repo.git');
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: false
				});
			});

			it('Should fetch an identicon the avatar fails to be saved', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce(null);
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(new Error());
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=identicon',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: true
				});
			});

			it('Should fetch an identicon if the first avatar request receives an HTTPS Client Request Error', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce(null);
				mockHttpsClientRequestErrorEvent();
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=identicon',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: true
				});
			});

			it('Should fetch an identicon if the first avatar request receives an HTTPS Incoming Message Error', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce(null);
				mockHttpsIncomingMessageErrorEvent();
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=identicon',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: true
				});
			});

			it('Should fetch an identicon once if the first avatar request receives multiple HTTPS Error Events', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce(null);
				mockHttpsMultipleErrorEvents();
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=identicon',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledTimes(1);
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: true
				});
			});

			it('Should fetch an identicon the first avatar HTTPS request throws an expected exception', async () => {
				// Setup
				spyOnGetRemoteUrl.mockResolvedValueOnce(null);
				spyOnHttpsGet.mockImplementationOnce(() => {
					throw new Error();
				});
				mockHttpsResponse(200, 'binary-image-data');
				mockWriteFile(null);
				mockReadFile('binary-image-data');
				const avatarEvents = waitForEvents(avatarManager, 1);

				// Run
				avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

				// Assert
				expect(await avatarEvents).toStrictEqual([{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				}]);
				expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expect(spyOnHttpsGet).toHaveBeenCalledWith({
					hostname: 'secure.gravatar.com',
					path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=identicon',
					headers: { 'User-Agent': 'vscode-git-graph' },
					agent: false,
					timeout: 15000
				}, expect.anything());
				expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
				expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
				expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
					image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
					timestamp: 1587559258000,
					identicon: true
				});
			});
		});

		it('Should fetch an avatar when the existing avatar is over 14 days old', async () => {
			// Setup
			spyOnGetRemoteUrl.mockResolvedValueOnce(null);
			mockReadFile('binary-image-data');
			mockHttpsResponse(200, 'new-binary-image-data');
			mockWriteFile(null);
			mockReadFile('new-binary-image-data');
			const avatarEvents = waitForEvents(avatarManager, 2);

			// Run
			avatarManager.fetchAvatarImage('user2@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

			// Assert
			expect(await avatarEvents).toStrictEqual([
				{
					email: 'user2@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				},
				{
					email: 'user2@mhutchie.com',
					image: 'data:image/png;base64,bmV3LWJpbmFyeS1pbWFnZS1kYXRh'
				}
			]);
			expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
			expect(spyOnHttpsGet).toHaveBeenCalledWith({
				hostname: 'secure.gravatar.com',
				path: '/avatar/57853c107d1aeaa7da6f3096385cb848?s=162&d=404',
				headers: { 'User-Agent': 'vscode-git-graph' },
				agent: false,
				timeout: 15000
			}, expect.anything());
			expectFileToHaveBeenWritten('/path/to/avatars/57853c107d1aeaa7da6f3096385cb848.png', 'new-binary-image-data');
			expectFileToHaveBeenRead('/path/to/avatars/57853c107d1aeaa7da6f3096385cb848.png');
			expect(spyOnSaveAvatar).toHaveBeenCalledWith('user2@mhutchie.com', {
				image: '57853c107d1aeaa7da6f3096385cb848.png',
				timestamp: 1587559258000,
				identicon: false
			});
		});

		it('Shouldn\'t replace the existing avatar if it wasn\'t an identicon and the new avatar is', async () => {
			// Setup
			spyOnGetRemoteUrl.mockResolvedValueOnce(null);
			mockReadFile('binary-image-data');
			mockHttpsResponse(404, 'new-binary-image-data');
			mockHttpsResponse(200, 'new-binary-image-data');
			mockWriteFile(null);
			mockReadFile('new-binary-image-data');
			const avatarEvents = waitForEvents(avatarManager, 2);

			// Run
			avatarManager.fetchAvatarImage('user2@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

			// Assert
			expect(await avatarEvents).toStrictEqual([
				{
					email: 'user2@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				},
				{
					email: 'user2@mhutchie.com',
					image: 'data:image/png;base64,bmV3LWJpbmFyeS1pbWFnZS1kYXRh'
				}
			]);
			expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
			expect(spyOnHttpsGet).toHaveBeenCalledWith({
				hostname: 'secure.gravatar.com',
				path: '/avatar/57853c107d1aeaa7da6f3096385cb848?s=162&d=404',
				headers: { 'User-Agent': 'vscode-git-graph' },
				agent: false,
				timeout: 15000
			}, expect.anything());
			expectFileToHaveBeenWritten('/path/to/avatars/57853c107d1aeaa7da6f3096385cb848.png', 'new-binary-image-data');
			expectFileToHaveBeenRead('/path/to/avatars/57853c107d1aeaa7da6f3096385cb848.png');
			expect(spyOnSaveAvatar).toHaveBeenCalledWith('user2@mhutchie.com', {
				image: '57853c107d1aeaa7da6f3096385cb848.png',
				timestamp: 1587559258000,
				identicon: false
			});
		});

		it('Should fetch an avatar when the existing identicon is over 4 days old', async () => {
			// Setup
			spyOnGetRemoteUrl.mockResolvedValueOnce(null);
			mockReadFile('binary-image-data');
			mockHttpsResponse(200, 'new-binary-image-data');
			mockWriteFile(null);
			mockReadFile('new-binary-image-data');
			const avatarEvents = waitForEvents(avatarManager, 2);

			// Run
			avatarManager.fetchAvatarImage('user3@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

			// Assert
			expect(await avatarEvents).toStrictEqual([
				{
					email: 'user3@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
				},
				{
					email: 'user3@mhutchie.com',
					image: 'data:image/png;base64,bmV3LWJpbmFyeS1pbWFnZS1kYXRh'
				}
			]);
			expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
			expect(spyOnHttpsGet).toHaveBeenCalledWith({
				hostname: 'secure.gravatar.com',
				path: '/avatar/e36b61e2afd912d3665f1aa92932aa87?s=162&d=404',
				headers: { 'User-Agent': 'vscode-git-graph' },
				agent: false,
				timeout: 15000
			}, expect.anything());
			expectFileToHaveBeenWritten('/path/to/avatars/e36b61e2afd912d3665f1aa92932aa87.png', 'new-binary-image-data');
			expectFileToHaveBeenRead('/path/to/avatars/e36b61e2afd912d3665f1aa92932aa87.png');
			expect(spyOnSaveAvatar).toHaveBeenCalledWith('user3@mhutchie.com', {
				image: 'e36b61e2afd912d3665f1aa92932aa87.png',
				timestamp: 1587559258000,
				identicon: false
			});
		});

		it('Should fetch multiple avatars', async () => {
			// Setup
			spyOnGetRemoteUrl.mockResolvedValueOnce(null);
			jest.useFakeTimers();
			mockHttpsResponse(200, 'binary-image-data-one');
			mockWriteFile(null);
			mockReadFile('binary-image-data-one');
			mockHttpsResponse(200, 'binary-image-data-two');
			mockWriteFile(null);
			mockReadFile('binary-image-data-two');
			const avatarEvents = waitForEvents(avatarManager, 2, true);

			// Run
			avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);
			avatarManager.fetchAvatarImage('user5@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

			// Assert
			expect(await avatarEvents).toStrictEqual([
				{
					email: 'user4@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGEtb25l'
				},
				{
					email: 'user5@mhutchie.com',
					image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGEtdHdv'
				}
			]);
			expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
			expect(spyOnHttpsGet).toHaveBeenCalledWith({
				hostname: 'secure.gravatar.com',
				path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
				headers: { 'User-Agent': 'vscode-git-graph' },
				agent: false,
				timeout: 15000
			}, expect.anything());
			expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data-one');
			expectFileToHaveBeenRead('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png');
			expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
				image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
				timestamp: 1587559258000,
				identicon: false
			});
			expect(spyOnHttpsGet).toHaveBeenCalledWith({
				hostname: 'secure.gravatar.com',
				path: '/avatar/da4173f868c17bcd6353cdba41070ca9?s=162&d=404',
				headers: { 'User-Agent': 'vscode-git-graph' },
				agent: false,
				timeout: 15000
			}, expect.anything());
			expectFileToHaveBeenWritten('/path/to/avatars/da4173f868c17bcd6353cdba41070ca9.png', 'binary-image-data-two');
			expectFileToHaveBeenRead('/path/to/avatars/da4173f868c17bcd6353cdba41070ca9.png');
			expect(spyOnSaveAvatar).toHaveBeenCalledWith('user5@mhutchie.com', {
				image: 'da4173f868c17bcd6353cdba41070ca9.png',
				timestamp: 1587559258000,
				identicon: false
			});
		});

		it('Should fetch a new avatar when the existing image can\'t be read', async () => {
			// Setup
			spyOnGetRemoteUrl.mockResolvedValueOnce(null);
			mockReadFile(null);
			mockHttpsResponse(200, 'binary-image-data');
			mockWriteFile(null);
			mockReadFile('binary-image-data');
			const avatarEvents = waitForEvents(avatarManager, 1);

			// Run
			avatarManager.fetchAvatarImage('user1@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

			// Assert
			expect(await avatarEvents).toStrictEqual([{
				email: 'user1@mhutchie.com',
				image: 'data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE='
			}]);
			expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
			expect(spyOnRemoveAvatarFromCache).toHaveBeenCalledWith('user1@mhutchie.com');
			expect(spyOnHttpsGet).toHaveBeenCalledWith({
				hostname: 'secure.gravatar.com',
				path: '/avatar/530a7b02594e057f39179d3bd8b849f0?s=162&d=404',
				headers: { 'User-Agent': 'vscode-git-graph' },
				agent: false,
				timeout: 15000
			}, expect.anything());
			expectFileToHaveBeenWritten('/path/to/avatars/530a7b02594e057f39179d3bd8b849f0.png', 'binary-image-data');
			expectFileToHaveBeenRead('/path/to/avatars/530a7b02594e057f39179d3bd8b849f0.png');
			expect(spyOnSaveAvatar).toHaveBeenCalledWith('user1@mhutchie.com', {
				image: '530a7b02594e057f39179d3bd8b849f0.png',
				timestamp: 1587559258000,
				identicon: false
			});
		});

		it('Should fetch a new avatar, but not send it to the Git Graph View', async () => {
			// Setup
			spyOnGetRemoteUrl.mockResolvedValueOnce(null);
			mockHttpsResponse(200, 'binary-image-data');
			mockWriteFile(null);
			mockReadFile(null);
			avatarManager.onAvatar(() => { });

			// Run
			avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Saved Avatar for user4@*****');
				expect(spyOnLog).toHaveBeenCalledWith('Failed to Send Avatar for user4@***** to the Git Graph View');
			});
			expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
			expect(spyOnHttpsGet).toHaveBeenCalledWith({
				hostname: 'secure.gravatar.com',
				path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
				headers: { 'User-Agent': 'vscode-git-graph' },
				agent: false,
				timeout: 15000
			}, expect.anything());
			expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
			expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
				image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
				timestamp: 1587559258000,
				identicon: false
			});
		});

		it('Should fetch a new avatar, and log when it fails to send it to the Git Graph View', async () => {
			// Setup
			spyOnGetRemoteUrl.mockResolvedValueOnce(null);
			mockHttpsResponse(200, 'binary-image-data');
			mockWriteFile(null);

			// Run
			avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('Saved Avatar for user4@*****');
				expect(spyOnLog).toHaveBeenCalledWith('Avatar for user4@***** is ready to be used the next time the Git Graph View is opened');
			});
			expect(spyOnGetRemoteUrl).toHaveBeenCalledWith('test-repo', 'test-remote');
			expect(spyOnHttpsGet).toHaveBeenCalledWith({
				hostname: 'secure.gravatar.com',
				path: '/avatar/0ca9d3f228e867bd4feb6d62cc2edbfe?s=162&d=404',
				headers: { 'User-Agent': 'vscode-git-graph' },
				agent: false,
				timeout: 15000
			}, expect.anything());
			expectFileToHaveBeenWritten('/path/to/avatars/0ca9d3f228e867bd4feb6d62cc2edbfe.png', 'binary-image-data');
			expect(spyOnSaveAvatar).toHaveBeenCalledWith('user4@mhutchie.com', {
				image: '0ca9d3f228e867bd4feb6d62cc2edbfe.png',
				timestamp: 1587559258000,
				identicon: false
			});
		});

		it('Should add new commits to existing records queued for the same user in the same repository', async () => {
			// Setup
			spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
			mockHttpsResponse(403, '', { 'x-ratelimit-remaining': '0', 'x-ratelimit-reset': (date.now + 1).toString() });

			// Run
			avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', [
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
				'5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f'
			]);

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('GitHub API Rate Limit Reached - Paused fetching from GitHub until the Rate Limit is reset');
			});

			// Run
			avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', [
				'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
				'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
				'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
				'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e'
			]);

			// Assert
			expect(avatarManager['queue']['queue']).toStrictEqual([
				{
					email: 'user4@mhutchie.com',
					repo: 'test-repo',
					remote: 'test-remote',
					commits: [
						'1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b',
						'3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d',
						'5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f',
						'2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c',
						'4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e'
					],
					checkAfter: (date.now + 1) * 1000,
					attempts: 0
				}
			]);
			expect(avatarManager['githubTimeout']).toBe(1587559259000);
		});

		it('Should insert requests into the priority queue in the correct order', async () => {
			// Setup
			spyOnGetRemoteUrl.mockResolvedValueOnce('https://github.com/mhutchie/test-repo.git');
			mockHttpsResponse(403, '', { 'x-ratelimit-remaining': '0', 'x-ratelimit-reset': (date.now + 1).toString() });

			// Run
			avatarManager.fetchAvatarImage('user4@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

			// Assert
			await waitForExpect(() => {
				expect(spyOnLog).toHaveBeenCalledWith('GitHub API Rate Limit Reached - Paused fetching from GitHub until the Rate Limit is reset');
			});

			// Run
			avatarManager.fetchAvatarImage('user2@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);
			avatarManager.fetchAvatarImage('user5@mhutchie.com', 'test-repo', 'test-remote', ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b']);

			// Assert
			expect(avatarManager['queue']['queue']).toStrictEqual([
				{
					email: 'user5@mhutchie.com',
					repo: 'test-repo',
					remote: 'test-remote',
					commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
					checkAfter: 0,
					attempts: 0
				},
				{
					email: 'user4@mhutchie.com',
					repo: 'test-repo',
					remote: 'test-remote',
					commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
					checkAfter: (date.now + 1) * 1000,
					attempts: 0
				},
				{
					email: 'user2@mhutchie.com',
					repo: 'test-repo',
					remote: 'test-remote',
					commits: ['1a2b3c4d5e6f1a2b3c4d5e6f1a2b3c4d5e6f1a2b'],
					checkAfter: (date.now + 1) * 1000 + 1,
					attempts: 0
				}
			]);
		});
	});

	describe('getAvatarImage', () => {
		it('Should return a Data Url of the avatar\'s image data', async () => {
			// Setup
			mockReadFile('binary-image-data');

			// Run
			const avatar = await avatarManager.getAvatarImage('user1@mhutchie.com');

			// Assert
			expect(avatar).toBe('data:image/png;base64,YmluYXJ5LWltYWdlLWRhdGE=');
			expectFileToHaveBeenRead('/path/to/avatars/530a7b02594e057f39179d3bd8b849f0.png');
		});

		it('Should return null when the avatar file could not be read from the file system', async () => {
			// Setup
			mockReadFile(null);

			// Run
			const avatar = await avatarManager.getAvatarImage('user1@mhutchie.com');

			// Assert
			expect(avatar).toBe(null);
			expectFileToHaveBeenRead('/path/to/avatars/530a7b02594e057f39179d3bd8b849f0.png');
		});

		it('Should return null when no avatar exists for the provided email address', async () => {
			// Run
			const avatar = await avatarManager.getAvatarImage('user4@mhutchie.com');

			// Assert
			expect(avatar).toBe(null);
			expect(spyOnReadFile).not.toHaveBeenCalled();
		});
	});

	describe('clearCache', () => {
		let spyOnClearAvatarCache: jest.SpyInstance;
		beforeAll(() => {
			spyOnClearAvatarCache = jest.spyOn(extensionState, 'clearAvatarCache');
		});

		it('Should clear the cache of avatars', async () => {
			// Setup
			spyOnClearAvatarCache.mockResolvedValueOnce(null);

			// Run
			const result = await avatarManager.clearCache();

			// Assert
			expect(result).toBeNull();
			expect(avatarManager['avatars']).toStrictEqual({});
			expect(spyOnClearAvatarCache).toHaveBeenCalledTimes(1);
		});

		it('Should return the error message returned by ExtensionState.clearAvatarCache', async () => {
			// Setup
			const errorMessage = 'Visual Studio Code was unable to save the Git Graph Global State Memento.';
			spyOnClearAvatarCache.mockResolvedValueOnce(errorMessage);

			// Run
			const result = await avatarManager.clearCache();

			// Assert
			expect(result).toBe(errorMessage);
			expect(avatarManager['avatars']).toStrictEqual({});
			expect(spyOnClearAvatarCache).toHaveBeenCalledTimes(1);
		});
	});
});

function mockHttpsResponse(statusCode: number, imageData: string, headers: { [header: string]: string } = {}) {
	spyOnHttpsGet.mockImplementationOnce((_: string | https.RequestOptions | URL, callback: (res: IncomingMessage) => void): ClientRequest => {
		if (callback) {
			const callbacks: { [event: string]: (...args: any) => void } = {};
			const message: IncomingMessage = <any>{
				statusCode: statusCode,
				headers: Object.assign({
					'content-type': 'image/png'
				}, headers),
				on: (event: string, listener: () => void) => {
					callbacks[event] = listener;
					return message;
				}
			};
			callback(message);
			callbacks['data'](Buffer.from(imageData));
			callbacks['end']();
		}
		return ({
			on: jest.fn()
		}) as any as ClientRequest;
	});
}

function mockHttpsClientRequestErrorEvent() {
	spyOnHttpsGet.mockImplementationOnce((_1: string | https.RequestOptions | URL, _2: (res: IncomingMessage) => void): ClientRequest => {
		const request: ClientRequest = <any>{
			on: (event: string, callback: () => void) => {
				if (event === 'error') {
					callback();
				}
				return request;
			}
		};
		return request;
	});
}

function mockHttpsIncomingMessageErrorEvent() {
	spyOnHttpsGet.mockImplementationOnce((_: string | https.RequestOptions | URL, callback: (res: IncomingMessage) => void): ClientRequest => {
		const callbacks: { [event: string]: (...args: any) => void } = {};
		const message: IncomingMessage = <any>{
			on: (event: string, listener: () => void) => {
				callbacks[event] = listener;
				return message;
			}
		};
		callback(message);
		callbacks['error']();
		return ({
			on: jest.fn()
		}) as any as ClientRequest;
	});
}

function mockHttpsMultipleErrorEvents() {
	spyOnHttpsGet.mockImplementationOnce((_: string | https.RequestOptions | URL, callback: (res: IncomingMessage) => void): ClientRequest => {
		const callbacks: { [event: string]: (...args: any) => void } = {};
		const message: IncomingMessage = <any>{
			on: (event: string, listener: () => void) => {
				callbacks[event] = listener;
				return message;
			}
		};
		callback(message);
		callbacks['error']();

		const request: ClientRequest = <any>{
			on: (event: string, callback: () => void) => {
				if (event === 'error') {
					callback();
				}
				return request;
			}
		};
		return request;
	});
}

function mockWriteFile(error: NodeJS.ErrnoException | null) {
	spyOnWriteFile.mockImplementationOnce((_1: fs.PathLike | number, _2: Buffer, callback: (err: NodeJS.ErrnoException | null) => void) => callback(error));
}

function mockReadFile(data: string | null) {
	spyOnReadFile.mockImplementationOnce((_: fs.PathLike | number, callback: (err: NodeJS.ErrnoException | null, _: Buffer) => void) => {
		if (data) {
			callback(null, Buffer.from(data));
		} else {
			callback(new Error(), Buffer.alloc(0));
		}
	});
}

function expectFileToHaveBeenWritten(name: string, data: string) {
	expect(spyOnWriteFile.mock.calls.some((args) => args[0] === name && args[1].toString() === data)).toBe(true);
}

function expectFileToHaveBeenRead(name: string) {
	expect(spyOnReadFile.mock.calls.some((args) => args[0] === name)).toBe(true);
}

function waitForEvents(avatarManager: AvatarManager, n: number, runPendingTimers = false) {
	return new Promise<AvatarEvent[]>((resolve) => {
		const events: AvatarEvent[] = [];
		avatarManager.onAvatar((event) => {
			events.push(event);
			if (runPendingTimers) {
				jest.runOnlyPendingTimers();
			}
			if (events.length === n) {
				resolve(events);
			}
		});
	});
}
-e 

================================================================================
// FILE: ./tests/bufferedQueue.test.ts
================================================================================
import { BufferedQueue } from '../src/utils/bufferedQueue';

import { waitForExpect } from './helpers/expectations';

describe('BufferedQueue', () => {
	beforeEach(() => {
		jest.useFakeTimers();
	});

	it('Should add items to the queue, and then process them once the buffer has expired', async () => {
		// Setup
		const onItem = jest.fn(() => Promise.resolve(true)), onChanges = jest.fn(() => { });
		const queue = new BufferedQueue<string>(onItem, onChanges);

		// Run
		queue.enqueue('a');
		queue.enqueue('b');
		queue.enqueue('c');

		// Assert
		expect(queue['queue']).toStrictEqual(['a', 'b', 'c']);
		expect(queue['processing']).toBe(false);
		expect(clearTimeout).toHaveBeenCalledTimes(2);

		// Run
		jest.runOnlyPendingTimers();
		jest.useRealTimers();

		// Assert
		await waitForExpect(() => expect(queue['processing']).toBe(false));
		expect(onItem).toHaveBeenCalledTimes(3);
		expect(onItem).toHaveBeenCalledWith('a');
		expect(onItem).toHaveBeenCalledWith('b');
		expect(onItem).toHaveBeenCalledWith('c');
		expect(onChanges).toHaveBeenCalledTimes(1);

		// Run
		expect(queue['timeout']).toBe(null);
		queue.dispose();
		expect(queue['timeout']).toBe(null);
	});

	it('Shouldn\'t add duplicate items to the queue', async () => {
		// Setup
		const onItem = jest.fn(() => Promise.resolve(true)), onChanges = jest.fn(() => { });
		const queue = new BufferedQueue<string>(onItem, onChanges);

		// Run
		queue.enqueue('a');
		queue.enqueue('b');
		queue.enqueue('c');
		queue.enqueue('a');

		// Assert
		expect(queue['queue']).toStrictEqual(['b', 'c', 'a']);
		expect(queue['processing']).toBe(false);

		// Run
		jest.runOnlyPendingTimers();
		jest.useRealTimers();

		// Assert
		await waitForExpect(() => expect(queue['processing']).toBe(false));
		expect(onItem).toHaveBeenCalledTimes(3);
		expect(onItem).toHaveBeenCalledWith('b');
		expect(onItem).toHaveBeenCalledWith('c');
		expect(onItem).toHaveBeenCalledWith('a');
		expect(onChanges).toHaveBeenCalledTimes(1);
	});

	it('Shouldn\'t call onChanges if not items resulted in a change', async () => {
		// Setup
		const onItem = jest.fn(() => Promise.resolve(false)), onChanges = jest.fn(() => { });
		const queue = new BufferedQueue<string>(onItem, onChanges);

		// Run
		queue.enqueue('a');
		queue.enqueue('b');
		queue.enqueue('c');

		// Assert
		expect(queue['queue']).toStrictEqual(['a', 'b', 'c']);
		expect(queue['processing']).toBe(false);

		// Run
		jest.runOnlyPendingTimers();
		jest.useRealTimers();

		// Assert
		await waitForExpect(() => expect(queue['processing']).toBe(false));
		expect(onItem).toHaveBeenCalledTimes(3);
		expect(onItem).toHaveBeenCalledWith('a');
		expect(onItem).toHaveBeenCalledWith('b');
		expect(onItem).toHaveBeenCalledWith('c');
		expect(onChanges).toHaveBeenCalledTimes(0);
	});

	it('Shouldn\'t trigger a new timeout if the queue is already processing events', () => {
		// Setup
		const onItem = jest.fn(() => Promise.resolve(true)), onChanges = jest.fn(() => { });
		const queue = new BufferedQueue<string>(onItem, onChanges);
		queue['processing'] = true;

		// Run
		queue.enqueue('a');
		queue.enqueue('b');
		queue.enqueue('c');

		// Assert
		expect(queue['queue']).toStrictEqual(['a', 'b', 'c']);
		expect(queue['timeout']).toBe(null);
	});

	it('Should clear the timeout when disposed', async () => {
		// Setup
		const onItem = jest.fn(() => Promise.resolve(true)), onChanges = jest.fn(() => { });
		const queue = new BufferedQueue<string>(onItem, onChanges);

		// Run
		queue.enqueue('a');
		queue.enqueue('b');
		queue.enqueue('c');

		// Assert
		expect(queue['queue']).toStrictEqual(['a', 'b', 'c']);
		expect(queue['processing']).toBe(false);
		expect(jest.getTimerCount()).toBe(1);

		// Run
		queue.dispose();

		// Assert
		expect(jest.getTimerCount()).toBe(0);
		expect(queue['timeout']).toBe(null);
	});

	describe('bufferDuration', () => {
		it('Should use the default buffer duration of 1000ms', async () => {
			// Setup
			const onItem = jest.fn(() => Promise.resolve(true)), onChanges = jest.fn(() => { });
			const queue = new BufferedQueue<string>(onItem, onChanges);

			// Run
			queue.enqueue('a');

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 1000);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();

			// Assert
			await waitForExpect(() => expect(queue['processing']).toBe(false));
			expect(onItem).toHaveBeenCalledTimes(1);
			expect(onItem).toHaveBeenCalledWith('a');
			expect(onChanges).toHaveBeenCalledTimes(1);
		});

		it('Should use the specified buffer duration', async () => {
			// Setup
			const onItem = jest.fn(() => Promise.resolve(true)), onChanges = jest.fn(() => { });
			const queue = new BufferedQueue<string>(onItem, onChanges, 128);

			// Run
			queue.enqueue('a');

			// Assert
			expect(setTimeout).toHaveBeenCalledWith(expect.anything(), 128);

			// Run
			jest.runOnlyPendingTimers();
			jest.useRealTimers();

			// Assert
			await waitForExpect(() => expect(queue['processing']).toBe(false));
			expect(onItem).toHaveBeenCalledTimes(1);
			expect(onItem).toHaveBeenCalledWith('a');
			expect(onChanges).toHaveBeenCalledTimes(1);
		});
	});
});
-e 

================================================================================
// FILE: ./web/main.ts
================================================================================
class GitGraphView {
	private gitRepos: GG.GitRepoSet;
	private gitBranches: ReadonlyArray<string> = [];
	private gitBranchHead: string | null = null;
	private gitConfig: GG.GitRepoConfig | null = null;
	private gitRemotes: ReadonlyArray<string> = [];
	private gitStashes: ReadonlyArray<GG.GitStash> = [];
	private gitTags: ReadonlyArray<string> = [];
	private commits: GG.GitCommit[] = [];
	private commitHead: string | null = null;
	private commitLookup: { [hash: string]: number } = {};
	private onlyFollowFirstParent: boolean = false;
	private avatars: AvatarImageCollection = {};
	private currentBranches: string[] | null = null;

	private currentRepo!: string;
	private currentRepoLoading: boolean = true;
	private currentRepoRefreshState: {
		inProgress: boolean;
		hard: boolean;
		loadRepoInfoRefreshId: number;
		loadCommitsRefreshId: number;
		repoInfoChanges: boolean;
		configChanges: boolean;
		requestingRepoInfo: boolean;
		requestingConfig: boolean;
	};
	private loadViewTo: GG.LoadGitGraphViewTo = null;

	private readonly graph: Graph;
	private readonly config: Config;

	private moreCommitsAvailable: boolean = false;
	private expandedCommit: ExpandedCommit | null = null;
	private maxCommits: number;
	private scrollTop = 0;
	private renderedGitBranchHead: string | null = null;

	private lastScrollToStash: {
		time: number,
		hash: string | null
	} = { time: 0, hash: null };

	private readonly findWidget: FindWidget;
	private readonly settingsWidget: SettingsWidget;
	private readonly repoDropdown: Dropdown;
	private readonly branchDropdown: Dropdown;

	private readonly viewElem: HTMLElement;
	private readonly controlsElem: HTMLElement;
	private readonly tableElem: HTMLElement;
	private readonly footerElem: HTMLElement;
	private readonly showRemoteBranchesElem: HTMLInputElement;
	private readonly refreshBtnElem: HTMLElement;
	private readonly scrollShadowElem: HTMLElement;

	constructor(viewElem: HTMLElement, prevState: WebViewState | null) {
		this.gitRepos = initialState.repos;
		this.config = initialState.config;
		this.maxCommits = this.config.initialLoadCommits;
		this.viewElem = viewElem;
		this.currentRepoRefreshState = {
			inProgress: false,
			hard: true,
			loadRepoInfoRefreshId: initialState.loadRepoInfoRefreshId,
			loadCommitsRefreshId: initialState.loadCommitsRefreshId,
			repoInfoChanges: false,
			configChanges: false,
			requestingRepoInfo: false,
			requestingConfig: false
		};

		this.controlsElem = document.getElementById('controls')!;
		this.tableElem = document.getElementById('commitTable')!;
		this.footerElem = document.getElementById('footer')!;
		this.scrollShadowElem = <HTMLInputElement>document.getElementById('scrollShadow')!;

		viewElem.focus();

		this.graph = new Graph('commitGraph', viewElem, this.config.graph, this.config.mute);

		this.repoDropdown = new Dropdown('repoDropdown', true, false, 'Repos', (values) => {
			this.loadRepo(values[0]);
		});

		this.branchDropdown = new Dropdown('branchDropdown', false, true, 'Branches', (values) => {
			this.currentBranches = values;
			this.maxCommits = this.config.initialLoadCommits;
			this.saveState();
			this.clearCommits();
			this.requestLoadRepoInfoAndCommits(true, true);
		});

		this.showRemoteBranchesElem = <HTMLInputElement>document.getElementById('showRemoteBranchesCheckbox')!;
		this.showRemoteBranchesElem.addEventListener('change', () => {
			this.saveRepoStateValue(this.currentRepo, 'showRemoteBranchesV2', this.showRemoteBranchesElem.checked ? GG.BooleanOverride.Enabled : GG.BooleanOverride.Disabled);
			this.refresh(true);
		});

		this.refreshBtnElem = document.getElementById('refreshBtn')!;
		this.refreshBtnElem.addEventListener('click', () => {
			if (!this.refreshBtnElem.classList.contains(CLASS_REFRESHING)) {
				this.refresh(true, true);
			}
		});
		this.renderRefreshButton();

		this.findWidget = new FindWidget(this);
		this.settingsWidget = new SettingsWidget(this);

		alterClass(document.body, CLASS_BRANCH_LABELS_ALIGNED_TO_GRAPH, this.config.referenceLabels.branchLabelsAlignedToGraph);
		alterClass(document.body, CLASS_TAG_LABELS_RIGHT_ALIGNED, this.config.referenceLabels.tagLabelsOnRight);

		this.observeWindowSizeChanges();
		this.observeWebviewStyleChanges();
		this.observeViewScroll();
		this.observeKeyboardEvents();
		this.observeUrls();
		this.observeTableEvents();

		if (prevState && !prevState.currentRepoLoading && typeof this.gitRepos[prevState.currentRepo] !== 'undefined') {
			this.currentRepo = prevState.currentRepo;
			this.currentBranches = prevState.currentBranches;
			this.maxCommits = prevState.maxCommits;
			this.expandedCommit = prevState.expandedCommit;
			this.avatars = prevState.avatars;
			this.gitConfig = prevState.gitConfig;
			this.loadRepoInfo(prevState.gitBranches, prevState.gitBranchHead, prevState.gitRemotes, prevState.gitStashes, true);
			this.loadCommits(prevState.commits, prevState.commitHead, prevState.gitTags, prevState.moreCommitsAvailable, prevState.onlyFollowFirstParent);
			this.findWidget.restoreState(prevState.findWidget);
			this.settingsWidget.restoreState(prevState.settingsWidget);
			this.showRemoteBranchesElem.checked = getShowRemoteBranches(this.gitRepos[prevState.currentRepo].showRemoteBranchesV2);
		}

		let loadViewTo = initialState.loadViewTo;
		if (loadViewTo === null && prevState && prevState.currentRepoLoading && typeof prevState.currentRepo !== 'undefined') {
			loadViewTo = { repo: prevState.currentRepo };
		}

		if (!this.loadRepos(this.gitRepos, initialState.lastActiveRepo, loadViewTo)) {
			if (prevState) {
				this.scrollTop = prevState.scrollTop;
				this.viewElem.scroll(0, this.scrollTop);
			}
			this.requestLoadRepoInfoAndCommits(false, false);
		}

		const fetchBtn = document.getElementById('fetchBtn')!, findBtn = document.getElementById('findBtn')!, settingsBtn = document.getElementById('settingsBtn')!, terminalBtn = document.getElementById('terminalBtn')!;
		fetchBtn.title = 'Fetch' + (this.config.fetchAndPrune ? ' & Prune' : '') + ' from Remote(s)';
		fetchBtn.innerHTML = SVG_ICONS.download;
		fetchBtn.addEventListener('click', () => this.fetchFromRemotesAction());
		findBtn.innerHTML = SVG_ICONS.search;
		findBtn.addEventListener('click', () => this.findWidget.show(true));
		settingsBtn.innerHTML = SVG_ICONS.gear;
		settingsBtn.addEventListener('click', () => this.settingsWidget.show(this.currentRepo));
		terminalBtn.innerHTML = SVG_ICONS.terminal;
		terminalBtn.addEventListener('click', () => {
			runAction({
				command: 'openTerminal',
				repo: this.currentRepo,
				name: this.gitRepos[this.currentRepo].name || getRepoName(this.currentRepo)
			}, 'Opening Terminal');
		});
	}


	/* Loading Data */

	public loadRepos(repos: GG.GitRepoSet, lastActiveRepo: string | null, loadViewTo: GG.LoadGitGraphViewTo) {
		this.gitRepos = repos;
		this.saveState();

		let newRepo: string;
		if (loadViewTo !== null && this.currentRepo !== loadViewTo.repo && typeof repos[loadViewTo.repo] !== 'undefined') {
			newRepo = loadViewTo.repo;
		} else if (typeof repos[this.currentRepo] === 'undefined') {
			newRepo = lastActiveRepo !== null && typeof repos[lastActiveRepo] !== 'undefined'
				? lastActiveRepo
				: getSortedRepositoryPaths(repos, this.config.repoDropdownOrder)[0];
		} else {
			newRepo = this.currentRepo;
		}

		alterClass(this.controlsElem, 'singleRepo', Object.keys(repos).length === 1);
		this.renderRepoDropdownOptions(newRepo);

		if (loadViewTo !== null) {
			if (loadViewTo.repo === newRepo) {
				this.loadViewTo = loadViewTo;
			} else {
				this.loadViewTo = null;
				showErrorMessage('Unable to load the Git Graph View for the repository "' + loadViewTo.repo + '". It is not currently included in Git Graph.');
			}
		} else {
			this.loadViewTo = null;
		}

		if (this.currentRepo !== newRepo) {
			this.loadRepo(newRepo);
			return true;
		} else {
			this.finaliseRepoLoad(false);
			return false;
		}
	}

	private loadRepo(repo: string) {
		this.currentRepo = repo;
		this.currentRepoLoading = true;
		this.showRemoteBranchesElem.checked = getShowRemoteBranches(this.gitRepos[this.currentRepo].showRemoteBranchesV2);
		this.maxCommits = this.config.initialLoadCommits;
		this.gitConfig = null;
		this.gitRemotes = [];
		this.gitStashes = [];
		this.gitTags = [];
		this.currentBranches = null;
		this.renderFetchButton();
		this.closeCommitDetails(false);
		this.settingsWidget.close();
		this.saveState();
		this.refresh(true);
	}

	private loadRepoInfo(branchOptions: ReadonlyArray<string>, branchHead: string | null, remotes: ReadonlyArray<string>, stashes: ReadonlyArray<GG.GitStash>, isRepo: boolean) {
		// Changes to this.gitStashes are reflected as changes to the commits when loadCommits is run
		this.gitStashes = stashes;

		if (!isRepo || (!this.currentRepoRefreshState.hard && arraysStrictlyEqual(this.gitBranches, branchOptions) && this.gitBranchHead === branchHead && arraysStrictlyEqual(this.gitRemotes, remotes))) {
			this.saveState();
			this.finaliseLoadRepoInfo(false, isRepo);
			return;
		}

		// Changes to these properties must be indicated as a repository info change
		this.gitBranches = branchOptions;
		this.gitBranchHead = branchHead;
		this.gitRemotes = remotes;

		// Update the state of the fetch button
		this.renderFetchButton();

		// Configure current branches
		if (this.currentBranches !== null && !(this.currentBranches.length === 1 && this.currentBranches[0] === SHOW_ALL_BRANCHES)) {
			// Filter any branches that are currently selected, but no longer exist
			const globPatterns = this.config.customBranchGlobPatterns.map((pattern) => pattern.glob);
			this.currentBranches = this.currentBranches.filter((branch) =>
				this.gitBranches.includes(branch) || globPatterns.includes(branch)
			);
		}
		if (this.currentBranches === null || this.currentBranches.length === 0) {
			// No branches are currently selected
			const onRepoLoadShowCheckedOutBranch = getOnRepoLoadShowCheckedOutBranch(this.gitRepos[this.currentRepo].onRepoLoadShowCheckedOutBranch);
			const onRepoLoadShowSpecificBranches = getOnRepoLoadShowSpecificBranches(this.gitRepos[this.currentRepo].onRepoLoadShowSpecificBranches);
			this.currentBranches = [];
			if (onRepoLoadShowSpecificBranches.length > 0) {
				// Show specific branches if they exist in the repository
				const globPatterns = this.config.customBranchGlobPatterns.map((pattern) => pattern.glob);
				this.currentBranches.push(...onRepoLoadShowSpecificBranches.filter((branch) =>
					this.gitBranches.includes(branch) || globPatterns.includes(branch)
				));
			}
			if (onRepoLoadShowCheckedOutBranch && this.gitBranchHead !== null && !this.currentBranches.includes(this.gitBranchHead)) {
				// Show the checked-out branch, and it hasn't already been added as a specific branch
				this.currentBranches.push(this.gitBranchHead);
			}
			if (this.currentBranches.length === 0) {
				this.currentBranches.push(SHOW_ALL_BRANCHES);
			}
		}

		this.saveState();

		// Set up branch dropdown options
		this.branchDropdown.setOptions(this.getBranchOptions(true), this.currentBranches);

		// Remove hidden remotes that no longer exist
		let hiddenRemotes = this.gitRepos[this.currentRepo].hideRemotes;
		let hideRemotes = hiddenRemotes.filter((hiddenRemote) => remotes.includes(hiddenRemote));
		if (hiddenRemotes.length !== hideRemotes.length) {
			this.saveRepoStateValue(this.currentRepo, 'hideRemotes', hideRemotes);
		}

		this.finaliseLoadRepoInfo(true, isRepo);
	}

	private finaliseLoadRepoInfo(repoInfoChanges: boolean, isRepo: boolean) {
		const refreshState = this.currentRepoRefreshState;
		if (refreshState.inProgress) {
			if (isRepo) {
				refreshState.repoInfoChanges = refreshState.repoInfoChanges || repoInfoChanges;
				refreshState.requestingRepoInfo = false;
				this.requestLoadCommits();
			} else {
				dialog.closeActionRunning();
				refreshState.inProgress = false;
				this.loadViewTo = null;
				this.renderRefreshButton();
				sendMessage({ command: 'loadRepos', check: true });
			}
		}
	}

	private loadCommits(commits: GG.GitCommit[], commitHead: string | null, tags: ReadonlyArray<string>, moreAvailable: boolean, onlyFollowFirstParent: boolean) {
		// This list of tags is just used to provide additional information in the dialogs. Tag information included in commits is used for all other purposes (e.g. rendering, context menus)
		const tagsChanged = !arraysStrictlyEqual(this.gitTags, tags);
		this.gitTags = tags;

		if (!this.currentRepoLoading && !this.currentRepoRefreshState.hard && this.moreCommitsAvailable === moreAvailable && this.onlyFollowFirstParent === onlyFollowFirstParent && this.commitHead === commitHead && commits.length > 0 && arraysEqual(this.commits, commits, (a, b) =>
			a.hash === b.hash &&
			arraysStrictlyEqual(a.heads, b.heads) &&
			arraysEqual(a.tags, b.tags, (a, b) => a.name === b.name && a.annotated === b.annotated) &&
			arraysEqual(a.remotes, b.remotes, (a, b) => a.name === b.name && a.remote === b.remote) &&
			arraysStrictlyEqual(a.parents, b.parents) &&
			((a.stash === null && b.stash === null) || (a.stash !== null && b.stash !== null && a.stash.selector === b.stash.selector))
		) && this.renderedGitBranchHead === this.gitBranchHead) {

			if (this.commits[0].hash === UNCOMMITTED) {
				this.commits[0] = commits[0];
				this.saveState();
				this.renderUncommittedChanges();
				if (this.expandedCommit !== null && this.expandedCommit.commitElem !== null) {
					if (this.expandedCommit.compareWithHash === null) {
						// Commit Details View is open
						if (this.expandedCommit.commitHash === UNCOMMITTED) {
							this.requestCommitDetails(this.expandedCommit.commitHash, true);
						}
					} else {
						// Commit Comparison is open
						if (this.expandedCommit.compareWithElem !== null && (this.expandedCommit.commitHash === UNCOMMITTED || this.expandedCommit.compareWithHash === UNCOMMITTED)) {
							this.requestCommitComparison(this.expandedCommit.commitHash, this.expandedCommit.compareWithHash, true);
						}
					}
				}
			} else if (tagsChanged) {
				this.saveState();
			}
			this.finaliseLoadCommits();
			return;
		}

		const currentRepoLoading = this.currentRepoLoading;
		this.currentRepoLoading = false;
		this.moreCommitsAvailable = moreAvailable;
		this.onlyFollowFirstParent = onlyFollowFirstParent;
		this.commits = commits;
		this.commitHead = commitHead;
		this.commitLookup = {};

		let i: number, expandedCommitVisible = false, expandedCompareWithCommitVisible = false, avatarsNeeded: { [email: string]: string[] } = {}, commit;
		for (i = 0; i < this.commits.length; i++) {
			commit = this.commits[i];
			this.commitLookup[commit.hash] = i;
			if (this.expandedCommit !== null) {
				if (this.expandedCommit.commitHash === commit.hash) {
					expandedCommitVisible = true;
				} else if (this.expandedCommit.compareWithHash === commit.hash) {
					expandedCompareWithCommitVisible = true;
				}
			}
			if (this.config.fetchAvatars && typeof this.avatars[commit.email] !== 'string' && commit.email !== '') {
				if (typeof avatarsNeeded[commit.email] === 'undefined') {
					avatarsNeeded[commit.email] = [commit.hash];
				} else {
					avatarsNeeded[commit.email].push(commit.hash);
				}
			}
		}

		if (this.expandedCommit !== null && (!expandedCommitVisible || (this.expandedCommit.compareWithHash !== null && !expandedCompareWithCommitVisible))) {
			this.closeCommitDetails(false);
		}

		this.saveState();

		this.graph.loadCommits(this.commits, this.commitHead, this.commitLookup, this.onlyFollowFirstParent);
		this.render();

		if (currentRepoLoading && this.config.onRepoLoad.scrollToHead && this.commitHead !== null) {
			this.scrollToCommit(this.commitHead, true);
		}

		this.finaliseLoadCommits();
		this.requestAvatars(avatarsNeeded);
	}

	private finaliseLoadCommits() {
		const refreshState = this.currentRepoRefreshState;
		if (refreshState.inProgress) {
			dialog.closeActionRunning();

			if (dialog.isTargetDynamicSource()) {
				if (refreshState.repoInfoChanges) {
					dialog.close();
				} else {
					dialog.refresh(this.getCommits());
				}
			}

			if (contextMenu.isTargetDynamicSource()) {
				if (refreshState.repoInfoChanges) {
					contextMenu.close();
				} else {
					contextMenu.refresh(this.getCommits());
				}
			}

			refreshState.inProgress = false;
			this.renderRefreshButton();
		}

		this.finaliseRepoLoad(true);
	}

	private finaliseRepoLoad(didLoadRepoData: boolean) {
		if (this.loadViewTo !== null && this.currentRepo === this.loadViewTo.repo) {
			if (this.loadViewTo.commitDetails && (this.expandedCommit === null || this.expandedCommit.commitHash !== this.loadViewTo.commitDetails.commitHash || this.expandedCommit.compareWithHash !== this.loadViewTo.commitDetails.compareWithHash)) {
				const commitIndex = this.getCommitId(this.loadViewTo.commitDetails.commitHash);
				const compareWithIndex = this.loadViewTo.commitDetails.compareWithHash !== null ? this.getCommitId(this.loadViewTo.commitDetails.compareWithHash) : null;
				const commitElems = getCommitElems();
				const commitElem = findCommitElemWithId(commitElems, commitIndex);
				const compareWithElem = findCommitElemWithId(commitElems, compareWithIndex);

				if (commitElem !== null && (this.loadViewTo.commitDetails.compareWithHash === null || compareWithElem !== null)) {
					if (compareWithElem !== null) {
						this.loadCommitComparison(commitElem, compareWithElem);
					} else {
						this.loadCommitDetails(commitElem);
					}
				} else {
					showErrorMessage('Unable to resume Code Review, it could not be found in the latest ' + this.maxCommits + ' commits that were loaded in this repository.');
				}
			} else if (this.loadViewTo.runCommandOnLoad) {
				switch (this.loadViewTo.runCommandOnLoad) {
					case 'fetch':
						this.fetchFromRemotesAction();
						break;
				}
			}
		}
		this.loadViewTo = null;

		if (this.gitConfig === null || (didLoadRepoData && this.currentRepoRefreshState.configChanges)) {
			this.requestLoadConfig();
		}
	}

	private clearCommits() {
		closeDialogAndContextMenu();
		this.moreCommitsAvailable = false;
		this.commits = [];
		this.commitHead = null;
		this.commitLookup = {};
		this.renderedGitBranchHead = null;
		this.closeCommitDetails(false);
		this.saveState();
		this.graph.loadCommits(this.commits, this.commitHead, this.commitLookup, this.onlyFollowFirstParent);
		this.tableElem.innerHTML = '';
		this.footerElem.innerHTML = '';
		this.renderGraph();
		this.findWidget.refresh();
	}

	public processLoadRepoInfoResponse(msg: GG.ResponseLoadRepoInfo) {
		if (msg.error === null) {
			const refreshState = this.currentRepoRefreshState;
			if (refreshState.inProgress && refreshState.loadRepoInfoRefreshId === msg.refreshId) {
				this.loadRepoInfo(msg.branches, msg.head, msg.remotes, msg.stashes, msg.isRepo);
			}
		} else {
			this.displayLoadDataError('Unable to load Repository Info', msg.error);
		}
	}

	public processLoadCommitsResponse(msg: GG.ResponseLoadCommits) {
		if (msg.error === null) {
			const refreshState = this.currentRepoRefreshState;
			if (refreshState.inProgress && refreshState.loadCommitsRefreshId === msg.refreshId) {
				this.loadCommits(msg.commits, msg.head, msg.tags, msg.moreCommitsAvailable, msg.onlyFollowFirstParent);
			}
		} else {
			const error = this.gitBranches.length === 0 && msg.error.indexOf('bad revision \'HEAD\'') > -1
				? 'There are no commits in this repository.'
				: msg.error;
			this.displayLoadDataError('Unable to load Commits', error);
		}
	}

	public processLoadConfig(msg: GG.ResponseLoadConfig) {
		this.currentRepoRefreshState.requestingConfig = false;
		if (msg.config !== null && this.currentRepo === msg.repo) {
			this.gitConfig = msg.config;
			this.saveState();

			this.renderCdvExternalDiffBtn();
		}
		this.settingsWidget.refresh();
	}

	private displayLoadDataError(message: string, reason: string) {
		this.clearCommits();
		this.currentRepoRefreshState.inProgress = false;
		this.loadViewTo = null;
		this.renderRefreshButton();
		dialog.showError(message, reason, 'Retry', () => {
			this.refresh(true);
		});
	}

	public loadAvatar(email: string, image: string) {
		this.avatars[email] = image;
		this.saveState();
		let avatarsElems = <HTMLCollectionOf<HTMLElement>>document.getElementsByClassName('avatar'), escapedEmail = escapeHtml(email);
		for (let i = 0; i < avatarsElems.length; i++) {
			if (avatarsElems[i].dataset.email === escapedEmail) {
				avatarsElems[i].innerHTML = '<img class="avatarImg" src="' + image + '">';
			}
		}
	}


	/* Getters */

	public getBranches(): ReadonlyArray<string> {
		return this.gitBranches;
	}

	public getBranchOptions(includeShowAll?: boolean): ReadonlyArray<DialogSelectInputOption> {
		const options: DialogSelectInputOption[] = [];
		if (includeShowAll) {
			options.push({ name: 'Show All', value: SHOW_ALL_BRANCHES });
		}
		for (let i = 0; i < this.config.customBranchGlobPatterns.length; i++) {
			options.push({ name: 'Glob: ' + this.config.customBranchGlobPatterns[i].name, value: this.config.customBranchGlobPatterns[i].glob });
		}
		for (let i = 0; i < this.gitBranches.length; i++) {
			options.push({ name: this.gitBranches[i].indexOf('remotes/') === 0 ? this.gitBranches[i].substring(8) : this.gitBranches[i], value: this.gitBranches[i] });
		}
		return options;
	}

	public getCommitId(hash: string) {
		return typeof this.commitLookup[hash] === 'number' ? this.commitLookup[hash] : null;
	}

	private getCommitOfElem(elem: HTMLElement) {
		let id = parseInt(elem.dataset.id!);
		return id < this.commits.length ? this.commits[id] : null;
	}

	public getCommits(): ReadonlyArray<GG.GitCommit> {
		return this.commits;
	}

	private getPushRemote(branch: string | null = null) {
		const possibleRemotes = [];
		if (this.gitConfig !== null) {
			if (branch !== null && typeof this.gitConfig.branches[branch] !== 'undefined') {
				possibleRemotes.push(this.gitConfig.branches[branch].pushRemote, this.gitConfig.branches[branch].remote);
			}
			possibleRemotes.push(this.gitConfig.pushDefault);
		}
		possibleRemotes.push('origin');
		return possibleRemotes.find((remote) => remote !== null && this.gitRemotes.includes(remote)) || this.gitRemotes[0];
	}

	public getRepoConfig(): Readonly<GG.GitRepoConfig> | null {
		return this.gitConfig;
	}

	public getRepoState(repo: string): Readonly<GG.GitRepoState> | null {
		return typeof this.gitRepos[repo] !== 'undefined'
			? this.gitRepos[repo]
			: null;
	}

	public isConfigLoading(): boolean {
		return this.currentRepoRefreshState.requestingConfig;
	}


	/* Refresh */

	public refresh(hard: boolean, configChanges: boolean = false) {
		if (hard) {
			this.clearCommits();
		}
		this.requestLoadRepoInfoAndCommits(hard, false, configChanges);
	}


	/* Requests */

	private requestLoadRepoInfo() {
		const repoState = this.gitRepos[this.currentRepo];
		sendMessage({
			command: 'loadRepoInfo',
			repo: this.currentRepo,
			refreshId: ++this.currentRepoRefreshState.loadRepoInfoRefreshId,
			showRemoteBranches: getShowRemoteBranches(repoState.showRemoteBranchesV2),
			showStashes: getShowStashes(repoState.showStashes),
			hideRemotes: repoState.hideRemotes
		});
	}

	private requestLoadCommits() {
		const repoState = this.gitRepos[this.currentRepo];
		sendMessage({
			command: 'loadCommits',
			repo: this.currentRepo,
			refreshId: ++this.currentRepoRefreshState.loadCommitsRefreshId,
			branches: this.currentBranches === null || (this.currentBranches.length === 1 && this.currentBranches[0] === SHOW_ALL_BRANCHES) ? null : this.currentBranches,
			maxCommits: this.maxCommits,
			showTags: getShowTags(repoState.showTags),
			showRemoteBranches: getShowRemoteBranches(repoState.showRemoteBranchesV2),
			includeCommitsMentionedByReflogs: getIncludeCommitsMentionedByReflogs(repoState.includeCommitsMentionedByReflogs),
			onlyFollowFirstParent: getOnlyFollowFirstParent(repoState.onlyFollowFirstParent),
			commitOrdering: getCommitOrdering(repoState.commitOrdering),
			remotes: this.gitRemotes,
			hideRemotes: repoState.hideRemotes,
			stashes: this.gitStashes
		});
	}

	private requestLoadRepoInfoAndCommits(hard: boolean, skipRepoInfo: boolean, configChanges: boolean = false) {
		const refreshState = this.currentRepoRefreshState;
		if (refreshState.inProgress) {
			refreshState.hard = refreshState.hard || hard;
			refreshState.configChanges = refreshState.configChanges || configChanges;
			if (!skipRepoInfo) {
				// This request will trigger a loadCommit request after the loadRepoInfo request has completed.
				// Invalidate any previous commit requests in progress.
				refreshState.loadCommitsRefreshId++;
			}
		} else {
			refreshState.hard = hard;
			refreshState.inProgress = true;
			refreshState.repoInfoChanges = false;
			refreshState.configChanges = configChanges;
			refreshState.requestingRepoInfo = false;
		}

		this.renderRefreshButton();
		if (this.commits.length === 0) {
			this.tableElem.innerHTML = '<h2 id="loadingHeader">' + SVG_ICONS.loading + 'Loading ...</h2>';
		}

		if (skipRepoInfo) {
			if (!refreshState.requestingRepoInfo) {
				this.requestLoadCommits();
			}
		} else {
			refreshState.requestingRepoInfo = true;
			this.requestLoadRepoInfo();
		}
	}

	public requestLoadConfig() {
		this.currentRepoRefreshState.requestingConfig = true;
		sendMessage({ command: 'loadConfig', repo: this.currentRepo, remotes: this.gitRemotes });
		this.settingsWidget.refresh();
	}

	public requestCommitDetails(hash: string, refresh: boolean) {
		let commit = this.commits[this.commitLookup[hash]];
		sendMessage({
			command: 'commitDetails',
			repo: this.currentRepo,
			commitHash: hash,
			hasParents: commit.parents.length > 0,
			stash: commit.stash,
			avatarEmail: this.config.fetchAvatars && hash !== UNCOMMITTED ? commit.email : null,
			refresh: refresh
		});
	}

	public requestCommitComparison(hash: string, compareWithHash: string, refresh: boolean) {
		let commitOrder = this.getCommitOrder(hash, compareWithHash);
		sendMessage({
			command: 'compareCommits',
			repo: this.currentRepo,
			commitHash: hash, compareWithHash: compareWithHash,
			fromHash: commitOrder.from, toHash: commitOrder.to,
			refresh: refresh
		});
	}

	private requestAvatars(avatars: { [email: string]: string[] }) {
		let emails = Object.keys(avatars), remote = this.gitRemotes.length > 0 ? this.gitRemotes.includes('origin') ? 'origin' : this.gitRemotes[0] : null;
		for (let i = 0; i < emails.length; i++) {
			sendMessage({ command: 'fetchAvatar', repo: this.currentRepo, remote: remote, email: emails[i], commits: avatars[emails[i]] });
		}
	}


	/* State */

	public saveState() {
		let expandedCommit;
		if (this.expandedCommit !== null) {
			expandedCommit = Object.assign({}, this.expandedCommit);
			expandedCommit.commitElem = null;
			expandedCommit.compareWithElem = null;
			expandedCommit.contextMenuOpen = {
				summary: false,
				fileView: -1
			};
		} else {
			expandedCommit = null;
		}

		VSCODE_API.setState({
			currentRepo: this.currentRepo,
			currentRepoLoading: this.currentRepoLoading,
			gitRepos: this.gitRepos,
			gitBranches: this.gitBranches,
			gitBranchHead: this.gitBranchHead,
			gitConfig: this.gitConfig,
			gitRemotes: this.gitRemotes,
			gitStashes: this.gitStashes,
			gitTags: this.gitTags,
			commits: this.commits,
			commitHead: this.commitHead,
			avatars: this.avatars,
			currentBranches: this.currentBranches,
			moreCommitsAvailable: this.moreCommitsAvailable,
			maxCommits: this.maxCommits,
			onlyFollowFirstParent: this.onlyFollowFirstParent,
			expandedCommit: expandedCommit,
			scrollTop: this.scrollTop,
			findWidget: this.findWidget.getState(),
			settingsWidget: this.settingsWidget.getState()
		});
	}

	public saveRepoState() {
		sendMessage({ command: 'setRepoState', repo: this.currentRepo, state: this.gitRepos[this.currentRepo] });
	}

	private saveColumnWidths(columnWidths: GG.ColumnWidth[]) {
		this.gitRepos[this.currentRepo].columnWidths = [columnWidths[0], columnWidths[2], columnWidths[3], columnWidths[4]];
		this.saveRepoState();
	}

	private saveExpandedCommitLoading(index: number, commitHash: string, commitElem: HTMLElement, compareWithHash: string | null, compareWithElem: HTMLElement | null) {
		this.expandedCommit = {
			index: index,
			commitHash: commitHash,
			commitElem: commitElem,
			compareWithHash: compareWithHash,
			compareWithElem: compareWithElem,
			commitDetails: null,
			fileChanges: null,
			fileTree: null,
			avatar: null,
			codeReview: null,
			lastViewedFile: null,
			loading: true,
			scrollTop: {
				summary: 0,
				fileView: 0
			},
			contextMenuOpen: {
				summary: false,
				fileView: -1
			}
		};
		this.saveState();
	}

	public saveRepoStateValue<K extends keyof GG.GitRepoState>(repo: string, key: K, value: GG.GitRepoState[K]) {
		if (repo === this.currentRepo) {
			this.gitRepos[this.currentRepo][key] = value;
			this.saveRepoState();
		}
	}


	/* Renderers */

	private render() {
		this.renderTable();
		this.renderGraph();
	}

	private renderGraph() {
		if (typeof this.currentRepo === 'undefined') {
			// Only render the graph if a repo is loaded (or a repo is currently being loaded)
			return;
		}

		const colHeadersElem = document.getElementById('tableColHeaders');
		const cdvHeight = this.gitRepos[this.currentRepo].cdvHeight;
		const headerHeight = colHeadersElem !== null ? colHeadersElem.clientHeight + 1 : 0;
		const expandedCommit = this.isCdvDocked() ? null : this.expandedCommit;
		const expandedCommitElem = expandedCommit !== null ? document.getElementById('cdv') : null;

		// Update the graphs grid dimensions
		this.config.graph.grid.expandY = expandedCommitElem !== null
			? expandedCommitElem.getBoundingClientRect().height
			: cdvHeight;
		this.config.graph.grid.y = this.commits.length > 0 && this.tableElem.children.length > 0
			? (this.tableElem.children[0].clientHeight - headerHeight - (expandedCommit !== null ? cdvHeight : 0)) / this.commits.length
			: this.config.graph.grid.y;
		this.config.graph.grid.offsetY = headerHeight + this.config.graph.grid.y / 2;

		this.graph.render(expandedCommit);
	}

	private renderTable() {
		const colVisibility = this.getColumnVisibility();
		const currentHash = this.commits.length > 0 && this.commits[0].hash === UNCOMMITTED ? UNCOMMITTED : this.commitHead;
		const vertexColours = this.graph.getVertexColours();
		const widthsAtVertices = this.config.referenceLabels.branchLabelsAlignedToGraph ? this.graph.getWidthsAtVertices() : [];
		const mutedCommits = this.graph.getMutedCommits(currentHash);
		const textFormatter = new TextFormatter(this.commits, this.gitRepos[this.currentRepo].issueLinkingConfig, {
			emoji: true,
			issueLinking: true,
			markdown: this.config.markdown
		});

		let html = '<tr id="tableColHeaders"><th id="tableHeaderGraphCol" class="tableColHeader" data-col="0">Graph</th><th class="tableColHeader" data-col="1">Description</th>' +
			(colVisibility.date ? '<th class="tableColHeader dateCol" data-col="2">Date</th>' : '') +
			(colVisibility.author ? '<th class="tableColHeader authorCol" data-col="3">Author</th>' : '') +
			(colVisibility.commit ? '<th class="tableColHeader" data-col="4">Commit</th>' : '') +
			'</tr>';

		for (let i = 0; i < this.commits.length; i++) {
			let commit = this.commits[i];
			let message = '<span class="text">' + textFormatter.format(commit.message) + '</span>';
			let date = formatShortDate(commit.date);
			let branchLabels = getBranchLabels(commit.heads, commit.remotes);
			let refBranches = '', refTags = '', j, k, refName, remoteName, refActive, refHtml, branchCheckedOutAtCommit: string | null = null;

			for (j = 0; j < branchLabels.heads.length; j++) {
				refName = escapeHtml(branchLabels.heads[j].name);
				refActive = branchLabels.heads[j].name === this.gitBranchHead;
				refHtml = '<span class="gitRef head' + (refActive ? ' active' : '') + '" data-name="' + refName + '">' + SVG_ICONS.branch + '<span class="gitRefName" data-fullref="' + refName + '">' + refName + '</span>';
				for (k = 0; k < branchLabels.heads[j].remotes.length; k++) {
					remoteName = escapeHtml(branchLabels.heads[j].remotes[k]);
					refHtml += '<span class="gitRefHeadRemote" data-remote="' + remoteName + '" data-fullref="' + escapeHtml(branchLabels.heads[j].remotes[k] + '/' + branchLabels.heads[j].name) + '">' + remoteName + '</span>';
				}
				refHtml += '</span>';
				refBranches = refActive ? refHtml + refBranches : refBranches + refHtml;
				if (refActive) branchCheckedOutAtCommit = this.gitBranchHead;
			}
			for (j = 0; j < branchLabels.remotes.length; j++) {
				refName = escapeHtml(branchLabels.remotes[j].name);
				refBranches += '<span class="gitRef remote" data-name="' + refName + '" data-remote="' + (branchLabels.remotes[j].remote !== null ? escapeHtml(branchLabels.remotes[j].remote!) : '') + '">' + SVG_ICONS.branch + '<span class="gitRefName" data-fullref="' + refName + '">' + refName + '</span></span>';
			}

			for (j = 0; j < commit.tags.length; j++) {
				refName = escapeHtml(commit.tags[j].name);
				refTags += '<span class="gitRef tag" data-name="' + refName + '" data-tagtype="' + (commit.tags[j].annotated ? 'annotated' : 'lightweight') + '">' + SVG_ICONS.tag + '<span class="gitRefName" data-fullref="' + refName + '">' + refName + '</span></span>';
			}

			if (commit.stash !== null) {
				refName = escapeHtml(commit.stash.selector);
				refBranches = '<span class="gitRef stash" data-name="' + refName + '">' + SVG_ICONS.stash + '<span class="gitRefName" data-fullref="' + refName + '">' + escapeHtml(commit.stash.selector.substring(5)) + '</span></span>' + refBranches;
			}

			const commitDot = commit.hash === this.commitHead
				? '<span class="commitHeadDot" title="' + (branchCheckedOutAtCommit !== null
					? 'The branch ' + escapeHtml('"' + branchCheckedOutAtCommit + '"') + ' is currently checked out at this commit'
					: 'This commit is currently checked out'
				) + '."></span>'
				: '';

			html += '<tr class="commit' + (commit.hash === currentHash ? ' current' : '') + (mutedCommits[i] ? ' mute' : '') + '"' + (commit.hash !== UNCOMMITTED ? '' : ' id="uncommittedChanges"') + ' data-id="' + i + '" data-color="' + vertexColours[i] + '">' +
				(this.config.referenceLabels.branchLabelsAlignedToGraph ? '<td>' + (refBranches !== '' ? '<span style="margin-left:' + (widthsAtVertices[i] - 4) + 'px"' + refBranches.substring(5) : '') + '</td><td><span class="description">' + commitDot : '<td></td><td><span class="description">' + commitDot + refBranches) + (this.config.referenceLabels.tagLabelsOnRight ? message + refTags : refTags + message) + '</span></td>' +
				(colVisibility.date ? '<td class="dateCol text" title="' + date.title + '">' + date.formatted + '</td>' : '') +
				(colVisibility.author ? '<td class="authorCol text" title="' + escapeHtml(commit.author + ' <' + commit.email + '>') + '">' + (this.config.fetchAvatars ? '<span class="avatar" data-email="' + escapeHtml(commit.email) + '">' + (typeof this.avatars[commit.email] === 'string' ? '<img class="avatarImg" src="' + this.avatars[commit.email] + '">' : '') + '</span>' : '') + escapeHtml(commit.author) + '</td>' : '') +
				(colVisibility.commit ? '<td class="text" title="' + escapeHtml(commit.hash) + '">' + abbrevCommit(commit.hash) + '</td>' : '') +
				'</tr>';
		}
		this.tableElem.innerHTML = '<table>' + html + '</table>';
		this.footerElem.innerHTML = this.moreCommitsAvailable ? '<div id="loadMoreCommitsBtn" class="roundedBtn">Load More Commits</div>' : '';
		this.makeTableResizable();
		this.findWidget.refresh();
		this.renderedGitBranchHead = this.gitBranchHead;

		if (this.moreCommitsAvailable) {
			document.getElementById('loadMoreCommitsBtn')!.addEventListener('click', () => {
				this.loadMoreCommits();
			});
		}

		if (this.expandedCommit !== null) {
			const expandedCommit = this.expandedCommit, elems = getCommitElems();
			const commitElem = findCommitElemWithId(elems, this.getCommitId(expandedCommit.commitHash));
			const compareWithElem = expandedCommit.compareWithHash !== null ? findCommitElemWithId(elems, this.getCommitId(expandedCommit.compareWithHash)) : null;

			if (commitElem === null || (expandedCommit.compareWithHash !== null && compareWithElem === null)) {
				this.closeCommitDetails(false);
				this.saveState();
			} else {
				expandedCommit.index = parseInt(commitElem.dataset.id!);
				expandedCommit.commitElem = commitElem;
				expandedCommit.compareWithElem = compareWithElem;
				this.saveState();
				if (expandedCommit.compareWithHash === null) {
					// Commit Details View is open
					if (!expandedCommit.loading && expandedCommit.commitDetails !== null && expandedCommit.fileTree !== null) {
						this.showCommitDetails(expandedCommit.commitDetails, expandedCommit.fileTree, expandedCommit.avatar, expandedCommit.codeReview, expandedCommit.lastViewedFile, true);
						if (expandedCommit.commitHash === UNCOMMITTED) {
							this.requestCommitDetails(expandedCommit.commitHash, true);
						}
					} else {
						this.loadCommitDetails(commitElem);
					}
				} else {
					// Commit Comparison is open
					if (!expandedCommit.loading && expandedCommit.fileChanges !== null && expandedCommit.fileTree !== null) {
						this.showCommitComparison(expandedCommit.commitHash, expandedCommit.compareWithHash, expandedCommit.fileChanges, expandedCommit.fileTree, expandedCommit.codeReview, expandedCommit.lastViewedFile, true);
						if (expandedCommit.commitHash === UNCOMMITTED || expandedCommit.compareWithHash === UNCOMMITTED) {
							this.requestCommitComparison(expandedCommit.commitHash, expandedCommit.compareWithHash, true);
						}
					} else {
						this.loadCommitComparison(commitElem, compareWithElem!);
					}
				}
			}
		}
	}

	private renderUncommittedChanges() {
		const colVisibility = this.getColumnVisibility(), date = formatShortDate(this.commits[0].date);
		document.getElementById('uncommittedChanges')!.innerHTML = '<td></td><td><b>' + escapeHtml(this.commits[0].message) + '</b></td>' +
			(colVisibility.date ? '<td class="dateCol text" title="' + date.title + '">' + date.formatted + '</td>' : '') +
			(colVisibility.author ? '<td class="authorCol text" title="* <>">*</td>' : '') +
			(colVisibility.commit ? '<td class="text" title="*">*</td>' : '');
	}

	private renderFetchButton() {
		alterClass(this.controlsElem, CLASS_FETCH_SUPPORTED, this.gitRemotes.length > 0);
	}

	public renderRefreshButton() {
		const enabled = !this.currentRepoRefreshState.inProgress;
		this.refreshBtnElem.title = enabled ? 'Refresh' : 'Refreshing';
		this.refreshBtnElem.innerHTML = enabled ? SVG_ICONS.refresh : SVG_ICONS.loading;
		alterClass(this.refreshBtnElem, CLASS_REFRESHING, !enabled);
	}

	public renderTagDetails(tagName: string, commitHash: string, details: GG.GitTagDetails) {
		const textFormatter = new TextFormatter(this.commits, this.gitRepos[this.currentRepo].issueLinkingConfig, {
			commits: true,
			emoji: true,
			issueLinking: true,
			markdown: this.config.markdown,
			multiline: true,
			urls: true
		});
		dialog.showMessage(
			'Tag <b><i>' + escapeHtml(tagName) + '</i></b><br><span class="messageContent">' +
			'<b>Object: </b>' + escapeHtml(details.hash) + '<br>' +
			'<b>Commit: </b>' + escapeHtml(commitHash) + '<br>' +
			'<b>Tagger: </b>' + escapeHtml(details.taggerName) + ' &lt;<a class="' + CLASS_EXTERNAL_URL + '" href="mailto:' + escapeHtml(details.taggerEmail) + '" tabindex="-1">' + escapeHtml(details.taggerEmail) + '</a>&gt;' + (details.signature !== null ? generateSignatureHtml(details.signature) : '') + '<br>' +
			'<b>Date: </b>' + formatLongDate(details.taggerDate) + '<br><br>' +
			textFormatter.format(details.message) +
			'</span>'
		);
	}

	public renderRepoDropdownOptions(repo?: string) {
		this.repoDropdown.setOptions(getRepoDropdownOptions(this.gitRepos), [repo || this.currentRepo]);
	}


	/* Context Menu Generation */

	private getBranchContextMenuActions(target: DialogTarget & RefTarget): ContextMenuActions {
		const refName = target.ref, visibility = this.config.contextMenuActionsVisibility.branch;
		const isSelectedInBranchesDropdown = this.branchDropdown.isSelected(refName);
		return [[
			{
				title: 'Checkout Branch',
				visible: visibility.checkout && this.gitBranchHead !== refName,
				onClick: () => this.checkoutBranchAction(refName, null, null, target)
			}, {
				title: 'Rename Branch' + ELLIPSIS,
				visible: visibility.rename,
				onClick: () => {
					dialog.showRefInput('Enter the new name for branch <b><i>' + escapeHtml(refName) + '</i></b>:', refName, 'Rename Branch', (newName) => {
						runAction({ command: 'renameBranch', repo: this.currentRepo, oldName: refName, newName: newName }, 'Renaming Branch');
					}, target);
				}
			}, {
				title: 'Delete Branch' + ELLIPSIS,
				visible: visibility.delete && this.gitBranchHead !== refName,
				onClick: () => {
					let remotesWithBranch = this.gitRemotes.filter(remote => this.gitBranches.includes('remotes/' + remote + '/' + refName));
					let inputs: DialogInput[] = [{ type: DialogInputType.Checkbox, name: 'Force Delete', value: this.config.dialogDefaults.deleteBranch.forceDelete }];
					if (remotesWithBranch.length > 0) {
						inputs.push({
							type: DialogInputType.Checkbox,
							name: 'Delete this branch on the remote' + (this.gitRemotes.length > 1 ? 's' : ''),
							value: false,
							info: 'This branch is on the remote' + (remotesWithBranch.length > 1 ? 's: ' : ' ') + formatCommaSeparatedList(remotesWithBranch.map((remote) => '"' + remote + '"'))
						});
					}
					dialog.showForm('Are you sure you want to delete the branch <b><i>' + escapeHtml(refName) + '</i></b>?', inputs, 'Yes, delete', (values) => {
						runAction({ command: 'deleteBranch', repo: this.currentRepo, branchName: refName, forceDelete: <boolean>values[0], deleteOnRemotes: remotesWithBranch.length > 0 && <boolean>values[1] ? remotesWithBranch : [] }, 'Deleting Branch');
					}, target);
				}
			}, {
				title: 'Merge into current branch' + ELLIPSIS,
				visible: visibility.merge && this.gitBranchHead !== refName,
				onClick: () => this.mergeAction(refName, refName, GG.MergeActionOn.Branch, target)
			}, {
				title: 'Rebase current branch on Branch' + ELLIPSIS,
				visible: visibility.rebase && this.gitBranchHead !== refName,
				onClick: () => this.rebaseAction(refName, refName, GG.RebaseActionOn.Branch, target)
			}, {
				title: 'Push Branch' + ELLIPSIS,
				visible: visibility.push && this.gitRemotes.length > 0,
				onClick: () => {
					const multipleRemotes = this.gitRemotes.length > 1;
					const inputs: DialogInput[] = [
						{ type: DialogInputType.Checkbox, name: 'Set Upstream', value: true },
						{
							type: DialogInputType.Radio,
							name: 'Push Mode',
							options: [
								{ name: 'Normal', value: GG.GitPushBranchMode.Normal },
								{ name: 'Force With Lease', value: GG.GitPushBranchMode.ForceWithLease },
								{ name: 'Force', value: GG.GitPushBranchMode.Force }
							],
							default: GG.GitPushBranchMode.Normal
						}
					];

					if (multipleRemotes) {
						inputs.unshift({
							type: DialogInputType.Select,
							name: 'Push to Remote(s)',
							defaults: [this.getPushRemote(refName)],
							options: this.gitRemotes.map((remote) => ({ name: remote, value: remote })),
							multiple: true
						});
					}

					dialog.showForm('Are you sure you want to push the branch <b><i>' + escapeHtml(refName) + '</i></b>' + (multipleRemotes ? '' : ' to the remote <b><i>' + escapeHtml(this.gitRemotes[0]) + '</i></b>') + '?', inputs, 'Yes, push', (values) => {
						const remotes = multipleRemotes ? <string[]>values.shift() : [this.gitRemotes[0]];
						const setUpstream = <boolean>values[0];
						runAction({
							command: 'pushBranch',
							repo: this.currentRepo,
							branchName: refName,
							remotes: remotes,
							setUpstream: setUpstream,
							mode: <GG.GitPushBranchMode>values[1],
							willUpdateBranchConfig: setUpstream && remotes.length > 0 && (this.gitConfig === null || typeof this.gitConfig.branches[refName] === 'undefined' || this.gitConfig.branches[refName].remote !== remotes[remotes.length - 1])
						}, 'Pushing Branch');
					}, target);
				}
			}
		], [
			this.getViewIssueAction(refName, visibility.viewIssue, target),
			{
				title: 'Create Pull Request' + ELLIPSIS,
				visible: visibility.createPullRequest && this.gitRepos[this.currentRepo].pullRequestConfig !== null,
				onClick: () => {
					const config = this.gitRepos[this.currentRepo].pullRequestConfig;
					if (config === null) return;
					dialog.showCheckbox('Are you sure you want to create a Pull Request for branch <b><i>' + escapeHtml(refName) + '</i></b>?', 'Push branch before creating the Pull Request', true, 'Yes, create Pull Request', (push) => {
						runAction({ command: 'createPullRequest', repo: this.currentRepo, config: config, sourceRemote: config.sourceRemote, sourceOwner: config.sourceOwner, sourceRepo: config.sourceRepo, sourceBranch: refName, push: push }, 'Creating Pull Request');
					}, target);
				}
			}
		], [
			{
				title: 'Create Archive',
				visible: visibility.createArchive,
				onClick: () => {
					runAction({ command: 'createArchive', repo: this.currentRepo, ref: refName }, 'Creating Archive');
				}
			},
			{
				title: 'Select in Branches Dropdown',
				visible: visibility.selectInBranchesDropdown && !isSelectedInBranchesDropdown,
				onClick: () => this.branchDropdown.selectOption(refName)
			},
			{
				title: 'Unselect in Branches Dropdown',
				visible: visibility.unselectInBranchesDropdown && isSelectedInBranchesDropdown,
				onClick: () => this.branchDropdown.unselectOption(refName)
			}
		], [
			{
				title: 'Copy Branch Name to Clipboard',
				visible: visibility.copyName,
				onClick: () => {
					sendMessage({ command: 'copyToClipboard', type: 'Branch Name', data: refName });
				}
			}
		]];
	}

	private getCommitContextMenuActions(target: DialogTarget & CommitTarget): ContextMenuActions {
		const hash = target.hash, visibility = this.config.contextMenuActionsVisibility.commit;
		const commit = this.commits[this.commitLookup[hash]];
		return [[
			{
				title: 'Add Tag' + ELLIPSIS,
				visible: visibility.addTag,
				onClick: () => this.addTagAction(hash, '', this.config.dialogDefaults.addTag.type, '', null, target)
			}, {
				title: 'Create Branch' + ELLIPSIS,
				visible: visibility.createBranch,
				onClick: () => this.createBranchAction(hash, '', this.config.dialogDefaults.createBranch.checkout, target)
			}
		], [
			{
				title: 'Checkout' + (globalState.alwaysAcceptCheckoutCommit ? '' : ELLIPSIS),
				visible: visibility.checkout,
				onClick: () => {
					const checkoutCommit = () => runAction({ command: 'checkoutCommit', repo: this.currentRepo, commitHash: hash }, 'Checking out Commit');
					if (globalState.alwaysAcceptCheckoutCommit) {
						checkoutCommit();
					} else {
						dialog.showCheckbox('Are you sure you want to checkout commit <b><i>' + abbrevCommit(hash) + '</i></b>? This will result in a \'detached HEAD\' state.', 'Always Accept', false, 'Yes, checkout', (alwaysAccept) => {
							if (alwaysAccept) {
								updateGlobalViewState('alwaysAcceptCheckoutCommit', true);
							}
							checkoutCommit();
						}, target);
					}
				}
			}, {
				title: 'Cherry Pick' + ELLIPSIS,
				visible: visibility.cherrypick,
				onClick: () => {
					const isMerge = commit.parents.length > 1;
					let inputs: DialogInput[] = [];
					if (isMerge) {
						let options = commit.parents.map((hash, index) => ({
							name: abbrevCommit(hash) + (typeof this.commitLookup[hash] === 'number' ? ': ' + this.commits[this.commitLookup[hash]].message : ''),
							value: (index + 1).toString()
						}));
						inputs.push({
							type: DialogInputType.Select,
							name: 'Parent Hash',
							options: options,
							default: '1',
							info: 'Choose the parent hash on the main branch, to cherry pick the commit relative to.'
						});
					}
					inputs.push({
						type: DialogInputType.Checkbox,
						name: 'Record Origin',
						value: this.config.dialogDefaults.cherryPick.recordOrigin,
						info: 'Record that this commit was the origin of the cherry pick by appending a line to the original commit message that states "(cherry picked from commit ...)".'
					}, {
						type: DialogInputType.Checkbox,
						name: 'No Commit',
						value: this.config.dialogDefaults.cherryPick.noCommit,
						info: 'Cherry picked changes will be staged but not committed, so that you can select and commit specific parts of this commit.'
					});

					dialog.showForm('Are you sure you want to cherry pick commit <b><i>' + abbrevCommit(hash) + '</i></b>?', inputs, 'Yes, cherry pick', (values) => {
						let parentIndex = isMerge ? parseInt(<string>values.shift()) : 0;
						runAction({
							command: 'cherrypickCommit',
							repo: this.currentRepo,
							commitHash: hash,
							parentIndex: parentIndex,
							recordOrigin: <boolean>values[0],
							noCommit: <boolean>values[1]
						}, 'Cherry picking Commit');
					}, target);
				}
			}, {
				title: 'Revert' + ELLIPSIS,
				visible: visibility.revert,
				onClick: () => {
					if (commit.parents.length > 1) {
						let options = commit.parents.map((hash, index) => ({
							name: abbrevCommit(hash) + (typeof this.commitLookup[hash] === 'number' ? ': ' + this.commits[this.commitLookup[hash]].message : ''),
							value: (index + 1).toString()
						}));
						dialog.showSelect('Are you sure you want to revert merge commit <b><i>' + abbrevCommit(hash) + '</i></b>? Choose the parent hash on the main branch, to revert the commit relative to:', '1', options, 'Yes, revert', (parentIndex) => {
							runAction({ command: 'revertCommit', repo: this.currentRepo, commitHash: hash, parentIndex: parseInt(parentIndex) }, 'Reverting Commit');
						}, target);
					} else {
						dialog.showConfirmation('Are you sure you want to revert commit <b><i>' + abbrevCommit(hash) + '</i></b>?', 'Yes, revert', () => {
							runAction({ command: 'revertCommit', repo: this.currentRepo, commitHash: hash, parentIndex: 0 }, 'Reverting Commit');
						}, target);
					}
				}
			}, {
				title: 'Drop' + ELLIPSIS,
				visible: visibility.drop && this.graph.dropCommitPossible(this.commitLookup[hash]),
				onClick: () => {
					dialog.showConfirmation('Are you sure you want to permanently drop commit <b><i>' + abbrevCommit(hash) + '</i></b>?' + (this.onlyFollowFirstParent ? '<br/><i>Note: By enabling "Only follow the first parent of commits", some commits may have been hidden from the Git Graph View that could affect the outcome of performing this action.</i>' : ''), 'Yes, drop', () => {
						runAction({ command: 'dropCommit', repo: this.currentRepo, commitHash: hash }, 'Dropping Commit');
					}, target);
				}
			}
		], [
			{
				title: 'Merge into current branch' + ELLIPSIS,
				visible: visibility.merge,
				onClick: () => this.mergeAction(hash, abbrevCommit(hash), GG.MergeActionOn.Commit, target)
			}, {
				title: 'Rebase current branch on this Commit' + ELLIPSIS,
				visible: visibility.rebase,
				onClick: () => this.rebaseAction(hash, abbrevCommit(hash), GG.RebaseActionOn.Commit, target)
			}, {
				title: 'Reset current branch to this Commit' + ELLIPSIS,
				visible: visibility.reset,
				onClick: () => {
					dialog.showSelect('Are you sure you want to reset ' + (this.gitBranchHead !== null ? '<b><i>' + escapeHtml(this.gitBranchHead) + '</i></b> (the current branch)' : 'the current branch') + ' to commit <b><i>' + abbrevCommit(hash) + '</i></b>?', this.config.dialogDefaults.resetCommit.mode, [
						{ name: 'Soft - Keep all changes, but reset head', value: GG.GitResetMode.Soft },
						{ name: 'Mixed - Keep working tree, but reset index', value: GG.GitResetMode.Mixed },
						{ name: 'Hard - Discard all changes', value: GG.GitResetMode.Hard }
					], 'Yes, reset', (mode) => {
						runAction({ command: 'resetToCommit', repo: this.currentRepo, commit: hash, resetMode: <GG.GitResetMode>mode }, 'Resetting to Commit');
					}, target);
				}
			}
		], [
			{
				title: 'Copy Commit Hash to Clipboard',
				visible: visibility.copyHash,
				onClick: () => {
					sendMessage({ command: 'copyToClipboard', type: 'Commit Hash', data: hash });
				}
			},
			{
				title: 'Copy Commit Subject to Clipboard',
				visible: visibility.copySubject,
				onClick: () => {
					sendMessage({ command: 'copyToClipboard', type: 'Commit Subject', data: commit.message });
				}
			}
		]];
	}

	private getRemoteBranchContextMenuActions(remote: string, target: DialogTarget & RefTarget): ContextMenuActions {
		const refName = target.ref, visibility = this.config.contextMenuActionsVisibility.remoteBranch;
		const branchName = remote !== '' ? refName.substring(remote.length + 1) : '';
		const prefixedRefName = 'remotes/' + refName;
		const isSelectedInBranchesDropdown = this.branchDropdown.isSelected(prefixedRefName);
		return [[
			{
				title: 'Checkout Branch' + ELLIPSIS,
				visible: visibility.checkout,
				onClick: () => this.checkoutBranchAction(refName, remote, null, target)
			}, {
				title: 'Delete Remote Branch' + ELLIPSIS,
				visible: visibility.delete && remote !== '',
				onClick: () => {
					dialog.showConfirmation('Are you sure you want to delete the remote branch <b><i>' + escapeHtml(refName) + '</i></b>?', 'Yes, delete', () => {
						runAction({ command: 'deleteRemoteBranch', repo: this.currentRepo, branchName: branchName, remote: remote }, 'Deleting Remote Branch');
					}, target);
				}
			}, {
				title: 'Fetch into local branch' + ELLIPSIS,
				visible: visibility.fetch && remote !== '' && this.gitBranches.includes(branchName) && this.gitBranchHead !== branchName,
				onClick: () => {
					dialog.showForm('Are you sure you want to fetch the remote branch <b><i>' + escapeHtml(refName) + '</i></b> into the local branch <b><i>' + escapeHtml(branchName) + '</i></b>?', [{
						type: DialogInputType.Checkbox,
						name: 'Force Fetch',
						value: this.config.dialogDefaults.fetchIntoLocalBranch.forceFetch,
						info: 'Force the local branch to be reset to this remote branch.'
					}], 'Yes, fetch', (values) => {
						runAction({ command: 'fetchIntoLocalBranch', repo: this.currentRepo, remote: remote, remoteBranch: branchName, localBranch: branchName, force: <boolean>values[0] }, 'Fetching Branch');
					}, target);
				}
			}, {
				title: 'Merge into current branch' + ELLIPSIS,
				visible: visibility.merge,
				onClick: () => this.mergeAction(refName, refName, GG.MergeActionOn.RemoteTrackingBranch, target)
			}, {
				title: 'Pull into current branch' + ELLIPSIS,
				visible: visibility.pull && remote !== '',
				onClick: () => {
					dialog.showForm('Are you sure you want to pull the remote branch <b><i>' + escapeHtml(refName) + '</i></b> into ' + (this.gitBranchHead !== null ? '<b><i>' + escapeHtml(this.gitBranchHead) + '</i></b> (the current branch)' : 'the current branch') + '? If a merge is required:', [
						{ type: DialogInputType.Checkbox, name: 'Create a new commit even if fast-forward is possible', value: this.config.dialogDefaults.pullBranch.noFastForward },
						{ type: DialogInputType.Checkbox, name: 'Squash Commits', value: this.config.dialogDefaults.pullBranch.squash, info: 'Create a single commit on the current branch whose effect is the same as merging this remote branch.' }
					], 'Yes, pull', (values) => {
						runAction({ command: 'pullBranch', repo: this.currentRepo, branchName: branchName, remote: remote, createNewCommit: <boolean>values[0], squash: <boolean>values[1] }, 'Pulling Branch');
					}, target);
				}
			}
		], [
			this.getViewIssueAction(refName, visibility.viewIssue, target),
			{
				title: 'Create Pull Request',
				visible: visibility.createPullRequest && this.gitRepos[this.currentRepo].pullRequestConfig !== null && branchName !== 'HEAD' &&
					(this.gitRepos[this.currentRepo].pullRequestConfig!.sourceRemote === remote || this.gitRepos[this.currentRepo].pullRequestConfig!.destRemote === remote),
				onClick: () => {
					const config = this.gitRepos[this.currentRepo].pullRequestConfig;
					if (config === null) return;
					const isDestRemote = config.destRemote === remote;
					runAction({
						command: 'createPullRequest',
						repo: this.currentRepo,
						config: config,
						sourceRemote: isDestRemote ? config.destRemote! : config.sourceRemote,
						sourceOwner: isDestRemote ? config.destOwner : config.sourceOwner,
						sourceRepo: isDestRemote ? config.destRepo : config.sourceRepo,
						sourceBranch: branchName,
						push: false
					}, 'Creating Pull Request');
				}
			}
		], [
			{
				title: 'Create Archive',
				visible: visibility.createArchive,
				onClick: () => {
					runAction({ command: 'createArchive', repo: this.currentRepo, ref: refName }, 'Creating Archive');
				}
			},
			{
				title: 'Select in Branches Dropdown',
				visible: visibility.selectInBranchesDropdown && !isSelectedInBranchesDropdown,
				onClick: () => this.branchDropdown.selectOption(prefixedRefName)
			},
			{
				title: 'Unselect in Branches Dropdown',
				visible: visibility.unselectInBranchesDropdown && isSelectedInBranchesDropdown,
				onClick: () => this.branchDropdown.unselectOption(prefixedRefName)
			}
		], [
			{
				title: 'Copy Branch Name to Clipboard',
				visible: visibility.copyName,
				onClick: () => {
					sendMessage({ command: 'copyToClipboard', type: 'Branch Name', data: refName });
				}
			}
		]];
	}

	private getStashContextMenuActions(target: DialogTarget & RefTarget): ContextMenuActions {
		const hash = target.hash, selector = target.ref, visibility = this.config.contextMenuActionsVisibility.stash;
		return [[
			{
				title: 'Apply Stash' + ELLIPSIS,
				visible: visibility.apply,
				onClick: () => {
					dialog.showForm('Are you sure you want to apply the stash <b><i>' + escapeHtml(selector.substring(5)) + '</i></b>?', [{
						type: DialogInputType.Checkbox,
						name: 'Reinstate Index',
						value: this.config.dialogDefaults.applyStash.reinstateIndex,
						info: 'Attempt to reinstate the indexed changes, in addition to the working tree\'s changes.'
					}], 'Yes, apply stash', (values) => {
						runAction({ command: 'applyStash', repo: this.currentRepo, selector: selector, reinstateIndex: <boolean>values[0] }, 'Applying Stash');
					}, target);
				}
			}, {
				title: 'Create Branch from Stash' + ELLIPSIS,
				visible: visibility.createBranch,
				onClick: () => {
					dialog.showRefInput('Create a branch from stash <b><i>' + escapeHtml(selector.substring(5)) + '</i></b> with the name:', '', 'Create Branch', (branchName) => {
						runAction({ command: 'branchFromStash', repo: this.currentRepo, selector: selector, branchName: branchName }, 'Creating Branch');
					}, target);
				}
			}, {
				title: 'Pop Stash' + ELLIPSIS,
				visible: visibility.pop,
				onClick: () => {
					dialog.showForm('Are you sure you want to pop the stash <b><i>' + escapeHtml(selector.substring(5)) + '</i></b>?', [{
						type: DialogInputType.Checkbox,
						name: 'Reinstate Index',
						value: this.config.dialogDefaults.popStash.reinstateIndex,
						info: 'Attempt to reinstate the indexed changes, in addition to the working tree\'s changes.'
					}], 'Yes, pop stash', (values) => {
						runAction({ command: 'popStash', repo: this.currentRepo, selector: selector, reinstateIndex: <boolean>values[0] }, 'Popping Stash');
					}, target);
				}
			}, {
				title: 'Drop Stash' + ELLIPSIS,
				visible: visibility.drop,
				onClick: () => {
					dialog.showConfirmation('Are you sure you want to drop the stash <b><i>' + escapeHtml(selector.substring(5)) + '</i></b>?', 'Yes, drop', () => {
						runAction({ command: 'dropStash', repo: this.currentRepo, selector: selector }, 'Dropping Stash');
					}, target);
				}
			}
		], [
			{
				title: 'Copy Stash Name to Clipboard',
				visible: visibility.copyName,
				onClick: () => {
					sendMessage({ command: 'copyToClipboard', type: 'Stash Name', data: selector });
				}
			}, {
				title: 'Copy Stash Hash to Clipboard',
				visible: visibility.copyHash,
				onClick: () => {
					sendMessage({ command: 'copyToClipboard', type: 'Stash Hash', data: hash });
				}
			}
		]];
	}

	private getTagContextMenuActions(isAnnotated: boolean, target: DialogTarget & RefTarget): ContextMenuActions {
		const hash = target.hash, tagName = target.ref, visibility = this.config.contextMenuActionsVisibility.tag;
		return [[
			{
				title: 'View Details',
				visible: visibility.viewDetails && isAnnotated,
				onClick: () => {
					runAction({ command: 'tagDetails', repo: this.currentRepo, tagName: tagName, commitHash: hash }, 'Retrieving Tag Details');
				}
			}, {
				title: 'Delete Tag' + ELLIPSIS,
				visible: visibility.delete,
				onClick: () => {
					let message = 'Are you sure you want to delete the tag <b><i>' + escapeHtml(tagName) + '</i></b>?';
					if (this.gitRemotes.length > 1) {
						let options = [{ name: 'Don\'t delete on any remote', value: '-1' }];
						this.gitRemotes.forEach((remote, i) => options.push({ name: remote, value: i.toString() }));
						dialog.showSelect(message + '<br>Do you also want to delete the tag on a remote:', '-1', options, 'Yes, delete', remoteIndex => {
							this.deleteTagAction(tagName, remoteIndex !== '-1' ? this.gitRemotes[parseInt(remoteIndex)] : null);
						}, target);
					} else if (this.gitRemotes.length === 1) {
						dialog.showCheckbox(message, 'Also delete on remote', false, 'Yes, delete', deleteOnRemote => {
							this.deleteTagAction(tagName, deleteOnRemote ? this.gitRemotes[0] : null);
						}, target);
					} else {
						dialog.showConfirmation(message, 'Yes, delete', () => {
							this.deleteTagAction(tagName, null);
						}, target);
					}
				}
			}, {
				title: 'Push Tag' + ELLIPSIS,
				visible: visibility.push && this.gitRemotes.length > 0,
				onClick: () => {
					const runPushTagAction = (remotes: string[]) => {
						runAction({
							command: 'pushTag',
							repo: this.currentRepo,
							tagName: tagName,
							remotes: remotes,
							commitHash: hash,
							skipRemoteCheck: globalState.pushTagSkipRemoteCheck
						}, 'Pushing Tag');
					};

					if (this.gitRemotes.length === 1) {
						dialog.showConfirmation('Are you sure you want to push the tag <b><i>' + escapeHtml(tagName) + '</i></b> to the remote <b><i>' + escapeHtml(this.gitRemotes[0]) + '</i></b>?', 'Yes, push', () => {
							runPushTagAction([this.gitRemotes[0]]);
						}, target);
					} else if (this.gitRemotes.length > 1) {
						const defaults = [this.getPushRemote()];
						const options = this.gitRemotes.map((remote) => ({ name: remote, value: remote }));
						dialog.showMultiSelect('Are you sure you want to push the tag <b><i>' + escapeHtml(tagName) + '</i></b>? Select the remote(s) to push the tag to:', defaults, options, 'Yes, push', (remotes) => {
							runPushTagAction(remotes);
						}, target);
					}
				}
			}
		], [
			{
				title: 'Create Archive',
				visible: visibility.createArchive,
				onClick: () => {
					runAction({ command: 'createArchive', repo: this.currentRepo, ref: tagName }, 'Creating Archive');
				}
			},
			{
				title: 'Copy Tag Name to Clipboard',
				visible: visibility.copyName,
				onClick: () => {
					sendMessage({ command: 'copyToClipboard', type: 'Tag Name', data: tagName });
				}
			}
		]];
	}

	private getUncommittedChangesContextMenuActions(target: DialogTarget & CommitTarget): ContextMenuActions {
		let visibility = this.config.contextMenuActionsVisibility.uncommittedChanges;
		return [[
			{
				title: 'Stash uncommitted changes' + ELLIPSIS,
				visible: visibility.stash,
				onClick: () => {
					dialog.showForm('Are you sure you want to stash the <b>uncommitted changes</b>?', [
						{ type: DialogInputType.Text, name: 'Message', default: '', placeholder: 'Optional' },
						{ type: DialogInputType.Checkbox, name: 'Include Untracked', value: this.config.dialogDefaults.stashUncommittedChanges.includeUntracked, info: 'Include all untracked files in the stash, and then clean them from the working directory.' }
					], 'Yes, stash', (values) => {
						runAction({ command: 'pushStash', repo: this.currentRepo, message: <string>values[0], includeUntracked: <boolean>values[1] }, 'Stashing uncommitted changes');
					}, target);
				}
			}
		], [
			{
				title: 'Reset uncommitted changes' + ELLIPSIS,
				visible: visibility.reset,
				onClick: () => {
					dialog.showSelect('Are you sure you want to reset the <b>uncommitted changes</b> to <b>HEAD</b>?', this.config.dialogDefaults.resetUncommitted.mode, [
						{ name: 'Mixed - Keep working tree, but reset index', value: GG.GitResetMode.Mixed },
						{ name: 'Hard - Discard all changes', value: GG.GitResetMode.Hard }
					], 'Yes, reset', (mode) => {
						runAction({ command: 'resetToCommit', repo: this.currentRepo, commit: 'HEAD', resetMode: <GG.GitResetMode>mode }, 'Resetting uncommitted changes');
					}, target);
				}
			}, {
				title: 'Clean untracked files' + ELLIPSIS,
				visible: visibility.clean,
				onClick: () => {
					dialog.showCheckbox('Are you sure you want to clean all untracked files?', 'Clean untracked directories', true, 'Yes, clean', directories => {
						runAction({ command: 'cleanUntrackedFiles', repo: this.currentRepo, directories: directories }, 'Cleaning untracked files');
					}, target);
				}
			}
		], [
			{
				title: 'Open Source Control View',
				visible: visibility.openSourceControlView,
				onClick: () => {
					sendMessage({ command: 'viewScm' });
				}
			}
		]];
	}

	private getViewIssueAction(refName: string, visible: boolean, target: DialogTarget & RefTarget): ContextMenuAction {
		const issueLinks: { url: string, displayText: string }[] = [];

		let issueLinking: IssueLinking | null, match: RegExpExecArray | null;
		if (visible && (issueLinking = parseIssueLinkingConfig(this.gitRepos[this.currentRepo].issueLinkingConfig)) !== null) {
			issueLinking.regexp.lastIndex = 0;
			while (match = issueLinking.regexp.exec(refName)) {
				if (match[0].length === 0) break;
				issueLinks.push({
					url: generateIssueLinkFromMatch(match, issueLinking),
					displayText: match[0]
				});
			}
		}

		return {
			title: 'View Issue' + (issueLinks.length > 1 ? ELLIPSIS : ''),
			visible: issueLinks.length > 0,
			onClick: () => {
				if (issueLinks.length > 1) {
					dialog.showSelect('Select which issue you want to view for this branch:', '0', issueLinks.map((issueLink, i) => ({ name: issueLink.displayText, value: i.toString() })), 'View Issue', (value) => {
						sendMessage({ command: 'openExternalUrl', url: issueLinks[parseInt(value)].url });
					}, target);
				} else if (issueLinks.length === 1) {
					sendMessage({ command: 'openExternalUrl', url: issueLinks[0].url });
				}
			}
		};
	}


	/* Actions */

	private addTagAction(hash: string, initialName: string, initialType: GG.TagType, initialMessage: string, initialPushToRemote: string | null, target: DialogTarget & CommitTarget, isInitialLoad: boolean = true) {
		let mostRecentTagsIndex = -1;
		for (let i = 0; i < this.commits.length; i++) {
			if (this.commits[i].tags.length > 0 && (mostRecentTagsIndex === -1 || this.commits[i].date > this.commits[mostRecentTagsIndex].date)) {
				mostRecentTagsIndex = i;
			}
		}
		const mostRecentTags = mostRecentTagsIndex > -1 ? this.commits[mostRecentTagsIndex].tags.map((tag) => '"' + tag.name + '"') : [];

		const inputs: DialogInput[] = [
			{ type: DialogInputType.TextRef, name: 'Name', default: initialName, info: mostRecentTags.length > 0 ? 'The most recent tag' + (mostRecentTags.length > 1 ? 's' : '') + ' in the loaded commits ' + (mostRecentTags.length > 1 ? 'are' : 'is') + ' ' + formatCommaSeparatedList(mostRecentTags) + '.' : undefined },
			{ type: DialogInputType.Select, name: 'Type', default: initialType === GG.TagType.Annotated ? 'annotated' : 'lightweight', options: [{ name: 'Annotated', value: 'annotated' }, { name: 'Lightweight', value: 'lightweight' }] },
			{ type: DialogInputType.Text, name: 'Message', default: initialMessage, placeholder: 'Optional', info: 'A message can only be added to an annotated tag.' }
		];
		if (this.gitRemotes.length > 1) {
			const options = [{ name: 'Don\'t push', value: '-1' }];
			this.gitRemotes.forEach((remote, i) => options.push({ name: remote, value: i.toString() }));
			const defaultOption = initialPushToRemote !== null
				? this.gitRemotes.indexOf(initialPushToRemote)
				: isInitialLoad && this.config.dialogDefaults.addTag.pushToRemote
					? this.gitRemotes.indexOf(this.getPushRemote())
					: -1;
			inputs.push({ type: DialogInputType.Select, name: 'Push to remote', options: options, default: defaultOption.toString(), info: 'Once this tag has been added, push it to this remote.' });
		} else if (this.gitRemotes.length === 1) {
			const defaultValue = initialPushToRemote !== null || (isInitialLoad && this.config.dialogDefaults.addTag.pushToRemote);
			inputs.push({ type: DialogInputType.Checkbox, name: 'Push to remote', value: defaultValue, info: 'Once this tag has been added, push it to the repositories remote.' });
		}

		dialog.showForm('Add tag to commit <b><i>' + abbrevCommit(hash) + '</i></b>:', inputs, 'Add Tag', (values) => {
			const tagName = <string>values[0];
			const type = <string>values[1] === 'annotated' ? GG.TagType.Annotated : GG.TagType.Lightweight;
			const message = <string>values[2];
			const pushToRemote = this.gitRemotes.length > 1 && <string>values[3] !== '-1'
				? this.gitRemotes[parseInt(<string>values[3])]
				: this.gitRemotes.length === 1 && <boolean>values[3]
					? this.gitRemotes[0]
					: null;

			const runAddTagAction = (force: boolean) => {
				runAction({
					command: 'addTag',
					repo: this.currentRepo,
					tagName: tagName,
					commitHash: hash,
					type: type,
					message: message,
					pushToRemote: pushToRemote,
					pushSkipRemoteCheck: globalState.pushTagSkipRemoteCheck,
					force: force
				}, 'Adding Tag');
			};

			if (this.gitTags.includes(tagName)) {
				dialog.showTwoButtons('A tag named <b><i>' + escapeHtml(tagName) + '</i></b> already exists, do you want to replace it with this new tag?', 'Yes, replace the existing tag', () => {
					runAddTagAction(true);
				}, 'No, choose another tag name', () => {
					this.addTagAction(hash, tagName, type, message, pushToRemote, target, false);
				}, target);
			} else {
				runAddTagAction(false);
			}
		}, target);
	}

	private checkoutBranchAction(refName: string, remote: string | null, prefillName: string | null, target: DialogTarget & (CommitTarget | RefTarget)) {
		if (remote !== null) {
			dialog.showRefInput('Enter the name of the new branch you would like to create when checking out <b><i>' + escapeHtml(refName) + '</i></b>:', (prefillName !== null ? prefillName : (remote !== '' ? refName.substring(remote.length + 1) : refName)), 'Checkout Branch', newBranch => {
				if (this.gitBranches.includes(newBranch)) {
					const canPullFromRemote = remote !== '';
					dialog.showTwoButtons('The name <b><i>' + escapeHtml(newBranch) + '</i></b> is already used by another branch:', 'Choose another branch name', () => {
						this.checkoutBranchAction(refName, remote, newBranch, target);
					}, 'Checkout the existing branch' + (canPullFromRemote ? ' & pull changes' : ''), () => {
						runAction({
							command: 'checkoutBranch',
							repo: this.currentRepo,
							branchName: newBranch,
							remoteBranch: null,
							pullAfterwards: canPullFromRemote
								? {
									branchName: refName.substring(remote.length + 1),
									remote: remote,
									createNewCommit: this.config.dialogDefaults.pullBranch.noFastForward,
									squash: this.config.dialogDefaults.pullBranch.squash
								}
								: null
						}, 'Checking out Branch' + (canPullFromRemote ? ' & Pulling Changes' : ''));
					}, target);
				} else {
					runAction({ command: 'checkoutBranch', repo: this.currentRepo, branchName: newBranch, remoteBranch: refName, pullAfterwards: null }, 'Checking out Branch');
				}
			}, target);
		} else {
			runAction({ command: 'checkoutBranch', repo: this.currentRepo, branchName: refName, remoteBranch: null, pullAfterwards: null }, 'Checking out Branch');
		}
	}

	private createBranchAction(hash: string, initialName: string, initialCheckOut: boolean, target: DialogTarget & CommitTarget) {
		dialog.showForm('Create branch at commit <b><i>' + abbrevCommit(hash) + '</i></b>:', [
			{ type: DialogInputType.TextRef, name: 'Name', default: initialName },
			{ type: DialogInputType.Checkbox, name: 'Check out', value: initialCheckOut }
		], 'Create Branch', (values) => {
			const branchName = <string>values[0], checkOut = <boolean>values[1];
			if (this.gitBranches.includes(branchName)) {
				dialog.showTwoButtons('A branch named <b><i>' + escapeHtml(branchName) + '</i></b> already exists, do you want to replace it with this new branch?', 'Yes, replace the existing branch', () => {
					runAction({ command: 'createBranch', repo: this.currentRepo, branchName: branchName, commitHash: hash, checkout: checkOut, force: true }, 'Creating Branch');
				}, 'No, choose another branch name', () => {
					this.createBranchAction(hash, branchName, checkOut, target);
				}, target);
			} else {
				runAction({ command: 'createBranch', repo: this.currentRepo, branchName: branchName, commitHash: hash, checkout: checkOut, force: false }, 'Creating Branch');
			}
		}, target);
	}

	private deleteTagAction(refName: string, deleteOnRemote: string | null) {
		runAction({ command: 'deleteTag', repo: this.currentRepo, tagName: refName, deleteOnRemote: deleteOnRemote }, 'Deleting Tag');
	}

	private fetchFromRemotesAction() {
		runAction({ command: 'fetch', repo: this.currentRepo, name: null, prune: this.config.fetchAndPrune, pruneTags: this.config.fetchAndPruneTags }, 'Fetching from Remote(s)');
	}

	private mergeAction(obj: string, name: string, actionOn: GG.MergeActionOn, target: DialogTarget & (CommitTarget | RefTarget)) {
		dialog.showForm('Are you sure you want to merge ' + actionOn.toLowerCase() + ' <b><i>' + escapeHtml(name) + '</i></b> into ' + (this.gitBranchHead !== null ? '<b><i>' + escapeHtml(this.gitBranchHead) + '</i></b> (the current branch)' : 'the current branch') + '?', [
			{ type: DialogInputType.Checkbox, name: 'Create a new commit even if fast-forward is possible', value: this.config.dialogDefaults.merge.noFastForward },
			{ type: DialogInputType.Checkbox, name: 'Squash Commits', value: this.config.dialogDefaults.merge.squash, info: 'Create a single commit on the current branch whose effect is the same as merging this ' + actionOn.toLowerCase() + '.' },
			{ type: DialogInputType.Checkbox, name: 'No Commit', value: this.config.dialogDefaults.merge.noCommit, info: 'The changes of the merge will be staged but not committed, so that you can review and/or modify the merge result before committing.' }
		], 'Yes, merge', (values) => {
			runAction({ command: 'merge', repo: this.currentRepo, obj: obj, actionOn: actionOn, createNewCommit: <boolean>values[0], squash: <boolean>values[1], noCommit: <boolean>values[2] }, 'Merging ' + actionOn);
		}, target);
	}

	private rebaseAction(obj: string, name: string, actionOn: GG.RebaseActionOn, target: DialogTarget & (CommitTarget | RefTarget)) {
		dialog.showForm('Are you sure you want to rebase ' + (this.gitBranchHead !== null ? '<b><i>' + escapeHtml(this.gitBranchHead) + '</i></b> (the current branch)' : 'the current branch') + ' on ' + actionOn.toLowerCase() + ' <b><i>' + escapeHtml(name) + '</i></b>?', [
			{ type: DialogInputType.Checkbox, name: 'Launch Interactive Rebase in new Terminal', value: this.config.dialogDefaults.rebase.interactive },
			{ type: DialogInputType.Checkbox, name: 'Ignore Date', value: this.config.dialogDefaults.rebase.ignoreDate, info: 'Only applicable to a non-interactive rebase.' }
		], 'Yes, rebase', (values) => {
			let interactive = <boolean>values[0];
			runAction({ command: 'rebase', repo: this.currentRepo, obj: obj, actionOn: actionOn, ignoreDate: <boolean>values[1], interactive: interactive }, interactive ? 'Launching Interactive Rebase' : 'Rebasing on ' + actionOn);
		}, target);
	}


	/* Table Utils */

	private makeTableResizable() {
		let colHeadersElem = document.getElementById('tableColHeaders')!, cols = <HTMLCollectionOf<HTMLElement>>document.getElementsByClassName('tableColHeader');
		let columnWidths: GG.ColumnWidth[], mouseX = -1, col = -1, colIndex = -1;

		const makeTableFixedLayout = () => {
			cols[0].style.width = columnWidths[0] + 'px';
			cols[0].style.padding = '';
			for (let i = 2; i < cols.length; i++) {
				cols[i].style.width = columnWidths[parseInt(cols[i].dataset.col!)] + 'px';
			}
			this.tableElem.className = 'fixedLayout';
			this.tableElem.style.removeProperty(CSS_PROP_LIMIT_GRAPH_WIDTH);
			this.graph.limitMaxWidth(columnWidths[0] + COLUMN_LEFT_RIGHT_PADDING);
		};

		for (let i = 0; i < cols.length; i++) {
			let col = parseInt(cols[i].dataset.col!);
			cols[i].innerHTML += (i > 0 ? '<span class="resizeCol left" data-col="' + (col - 1) + '"></span>' : '') + (i < cols.length - 1 ? '<span class="resizeCol right" data-col="' + col + '"></span>' : '');
		}

		let cWidths = this.gitRepos[this.currentRepo].columnWidths;
		if (cWidths === null) { // Initialise auto column layout if it is the first time viewing the repo.
			let defaults = this.config.defaultColumnVisibility;
			columnWidths = [COLUMN_AUTO, COLUMN_AUTO, defaults.date ? COLUMN_AUTO : COLUMN_HIDDEN, defaults.author ? COLUMN_AUTO : COLUMN_HIDDEN, defaults.commit ? COLUMN_AUTO : COLUMN_HIDDEN];
			this.saveColumnWidths(columnWidths);
		} else {
			columnWidths = [cWidths[0], COLUMN_AUTO, cWidths[1], cWidths[2], cWidths[3]];
		}

		if (columnWidths[0] !== COLUMN_AUTO) {
			// Table should have fixed layout
			makeTableFixedLayout();
		} else {
			// Table should have automatic layout
			this.tableElem.className = 'autoLayout';

			let colWidth = cols[0].offsetWidth, graphWidth = this.graph.getContentWidth();
			let maxWidth = Math.round(this.viewElem.clientWidth * 0.333);
			if (Math.max(graphWidth, colWidth) > maxWidth) {
				this.graph.limitMaxWidth(maxWidth);
				graphWidth = maxWidth;
				this.tableElem.className += ' limitGraphWidth';
				this.tableElem.style.setProperty(CSS_PROP_LIMIT_GRAPH_WIDTH, maxWidth + 'px');
			} else {
				this.graph.limitMaxWidth(-1);
				this.tableElem.style.removeProperty(CSS_PROP_LIMIT_GRAPH_WIDTH);
			}

			if (colWidth < Math.max(graphWidth, 64)) {
				cols[0].style.padding = '6px ' + Math.floor((Math.max(graphWidth, 64) - (colWidth - COLUMN_LEFT_RIGHT_PADDING)) / 2) + 'px';
			}
		}

		const processResizingColumn: EventListener = (e) => {
			if (col > -1) {
				let mouseEvent = <MouseEvent>e;
				let mouseDeltaX = mouseEvent.clientX - mouseX;

				if (col === 0) {
					if (columnWidths[0] + mouseDeltaX < COLUMN_MIN_WIDTH) mouseDeltaX = -columnWidths[0] + COLUMN_MIN_WIDTH;
					if (cols[1].clientWidth - COLUMN_LEFT_RIGHT_PADDING - mouseDeltaX < COLUMN_MIN_WIDTH) mouseDeltaX = cols[1].clientWidth - COLUMN_LEFT_RIGHT_PADDING - COLUMN_MIN_WIDTH;
					columnWidths[0] += mouseDeltaX;
					cols[0].style.width = columnWidths[0] + 'px';
					this.graph.limitMaxWidth(columnWidths[0] + COLUMN_LEFT_RIGHT_PADDING);
				} else {
					let colWidth = col !== 1 ? columnWidths[col] : cols[1].clientWidth - COLUMN_LEFT_RIGHT_PADDING;
					let nextCol = col + 1;
					while (columnWidths[nextCol] === COLUMN_HIDDEN) nextCol++;

					if (colWidth + mouseDeltaX < COLUMN_MIN_WIDTH) mouseDeltaX = -colWidth + COLUMN_MIN_WIDTH;
					if (columnWidths[nextCol] - mouseDeltaX < COLUMN_MIN_WIDTH) mouseDeltaX = columnWidths[nextCol] - COLUMN_MIN_WIDTH;
					if (col !== 1) {
						columnWidths[col] += mouseDeltaX;
						cols[colIndex].style.width = columnWidths[col] + 'px';
					}
					columnWidths[nextCol] -= mouseDeltaX;
					cols[colIndex + 1].style.width = columnWidths[nextCol] + 'px';
				}
				mouseX = mouseEvent.clientX;
			}
		};
		const stopResizingColumn: EventListener = () => {
			if (col > -1) {
				col = -1;
				colIndex = -1;
				mouseX = -1;
				eventOverlay.remove();
				this.saveColumnWidths(columnWidths);
			}
		};

		addListenerToClass('resizeCol', 'mousedown', (e) => {
			if (e.target === null) return;
			col = parseInt((<HTMLElement>e.target).dataset.col!);
			while (columnWidths[col] === COLUMN_HIDDEN) col--;
			mouseX = (<MouseEvent>e).clientX;

			let isAuto = columnWidths[0] === COLUMN_AUTO;
			for (let i = 0; i < cols.length; i++) {
				let curCol = parseInt(cols[i].dataset.col!);
				if (isAuto && curCol !== 1) columnWidths[curCol] = cols[i].clientWidth - COLUMN_LEFT_RIGHT_PADDING;
				if (curCol === col) colIndex = i;
			}
			if (isAuto) makeTableFixedLayout();
			eventOverlay.create('colResize', processResizingColumn, stopResizingColumn);
		});

		colHeadersElem.addEventListener('contextmenu', (e: MouseEvent) => {
			handledEvent(e);

			const toggleColumnState = (col: number, defaultWidth: number) => {
				columnWidths[col] = columnWidths[col] !== COLUMN_HIDDEN ? COLUMN_HIDDEN : columnWidths[0] === COLUMN_AUTO ? COLUMN_AUTO : defaultWidth - COLUMN_LEFT_RIGHT_PADDING;
				this.saveColumnWidths(columnWidths);
				this.render();
			};

			const commitOrdering = getCommitOrdering(this.gitRepos[this.currentRepo].commitOrdering);
			const changeCommitOrdering = (repoCommitOrdering: GG.RepoCommitOrdering) => {
				this.saveRepoStateValue(this.currentRepo, 'commitOrdering', repoCommitOrdering);
				this.refresh(true);
			};

			contextMenu.show([
				[
					{
						title: 'Date',
						visible: true,
						checked: columnWidths[2] !== COLUMN_HIDDEN,
						onClick: () => toggleColumnState(2, 128)
					},
					{
						title: 'Author',
						visible: true,
						checked: columnWidths[3] !== COLUMN_HIDDEN,
						onClick: () => toggleColumnState(3, 128)
					},
					{
						title: 'Commit',
						visible: true,
						checked: columnWidths[4] !== COLUMN_HIDDEN,
						onClick: () => toggleColumnState(4, 80)
					}
				],
				[
					{
						title: 'Commit Timestamp Order',
						visible: true,
						checked: commitOrdering === GG.CommitOrdering.Date,
						onClick: () => changeCommitOrdering(GG.RepoCommitOrdering.Date)
					},
					{
						title: 'Author Timestamp Order',
						visible: true,
						checked: commitOrdering === GG.CommitOrdering.AuthorDate,
						onClick: () => changeCommitOrdering(GG.RepoCommitOrdering.AuthorDate)
					},
					{
						title: 'Topological Order',
						visible: true,
						checked: commitOrdering === GG.CommitOrdering.Topological,
						onClick: () => changeCommitOrdering(GG.RepoCommitOrdering.Topological)
					}
				]
			], true, null, e, this.viewElem);
		});
	}

	public getColumnVisibility() {
		let colWidths = this.gitRepos[this.currentRepo].columnWidths;
		if (colWidths !== null) {
			return { date: colWidths[1] !== COLUMN_HIDDEN, author: colWidths[2] !== COLUMN_HIDDEN, commit: colWidths[3] !== COLUMN_HIDDEN };
		} else {
			let defaults = this.config.defaultColumnVisibility;
			return { date: defaults.date, author: defaults.author, commit: defaults.commit };
		}
	}

	private getNumColumns() {
		let colVisibility = this.getColumnVisibility();
		return 2 + (colVisibility.date ? 1 : 0) + (colVisibility.author ? 1 : 0) + (colVisibility.commit ? 1 : 0);
	}

	/**
	 * Scroll the view to the previous or next stash.
	 * @param next TRUE => Jump to the next stash, FALSE => Jump to the previous stash.
	 */
	private scrollToStash(next: boolean) {
		const stashCommits = this.commits.filter((commit) => commit.stash !== null);
		if (stashCommits.length > 0) {
			const curTime = (new Date()).getTime();
			if (this.lastScrollToStash.time < curTime - 5000) {
				// Reset the lastScrollToStash hash if it was more than 5 seconds ago
				this.lastScrollToStash.hash = null;
			}

			const lastScrollToStashCommitIndex = this.lastScrollToStash.hash !== null
				? stashCommits.findIndex((commit) => commit.hash === this.lastScrollToStash.hash)
				: -1;
			let scrollToStashCommitIndex = lastScrollToStashCommitIndex + (next ? 1 : -1);
			if (scrollToStashCommitIndex >= stashCommits.length) {
				scrollToStashCommitIndex = 0;
			} else if (scrollToStashCommitIndex < 0) {
				scrollToStashCommitIndex = stashCommits.length - 1;
			}
			this.scrollToCommit(stashCommits[scrollToStashCommitIndex].hash, true, true);
			this.lastScrollToStash.time = curTime;
			this.lastScrollToStash.hash = stashCommits[scrollToStashCommitIndex].hash;
		}
	}

	/**
	 * Scroll the view to a commit (if it exists).
	 * @param hash The hash of the commit to scroll to.
	 * @param alwaysCenterCommit TRUE => Always scroll the view to be centered on the commit. FALSE => Don't scroll the view if the commit is already within the visible portion of commits.
	 * @param flash Should the commit flash after it has been scrolled to.
	 */
	public scrollToCommit(hash: string, alwaysCenterCommit: boolean, flash: boolean = false) {
		const elem = findCommitElemWithId(getCommitElems(), this.getCommitId(hash));
		if (elem === null) return;

		let elemTop = this.controlsElem.clientHeight + elem.offsetTop;
		if (alwaysCenterCommit || elemTop - 8 < this.viewElem.scrollTop || elemTop + 32 - this.viewElem.clientHeight > this.viewElem.scrollTop) {
			this.viewElem.scroll(0, this.controlsElem.clientHeight + elem.offsetTop + 12 - this.viewElem.clientHeight / 2);
		}

		if (flash && !elem.classList.contains('flash')) {
			elem.classList.add('flash');
			setTimeout(() => {
				elem.classList.remove('flash');
			}, 850);
		}
	}

	private loadMoreCommits() {
		this.footerElem.innerHTML = '<h2 id="loadingHeader">' + SVG_ICONS.loading + 'Loading ...</h2>';
		this.maxCommits += this.config.loadMoreCommits;
		this.saveState();
		this.requestLoadRepoInfoAndCommits(false, true);
	}


	/* Observers */

	private observeWindowSizeChanges() {
		let windowWidth = window.outerWidth, windowHeight = window.outerHeight;
		window.addEventListener('resize', () => {
			if (windowWidth === window.outerWidth && windowHeight === window.outerHeight) {
				this.renderGraph();
			} else {
				windowWidth = window.outerWidth;
				windowHeight = window.outerHeight;
			}
		});
	}

	private observeWebviewStyleChanges() {
		let fontFamily = getVSCodeStyle(CSS_PROP_FONT_FAMILY),
			editorFontFamily = getVSCodeStyle(CSS_PROP_EDITOR_FONT_FAMILY),
			findMatchColour = getVSCodeStyle(CSS_PROP_FIND_MATCH_HIGHLIGHT_BACKGROUND),
			selectionBackgroundColor = !!getVSCodeStyle(CSS_PROP_SELECTION_BACKGROUND);

		const setFlashColour = (colour: string) => {
			document.body.style.setProperty('--git-graph-flashPrimary', modifyColourOpacity(colour, 0.7));
			document.body.style.setProperty('--git-graph-flashSecondary', modifyColourOpacity(colour, 0.5));
		};
		const setSelectionBackgroundColorExists = () => {
			alterClass(document.body, 'selection-background-color-exists', selectionBackgroundColor);
		};

		this.findWidget.setColour(findMatchColour);
		setFlashColour(findMatchColour);
		setSelectionBackgroundColorExists();

		(new MutationObserver(() => {
			let ff = getVSCodeStyle(CSS_PROP_FONT_FAMILY),
				eff = getVSCodeStyle(CSS_PROP_EDITOR_FONT_FAMILY),
				fmc = getVSCodeStyle(CSS_PROP_FIND_MATCH_HIGHLIGHT_BACKGROUND),
				sbc = !!getVSCodeStyle(CSS_PROP_SELECTION_BACKGROUND);

			if (ff !== fontFamily || eff !== editorFontFamily) {
				fontFamily = ff;
				editorFontFamily = eff;
				this.repoDropdown.refresh();
				this.branchDropdown.refresh();
			}
			if (fmc !== findMatchColour) {
				findMatchColour = fmc;
				this.findWidget.setColour(findMatchColour);
				setFlashColour(findMatchColour);
			}
			if (selectionBackgroundColor !== sbc) {
				selectionBackgroundColor = sbc;
				setSelectionBackgroundColorExists();
			}
		})).observe(document.documentElement, { attributes: true, attributeFilter: ['style'] });
	}

	private observeViewScroll() {
		let active = this.viewElem.scrollTop > 0, timeout: NodeJS.Timer | null = null;
		this.scrollShadowElem.className = active ? CLASS_ACTIVE : '';
		this.viewElem.addEventListener('scroll', () => {
			const scrollTop = this.viewElem.scrollTop;
			if (active !== scrollTop > 0) {
				active = scrollTop > 0;
				this.scrollShadowElem.className = active ? CLASS_ACTIVE : '';
			}

			if (this.config.loadMoreCommitsAutomatically && this.moreCommitsAvailable && !this.currentRepoRefreshState.inProgress) {
				const viewHeight = this.viewElem.clientHeight, contentHeight = this.viewElem.scrollHeight;
				if (scrollTop > 0 && viewHeight > 0 && contentHeight > 0 && (scrollTop + viewHeight) >= contentHeight - 25) {
					// If the user has scrolled such that the bottom of the visible view is within 25px of the end of the content, load more commits.
					this.loadMoreCommits();
				}
			}

			if (timeout !== null) clearTimeout(timeout);
			timeout = setTimeout(() => {
				this.scrollTop = scrollTop;
				this.saveState();
				timeout = null;
			}, 250);
		});
	}

	private observeKeyboardEvents() {
		document.addEventListener('keydown', (e) => {
			if (contextMenu.isOpen()) {
				if (e.key === 'Escape') {
					contextMenu.close();
					handledEvent(e);
				}
			} else if (dialog.isOpen()) {
				if (e.key === 'Escape') {
					dialog.close();
					handledEvent(e);
				} else if (e.keyCode ? e.keyCode === 13 : e.key === 'Enter') {
					// Use keyCode === 13 to detect 'Enter' events if available (for compatibility with IME Keyboards used by Chinese / Japanese / Korean users)
					dialog.submit();
					handledEvent(e);
				}
			} else if (this.expandedCommit !== null && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
				const curHashIndex = this.commitLookup[this.expandedCommit.commitHash];
				let newHashIndex = -1;

				if (e.ctrlKey || e.metaKey) {
					// Up / Down navigates according to the order of commits on the branch
					if (e.shiftKey) {
						// Follow commits on alternative branches when possible
						if (e.key === 'ArrowUp') {
							newHashIndex = this.graph.getAlternativeChildIndex(curHashIndex);
						} else if (e.key === 'ArrowDown') {
							newHashIndex = this.graph.getAlternativeParentIndex(curHashIndex);
						}
					} else {
						// Follow commits on the same branch
						if (e.key === 'ArrowUp') {
							newHashIndex = this.graph.getFirstChildIndex(curHashIndex);
						} else if (e.key === 'ArrowDown') {
							newHashIndex = this.graph.getFirstParentIndex(curHashIndex);
						}
					}
				} else {
					// Up / Down navigates according to the order of commits in the table
					if (e.key === 'ArrowUp' && curHashIndex > 0) {
						newHashIndex = curHashIndex - 1;
					} else if (e.key === 'ArrowDown' && curHashIndex < this.commits.length - 1) {
						newHashIndex = curHashIndex + 1;
					}
				}

				if (newHashIndex > -1) {
					handledEvent(e);
					const elem = findCommitElemWithId(getCommitElems(), newHashIndex);
					if (elem !== null) this.loadCommitDetails(elem);
				}
			} else if (e.key && (e.ctrlKey || e.metaKey)) {
				const key = e.key.toLowerCase(), keybindings = this.config.keybindings;
				if (key === keybindings.scrollToStash) {
					this.scrollToStash(!e.shiftKey);
					handledEvent(e);
				} else if (!e.shiftKey) {
					if (key === keybindings.refresh) {
						this.refresh(true, true);
						handledEvent(e);
					} else if (key === keybindings.find) {
						this.findWidget.show(true);
						handledEvent(e);
					} else if (key === keybindings.scrollToHead && this.commitHead !== null) {
						this.scrollToCommit(this.commitHead, true, true);
						handledEvent(e);
					}
				}
			} else if (e.key === 'Escape') {
				if (this.repoDropdown.isOpen()) {
					this.repoDropdown.close();
					handledEvent(e);
				} else if (this.branchDropdown.isOpen()) {
					this.branchDropdown.close();
					handledEvent(e);
				} else if (this.settingsWidget.isVisible()) {
					this.settingsWidget.close();
					handledEvent(e);
				} else if (this.findWidget.isVisible()) {
					this.findWidget.close();
					handledEvent(e);
				} else if (this.expandedCommit !== null) {
					this.closeCommitDetails(true);
					handledEvent(e);
				}
			}
		});
	}

	private observeUrls() {
		const followInternalLink = (e: MouseEvent) => {
			if (e.target !== null && isInternalUrlElem(<Element>e.target)) {
				const value = unescapeHtml((<HTMLElement>e.target).dataset.value!);
				switch ((<HTMLElement>e.target).dataset.type!) {
					case 'commit':
						if (typeof this.commitLookup[value] === 'number' && (this.expandedCommit === null || this.expandedCommit.commitHash !== value || this.expandedCommit.compareWithHash !== null)) {
							const elem = findCommitElemWithId(getCommitElems(), this.commitLookup[value]);
							if (elem !== null) this.loadCommitDetails(elem);
						}
						break;
				}
			}
		};

		document.body.addEventListener('click', followInternalLink);

		document.body.addEventListener('contextmenu', (e: MouseEvent) => {
			if (e.target === null) return;
			const eventTarget = <Element>e.target;

			const isExternalUrl = isExternalUrlElem(eventTarget), isInternalUrl = isInternalUrlElem(eventTarget);
			if (isExternalUrl || isInternalUrl) {
				const viewElem: HTMLElement | null = eventTarget.closest('#view');
				let eventElem: HTMLElement | null;

				let target: (ContextMenuTarget & CommitTarget) | RepoTarget, isInDialog = false;
				if (this.expandedCommit !== null && eventTarget.closest('#cdv') !== null) {
					// URL is in the Commit Details View
					target = {
						type: TargetType.CommitDetailsView,
						hash: this.expandedCommit.commitHash,
						index: this.commitLookup[this.expandedCommit.commitHash],
						elem: <HTMLElement>eventTarget
					};
					GitGraphView.closeCdvContextMenuIfOpen(this.expandedCommit);
					this.expandedCommit.contextMenuOpen.summary = true;
				} else if ((eventElem = eventTarget.closest('.commit')) !== null) {
					// URL is in the Commits
					const commit = this.getCommitOfElem(eventElem);
					if (commit === null) return;
					target = {
						type: TargetType.Commit,
						hash: commit.hash,
						index: parseInt(eventElem.dataset.id!),
						elem: <HTMLElement>eventTarget
					};
				} else {
					// URL is in a dialog
					target = {
						type: TargetType.Repo
					};
					isInDialog = true;
				}

				handledEvent(e);
				contextMenu.show([
					[
						{
							title: 'Open URL',
							visible: isExternalUrl,
							onClick: () => {
								sendMessage({ command: 'openExternalUrl', url: (<HTMLAnchorElement>eventTarget).href });
							}
						},
						{
							title: 'Follow Internal Link',
							visible: isInternalUrl,
							onClick: () => followInternalLink(e)
						},
						{
							title: 'Copy URL to Clipboard',
							visible: isExternalUrl,
							onClick: () => {
								sendMessage({ command: 'copyToClipboard', type: 'External URL', data: (<HTMLAnchorElement>eventTarget).href });
							}
						}
					]
				], false, target, e, viewElem || document.body, () => {
					if (target.type === TargetType.CommitDetailsView && this.expandedCommit !== null) {
						this.expandedCommit.contextMenuOpen.summary = false;
					}
				}, isInDialog ? 'dialogContextMenu' : null);
			}
		});
	}

	private observeTableEvents() {

		// Register Click Event Handler
		this.tableElem.addEventListener('click', (e: MouseEvent) => {
			if (e.target === null) return;
			const eventTarget = <Element>e.target;
			if (isUrlElem(eventTarget)) return;
			let eventElem: HTMLElement | null;

			if ((eventElem = eventTarget.closest('.gitRef')) !== null) {
				// .gitRef was clicked
				e.stopPropagation();
				if (contextMenu.isOpen()) {
					contextMenu.close();
				}

			} else if ((eventElem = eventTarget.closest('.commit')) !== null) {
				// .commit was clicked
				if (this.expandedCommit !== null) {
					const commit = this.getCommitOfElem(eventElem);
					if (commit === null) return;

					if (this.expandedCommit.commitHash === commit.hash) {
						this.closeCommitDetails(true);
					} else if ((<MouseEvent>e).ctrlKey || (<MouseEvent>e).metaKey) {
						if (this.expandedCommit.compareWithHash === commit.hash) {
							this.closeCommitComparison(true);
						} else if (this.expandedCommit.commitElem !== null) {
							this.loadCommitComparison(this.expandedCommit.commitElem, eventElem);
						}
					} else {
						this.loadCommitDetails(eventElem);
					}
				} else {
					this.loadCommitDetails(eventElem);
				}
			}
		});

		// Register Double Click Event Handler
		this.tableElem.addEventListener('dblclick', (e: MouseEvent) => {
			if (e.target === null) return;
			const eventTarget = <Element>e.target;
			if (isUrlElem(eventTarget)) return;
			let eventElem: HTMLElement | null;

			if ((eventElem = eventTarget.closest('.gitRef')) !== null) {
				// .gitRef was double clicked
				e.stopPropagation();
				closeDialogAndContextMenu();
				const commitElem = <HTMLElement>eventElem.closest('.commit')!;
				const commit = this.getCommitOfElem(commitElem);
				if (commit === null) return;

				if (eventElem.classList.contains(CLASS_REF_HEAD) || eventElem.classList.contains(CLASS_REF_REMOTE)) {
					let sourceElem = <HTMLElement>eventElem.children[1];
					let refName = unescapeHtml(eventElem.dataset.name!), isHead = eventElem.classList.contains(CLASS_REF_HEAD), isRemoteCombinedWithHead = eventTarget.classList.contains('gitRefHeadRemote');
					if (isHead && isRemoteCombinedWithHead) {
						refName = unescapeHtml((<HTMLElement>eventTarget).dataset.fullref!);
						sourceElem = <HTMLElement>eventTarget;
						isHead = false;
					}

					const target: ContextMenuTarget & DialogTarget & RefTarget = {
						type: TargetType.Ref,
						hash: commit.hash,
						index: parseInt(commitElem.dataset.id!),
						ref: refName,
						elem: sourceElem
					};

					this.checkoutBranchAction(refName, isHead ? null : unescapeHtml((isRemoteCombinedWithHead ? <HTMLElement>eventTarget : eventElem).dataset.remote!), null, target);
				}
			}
		});

		// Register ContextMenu Event Handler
		this.tableElem.addEventListener('contextmenu', (e: Event) => {
			if (e.target === null) return;
			const eventTarget = <Element>e.target;
			if (isUrlElem(eventTarget)) return;
			let eventElem: HTMLElement | null;

			if ((eventElem = eventTarget.closest('.gitRef')) !== null) {
				// .gitRef was right clicked
				handledEvent(e);
				const commitElem = <HTMLElement>eventElem.closest('.commit')!;
				const commit = this.getCommitOfElem(commitElem);
				if (commit === null) return;

				const target: ContextMenuTarget & DialogTarget & RefTarget = {
					type: TargetType.Ref,
					hash: commit.hash,
					index: parseInt(commitElem.dataset.id!),
					ref: unescapeHtml(eventElem.dataset.name!),
					elem: <HTMLElement>eventElem.children[1]
				};

				let actions: ContextMenuActions;
				if (eventElem.classList.contains(CLASS_REF_STASH)) {
					actions = this.getStashContextMenuActions(target);
				} else if (eventElem.classList.contains(CLASS_REF_TAG)) {
					actions = this.getTagContextMenuActions(eventElem.dataset.tagtype === 'annotated', target);
				} else {
					let isHead = eventElem.classList.contains(CLASS_REF_HEAD), isRemoteCombinedWithHead = eventTarget.classList.contains('gitRefHeadRemote');
					if (isHead && isRemoteCombinedWithHead) {
						target.ref = unescapeHtml((<HTMLElement>eventTarget).dataset.fullref!);
						target.elem = <HTMLElement>eventTarget;
						isHead = false;
					}
					if (isHead) {
						actions = this.getBranchContextMenuActions(target);
					} else {
						const remote = unescapeHtml((isRemoteCombinedWithHead ? <HTMLElement>eventTarget : eventElem).dataset.remote!);
						actions = this.getRemoteBranchContextMenuActions(remote, target);
					}
				}

				contextMenu.show(actions, false, target, <MouseEvent>e, this.viewElem);

			} else if ((eventElem = eventTarget.closest('.commit')) !== null) {
				// .commit was right clicked
				handledEvent(e);
				const commit = this.getCommitOfElem(eventElem);
				if (commit === null) return;

				const target: ContextMenuTarget & DialogTarget & CommitTarget = {
					type: TargetType.Commit,
					hash: commit.hash,
					index: parseInt(eventElem.dataset.id!),
					elem: eventElem
				};

				let actions: ContextMenuActions;
				if (commit.hash === UNCOMMITTED) {
					actions = this.getUncommittedChangesContextMenuActions(target);
				} else if (commit.stash !== null) {
					target.ref = commit.stash.selector;
					actions = this.getStashContextMenuActions(<RefTarget>target);
				} else {
					actions = this.getCommitContextMenuActions(target);
				}

				contextMenu.show(actions, false, target, <MouseEvent>e, this.viewElem);
			}
		});
	}


	/* Commit Details View */

	public loadCommitDetails(commitElem: HTMLElement) {
		const commit = this.getCommitOfElem(commitElem);
		if (commit === null) return;

		this.closeCommitDetails(false);
		this.saveExpandedCommitLoading(parseInt(commitElem.dataset.id!), commit.hash, commitElem, null, null);
		commitElem.classList.add(CLASS_COMMIT_DETAILS_OPEN);
		this.renderCommitDetailsView(false);
		this.requestCommitDetails(commit.hash, false);
	}

	public closeCommitDetails(saveAndRender: boolean) {
		const expandedCommit = this.expandedCommit;
		if (expandedCommit === null) return;

		const elem = document.getElementById('cdv'), isDocked = this.isCdvDocked();
		if (elem !== null) {
			elem.remove();
		}
		if (isDocked) {
			this.viewElem.style.bottom = '0px';
		}
		if (expandedCommit.commitElem !== null) {
			expandedCommit.commitElem.classList.remove(CLASS_COMMIT_DETAILS_OPEN);
		}
		if (expandedCommit.compareWithElem !== null) {
			expandedCommit.compareWithElem.classList.remove(CLASS_COMMIT_DETAILS_OPEN);
		}
		GitGraphView.closeCdvContextMenuIfOpen(expandedCommit);
		this.expandedCommit = null;
		if (saveAndRender) {
			this.saveState();
			if (!isDocked) {
				this.renderGraph();
			}
		}
	}

	public showCommitDetails(commitDetails: GG.GitCommitDetails, fileTree: FileTreeFolder, avatar: string | null, codeReview: GG.CodeReview | null, lastViewedFile: string | null, refresh: boolean) {
		const expandedCommit = this.expandedCommit;
		if (expandedCommit === null || expandedCommit.commitElem === null || expandedCommit.commitHash !== commitDetails.hash || expandedCommit.compareWithHash !== null) return;

		if (!this.isCdvDocked()) {
			const elem = document.getElementById('cdv');
			if (elem !== null) elem.remove();
		}

		expandedCommit.commitDetails = commitDetails;
		if (haveFilesChanged(expandedCommit.fileChanges, commitDetails.fileChanges)) {
			expandedCommit.fileChanges = commitDetails.fileChanges;
			expandedCommit.fileTree = fileTree;
			GitGraphView.closeCdvContextMenuIfOpen(expandedCommit);
		}
		expandedCommit.avatar = avatar;
		expandedCommit.codeReview = codeReview;
		if (!refresh) {
			expandedCommit.lastViewedFile = lastViewedFile;
		}
		expandedCommit.commitElem.classList.add(CLASS_COMMIT_DETAILS_OPEN);
		expandedCommit.loading = false;
		this.saveState();

		this.renderCommitDetailsView(refresh);
	}

	public createFileTree(gitFiles: ReadonlyArray<GG.GitFileChange>, codeReview: GG.CodeReview | null) {
		let contents: FileTreeFolderContents = {}, i, j, path, absPath, cur: FileTreeFolder;
		let files: FileTreeFolder = { type: 'folder', name: '', folderPath: '', contents: contents, open: true, reviewed: true };

		for (i = 0; i < gitFiles.length; i++) {
			cur = files;
			path = gitFiles[i].newFilePath.split('/');
			absPath = this.currentRepo;
			for (j = 0; j < path.length; j++) {
				absPath += '/' + path[j];
				if (typeof this.gitRepos[absPath] !== 'undefined') {
					if (typeof cur.contents[path[j]] === 'undefined') {
						cur.contents[path[j]] = { type: 'repo', name: path[j], path: absPath };
					}
					break;
				} else if (j < path.length - 1) {
					if (typeof cur.contents[path[j]] === 'undefined') {
						contents = {};
						cur.contents[path[j]] = { type: 'folder', name: path[j], folderPath: absPath.substring(this.currentRepo.length + 1), contents: contents, open: true, reviewed: true };
					}
					cur = <FileTreeFolder>cur.contents[path[j]];
				} else if (path[j] !== '') {
					cur.contents[path[j]] = { type: 'file', name: path[j], index: i, reviewed: codeReview === null || !codeReview.remainingFiles.includes(gitFiles[i].newFilePath) };
				}
			}
		}
		if (codeReview !== null) calcFileTreeFoldersReviewed(files);
		return files;
	}


	/* Commit Comparison View */

	private loadCommitComparison(commitElem: HTMLElement, compareWithElem: HTMLElement) {
		const commit = this.getCommitOfElem(commitElem);
		const compareWithCommit = this.getCommitOfElem(compareWithElem);

		if (commit !== null && compareWithCommit !== null) {
			if (this.expandedCommit !== null) {
				if (this.expandedCommit.commitHash !== commit.hash) {
					this.closeCommitDetails(false);
				} else if (this.expandedCommit.compareWithHash !== compareWithCommit.hash) {
					this.closeCommitComparison(false);
				}
			}

			this.saveExpandedCommitLoading(parseInt(commitElem.dataset.id!), commit.hash, commitElem, compareWithCommit.hash, compareWithElem);
			commitElem.classList.add(CLASS_COMMIT_DETAILS_OPEN);
			compareWithElem.classList.add(CLASS_COMMIT_DETAILS_OPEN);
			this.renderCommitDetailsView(false);
			this.requestCommitComparison(commit.hash, compareWithCommit.hash, false);
		}
	}

	public closeCommitComparison(saveAndRequestCommitDetails: boolean) {
		const expandedCommit = this.expandedCommit;
		if (expandedCommit === null || expandedCommit.compareWithHash === null) return;

		if (expandedCommit.compareWithElem !== null) {
			expandedCommit.compareWithElem.classList.remove(CLASS_COMMIT_DETAILS_OPEN);
		}
		GitGraphView.closeCdvContextMenuIfOpen(expandedCommit);
		if (saveAndRequestCommitDetails) {
			if (expandedCommit.commitElem !== null) {
				this.saveExpandedCommitLoading(expandedCommit.index, expandedCommit.commitHash, expandedCommit.commitElem, null, null);
				this.renderCommitDetailsView(false);
				this.requestCommitDetails(expandedCommit.commitHash, false);
			} else {
				this.closeCommitDetails(true);
			}
		}
	}

	public showCommitComparison(commitHash: string, compareWithHash: string, fileChanges: ReadonlyArray<GG.GitFileChange>, fileTree: FileTreeFolder, codeReview: GG.CodeReview | null, lastViewedFile: string | null, refresh: boolean) {
		const expandedCommit = this.expandedCommit;
		if (expandedCommit === null || expandedCommit.commitElem === null || expandedCommit.compareWithElem === null || expandedCommit.commitHash !== commitHash || expandedCommit.compareWithHash !== compareWithHash) return;

		if (haveFilesChanged(expandedCommit.fileChanges, fileChanges)) {
			expandedCommit.fileChanges = fileChanges;
			expandedCommit.fileTree = fileTree;
			GitGraphView.closeCdvContextMenuIfOpen(expandedCommit);
		}
		expandedCommit.codeReview = codeReview;
		if (!refresh) {
			expandedCommit.lastViewedFile = lastViewedFile;
		}
		expandedCommit.commitElem.classList.add(CLASS_COMMIT_DETAILS_OPEN);
		expandedCommit.compareWithElem.classList.add(CLASS_COMMIT_DETAILS_OPEN);
		expandedCommit.loading = false;
		this.saveState();

		this.renderCommitDetailsView(refresh);
	}


	/* Render Commit Details / Comparison View */

	private renderCommitDetailsView(refresh: boolean) {
		const expandedCommit = this.expandedCommit;
		if (expandedCommit === null || expandedCommit.commitElem === null) return;

		let elem = document.getElementById('cdv'), html = '<div id="cdvContent">', isDocked = this.isCdvDocked();
		const commitOrder = this.getCommitOrder(expandedCommit.commitHash, expandedCommit.compareWithHash === null ? expandedCommit.commitHash : expandedCommit.compareWithHash);
		const codeReviewPossible = !expandedCommit.loading && commitOrder.to !== UNCOMMITTED;
		const externalDiffPossible = !expandedCommit.loading && (expandedCommit.compareWithHash !== null || this.commits[this.commitLookup[expandedCommit.commitHash]].parents.length > 0);

		if (elem === null) {
			elem = document.createElement(isDocked ? 'div' : 'tr');
			elem.id = 'cdv';
			elem.className = isDocked ? 'docked' : 'inline';
			this.setCdvHeight(elem, isDocked);
			if (isDocked) {
				document.body.appendChild(elem);
			} else {
				insertAfter(elem, expandedCommit.commitElem);
			}
		}

		if (expandedCommit.loading) {
			html += '<div id="cdvLoading">' + SVG_ICONS.loading + ' Loading ' + (expandedCommit.compareWithHash === null ? expandedCommit.commitHash !== UNCOMMITTED ? 'Commit Details' : 'Uncommitted Changes' : 'Commit Comparison') + ' ...</div>';
		} else {
			html += '<div id="cdvSummary">';
			if (expandedCommit.compareWithHash === null) {
				// Commit details should be shown
				if (expandedCommit.commitHash !== UNCOMMITTED) {
					const textFormatter = new TextFormatter(this.commits, this.gitRepos[this.currentRepo].issueLinkingConfig, {
						commits: true,
						emoji: true,
						issueLinking: true,
						markdown: this.config.markdown,
						multiline: true,
						urls: true
					});
					const commitDetails = expandedCommit.commitDetails!;
					const parents = commitDetails.parents.length > 0
						? commitDetails.parents.map((parent) => {
							const escapedParent = escapeHtml(parent);
							return typeof this.commitLookup[parent] === 'number'
								? '<span class="' + CLASS_INTERNAL_URL + '" data-type="commit" data-value="' + escapedParent + '" tabindex="-1">' + escapedParent + '</span>'
								: escapedParent;
						}).join(', ')
						: 'None';
					html += '<span class="cdvSummaryTop' + (expandedCommit.avatar !== null ? ' withAvatar' : '') + '"><span class="cdvSummaryTopRow"><span class="cdvSummaryKeyValues">'
						+ '<b>Commit: </b>' + escapeHtml(commitDetails.hash) + '<br>'
						+ '<b>Parents: </b>' + parents + '<br>'
						+ '<b>Author: </b>' + escapeHtml(commitDetails.author) + (commitDetails.authorEmail !== '' ? ' &lt;<a class="' + CLASS_EXTERNAL_URL + '" href="mailto:' + escapeHtml(commitDetails.authorEmail) + '" tabindex="-1">' + escapeHtml(commitDetails.authorEmail) + '</a>&gt;' : '') + '<br>'
						+ (commitDetails.authorDate !== commitDetails.committerDate ? '<b>Author Date: </b>' + formatLongDate(commitDetails.authorDate) + '<br>' : '')
						+ '<b>Committer: </b>' + escapeHtml(commitDetails.committer) + (commitDetails.committerEmail !== '' ? ' &lt;<a class="' + CLASS_EXTERNAL_URL + '" href="mailto:' + escapeHtml(commitDetails.committerEmail) + '" tabindex="-1">' + escapeHtml(commitDetails.committerEmail) + '</a>&gt;' : '') + (commitDetails.signature !== null ? generateSignatureHtml(commitDetails.signature) : '') + '<br>'
						+ '<b>' + (commitDetails.authorDate !== commitDetails.committerDate ? 'Committer ' : '') + 'Date: </b>' + formatLongDate(commitDetails.committerDate)
						+ '</span>'
						+ (expandedCommit.avatar !== null ? '<span class="cdvSummaryAvatar"><img src="' + expandedCommit.avatar + '"></span>' : '')
						+ '</span></span><br><br>' + textFormatter.format(commitDetails.body);
				} else {
					html += 'Displaying all uncommitted changes.';
				}
			} else {
				// Commit comparison should be shown
				html += 'Displaying all changes from <b>' + commitOrder.from + '</b> to <b>' + (commitOrder.to !== UNCOMMITTED ? commitOrder.to : 'Uncommitted Changes') + '</b>.';
			}
			html += '</div><div id="cdvFiles">' + generateFileViewHtml(expandedCommit.fileTree!, expandedCommit.fileChanges!, expandedCommit.lastViewedFile, expandedCommit.contextMenuOpen.fileView, this.getFileViewType(), commitOrder.to === UNCOMMITTED) + '</div><div id="cdvDivider"></div>';
		}
		html += '</div><div id="cdvControls"><div id="cdvClose" class="cdvControlBtn" title="Close">' + SVG_ICONS.close + '</div>' +
			(codeReviewPossible ? '<div id="cdvCodeReview" class="cdvControlBtn">' + SVG_ICONS.review + '</div>' : '') +
			(!expandedCommit.loading ? '<div id="cdvFileViewTypeTree" class="cdvControlBtn cdvFileViewTypeBtn" title="File Tree View">' + SVG_ICONS.fileTree + '</div><div id="cdvFileViewTypeList" class="cdvControlBtn cdvFileViewTypeBtn" title="File List View">' + SVG_ICONS.fileList + '</div>' : '') +
			(externalDiffPossible ? '<div id="cdvExternalDiff" class="cdvControlBtn">' + SVG_ICONS.linkExternal + '</div>' : '') +
			'</div><div class="cdvHeightResize"></div>';

		elem.innerHTML = isDocked ? html : '<td><div class="cdvHeightResize"></div></td><td colspan="' + (this.getNumColumns() - 1) + '">' + html + '</td>';
		if (!expandedCommit.loading) this.setCdvDivider();
		if (!isDocked) this.renderGraph();

		if (!refresh) {
			if (isDocked) {
				let elemTop = this.controlsElem.clientHeight + expandedCommit.commitElem.offsetTop;
				if (elemTop - 8 < this.viewElem.scrollTop) {
					// Commit is above what is visible on screen
					this.viewElem.scroll(0, elemTop - 8);
				} else if (elemTop - this.viewElem.clientHeight + 32 > this.viewElem.scrollTop) {
					// Commit is below what is visible on screen
					this.viewElem.scroll(0, elemTop - this.viewElem.clientHeight + 32);
				}
			} else {
				let elemTop = this.controlsElem.clientHeight + elem.offsetTop, cdvHeight = this.gitRepos[this.currentRepo].cdvHeight;
				if (this.config.commitDetailsView.autoCenter) {
					// Center Commit Detail View setting is enabled
					// elemTop - commit height [24px] + (commit details view height + commit height [24px]) / 2 - (view height) / 2
					this.viewElem.scroll(0, elemTop - 12 + (cdvHeight - this.viewElem.clientHeight) / 2);
				} else if (elemTop - 32 < this.viewElem.scrollTop) {
					// Commit Detail View is opening above what is visible on screen
					// elemTop - commit height [24px] - desired gap from top [8px] < view scroll offset
					this.viewElem.scroll(0, elemTop - 32);
				} else if (elemTop + cdvHeight - this.viewElem.clientHeight + 8 > this.viewElem.scrollTop) {
					// Commit Detail View is opening below what is visible on screen
					// elemTop + commit details view height + desired gap from bottom [8px] - view height > view scroll offset
					this.viewElem.scroll(0, elemTop + cdvHeight - this.viewElem.clientHeight + 8);
				}
			}
		}

		this.makeCdvResizable();
		document.getElementById('cdvClose')!.addEventListener('click', () => {
			this.closeCommitDetails(true);
		});

		if (!expandedCommit.loading) {
			this.makeCdvFileViewInteractive();
			this.renderCdvFileViewTypeBtns();
			this.renderCdvExternalDiffBtn();
			this.makeCdvDividerDraggable();

			observeElemScroll('cdvSummary', expandedCommit.scrollTop.summary, (scrollTop) => {
				if (this.expandedCommit === null) return;
				this.expandedCommit.scrollTop.summary = scrollTop;
				if (this.expandedCommit.contextMenuOpen.summary) {
					this.expandedCommit.contextMenuOpen.summary = false;
					contextMenu.close();
				}
			}, () => this.saveState());

			observeElemScroll('cdvFiles', expandedCommit.scrollTop.fileView, (scrollTop) => {
				if (this.expandedCommit === null) return;
				this.expandedCommit.scrollTop.fileView = scrollTop;
				if (this.expandedCommit.contextMenuOpen.fileView > -1) {
					this.expandedCommit.contextMenuOpen.fileView = -1;
					contextMenu.close();
				}
			}, () => this.saveState());

			document.getElementById('cdvFileViewTypeTree')!.addEventListener('click', () => {
				this.changeFileViewType(GG.FileViewType.Tree);
			});

			document.getElementById('cdvFileViewTypeList')!.addEventListener('click', () => {
				this.changeFileViewType(GG.FileViewType.List);
			});

			if (codeReviewPossible) {
				this.renderCodeReviewBtn();
				document.getElementById('cdvCodeReview')!.addEventListener('click', (e) => {
					const expandedCommit = this.expandedCommit;
					if (expandedCommit === null || e.target === null) return;
					let sourceElem = <HTMLElement>(<Element>e.target).closest('#cdvCodeReview')!;
					if (sourceElem.classList.contains(CLASS_ACTIVE)) {
						sendMessage({ command: 'endCodeReview', repo: this.currentRepo, id: expandedCommit.codeReview!.id });
						this.endCodeReview();
					} else {
						const commitOrder = this.getCommitOrder(expandedCommit.commitHash, expandedCommit.compareWithHash === null ? expandedCommit.commitHash : expandedCommit.compareWithHash);
						const id = expandedCommit.compareWithHash !== null ? commitOrder.from + '-' + commitOrder.to : expandedCommit.commitHash;
						sendMessage({
							command: 'startCodeReview',
							repo: this.currentRepo,
							id: id,
							commitHash: expandedCommit.commitHash,
							compareWithHash: expandedCommit.compareWithHash,
							files: getFilesInTree(expandedCommit.fileTree!, expandedCommit.fileChanges!),
							lastViewedFile: expandedCommit.lastViewedFile
						});
					}
				});
			}

			if (externalDiffPossible) {
				document.getElementById('cdvExternalDiff')!.addEventListener('click', () => {
					const expandedCommit = this.expandedCommit;
					if (expandedCommit === null || this.gitConfig === null || (this.gitConfig.diffTool === null && this.gitConfig.guiDiffTool === null)) return;
					const commitOrder = this.getCommitOrder(expandedCommit.commitHash, expandedCommit.compareWithHash === null ? expandedCommit.commitHash : expandedCommit.compareWithHash);
					runAction({
						command: 'openExternalDirDiff',
						repo: this.currentRepo,
						fromHash: commitOrder.from,
						toHash: commitOrder.to,
						isGui: this.gitConfig.guiDiffTool !== null
					}, 'Opening External Directory Diff');
				});
			}
		}
	}

	private setCdvHeight(elem: HTMLElement, isDocked: boolean) {
		let height = this.gitRepos[this.currentRepo].cdvHeight, windowHeight = window.innerHeight;
		if (height > windowHeight - 40) {
			height = Math.max(windowHeight - 40, 100);
			if (height !== this.gitRepos[this.currentRepo].cdvHeight) {
				this.gitRepos[this.currentRepo].cdvHeight = height;
				this.saveRepoState();
			}
		}

		let heightPx = height + 'px';
		elem.style.height = heightPx;
		if (isDocked) this.viewElem.style.bottom = heightPx;
	}

	private setCdvDivider() {
		let percent = (this.gitRepos[this.currentRepo].cdvDivider * 100).toFixed(2) + '%';
		let summaryElem = document.getElementById('cdvSummary'), dividerElem = document.getElementById('cdvDivider'), filesElem = document.getElementById('cdvFiles');
		if (summaryElem !== null) summaryElem.style.width = percent;
		if (dividerElem !== null) dividerElem.style.left = percent;
		if (filesElem !== null) filesElem.style.left = percent;
	}

	private makeCdvResizable() {
		let prevY = -1;

		const processResizingCdvHeight: EventListener = (e) => {
			if (prevY < 0) return;
			let delta = (<MouseEvent>e).pageY - prevY, isDocked = this.isCdvDocked(), windowHeight = window.innerHeight;
			prevY = (<MouseEvent>e).pageY;
			let height = this.gitRepos[this.currentRepo].cdvHeight + (isDocked ? -delta : delta);
			if (height < 100) height = 100;
			else if (height > 600) height = 600;
			if (height > windowHeight - 40) height = Math.max(windowHeight - 40, 100);

			if (this.gitRepos[this.currentRepo].cdvHeight !== height) {
				this.gitRepos[this.currentRepo].cdvHeight = height;
				let elem = document.getElementById('cdv');
				if (elem !== null) this.setCdvHeight(elem, isDocked);
				if (!isDocked) this.renderGraph();
			}
		};
		const stopResizingCdvHeight: EventListener = (e) => {
			if (prevY < 0) return;
			processResizingCdvHeight(e);
			this.saveRepoState();
			prevY = -1;
			eventOverlay.remove();
		};

		addListenerToClass('cdvHeightResize', 'mousedown', (e) => {
			prevY = (<MouseEvent>e).pageY;
			eventOverlay.create('rowResize', processResizingCdvHeight, stopResizingCdvHeight);
		});
	}

	private makeCdvDividerDraggable() {
		let minX = -1, width = -1;

		const processDraggingCdvDivider: EventListener = (e) => {
			if (minX < 0) return;
			let percent = ((<MouseEvent>e).clientX - minX) / width;
			if (percent < 0.2) percent = 0.2;
			else if (percent > 0.8) percent = 0.8;

			if (this.gitRepos[this.currentRepo].cdvDivider !== percent) {
				this.gitRepos[this.currentRepo].cdvDivider = percent;
				this.setCdvDivider();
			}
		};
		const stopDraggingCdvDivider: EventListener = (e) => {
			if (minX < 0) return;
			processDraggingCdvDivider(e);
			this.saveRepoState();
			minX = -1;
			eventOverlay.remove();
		};

		document.getElementById('cdvDivider')!.addEventListener('mousedown', () => {
			const contentElem = document.getElementById('cdvContent');
			if (contentElem === null) return;

			const bounds = contentElem.getBoundingClientRect();
			minX = bounds.left;
			width = bounds.width;
			eventOverlay.create('colResize', processDraggingCdvDivider, stopDraggingCdvDivider);
		});
	}

	/**
	 * Updates the state of a file in the Commit Details View.
	 * @param file The file that was affected.
	 * @param fileElem The HTML Element of the file.
	 * @param isReviewed TRUE/FALSE => Set the files reviewed state accordingly, NULL => Don't update the files reviewed state.
	 * @param fileWasViewed Was the file viewed - if so, set it to be the last viewed file.
	 */
	private cdvUpdateFileState(file: GG.GitFileChange, fileElem: HTMLElement, isReviewed: boolean | null, fileWasViewed: boolean) {
		const expandedCommit = this.expandedCommit, filesElem = document.getElementById('cdvFiles'), filePath = file.newFilePath;
		if (expandedCommit === null || expandedCommit.fileTree === null || filesElem === null) return;

		if (fileWasViewed) {
			expandedCommit.lastViewedFile = filePath;
			let lastViewedElem = document.getElementById('cdvLastFileViewed');
			if (lastViewedElem !== null) lastViewedElem.remove();
			lastViewedElem = document.createElement('span');
			lastViewedElem.id = 'cdvLastFileViewed';
			lastViewedElem.title = 'Last File Viewed';
			lastViewedElem.innerHTML = SVG_ICONS.eyeOpen;
			insertBeforeFirstChildWithClass(lastViewedElem, fileElem, 'fileTreeFileAction');
		}

		if (expandedCommit.codeReview !== null) {
			if (isReviewed !== null) {
				if (isReviewed) {
					expandedCommit.codeReview.remainingFiles = expandedCommit.codeReview.remainingFiles.filter((path: string) => path !== filePath);
				} else {
					expandedCommit.codeReview.remainingFiles.push(filePath);
				}

				alterFileTreeFileReviewed(expandedCommit.fileTree, filePath, isReviewed);
				updateFileTreeHtmlFileReviewed(filesElem, expandedCommit.fileTree, filePath);
			}

			sendMessage({
				command: 'updateCodeReview',
				repo: this.currentRepo,
				id: expandedCommit.codeReview.id,
				remainingFiles: expandedCommit.codeReview.remainingFiles,
				lastViewedFile: expandedCommit.lastViewedFile
			});

			if (expandedCommit.codeReview.remainingFiles.length === 0) {
				expandedCommit.codeReview = null;
				this.renderCodeReviewBtn();
			}
		}

		this.saveState();
	}

	private isCdvDocked() {
		return this.config.commitDetailsView.location === GG.CommitDetailsViewLocation.DockedToBottom;
	}

	public isCdvOpen(commitHash: string, compareWithHash: string | null) {
		return this.expandedCommit !== null && this.expandedCommit.commitHash === commitHash && this.expandedCommit.compareWithHash === compareWithHash;
	}

	private getCommitOrder(hash1: string, hash2: string) {
		if (this.commitLookup[hash1] > this.commitLookup[hash2]) {
			return { from: hash1, to: hash2 };
		} else {
			return { from: hash2, to: hash1 };
		}
	}

	private getFileViewType() {
		return this.gitRepos[this.currentRepo].fileViewType === GG.FileViewType.Default
			? this.config.commitDetailsView.fileViewType
			: this.gitRepos[this.currentRepo].fileViewType;
	}

	private setFileViewType(type: GG.FileViewType) {
		this.gitRepos[this.currentRepo].fileViewType = type;
		this.saveRepoState();
	}

	private changeFileViewType(type: GG.FileViewType) {
		const expandedCommit = this.expandedCommit, filesElem = document.getElementById('cdvFiles');
		if (expandedCommit === null || expandedCommit.fileTree === null || expandedCommit.fileChanges === null || filesElem === null) return;
		GitGraphView.closeCdvContextMenuIfOpen(expandedCommit);
		this.setFileViewType(type);
		const commitOrder = this.getCommitOrder(expandedCommit.commitHash, expandedCommit.compareWithHash === null ? expandedCommit.commitHash : expandedCommit.compareWithHash);
		filesElem.innerHTML = generateFileViewHtml(expandedCommit.fileTree, expandedCommit.fileChanges, expandedCommit.lastViewedFile, expandedCommit.contextMenuOpen.fileView, type, commitOrder.to === UNCOMMITTED);
		this.makeCdvFileViewInteractive();
		this.renderCdvFileViewTypeBtns();
	}

	private makeCdvFileViewInteractive() {
		const getFileElemOfEventTarget = (target: EventTarget) => <HTMLElement>(<Element>target).closest('.fileTreeFileRecord');
		const getFileOfFileElem = (fileChanges: ReadonlyArray<GG.GitFileChange>, fileElem: HTMLElement) => fileChanges[parseInt(fileElem.dataset.index!)];

		const getCommitHashForFile = (file: GG.GitFileChange, expandedCommit: ExpandedCommit) => {
			const commit = this.commits[this.commitLookup[expandedCommit.commitHash]];
			if (expandedCommit.compareWithHash !== null) {
				return this.getCommitOrder(expandedCommit.commitHash, expandedCommit.compareWithHash).to;
			} else if (commit.stash !== null && file.type === GG.GitFileStatus.Untracked) {
				return commit.stash.untrackedFilesHash!;
			} else {
				return expandedCommit.commitHash;
			}
		};

		const triggerViewFileDiff = (file: GG.GitFileChange, fileElem: HTMLElement) => {
			const expandedCommit = this.expandedCommit;
			if (expandedCommit === null) return;

			let commit = this.commits[this.commitLookup[expandedCommit.commitHash]], fromHash: string, toHash: string, fileStatus = file.type;
			if (expandedCommit.compareWithHash !== null) {
				// Commit Comparison
				const commitOrder = this.getCommitOrder(expandedCommit.commitHash, expandedCommit.compareWithHash);
				fromHash = commitOrder.from;
				toHash = commitOrder.to;
			} else if (commit.stash !== null) {
				// Stash Commit
				if (fileStatus === GG.GitFileStatus.Untracked) {
					fromHash = commit.stash.untrackedFilesHash!;
					toHash = commit.stash.untrackedFilesHash!;
					fileStatus = GG.GitFileStatus.Added;
				} else {
					fromHash = commit.stash.baseHash;
					toHash = expandedCommit.commitHash;
				}
			} else {
				// Single Commit
				fromHash = expandedCommit.commitHash;
				toHash = expandedCommit.commitHash;
			}

			this.cdvUpdateFileState(file, fileElem, true, true);
			sendMessage({
				command: 'viewDiff',
				repo: this.currentRepo,
				fromHash: fromHash,
				toHash: toHash,
				oldFilePath: file.oldFilePath,
				newFilePath: file.newFilePath,
				type: fileStatus
			});
		};

		const triggerCopyFilePath = (file: GG.GitFileChange, absolute: boolean) => {
			sendMessage({ command: 'copyFilePath', repo: this.currentRepo, filePath: file.newFilePath, absolute: absolute });
		};

		const triggerResetFileToRevision = (file: GG.GitFileChange, fileElem: HTMLElement) => {
			const expandedCommit = this.expandedCommit;
			if (expandedCommit === null) return;

			const commitHash = getCommitHashForFile(file, expandedCommit);
			dialog.showConfirmation('Are you sure you want to reset <b><i>' + escapeHtml(file.newFilePath) + '</i></b> to it\'s state at commit <b><i>' + abbrevCommit(commitHash) + '</i></b>? Any uncommitted changes made to this file will be overwritten.', 'Yes, reset file', () => {
				runAction({ command: 'resetFileToRevision', repo: this.currentRepo, commitHash: commitHash, filePath: file.newFilePath }, 'Resetting file');
			}, {
				type: TargetType.CommitDetailsView,
				hash: commitHash,
				elem: fileElem
			});
		};

		const triggerViewFileAtRevision = (file: GG.GitFileChange, fileElem: HTMLElement) => {
			const expandedCommit = this.expandedCommit;
			if (expandedCommit === null) return;

			this.cdvUpdateFileState(file, fileElem, true, true);
			sendMessage({ command: 'viewFileAtRevision', repo: this.currentRepo, hash: getCommitHashForFile(file, expandedCommit), filePath: file.newFilePath });
		};

		const triggerViewFileDiffWithWorkingFile = (file: GG.GitFileChange, fileElem: HTMLElement) => {
			const expandedCommit = this.expandedCommit;
			if (expandedCommit === null) return;

			this.cdvUpdateFileState(file, fileElem, null, true);
			sendMessage({ command: 'viewDiffWithWorkingFile', repo: this.currentRepo, hash: getCommitHashForFile(file, expandedCommit), filePath: file.newFilePath });
		};

		const triggerOpenFile = (file: GG.GitFileChange, fileElem: HTMLElement) => {
			const expandedCommit = this.expandedCommit;
			if (expandedCommit === null) return;

			this.cdvUpdateFileState(file, fileElem, true, true);
			sendMessage({ command: 'openFile', repo: this.currentRepo, hash: getCommitHashForFile(file, expandedCommit), filePath: file.newFilePath });
		};

		addListenerToClass('fileTreeFolder', 'click', (e) => {
			let expandedCommit = this.expandedCommit;
			if (expandedCommit === null || expandedCommit.fileTree === null || e.target === null) return;

			let sourceElem = <HTMLElement>(<Element>e.target).closest('.fileTreeFolder');
			let parent = sourceElem.parentElement!;
			parent.classList.toggle('closed');
			let isOpen = !parent.classList.contains('closed');
			parent.children[0].children[0].innerHTML = isOpen ? SVG_ICONS.openFolder : SVG_ICONS.closedFolder;
			parent.children[1].classList.toggle('hidden');
			alterFileTreeFolderOpen(expandedCommit.fileTree, decodeURIComponent(sourceElem.dataset.folderpath!), isOpen);
			this.saveState();
		});

		addListenerToClass('fileTreeRepo', 'click', (e) => {
			if (e.target === null) return;
			this.loadRepos(this.gitRepos, null, {
				repo: decodeURIComponent((<HTMLElement>(<Element>e.target).closest('.fileTreeRepo')).dataset.path!)
			});
		});

		addListenerToClass('fileTreeFile', 'click', (e) => {
			const expandedCommit = this.expandedCommit;
			if (expandedCommit === null || expandedCommit.fileChanges === null || e.target === null) return;

			const sourceElem = <HTMLElement>(<Element>e.target).closest('.fileTreeFile'), fileElem = getFileElemOfEventTarget(e.target);
			if (!sourceElem.classList.contains('gitDiffPossible')) return;
			triggerViewFileDiff(getFileOfFileElem(expandedCommit.fileChanges, fileElem), fileElem);
		});

		addListenerToClass('copyGitFile', 'click', (e) => {
			const expandedCommit = this.expandedCommit;
			if (expandedCommit === null || expandedCommit.fileChanges === null || e.target === null) return;

			const fileElem = getFileElemOfEventTarget(e.target);
			triggerCopyFilePath(getFileOfFileElem(expandedCommit.fileChanges, fileElem), true);
		});

		addListenerToClass('viewGitFileAtRevision', 'click', (e) => {
			const expandedCommit = this.expandedCommit;
			if (expandedCommit === null || expandedCommit.fileChanges === null || e.target === null) return;

			const fileElem = getFileElemOfEventTarget(e.target);
			triggerViewFileAtRevision(getFileOfFileElem(expandedCommit.fileChanges, fileElem), fileElem);
		});

		addListenerToClass('openGitFile', 'click', (e) => {
			const expandedCommit = this.expandedCommit;
			if (expandedCommit === null || expandedCommit.fileChanges === null || e.target === null) return;

			const fileElem = getFileElemOfEventTarget(e.target);
			triggerOpenFile(getFileOfFileElem(expandedCommit.fileChanges, fileElem), fileElem);
		});

		addListenerToClass('fileTreeFileRecord', 'contextmenu', (e: Event) => {
			handledEvent(e);
			const expandedCommit = this.expandedCommit;
			if (expandedCommit === null || expandedCommit.fileChanges === null || e.target === null) return;
			const fileElem = getFileElemOfEventTarget(e.target);
			const file = getFileOfFileElem(expandedCommit.fileChanges, fileElem);
			const commitOrder = this.getCommitOrder(expandedCommit.commitHash, expandedCommit.compareWithHash === null ? expandedCommit.commitHash : expandedCommit.compareWithHash);
			const isUncommitted = commitOrder.to === UNCOMMITTED;

			GitGraphView.closeCdvContextMenuIfOpen(expandedCommit);
			expandedCommit.contextMenuOpen.fileView = parseInt(fileElem.dataset.index!);

			const target: ContextMenuTarget & CommitTarget = {
				type: TargetType.CommitDetailsView,
				hash: expandedCommit.commitHash,
				index: this.commitLookup[expandedCommit.commitHash],
				elem: fileElem
			};
			const diffPossible = file.type === GG.GitFileStatus.Untracked || (file.additions !== null && file.deletions !== null);
			const fileExistsAtThisRevision = file.type !== GG.GitFileStatus.Deleted && !isUncommitted;
			const fileExistsAtThisRevisionAndDiffPossible = fileExistsAtThisRevision && diffPossible;
			const codeReviewInProgressAndNotReviewed = expandedCommit.codeReview !== null && expandedCommit.codeReview.remainingFiles.includes(file.newFilePath);
			const visibility = this.config.contextMenuActionsVisibility.commitDetailsViewFile;

			contextMenu.show([
				[
					{
						title: 'View Diff',
						visible: visibility.viewDiff && diffPossible,
						onClick: () => triggerViewFileDiff(file, fileElem)
					},
					{
						title: 'View File at this Revision',
						visible: visibility.viewFileAtThisRevision && fileExistsAtThisRevisionAndDiffPossible,
						onClick: () => triggerViewFileAtRevision(file, fileElem)
					},
					{
						title: 'View Diff with Working File',
						visible: visibility.viewDiffWithWorkingFile && fileExistsAtThisRevisionAndDiffPossible,
						onClick: () => triggerViewFileDiffWithWorkingFile(file, fileElem)
					},
					{
						title: 'Open File',
						visible: visibility.openFile && file.type !== GG.GitFileStatus.Deleted,
						onClick: () => triggerOpenFile(file, fileElem)
					}
				],
				[
					{
						title: 'Mark as Reviewed',
						visible: visibility.markAsReviewed && codeReviewInProgressAndNotReviewed,
						onClick: () => this.cdvUpdateFileState(file, fileElem, true, false)
					},
					{
						title: 'Mark as Not Reviewed',
						visible: visibility.markAsNotReviewed && expandedCommit.codeReview !== null && !codeReviewInProgressAndNotReviewed,
						onClick: () => this.cdvUpdateFileState(file, fileElem, false, false)
					}
				],
				[
					{
						title: 'Reset File to this Revision' + ELLIPSIS,
						visible: visibility.resetFileToThisRevision && fileExistsAtThisRevision && expandedCommit.compareWithHash === null,
						onClick: () => triggerResetFileToRevision(file, fileElem)
					}
				],
				[
					{
						title: 'Copy Absolute File Path to Clipboard',
						visible: visibility.copyAbsoluteFilePath,
						onClick: () => triggerCopyFilePath(file, true)
					},
					{
						title: 'Copy Relative File Path to Clipboard',
						visible: visibility.copyRelativeFilePath,
						onClick: () => triggerCopyFilePath(file, false)
					}
				]
			], false, target, <MouseEvent>e, this.isCdvDocked() ? document.body : this.viewElem, () => {
				expandedCommit.contextMenuOpen.fileView = -1;
			});
		});
	}

	private renderCdvFileViewTypeBtns() {
		if (this.expandedCommit === null) return;
		let treeBtnElem = document.getElementById('cdvFileViewTypeTree'), listBtnElem = document.getElementById('cdvFileViewTypeList');
		if (treeBtnElem === null || listBtnElem === null) return;

		let listView = this.getFileViewType() === GG.FileViewType.List;
		alterClass(treeBtnElem, CLASS_ACTIVE, !listView);
		alterClass(listBtnElem, CLASS_ACTIVE, listView);
	}

	private renderCdvExternalDiffBtn() {
		if (this.expandedCommit === null) return;
		const externalDiffBtnElem = document.getElementById('cdvExternalDiff');
		if (externalDiffBtnElem === null) return;

		alterClass(externalDiffBtnElem, CLASS_ENABLED, this.gitConfig !== null && (this.gitConfig.diffTool !== null || this.gitConfig.guiDiffTool !== null));
		const toolName = this.gitConfig !== null
			? this.gitConfig.guiDiffTool !== null
				? this.gitConfig.guiDiffTool
				: this.gitConfig.diffTool
			: null;
		externalDiffBtnElem.title = 'Open External Directory Diff' + (toolName !== null ? ' with "' + toolName + '"' : '');
	}

	private static closeCdvContextMenuIfOpen(expandedCommit: ExpandedCommit) {
		if (expandedCommit.contextMenuOpen.summary || expandedCommit.contextMenuOpen.fileView > -1) {
			expandedCommit.contextMenuOpen.summary = false;
			expandedCommit.contextMenuOpen.fileView = -1;
			contextMenu.close();
		}
	}


	/* Code Review */

	public startCodeReview(commitHash: string, compareWithHash: string | null, codeReview: GG.CodeReview) {
		if (this.expandedCommit === null || this.expandedCommit.commitHash !== commitHash || this.expandedCommit.compareWithHash !== compareWithHash) return;
		this.saveAndRenderCodeReview(codeReview);
	}

	public endCodeReview() {
		if (this.expandedCommit === null || this.expandedCommit.codeReview === null) return;
		this.saveAndRenderCodeReview(null);
	}

	private saveAndRenderCodeReview(codeReview: GG.CodeReview | null) {
		let filesElem = document.getElementById('cdvFiles');
		if (this.expandedCommit === null || this.expandedCommit.fileTree === null || filesElem === null) return;

		this.expandedCommit.codeReview = codeReview;
		setFileTreeReviewed(this.expandedCommit.fileTree, codeReview === null);
		this.saveState();
		this.renderCodeReviewBtn();
		updateFileTreeHtml(filesElem, this.expandedCommit.fileTree);
	}

	private renderCodeReviewBtn() {
		if (this.expandedCommit === null) return;
		let btnElem = document.getElementById('cdvCodeReview');
		if (btnElem === null) return;

		let active = this.expandedCommit.codeReview !== null;
		alterClass(btnElem, CLASS_ACTIVE, active);
		btnElem.title = (active ? 'End' : 'Start') + ' Code Review';
	}
}


/* Main */

const contextMenu = new ContextMenu(), dialog = new Dialog(), eventOverlay = new EventOverlay();
let loaded = false;

window.addEventListener('load', () => {
	if (loaded) return;
	loaded = true;

	TextFormatter.registerCustomEmojiMappings(initialState.config.customEmojiShortcodeMappings);

	const viewElem = document.getElementById('view');
	if (viewElem === null) return;

	const gitGraph = new GitGraphView(viewElem, VSCODE_API.getState());
	const imageResizer = new ImageResizer();

	/* Command Processing */
	window.addEventListener('message', event => {
		const msg: GG.ResponseMessage = event.data;
		switch (msg.command) {
			case 'addRemote':
				refreshOrDisplayError(msg.error, 'Unable to Add Remote', true);
				break;
			case 'addTag':
				if (msg.pushToRemote !== null && msg.errors.length === 2 && msg.errors[0] === null && isExtensionErrorInfo(msg.errors[1], GG.ErrorInfoExtensionPrefix.PushTagCommitNotOnRemote)) {
					gitGraph.refresh(false);
					handleResponsePushTagCommitNotOnRemote(msg.repo, msg.tagName, [msg.pushToRemote], msg.commitHash, msg.errors[1]!);
				} else {
					refreshAndDisplayErrors(msg.errors, 'Unable to Add Tag');
				}
				break;
			case 'applyStash':
				refreshOrDisplayError(msg.error, 'Unable to Apply Stash');
				break;
			case 'branchFromStash':
				refreshOrDisplayError(msg.error, 'Unable to Create Branch from Stash');
				break;
			case 'checkoutBranch':
				refreshAndDisplayErrors(msg.errors, 'Unable to Checkout Branch' + (msg.pullAfterwards !== null ? ' & Pull Changes' : ''));
				break;
			case 'checkoutCommit':
				refreshOrDisplayError(msg.error, 'Unable to Checkout Commit');
				break;
			case 'cherrypickCommit':
				refreshAndDisplayErrors(msg.errors, 'Unable to Cherry Pick Commit');
				break;
			case 'cleanUntrackedFiles':
				refreshOrDisplayError(msg.error, 'Unable to Clean Untracked Files');
				break;
			case 'commitDetails':
				if (msg.commitDetails !== null) {
					gitGraph.showCommitDetails(msg.commitDetails, gitGraph.createFileTree(msg.commitDetails.fileChanges, msg.codeReview), msg.avatar, msg.codeReview, msg.codeReview !== null ? msg.codeReview.lastViewedFile : null, msg.refresh);
				} else {
					gitGraph.closeCommitDetails(true);
					dialog.showError('Unable to load Commit Details', msg.error, null, null);
				}
				break;
			case 'compareCommits':
				if (msg.error === null) {
					gitGraph.showCommitComparison(msg.commitHash, msg.compareWithHash, msg.fileChanges, gitGraph.createFileTree(msg.fileChanges, msg.codeReview), msg.codeReview, msg.codeReview !== null ? msg.codeReview.lastViewedFile : null, msg.refresh);
				} else {
					gitGraph.closeCommitComparison(true);
					dialog.showError('Unable to load Commit Comparison', msg.error, null, null);
				}
				break;
			case 'copyFilePath':
				finishOrDisplayError(msg.error, 'Unable to Copy File Path to Clipboard');
				break;
			case 'copyToClipboard':
				finishOrDisplayError(msg.error, 'Unable to Copy ' + msg.type + ' to Clipboard');
				break;
			case 'createArchive':
				finishOrDisplayError(msg.error, 'Unable to Create Archive', true);
				break;
			case 'createBranch':
				refreshAndDisplayErrors(msg.errors, 'Unable to Create Branch');
				break;
			case 'createPullRequest':
				finishOrDisplayErrors(msg.errors, 'Unable to Create Pull Request', () => {
					if (msg.push) {
						gitGraph.refresh(false);
					}
				}, true);
				break;
			case 'deleteBranch':
				handleResponseDeleteBranch(msg);
				break;
			case 'deleteRemote':
				refreshOrDisplayError(msg.error, 'Unable to Delete Remote', true);
				break;
			case 'deleteRemoteBranch':
				refreshOrDisplayError(msg.error, 'Unable to Delete Remote Branch');
				break;
			case 'deleteTag':
				refreshOrDisplayError(msg.error, 'Unable to Delete Tag');
				break;
			case 'deleteUserDetails':
				finishOrDisplayErrors(msg.errors, 'Unable to Remove Git User Details', () => gitGraph.requestLoadConfig(), true);
				break;
			case 'dropCommit':
				refreshOrDisplayError(msg.error, 'Unable to Drop Commit');
				break;
			case 'dropStash':
				refreshOrDisplayError(msg.error, 'Unable to Drop Stash');
				break;
			case 'editRemote':
				refreshOrDisplayError(msg.error, 'Unable to Save Changes to Remote', true);
				break;
			case 'editUserDetails':
				finishOrDisplayErrors(msg.errors, 'Unable to Save Git User Details', () => gitGraph.requestLoadConfig(), true);
				break;
			case 'exportRepoConfig':
				refreshOrDisplayError(msg.error, 'Unable to Export Repository Configuration');
				break;
			case 'fetch':
				refreshOrDisplayError(msg.error, 'Unable to Fetch from Remote(s)');
				break;
			case 'fetchAvatar':
				imageResizer.resize(msg.image, (resizedImage) => {
					gitGraph.loadAvatar(msg.email, resizedImage);
				});
				break;
			case 'fetchIntoLocalBranch':
				refreshOrDisplayError(msg.error, 'Unable to Fetch into Local Branch');
				break;
			case 'loadCommits':
				gitGraph.processLoadCommitsResponse(msg);
				break;
			case 'loadConfig':
				gitGraph.processLoadConfig(msg);
				break;
			case 'loadRepoInfo':
				gitGraph.processLoadRepoInfoResponse(msg);
				break;
			case 'loadRepos':
				gitGraph.loadRepos(msg.repos, msg.lastActiveRepo, msg.loadViewTo);
				break;
			case 'merge':
				refreshOrDisplayError(msg.error, 'Unable to Merge ' + msg.actionOn);
				break;
			case 'openExtensionSettings':
				finishOrDisplayError(msg.error, 'Unable to Open Extension Settings');
				break;
			case 'openExternalDirDiff':
				finishOrDisplayError(msg.error, 'Unable to Open External Directory Diff', true);
				break;
			case 'openExternalUrl':
				finishOrDisplayError(msg.error, 'Unable to Open External URL');
				break;
			case 'openFile':
				finishOrDisplayError(msg.error, 'Unable to Open File');
				break;
			case 'openTerminal':
				finishOrDisplayError(msg.error, 'Unable to Open Terminal', true);
				break;
			case 'popStash':
				refreshOrDisplayError(msg.error, 'Unable to Pop Stash');
				break;
			case 'pruneRemote':
				refreshOrDisplayError(msg.error, 'Unable to Prune Remote');
				break;
			case 'pullBranch':
				refreshOrDisplayError(msg.error, 'Unable to Pull Branch');
				break;
			case 'pushBranch':
				refreshAndDisplayErrors(msg.errors, 'Unable to Push Branch', msg.willUpdateBranchConfig);
				break;
			case 'pushStash':
				refreshOrDisplayError(msg.error, 'Unable to Stash Uncommitted Changes');
				break;
			case 'pushTag':
				if (msg.errors.length === 1 && isExtensionErrorInfo(msg.errors[0], GG.ErrorInfoExtensionPrefix.PushTagCommitNotOnRemote)) {
					handleResponsePushTagCommitNotOnRemote(msg.repo, msg.tagName, msg.remotes, msg.commitHash, msg.errors[0]!);
				} else {
					refreshAndDisplayErrors(msg.errors, 'Unable to Push Tag');
				}
				break;
			case 'rebase':
				if (msg.error === null) {
					if (msg.interactive) {
						dialog.closeActionRunning();
					} else {
						gitGraph.refresh(false);
					}
				} else {
					dialog.showError('Unable to Rebase current branch on ' + msg.actionOn, msg.error, null, null);
				}
				break;
			case 'refresh':
				gitGraph.refresh(false);
				break;
			case 'renameBranch':
				refreshOrDisplayError(msg.error, 'Unable to Rename Branch');
				break;
			case 'resetFileToRevision':
				refreshOrDisplayError(msg.error, 'Unable to Reset File to Revision');
				break;
			case 'resetToCommit':
				refreshOrDisplayError(msg.error, 'Unable to Reset to Commit');
				break;
			case 'revertCommit':
				refreshOrDisplayError(msg.error, 'Unable to Revert Commit');
				break;
			case 'setGlobalViewState':
				finishOrDisplayError(msg.error, 'Unable to save the Global View State');
				break;
			case 'setWorkspaceViewState':
				finishOrDisplayError(msg.error, 'Unable to save the Workspace View State');
				break;
			case 'startCodeReview':
				if (msg.error === null) {
					gitGraph.startCodeReview(msg.commitHash, msg.compareWithHash, msg.codeReview);
				} else {
					dialog.showError('Unable to Start Code Review', msg.error, null, null);
				}
				break;
			case 'tagDetails':
				if (msg.details !== null) {
					gitGraph.renderTagDetails(msg.tagName, msg.commitHash, msg.details);
				} else {
					dialog.showError('Unable to retrieve Tag Details', msg.error, null, null);
				}
				break;
			case 'updateCodeReview':
				if (msg.error !== null) {
					dialog.showError('Unable to update Code Review', msg.error, null, null);
				}
				break;
			case 'viewDiff':
				finishOrDisplayError(msg.error, 'Unable to View Diff');
				break;
			case 'viewDiffWithWorkingFile':
				finishOrDisplayError(msg.error, 'Unable to View Diff with Working File');
				break;
			case 'viewFileAtRevision':
				finishOrDisplayError(msg.error, 'Unable to View File at Revision');
				break;
			case 'viewScm':
				finishOrDisplayError(msg.error, 'Unable to open the Source Control View');
				break;
		}
	});

	function handleResponseDeleteBranch(msg: GG.ResponseDeleteBranch) {
		if (msg.errors.length > 0 && msg.errors[0] !== null && msg.errors[0].includes('git branch -D')) {
			dialog.showConfirmation('The branch <b><i>' + escapeHtml(msg.branchName) + '</i></b> is not fully merged. Would you like to force delete it?', 'Yes, force delete branch', () => {
				runAction({ command: 'deleteBranch', repo: msg.repo, branchName: msg.branchName, forceDelete: true, deleteOnRemotes: msg.deleteOnRemotes }, 'Deleting Branch');
			}, { type: TargetType.Repo });
		} else {
			refreshAndDisplayErrors(msg.errors, 'Unable to Delete Branch');
		}
	}

	function handleResponsePushTagCommitNotOnRemote(repo: string, tagName: string, remotes: string[], commitHash: string, error: string) {
		const remotesNotContainingCommit: string[] = parseExtensionErrorInfo(error, GG.ErrorInfoExtensionPrefix.PushTagCommitNotOnRemote);

		const html = '<span class="dialogAlert">' + SVG_ICONS.alert + 'Warning: Commit is not on Remote' + (remotesNotContainingCommit.length > 1 ? 's ' : ' ') + '</span><br>' +
			'<span class="messageContent">' +
			'<p style="margin:0 0 6px 0;">The tag <b><i>' + escapeHtml(tagName) + '</i></b> is on a commit that isn\'t on any known branch on the remote' + (remotesNotContainingCommit.length > 1 ? 's' : '') + ' ' + formatCommaSeparatedList(remotesNotContainingCommit.map((remote) => '<b><i>' + escapeHtml(remote) + '</i></b>')) + '.</p>' +
			'<p style="margin:0;">Would you like to proceed to push the tag to the remote' + (remotes.length > 1 ? 's' : '') + ' ' + formatCommaSeparatedList(remotes.map((remote) => '<b><i>' + escapeHtml(remote) + '</i></b>')) + ' anyway?</p>' +
			'</span>';

		dialog.showForm(html, [{ type: DialogInputType.Checkbox, name: 'Always Proceed', value: false }], 'Proceed to Push', (values) => {
			if (<boolean>values[0]) {
				updateGlobalViewState('pushTagSkipRemoteCheck', true);
			}
			runAction({
				command: 'pushTag',
				repo: repo,
				tagName: tagName,
				remotes: remotes,
				commitHash: commitHash,
				skipRemoteCheck: true
			}, 'Pushing Tag');
		}, { type: TargetType.Repo }, 'Cancel', null, true);
	}

	function refreshOrDisplayError(error: GG.ErrorInfo, errorMessage: string, configChanges: boolean = false) {
		if (error === null) {
			gitGraph.refresh(false, configChanges);
		} else {
			dialog.showError(errorMessage, error, null, null);
		}
	}

	function refreshAndDisplayErrors(errors: GG.ErrorInfo[], errorMessage: string, configChanges: boolean = false) {
		const reducedErrors = reduceErrorInfos(errors);
		if (reducedErrors.error !== null) {
			dialog.showError(errorMessage, reducedErrors.error, null, null);
		}
		if (reducedErrors.partialOrCompleteSuccess) {
			gitGraph.refresh(false, configChanges);
		} else if (configChanges) {
			gitGraph.requestLoadConfig();
		}
	}

	function finishOrDisplayError(error: GG.ErrorInfo, errorMessage: string, dismissActionRunning: boolean = false) {
		if (error !== null) {
			dialog.showError(errorMessage, error, null, null);
		} else if (dismissActionRunning) {
			dialog.closeActionRunning();
		}
	}

	function finishOrDisplayErrors(errors: GG.ErrorInfo[], errorMessage: string, partialOrCompleteSuccessCallback: () => void, dismissActionRunning: boolean = false) {
		const reducedErrors = reduceErrorInfos(errors);
		finishOrDisplayError(reducedErrors.error, errorMessage, dismissActionRunning);
		if (reducedErrors.partialOrCompleteSuccess) {
			partialOrCompleteSuccessCallback();
		}
	}

	function reduceErrorInfos(errors: GG.ErrorInfo[]) {
		let error: GG.ErrorInfo = null, partialOrCompleteSuccess = false;
		for (let i = 0; i < errors.length; i++) {
			if (errors[i] !== null) {
				error = error !== null ? error + '\n\n' + errors[i] : errors[i];
			} else {
				partialOrCompleteSuccess = true;
			}
		}

		return {
			error: error,
			partialOrCompleteSuccess: partialOrCompleteSuccess
		};
	}

	/**
	 * Checks whether the given ErrorInfo has an ErrorInfoExtensionPrefix.
	 * @param error The ErrorInfo to check.
	 * @param prefix The ErrorInfoExtensionPrefix to test.
	 * @returns TRUE => ErrorInfo has the ErrorInfoExtensionPrefix, FALSE => ErrorInfo doesn\'t have the ErrorInfoExtensionPrefix
	 */
	function isExtensionErrorInfo(error: GG.ErrorInfo, prefix: GG.ErrorInfoExtensionPrefix) {
		return error !== null && error.startsWith(prefix);
	}

	/**
	 * Parses the JSON data from an ErrorInfo prefixed by the provided ErrorInfoExtensionPrefix.
	 * @param error The ErrorInfo to parse.
	 * @param prefix The ErrorInfoExtensionPrefix used by `error`.
	 * @returns The parsed JSON data.
	 */
	function parseExtensionErrorInfo(error: string, prefix: GG.ErrorInfoExtensionPrefix) {
		return JSON.parse(error.substring(prefix.length));
	}
});


/* File Tree Methods (for the Commit Details & Comparison Views) */

function generateFileViewHtml(folder: FileTreeFolder, gitFiles: ReadonlyArray<GG.GitFileChange>, lastViewedFile: string | null, fileContextMenuOpen: number, type: GG.FileViewType, isUncommitted: boolean) {
	return type === GG.FileViewType.List
		? generateFileListHtml(folder, gitFiles, lastViewedFile, fileContextMenuOpen, isUncommitted)
		: generateFileTreeHtml(folder, gitFiles, lastViewedFile, fileContextMenuOpen, isUncommitted, true);
}

function generateFileTreeHtml(folder: FileTreeFolder, gitFiles: ReadonlyArray<GG.GitFileChange>, lastViewedFile: string | null, fileContextMenuOpen: number, isUncommitted: boolean, topLevelFolder: boolean): string {
	const curFolderInfo = topLevelFolder || !initialState.config.commitDetailsView.fileTreeCompactFolders
		? { folder: folder, name: folder.name, pathSeg: folder.name }
		: getCurrentFolderInfo(folder, folder.name, folder.name);

	const children = sortFolderKeys(curFolderInfo.folder).map((key) => {
		const cur = curFolderInfo.folder.contents[key];
		return cur.type === 'folder'
			? generateFileTreeHtml(cur, gitFiles, lastViewedFile, fileContextMenuOpen, isUncommitted, false)
			: generateFileTreeLeafHtml(cur.name, cur, gitFiles, lastViewedFile, fileContextMenuOpen, isUncommitted);
	});

	return (topLevelFolder ? '' : '<li' + (curFolderInfo.folder.open ? '' : ' class="closed"') + ' data-pathseg="' + encodeURIComponent(curFolderInfo.pathSeg) + '"><span class="fileTreeFolder' + (curFolderInfo.folder.reviewed ? '' : ' pendingReview') + '" title="./' + escapeHtml(curFolderInfo.folder.folderPath) + '" data-folderpath="' + encodeURIComponent(curFolderInfo.folder.folderPath) + '"><span class="fileTreeFolderIcon">' + (curFolderInfo.folder.open ? SVG_ICONS.openFolder : SVG_ICONS.closedFolder) + '</span><span class="gitFolderName">' + escapeHtml(curFolderInfo.name) + '</span></span>') +
		'<ul class="fileTreeFolderContents' + (curFolderInfo.folder.open ? '' : ' hidden') + '">' + children.join('') + '</ul>' +
		(topLevelFolder ? '' : '</li>');
}

function getCurrentFolderInfo(folder: FileTreeFolder, name: string, pathSeg: string): { folder: FileTreeFolder, name: string, pathSeg: string } {
	const keys = Object.keys(folder.contents);
	let child: FileTreeNode;
	return keys.length === 1 && (child = folder.contents[keys[0]]).type === 'folder'
		? getCurrentFolderInfo(<FileTreeFolder>child, name + ' / ' + child.name, pathSeg + '/' + child.name)
		: { folder: folder, name: name, pathSeg: pathSeg };
}

function generateFileListHtml(folder: FileTreeFolder, gitFiles: ReadonlyArray<GG.GitFileChange>, lastViewedFile: string | null, fileContextMenuOpen: number, isUncommitted: boolean) {
	const sortLeaves = (folder: FileTreeFolder, folderPath: string) => {
		let keys = sortFolderKeys(folder);
		let items: { relPath: string, leaf: FileTreeLeaf }[] = [];
		for (let i = 0; i < keys.length; i++) {
			let cur = folder.contents[keys[i]];
			let relPath = (folderPath !== '' ? folderPath + '/' : '') + cur.name;
			if (cur.type === 'folder') {
				items = items.concat(sortLeaves(cur, relPath));
			} else {
				items.push({ relPath: relPath, leaf: cur });
			}
		}
		return items;
	};
	let sortedLeaves = sortLeaves(folder, '');
	let html = '';
	for (let i = 0; i < sortedLeaves.length; i++) {
		html += generateFileTreeLeafHtml(sortedLeaves[i].relPath, sortedLeaves[i].leaf, gitFiles, lastViewedFile, fileContextMenuOpen, isUncommitted);
	}
	return '<ul class="fileTreeFolderContents">' + html + '</ul>';
}

function generateFileTreeLeafHtml(name: string, leaf: FileTreeLeaf, gitFiles: ReadonlyArray<GG.GitFileChange>, lastViewedFile: string | null, fileContextMenuOpen: number, isUncommitted: boolean) {
	let encodedName = encodeURIComponent(name), escapedName = escapeHtml(name);
	if (leaf.type === 'file') {
		const fileTreeFile = gitFiles[leaf.index];
		const textFile = fileTreeFile.additions !== null && fileTreeFile.deletions !== null;
		const diffPossible = fileTreeFile.type === GG.GitFileStatus.Untracked || textFile;
		const changeTypeMessage = GIT_FILE_CHANGE_TYPES[fileTreeFile.type] + (fileTreeFile.type === GG.GitFileStatus.Renamed ? ' (' + escapeHtml(fileTreeFile.oldFilePath) + '  ' + escapeHtml(fileTreeFile.newFilePath) + ')' : '');
		return '<li data-pathseg="' + encodedName + '"><span class="fileTreeFileRecord' + (leaf.index === fileContextMenuOpen ? ' ' + CLASS_CONTEXT_MENU_ACTIVE : '') + '" data-index="' + leaf.index + '"><span class="fileTreeFile' + (diffPossible ? ' gitDiffPossible' : '') + (leaf.reviewed ? '' : ' ' + CLASS_PENDING_REVIEW) + '" title="' + (diffPossible ? 'Click to View Diff' : 'Unable to View Diff' + (fileTreeFile.type !== GG.GitFileStatus.Deleted ? ' (this is a binary file)' : '')) + '  ' + changeTypeMessage + '"><span class="fileTreeFileIcon">' + SVG_ICONS.file + '</span><span class="gitFileName ' + fileTreeFile.type + '">' + escapedName + '</span></span>' +
			(initialState.config.enhancedAccessibility ? '<span class="fileTreeFileType" title="' + changeTypeMessage + '">' + fileTreeFile.type + '</span>' : '') +
			(fileTreeFile.type !== GG.GitFileStatus.Added && fileTreeFile.type !== GG.GitFileStatus.Untracked && fileTreeFile.type !== GG.GitFileStatus.Deleted && textFile ? '<span class="fileTreeFileAddDel">(<span class="fileTreeFileAdd" title="' + fileTreeFile.additions + ' addition' + (fileTreeFile.additions !== 1 ? 's' : '') + '">+' + fileTreeFile.additions + '</span>|<span class="fileTreeFileDel" title="' + fileTreeFile.deletions + ' deletion' + (fileTreeFile.deletions !== 1 ? 's' : '') + '">-' + fileTreeFile.deletions + '</span>)</span>' : '') +
			(fileTreeFile.newFilePath === lastViewedFile ? '<span id="cdvLastFileViewed" title="Last File Viewed">' + SVG_ICONS.eyeOpen + '</span>' : '') +
			'<span class="copyGitFile fileTreeFileAction" title="Copy Absolute File Path to Clipboard">' + SVG_ICONS.copy + '</span>' +
			(fileTreeFile.type !== GG.GitFileStatus.Deleted
				? (diffPossible && !isUncommitted ? '<span class="viewGitFileAtRevision fileTreeFileAction" title="View File at this Revision">' + SVG_ICONS.commit + '</span>' : '') +
				'<span class="openGitFile fileTreeFileAction" title="Open File">' + SVG_ICONS.openFile + '</span>'
				: ''
			) + '</span></li>';
	} else {
		return '<li data-pathseg="' + encodedName + '"><span class="fileTreeRepo" data-path="' + encodeURIComponent(leaf.path) + '" title="Click to View Repository"><span class="fileTreeRepoIcon">' + SVG_ICONS.closedFolder + '</span>' + escapedName + '</span></li>';
	}
}

function alterFileTreeFolderOpen(folder: FileTreeFolder, folderPath: string, open: boolean) {
	let path = folderPath.split('/'), i, cur = folder;
	for (i = 0; i < path.length; i++) {
		if (typeof cur.contents[path[i]] !== 'undefined') {
			cur = <FileTreeFolder>cur.contents[path[i]];
			if (i === path.length - 1) cur.open = open;
		} else {
			return;
		}
	}
}

function alterFileTreeFileReviewed(folder: FileTreeFolder, filePath: string, reviewed: boolean) {
	let path = filePath.split('/'), i, cur = folder, folders = [folder];
	for (i = 0; i < path.length; i++) {
		if (typeof cur.contents[path[i]] !== 'undefined') {
			if (i < path.length - 1) {
				cur = <FileTreeFolder>cur.contents[path[i]];
				folders.push(cur);
			} else {
				(<FileTreeFile>cur.contents[path[i]]).reviewed = reviewed;
			}
		} else {
			break;
		}
	}

	// Recalculate whether each of the folders leading to the file are now reviewed (deepest first).
	for (i = folders.length - 1; i >= 0; i--) {
		let keys = Object.keys(folders[i].contents), entireFolderReviewed = true;
		for (let j = 0; j < keys.length; j++) {
			let cur = folders[i].contents[keys[j]];
			if ((cur.type === 'folder' || cur.type === 'file') && !cur.reviewed) {
				entireFolderReviewed = false;
				break;
			}
		}
		folders[i].reviewed = entireFolderReviewed;
	}
}

function setFileTreeReviewed(folder: FileTreeFolder, reviewed: boolean) {
	folder.reviewed = reviewed;
	let keys = Object.keys(folder.contents);
	for (let i = 0; i < keys.length; i++) {
		let cur = folder.contents[keys[i]];
		if (cur.type === 'folder') {
			setFileTreeReviewed(cur, reviewed);
		} else if (cur.type === 'file') {
			cur.reviewed = reviewed;
		}
	}
}

function calcFileTreeFoldersReviewed(folder: FileTreeFolder) {
	const calc = (folder: FileTreeFolder) => {
		let reviewed = true;
		let keys = Object.keys(folder.contents);
		for (let i = 0; i < keys.length; i++) {
			let cur = folder.contents[keys[i]];
			if ((cur.type === 'folder' && !calc(cur)) || (cur.type === 'file' && !cur.reviewed)) reviewed = false;
		}
		folder.reviewed = reviewed;
		return reviewed;
	};
	calc(folder);
}

function updateFileTreeHtml(elem: HTMLElement, folder: FileTreeFolder) {
	let ul = getChildUl(elem);
	if (ul === null) return;

	for (let i = 0; i < ul.children.length; i++) {
		let li = <HTMLLIElement>ul.children[i];
		let pathSeg = decodeURIComponent(li.dataset.pathseg!);
		let child = getChildByPathSegment(folder, pathSeg);
		if (child.type === 'folder') {
			alterClass(<HTMLSpanElement>li.children[0], CLASS_PENDING_REVIEW, !child.reviewed);
			updateFileTreeHtml(li, child);
		} else if (child.type === 'file') {
			alterClass(<HTMLSpanElement>li.children[0].children[0], CLASS_PENDING_REVIEW, !child.reviewed);
		}
	}
}

function updateFileTreeHtmlFileReviewed(elem: HTMLElement, folder: FileTreeFolder, filePath: string) {
	let path = filePath;
	const update = (elem: HTMLElement, folder: FileTreeFolder) => {
		let ul = getChildUl(elem);
		if (ul === null) return;

		for (let i = 0; i < ul.children.length; i++) {
			let li = <HTMLLIElement>ul.children[i];
			let pathSeg = decodeURIComponent(li.dataset.pathseg!);
			if (path === pathSeg || path.startsWith(pathSeg + '/')) {
				let child = getChildByPathSegment(folder, pathSeg);
				if (child.type === 'folder') {
					alterClass(<HTMLSpanElement>li.children[0], CLASS_PENDING_REVIEW, !child.reviewed);
					path = path.substring(pathSeg.length + 1);
					update(li, child);
				} else if (child.type === 'file') {
					alterClass(<HTMLSpanElement>li.children[0].children[0], CLASS_PENDING_REVIEW, !child.reviewed);
				}
				break;
			}
		}
	};
	update(elem, folder);
}

function getFilesInTree(folder: FileTreeFolder, gitFiles: ReadonlyArray<GG.GitFileChange>) {
	let files: string[] = [];
	const scanFolder = (folder: FileTreeFolder) => {
		let keys = Object.keys(folder.contents);
		for (let i = 0; i < keys.length; i++) {
			let cur = folder.contents[keys[i]];
			if (cur.type === 'folder') {
				scanFolder(cur);
			} else if (cur.type === 'file') {
				files.push(gitFiles[cur.index].newFilePath);
			}
		}
	};
	scanFolder(folder);
	return files;
}

function sortFolderKeys(folder: FileTreeFolder) {
	let keys = Object.keys(folder.contents);
	keys.sort((a, b) => folder.contents[a].type !== 'file' && folder.contents[b].type === 'file' ? -1 : folder.contents[a].type === 'file' && folder.contents[b].type !== 'file' ? 1 : folder.contents[a].name.localeCompare(folder.contents[b].name));
	return keys;
}

function getChildByPathSegment(folder: FileTreeFolder, pathSeg: string) {
	let cur: FileTreeNode = folder, comps = pathSeg.split('/');
	for (let i = 0; i < comps.length; i++) {
		cur = (<FileTreeFolder>cur).contents[comps[i]];
	}
	return cur;
}


/* Repository State Helpers */

function getCommitOrdering(repoValue: GG.RepoCommitOrdering): GG.CommitOrdering {
	switch (repoValue) {
		case GG.RepoCommitOrdering.Default:
			return initialState.config.commitOrdering;
		case GG.RepoCommitOrdering.Date:
			return GG.CommitOrdering.Date;
		case GG.RepoCommitOrdering.AuthorDate:
			return GG.CommitOrdering.AuthorDate;
		case GG.RepoCommitOrdering.Topological:
			return GG.CommitOrdering.Topological;
	}
}

function getShowRemoteBranches(repoValue: GG.BooleanOverride) {
	return repoValue === GG.BooleanOverride.Default
		? initialState.config.showRemoteBranches
		: repoValue === GG.BooleanOverride.Enabled;
}

function getShowStashes(repoValue: GG.BooleanOverride) {
	return repoValue === GG.BooleanOverride.Default
		? initialState.config.showStashes
		: repoValue === GG.BooleanOverride.Enabled;
}

function getShowTags(repoValue: GG.BooleanOverride) {
	return repoValue === GG.BooleanOverride.Default
		? initialState.config.showTags
		: repoValue === GG.BooleanOverride.Enabled;
}

function getIncludeCommitsMentionedByReflogs(repoValue: GG.BooleanOverride) {
	return repoValue === GG.BooleanOverride.Default
		? initialState.config.includeCommitsMentionedByReflogs
		: repoValue === GG.BooleanOverride.Enabled;
}

function getOnlyFollowFirstParent(repoValue: GG.BooleanOverride) {
	return repoValue === GG.BooleanOverride.Default
		? initialState.config.onlyFollowFirstParent
		: repoValue === GG.BooleanOverride.Enabled;
}

function getOnRepoLoadShowCheckedOutBranch(repoValue: GG.BooleanOverride) {
	return repoValue === GG.BooleanOverride.Default
		? initialState.config.onRepoLoad.showCheckedOutBranch
		: repoValue === GG.BooleanOverride.Enabled;
}

function getOnRepoLoadShowSpecificBranches(repoValue: string[] | null) {
	return repoValue === null
		? initialState.config.onRepoLoad.showSpecificBranches
		: repoValue;
}


/* Miscellaneous Helper Methods */

function haveFilesChanged(oldFiles: ReadonlyArray<GG.GitFileChange> | null, newFiles: ReadonlyArray<GG.GitFileChange> | null) {
	if ((oldFiles === null) !== (newFiles === null)) {
		return true;
	} else if (oldFiles === null && newFiles === null) {
		return false;
	} else {
		return !arraysEqual(oldFiles!, newFiles!, (a, b) => a.additions === b.additions && a.deletions === b.deletions && a.newFilePath === b.newFilePath && a.oldFilePath === b.oldFilePath && a.type === b.type);
	}
}

function abbrevCommit(commitHash: string) {
	return commitHash.substring(0, 8);
}

function getRepoDropdownOptions(repos: Readonly<GG.GitRepoSet>) {
	const repoPaths = getSortedRepositoryPaths(repos, initialState.config.repoDropdownOrder);
	const paths: string[] = [], names: string[] = [], distinctNames: string[] = [], firstSep: number[] = [];
	const resolveAmbiguous = (indexes: number[]) => {
		// Find ambiguous names within indexes
		let firstOccurrence: { [name: string]: number } = {}, ambiguous: { [name: string]: number[] } = {};
		for (let i = 0; i < indexes.length; i++) {
			let name = distinctNames[indexes[i]];
			if (typeof firstOccurrence[name] === 'number') {
				// name is ambiguous
				if (typeof ambiguous[name] === 'undefined') {
					// initialise ambiguous array with the first occurrence
					ambiguous[name] = [firstOccurrence[name]];
				}
				ambiguous[name].push(indexes[i]); // append current ambiguous index
			} else {
				firstOccurrence[name] = indexes[i]; // set the first occurrence of the name
			}
		}

		let ambiguousNames = Object.keys(ambiguous);
		for (let i = 0; i < ambiguousNames.length; i++) {
			// For each ambiguous name, resolve the ambiguous indexes
			let ambiguousIndexes = ambiguous[ambiguousNames[i]], retestIndexes = [];
			for (let j = 0; j < ambiguousIndexes.length; j++) {
				let ambiguousIndex = ambiguousIndexes[j];
				let nextSep = paths[ambiguousIndex].lastIndexOf('/', paths[ambiguousIndex].length - distinctNames[ambiguousIndex].length - 2);
				if (firstSep[ambiguousIndex] < nextSep) {
					// prepend the addition path and retest
					distinctNames[ambiguousIndex] = paths[ambiguousIndex].substring(nextSep + 1);
					retestIndexes.push(ambiguousIndex);
				} else {
					distinctNames[ambiguousIndex] = paths[ambiguousIndex];
				}
			}
			if (retestIndexes.length > 1) {
				// If there are 2 or more indexes that may be ambiguous
				resolveAmbiguous(retestIndexes);
			}
		}
	};

	// Initialise recursion
	const indexes = [];
	for (let i = 0; i < repoPaths.length; i++) {
		firstSep.push(repoPaths[i].indexOf('/'));
		const repo = repos[repoPaths[i]];
		if (repo.name) {
			// A name has been set for the repository
			paths.push(repoPaths[i]);
			names.push(repo.name);
			distinctNames.push(repo.name);
		} else if (firstSep[i] === repoPaths[i].length - 1 || firstSep[i] === -1) {
			// Path has no slashes, or a single trailing slash ==> use the path as the name
			paths.push(repoPaths[i]);
			names.push(repoPaths[i]);
			distinctNames.push(repoPaths[i]);
		} else {
			paths.push(repoPaths[i].endsWith('/') ? repoPaths[i].substring(0, repoPaths[i].length - 1) : repoPaths[i]); // Remove trailing slash if it exists
			let name = paths[i].substring(paths[i].lastIndexOf('/') + 1);
			names.push(name);
			distinctNames.push(name);
			indexes.push(i);
		}
	}
	resolveAmbiguous(indexes);

	const options: DropdownOption[] = [];
	for (let i = 0; i < repoPaths.length; i++) {
		let hint;
		if (names[i] === distinctNames[i]) {
			// Name is distinct, no hint needed
			hint = '';
		} else {
			// Hint path is the prefix of the distinctName before the common suffix with name
			let hintPath = distinctNames[i].substring(0, distinctNames[i].length - names[i].length - 1);

			// Keep two informative directories
			let hintComps = hintPath.split('/');
			let keepDirs = hintComps[0] !== '' ? 2 : 3;
			if (hintComps.length > keepDirs) hintComps.splice(keepDirs, hintComps.length - keepDirs, '...');

			// Construct the hint
			hint = (distinctNames[i] !== paths[i] ? '.../' : '') + hintComps.join('/');
		}
		options.push({ name: names[i], value: repoPaths[i], hint: hint });
	}
	return options;
}

function runAction(msg: GG.RequestMessage, action: string) {
	dialog.showActionRunning(action);
	sendMessage(msg);
}

function getBranchLabels(heads: ReadonlyArray<string>, remotes: ReadonlyArray<GG.GitCommitRemote>) {
	let headLabels: { name: string; remotes: string[] }[] = [], headLookup: { [name: string]: number } = {}, remoteLabels: ReadonlyArray<GG.GitCommitRemote>;
	for (let i = 0; i < heads.length; i++) {
		headLabels.push({ name: heads[i], remotes: [] });
		headLookup[heads[i]] = i;
	}
	if (initialState.config.referenceLabels.combineLocalAndRemoteBranchLabels) {
		let remainingRemoteLabels = [];
		for (let i = 0; i < remotes.length; i++) {
			if (remotes[i].remote !== null) { // If the remote of the remote branch ref is known
				let branchName = remotes[i].name.substring(remotes[i].remote!.length + 1);
				if (typeof headLookup[branchName] === 'number') {
					headLabels[headLookup[branchName]].remotes.push(remotes[i].remote!);
					continue;
				}
			}
			remainingRemoteLabels.push(remotes[i]);
		}
		remoteLabels = remainingRemoteLabels;
	} else {
		remoteLabels = remotes;
	}
	return { heads: headLabels, remotes: remoteLabels };
}

function findCommitElemWithId(elems: HTMLCollectionOf<HTMLElement>, id: number | null) {
	if (id === null) return null;
	let findIdStr = id.toString();
	for (let i = 0; i < elems.length; i++) {
		if (findIdStr === elems[i].dataset.id) return elems[i];
	}
	return null;
}

function generateSignatureHtml(signature: GG.GitSignature) {
	return '<span class="signatureInfo ' + signature.status + '" title="' + GIT_SIGNATURE_STATUS_DESCRIPTIONS[signature.status] + ':'
		+ ' Signed by ' + escapeHtml(signature.signer !== '' ? signature.signer : '<Unknown>')
		+ ' (GPG Key Id: ' + escapeHtml(signature.key !== '' ? signature.key : '<Unknown>') + ')">'
		+ (signature.status === GG.GitSignatureStatus.GoodAndValid
			? SVG_ICONS.passed
			: signature.status === GG.GitSignatureStatus.Bad
				? SVG_ICONS.failed
				: SVG_ICONS.inconclusive)
		+ '</span>';
}

function closeDialogAndContextMenu() {
	if (dialog.isOpen()) dialog.close();
	if (contextMenu.isOpen()) contextMenu.close();
}
-e 

================================================================================
// FILE: ./web/findWidget.ts
================================================================================
const CLASS_FIND_CURRENT_COMMIT = 'findCurrentCommit';
const CLASS_FIND_MATCH = 'findMatch';

interface FindWidgetState {
	readonly text: string;
	readonly currentHash: string | null;
	readonly visible: boolean;
}

/**
 * Implements the Git Graph View's Find Widget.
 */
class FindWidget {
	private readonly view: GitGraphView;
	private text: string = '';
	private matches: { hash: string, elem: HTMLElement }[] = [];
	private position: number = -1;
	private visible: boolean = false;

	private readonly widgetElem: HTMLElement;
	private readonly inputElem: HTMLInputElement;
	private readonly caseSensitiveElem: HTMLElement;
	private readonly regexElem: HTMLElement;
	private readonly positionElem: HTMLElement;
	private readonly prevElem: HTMLElement;
	private readonly nextElem: HTMLElement;

	/**
	 * Construct a new FindWidget instance.
	 * @param view The Git Graph View that the FindWidget is for.
	 * @returns The FindWidget instance.
	 */
	constructor(view: GitGraphView) {
		this.view = view;
		this.widgetElem = document.createElement('div');
		this.widgetElem.className = 'findWidget';
		this.widgetElem.innerHTML = '<input id="findInput" type="text" placeholder="Find" disabled/><span id="findCaseSensitive" class="findModifier" title="Match Case">Aa</span><span id="findRegex" class="findModifier" title="Use Regular Expression">.*</span><span id="findPosition"></span><span id="findPrev" title="Previous match (Shift+Enter)"></span><span id="findNext" title="Next match (Enter)"></span><span id="findOpenCdv" title="Open the Commit Details View for the current match"></span><span id="findClose" title="Close (Escape)"></span>';
		document.body.appendChild(this.widgetElem);

		this.inputElem = <HTMLInputElement>document.getElementById('findInput')!;
		let keyupTimeout: NodeJS.Timer | null = null;
		this.inputElem.addEventListener('keyup', (e) => {
			if ((e.keyCode ? e.keyCode === 13 : e.key === 'Enter') && this.text !== '') {
				if (e.shiftKey) {
					this.prev();
				} else {
					this.next();
				}
				handledEvent(e);
			} else {
				if (keyupTimeout !== null) clearTimeout(keyupTimeout);
				keyupTimeout = setTimeout(() => {
					keyupTimeout = null;
					if (this.text !== this.inputElem.value) {
						this.text = this.inputElem.value;
						this.clearMatches();
						this.findMatches(this.getCurrentHash(), true);
						this.openCommitDetailsViewForCurrentMatchIfEnabled();
					}
				}, 200);
			}
		});

		this.caseSensitiveElem = document.getElementById('findCaseSensitive')!;
		alterClass(this.caseSensitiveElem, CLASS_ACTIVE, workspaceState.findIsCaseSensitive);
		this.caseSensitiveElem.addEventListener('click', () => {
			updateWorkspaceViewState('findIsCaseSensitive', !workspaceState.findIsCaseSensitive);
			alterClass(this.caseSensitiveElem, CLASS_ACTIVE, workspaceState.findIsCaseSensitive);
			this.clearMatches();
			this.findMatches(this.getCurrentHash(), true);
			this.openCommitDetailsViewForCurrentMatchIfEnabled();
		});

		this.regexElem = document.getElementById('findRegex')!;
		alterClass(this.regexElem, CLASS_ACTIVE, workspaceState.findIsRegex);
		this.regexElem.addEventListener('click', () => {
			updateWorkspaceViewState('findIsRegex', !workspaceState.findIsRegex);
			alterClass(this.regexElem, CLASS_ACTIVE, workspaceState.findIsRegex);
			this.clearMatches();
			this.findMatches(this.getCurrentHash(), true);
			this.openCommitDetailsViewForCurrentMatchIfEnabled();
		});

		this.positionElem = document.getElementById('findPosition')!;

		this.prevElem = document.getElementById('findPrev')!;
		this.prevElem.classList.add(CLASS_DISABLED);
		this.prevElem.innerHTML = SVG_ICONS.arrowUp;
		this.prevElem.addEventListener('click', () => this.prev());

		this.nextElem = document.getElementById('findNext')!;
		this.nextElem.classList.add(CLASS_DISABLED);
		this.nextElem.innerHTML = SVG_ICONS.arrowDown;
		this.nextElem.addEventListener('click', () => this.next());

		const openCdvElem = document.getElementById('findOpenCdv')!;
		openCdvElem.innerHTML = SVG_ICONS.cdv;
		alterClass(openCdvElem, CLASS_ACTIVE, workspaceState.findOpenCommitDetailsView);
		openCdvElem.addEventListener('click', () => {
			updateWorkspaceViewState('findOpenCommitDetailsView', !workspaceState.findOpenCommitDetailsView);
			alterClass(openCdvElem, CLASS_ACTIVE, workspaceState.findOpenCommitDetailsView);
			this.openCommitDetailsViewForCurrentMatchIfEnabled();
		});

		const findCloseElem = document.getElementById('findClose')!;
		findCloseElem.innerHTML = SVG_ICONS.close;
		findCloseElem.addEventListener('click', () => this.close());
	}

	/**
	 * Show the Find Widget.
	 * @param transition Should the Find Widget animate when becoming visible (sliding down).
	 */
	public show(transition: boolean) {
		if (!this.visible) {
			this.visible = true;
			this.inputElem.value = this.text;
			this.inputElem.disabled = false;
			this.updatePosition(-1, false);
			alterClass(this.widgetElem, CLASS_TRANSITION, transition);
			this.widgetElem.classList.add(CLASS_ACTIVE);
		}
		this.inputElem.focus();
	}

	/**
	 * Close the Find Widget, sliding it up out of view.
	 */
	public close() {
		if (!this.visible) return;
		this.visible = false;
		this.widgetElem.classList.add(CLASS_TRANSITION);
		this.widgetElem.classList.remove(CLASS_ACTIVE);
		this.clearMatches();
		this.text = '';
		this.matches = [];
		this.position = -1;
		this.inputElem.value = this.text;
		this.inputElem.disabled = true;
		this.widgetElem.removeAttribute(ATTR_ERROR);
		this.prevElem.classList.add(CLASS_DISABLED);
		this.nextElem.classList.add(CLASS_DISABLED);
		this.view.saveState();
	}

	/**
	 * Refresh the Find Widget's state / matches after the commits have changed.
	 */
	public refresh() {
		if (this.visible) {
			this.findMatches(this.getCurrentHash(), false);
		}
	}

	/**
	 * Set the colours used to indicate the find matches.
	 * @param colour The base colour for the find matches.
	 */
	public setColour(colour: string) {
		document.body.style.setProperty('--git-graph-findMatch', colour);
		document.body.style.setProperty('--git-graph-findMatchCommit', modifyColourOpacity(colour, 0.5));
	}


	/* State */

	/**
	 * Get the current state of the Find Widget.
	 */
	public getState(): FindWidgetState {
		return {
			text: this.text,
			currentHash: this.getCurrentHash(),
			visible: this.visible
		};
	}

	/**
	 * Get the commit hash of the current find match.
	 * @returns The commit hash, or NULL if no commit is currently matched.
	 */
	public getCurrentHash() {
		return this.position > -1 ? this.matches[this.position].hash : null;
	}

	/**
	 * Restore the Find Widget to an existing state.
	 * @param state The previous Find Widget state.
	 */
	public restoreState(state: FindWidgetState) {
		if (!state.visible) return;
		this.text = state.text;
		this.show(false);
		if (this.text !== '') this.findMatches(state.currentHash, false);
	}

	/**
	 * Is the Find Widget currently visible.
	 * @returns TRUE => The Find Widget is visible, FALSE => The Find Widget is not visible
	 */
	public isVisible() {
		return this.visible;
	}


	/* Matching */

	/**
	 * Find all matches based on the user's criteria.
	 * @param goToCommitHash If this commit hash matches the criteria, directly go to this commit instead of starting at the first match.
	 * @param scrollToCommit Should the resultant find match be scrolled to (so it's visible in the view).
	 */
	private findMatches(goToCommitHash: string | null, scrollToCommit: boolean) {
		this.matches = [];
		this.position = -1;

		if (this.text !== '') {
			let colVisibility = this.view.getColumnVisibility(), findPattern: RegExp | null, findGlobalPattern: RegExp | null;
			const regexText = workspaceState.findIsRegex ? this.text : this.text.replace(/[\\\[\](){}|.*+?^$]/g, '\\$&'), flags = 'u' + (workspaceState.findIsCaseSensitive ? '' : 'i');
			try {
				findPattern = new RegExp(regexText, flags);
				findGlobalPattern = new RegExp(regexText, 'g' + flags);
				this.widgetElem.removeAttribute(ATTR_ERROR);
			} catch (e) {
				findPattern = null;
				findGlobalPattern = null;
				this.widgetElem.setAttribute(ATTR_ERROR, e.message);
			}
			if (findPattern !== null && findGlobalPattern !== null) {
				let commitElems = getCommitElems(), j = 0, commit, zeroLengthMatch = false;

				// Search the commit data itself to detect commits that match, so that dom tree traversal is performed on matching commit rows (for performance)
				const commits = this.view.getCommits();
				for (let i = 0; i < commits.length; i++) {
					commit = commits[i];
					let branchLabels = getBranchLabels(commit.heads, commit.remotes);
					if (commit.hash !== UNCOMMITTED && (
						(colVisibility.author && findPattern.test(commit.author))
						|| (colVisibility.commit && (commit.hash.search(findPattern) === 0 || findPattern.test(abbrevCommit(commit.hash))))
						|| findPattern.test(commit.message)
						|| branchLabels.heads.some(head => findPattern!.test(head.name) || head.remotes.some(remote => findPattern!.test(remote)))
						|| branchLabels.remotes.some(remote => findPattern!.test(remote.name))
						|| commit.tags.some(tag => findPattern!.test(tag.name))
						|| (colVisibility.date && findPattern.test(formatShortDate(commit.date).formatted))
						|| (commit.stash !== null && findPattern.test(commit.stash.selector))
					)) {
						let idStr = i.toString();
						while (j < commitElems.length && commitElems[j].dataset.id !== idStr) j++;
						if (j === commitElems.length) continue;

						this.matches.push({ hash: commit.hash, elem: commitElems[j] });

						// Highlight matches
						let textElems = getChildNodesWithTextContent(commitElems[j]), textElem;
						for (let k = 0; k < textElems.length; k++) {
							textElem = textElems[k];
							let matchStart = 0, matchEnd = 0, text = textElem.textContent!, match: RegExpExecArray | null;
							findGlobalPattern.lastIndex = 0;
							while (match = findGlobalPattern.exec(text)) {
								if (match[0].length === 0) {
									zeroLengthMatch = true;
									break;
								}
								if (matchEnd !== match.index) {
									// This match isn't immediately after the previous match, or isn't at the beginning of the text
									if (matchStart !== matchEnd) {
										// There was a previous match, insert it in a text node
										textElem.parentNode!.insertBefore(FindWidget.createMatchElem(text.substring(matchStart, matchEnd)), textElem);
									}
									// Insert a text node containing the text between the last match and the current match
									textElem.parentNode!.insertBefore(document.createTextNode(text.substring(matchEnd, match.index)), textElem);
									matchStart = match.index;
								}
								matchEnd = findGlobalPattern.lastIndex;
							}
							if (matchEnd > 0) {
								// There were one or more matches
								if (matchStart !== matchEnd) {
									// There was a match, insert it in a text node
									textElem.parentNode!.insertBefore(FindWidget.createMatchElem(text.substring(matchStart, matchEnd)), textElem);
								}
								if (matchEnd !== text.length) {
									// There was some text after last match, update the textElem (the last node of it's parent) to contain the remaining text.
									textElem.textContent = text.substring(matchEnd);
								} else {
									// The last match was at the end of the text, the textElem is no longer required, so delete it
									textElem.parentNode!.removeChild(textElem);
								}
							}
							if (zeroLengthMatch) break;
						}
						if (colVisibility.commit && commit.hash.search(findPattern) === 0 && !findPattern.test(abbrevCommit(commit.hash)) && textElems.length > 0) {
							// The commit matches on more than the abbreviated commit, so the commit should be highlighted
							let commitNode = textElems[textElems.length - 1]; // Commit is always the last column if it is visible
							commitNode.parentNode!.replaceChild(FindWidget.createMatchElem(commitNode.textContent!), commitNode);
						}
						if (zeroLengthMatch) break;
					}
				}
				if (zeroLengthMatch) {
					this.widgetElem.setAttribute(ATTR_ERROR, 'Cannot use a regular expression which has zero length matches');
					this.clearMatches();
					this.matches = [];
				}
			}
		} else {
			this.widgetElem.removeAttribute(ATTR_ERROR);
		}

		alterClass(this.prevElem, CLASS_DISABLED, this.matches.length === 0);
		alterClass(this.nextElem, CLASS_DISABLED, this.matches.length === 0);

		let newPos = -1;
		if (this.matches.length > 0) {
			newPos = 0;
			if (goToCommitHash !== null) {
				let pos = this.matches.findIndex(match => match.hash === goToCommitHash);
				if (pos > -1) newPos = pos;
			}
		}
		this.updatePosition(newPos, scrollToCommit);
	}

	/**
	 * Clear all of the highlighted find matches in the view.
	 */
	private clearMatches() {
		for (let i = 0; i < this.matches.length; i++) {
			if (i === this.position) this.matches[i].elem.classList.remove(CLASS_FIND_CURRENT_COMMIT);
			let matchElems = getChildrenWithClassName(this.matches[i].elem, CLASS_FIND_MATCH), matchElem;
			for (let j = 0; j < matchElems.length; j++) {
				matchElem = matchElems[j];
				let text = matchElem.childNodes[0].textContent!;

				// Combine current text with the text from previous sibling text nodes
				let node = matchElem.previousSibling, elem = matchElem.previousElementSibling;
				while (node !== null && node !== elem && node.textContent !== null) {
					text = node.textContent + text;
					matchElem.parentNode!.removeChild(node);
					node = matchElem.previousSibling;
				}

				// Combine current text with the text from next sibling text nodes
				node = matchElem.nextSibling;
				elem = matchElem.nextElementSibling;
				while (node !== null && node !== elem && node.textContent !== null) {
					text = text + node.textContent;
					matchElem.parentNode!.removeChild(node);
					node = matchElem.nextSibling;
				}

				matchElem.parentNode!.replaceChild(document.createTextNode(text), matchElem);
			}
		}
	}

	/**
	 * Update the user's position in the set of find matches.
	 * @param position The new position index within the find matches.
	 * @param scrollToCommit After updating the user's position in the set of find matches, should the current match be scrolled to (so it's visible in the view).
	 */
	private updatePosition(position: number, scrollToCommit: boolean) {
		if (this.position > -1) this.matches[this.position].elem.classList.remove(CLASS_FIND_CURRENT_COMMIT);
		this.position = position;
		if (this.position > -1) {
			this.matches[this.position].elem.classList.add(CLASS_FIND_CURRENT_COMMIT);
			if (scrollToCommit) this.view.scrollToCommit(this.matches[position].hash, false);
		}
		this.positionElem.innerHTML = this.matches.length > 0 ? (this.position + 1) + ' of ' + this.matches.length : 'No Results';
		this.view.saveState();
	}

	/**
	 * Move the user's position to the previous match in the set of find matches.
	 */
	private prev() {
		if (this.matches.length === 0) return;
		this.updatePosition(this.position > 0 ? this.position - 1 : this.matches.length - 1, true);
		this.openCommitDetailsViewForCurrentMatchIfEnabled();
	}

	/**
	 * Move the user's position to the next match in the set of find matches.
	 */
	private next() {
		if (this.matches.length === 0) return;
		this.updatePosition(this.position < this.matches.length - 1 ? this.position + 1 : 0, true);
		this.openCommitDetailsViewForCurrentMatchIfEnabled();
	}

	/**
	 * If the Find Widget is configured to open the Commit Details View for the current find match, load the Commit Details View accordingly.
	 */
	private openCommitDetailsViewForCurrentMatchIfEnabled() {
		if (workspaceState.findOpenCommitDetailsView) {
			const commitHash = this.getCurrentHash();
			if (commitHash !== null && !this.view.isCdvOpen(commitHash, null)) {
				const commitElem = findCommitElemWithId(getCommitElems(), this.view.getCommitId(commitHash));
				if (commitElem !== null) {
					this.view.loadCommitDetails(commitElem);
				}
			}
		}
	}

	/**
	 * Create a find match element containing the specified text.
	 * @param text The text content of the find match.
	 * @returns The HTML element for the find match.
	 */
	private static createMatchElem(text: string) {
		const span = document.createElement('span');
		span.className = CLASS_FIND_MATCH;
		span.innerHTML = text;
		return span;
	}
}
-e 

================================================================================
// FILE: ./web/graph.ts
================================================================================
const CLASS_GRAPH_VERTEX_ACTIVE = 'graphVertexActive';
const NULL_VERTEX_ID = -1;


/* Types */

interface Point {
	readonly x: number;
	readonly y: number;
}
interface Line {
	readonly p1: Point;
	readonly p2: Point;
	readonly lockedFirst: boolean; // TRUE => The line is locked to p1, FALSE => The line is locked to p2
}

interface Pixel {
	x: number;
	y: number;
}
interface PlacedLine {
	readonly p1: Pixel;
	readonly p2: Pixel;
	readonly isCommitted: boolean;
	readonly lockedFirst: boolean; // TRUE => The line is locked to p1, FALSE => The line is locked to p2
}

interface UnavailablePoint {
	readonly connectsTo: VertexOrNull;
	readonly onBranch: Branch;
}

type VertexOrNull = Vertex | null;


/* Branch Class */

class Branch {
	private readonly colour: number;
	private end: number = 0;
	private lines: Line[] = [];
	private numUncommitted: number = 0;

	constructor(colour: number) {
		this.colour = colour;
	}

	public addLine(p1: Point, p2: Point, isCommitted: boolean, lockedFirst: boolean) {
		this.lines.push({ p1: p1, p2: p2, lockedFirst: lockedFirst });
		if (isCommitted) {
			if (p2.x === 0 && p2.y < this.numUncommitted) this.numUncommitted = p2.y;
		} else {
			this.numUncommitted++;
		}
	}


	/* Get / Set */

	public getColour() {
		return this.colour;
	}

	public getEnd() {
		return this.end;
	}

	public setEnd(end: number) {
		this.end = end;
	}


	/* Rendering */

	public draw(svg: SVGElement, config: GG.GraphConfig, expandAt: number) {
		let colour = config.colours[this.colour % config.colours.length], i, x1, y1, x2, y2, lines: PlacedLine[] = [], curPath = '', d = config.grid.y * (config.style === GG.GraphStyle.Angular ? 0.38 : 0.8), line, nextLine;

		// Convert branch lines into pixel coordinates, respecting expanded commit extensions
		for (i = 0; i < this.lines.length; i++) {
			line = this.lines[i];
			x1 = line.p1.x * config.grid.x + config.grid.offsetX; y1 = line.p1.y * config.grid.y + config.grid.offsetY;
			x2 = line.p2.x * config.grid.x + config.grid.offsetX; y2 = line.p2.y * config.grid.y + config.grid.offsetY;

			// If a commit is expanded, we need to stretch the graph for the height of the commit details view
			if (expandAt > -1) {
				if (line.p1.y > expandAt) { // If the line starts after the expansion, move the whole line lower
					y1 += config.grid.expandY;
					y2 += config.grid.expandY;
				} else if (line.p2.y > expandAt) { // If the line crosses the expansion
					if (x1 === x2) { // The line is vertical, extend the endpoint past the expansion
						y2 += config.grid.expandY;
					} else if (line.lockedFirst) { // If the line is locked to the first point, the transition stays in its normal position
						lines.push({ p1: { x: x1, y: y1 }, p2: { x: x2, y: y2 }, isCommitted: i >= this.numUncommitted, lockedFirst: line.lockedFirst }); // Display the normal transition
						lines.push({ p1: { x: x2, y: y1 + config.grid.y }, p2: { x: x2, y: y2 + config.grid.expandY }, isCommitted: i >= this.numUncommitted, lockedFirst: line.lockedFirst }); // Extend the line over the expansion from the transition end point
						continue;
					} else { // If the line is locked to the second point, the transition moves to after the expansion
						lines.push({ p1: { x: x1, y: y1 }, p2: { x: x1, y: y2 - config.grid.y + config.grid.expandY }, isCommitted: i >= this.numUncommitted, lockedFirst: line.lockedFirst }); // Extend the line over the expansion to the new transition start point
						y1 += config.grid.expandY; y2 += config.grid.expandY;
					}
				}
			}
			lines.push({ p1: { x: x1, y: y1 }, p2: { x: x2, y: y2 }, isCommitted: i >= this.numUncommitted, lockedFirst: line.lockedFirst });
		}

		// Simplify consecutive lines that are straight by removing the 'middle' point
		i = 0;
		while (i < lines.length - 1) {
			line = lines[i];
			nextLine = lines[i + 1];
			if (line.p1.x === line.p2.x && line.p2.x === nextLine.p1.x && nextLine.p1.x === nextLine.p2.x && line.p2.y === nextLine.p1.y && line.isCommitted === nextLine.isCommitted) {
				line.p2.y = nextLine.p2.y;
				lines.splice(i + 1, 1);
			} else {
				i++;
			}
		}

		// Iterate through all lines, producing and adding the svg paths to the DOM
		for (i = 0; i < lines.length; i++) {
			line = lines[i];
			x1 = line.p1.x; y1 = line.p1.y;
			x2 = line.p2.x; y2 = line.p2.y;

			// If the new point belongs to a different path, render the current path and reset it for the new path
			if (curPath !== '' && i > 0 && line.isCommitted !== lines[i - 1].isCommitted) {
				Branch.drawPath(svg, curPath, lines[i - 1].isCommitted, colour, config.uncommittedChanges);
				curPath = '';
			}

			// If the path hasn't been started or the new point belongs to a different path, move to p1
			if (curPath === '' || (i > 0 && (x1 !== lines[i - 1].p2.x || y1 !== lines[i - 1].p2.y))) curPath += 'M' + x1.toFixed(0) + ',' + y1.toFixed(1);

			if (x1 === x2) { // If the path is vertical, draw a straight line
				curPath += 'L' + x2.toFixed(0) + ',' + y2.toFixed(1);
			} else { // If the path moves horizontal, draw the appropriate transition
				if (config.style === GG.GraphStyle.Angular) {
					curPath += 'L' + (line.lockedFirst ? (x2.toFixed(0) + ',' + (y2 - d).toFixed(1)) : (x1.toFixed(0) + ',' + (y1 + d).toFixed(1))) + 'L' + x2.toFixed(0) + ',' + y2.toFixed(1);
				} else {
					curPath += 'C' + x1.toFixed(0) + ',' + (y1 + d).toFixed(1) + ' ' + x2.toFixed(0) + ',' + (y2 - d).toFixed(1) + ' ' + x2.toFixed(0) + ',' + y2.toFixed(1);
				}
			}
		}

		if (curPath !== '') {
			Branch.drawPath(svg, curPath, lines[lines.length - 1].isCommitted, colour, config.uncommittedChanges); // Draw the remaining path
		}
	}

	private static drawPath(svg: SVGElement, path: string, isCommitted: boolean, colour: string, uncommittedChanges: GG.GraphUncommittedChangesStyle) {
		const shadow = svg.appendChild(document.createElementNS(SVG_NAMESPACE, 'path')), line = svg.appendChild(document.createElementNS(SVG_NAMESPACE, 'path'));
		shadow.setAttribute('class', 'shadow');
		shadow.setAttribute('d', path);
		line.setAttribute('class', 'line');
		line.setAttribute('d', path);
		line.setAttribute('stroke', isCommitted ? colour : '#808080');
		if (!isCommitted && uncommittedChanges === GG.GraphUncommittedChangesStyle.OpenCircleAtTheCheckedOutCommit) {
			line.setAttribute('stroke-dasharray', '2px');
		}
	}
}


/* Vertex Class */

class Vertex {
	public readonly id: number;
	public readonly isStash: boolean;

	private x: number = 0;
	private children: Vertex[] = [];
	private parents: Vertex[] = [];
	private nextParent: number = 0;
	private onBranch: Branch | null = null;
	private isCommitted: boolean = true;
	private isCurrent: boolean = false;
	private nextX: number = 0;
	private connections: UnavailablePoint[] = [];

	constructor(id: number, isStash: boolean) {
		this.id = id;
		this.isStash = isStash;
	}


	/* Children */

	public addChild(vertex: Vertex) {
		this.children.push(vertex);
	}

	public getChildren(): ReadonlyArray<Vertex> {
		return this.children;
	}


	/* Parents */

	public addParent(vertex: Vertex) {
		this.parents.push(vertex);
	}

	public getParents(): ReadonlyArray<Vertex> {
		return this.parents;
	}

	public hasParents() {
		return this.parents.length > 0;
	}

	public getNextParent(): Vertex | null {
		if (this.nextParent < this.parents.length) return this.parents[this.nextParent];
		return null;
	}

	public getLastParent(): Vertex | null {
		if (this.nextParent < 1) return null;
		return this.parents[this.nextParent - 1];
	}

	public registerParentProcessed() {
		this.nextParent++;
	}

	public isMerge() {
		return this.parents.length > 1;
	}


	/* Branch */

	public addToBranch(branch: Branch, x: number) {
		if (this.onBranch === null) {
			this.onBranch = branch;
			this.x = x;
		}
	}

	public isNotOnBranch() {
		return this.onBranch === null;
	}

	public isOnThisBranch(branch: Branch) {
		return this.onBranch === branch;
	}

	public getBranch() {
		return this.onBranch;
	}


	/* Point */

	public getPoint(): Point {
		return { x: this.x, y: this.id };
	}

	public getNextPoint(): Point {
		return { x: this.nextX, y: this.id };
	}

	public getPointConnectingTo(vertex: VertexOrNull, onBranch: Branch) {
		for (let i = 0; i < this.connections.length; i++) {
			if (this.connections[i].connectsTo === vertex && this.connections[i].onBranch === onBranch) {
				return { x: i, y: this.id };
			}
		}
		return null;
	}
	public registerUnavailablePoint(x: number, connectsToVertex: VertexOrNull, onBranch: Branch) {
		if (x === this.nextX) {
			this.nextX = x + 1;
			this.connections[x] = { connectsTo: connectsToVertex, onBranch: onBranch };
		}
	}


	/* Get / Set State */

	public getColour() {
		return this.onBranch !== null ? this.onBranch.getColour() : 0;
	}

	public getIsCommitted() {
		return this.isCommitted;
	}

	public setNotCommitted() {
		this.isCommitted = false;
	}

	public setCurrent() {
		this.isCurrent = true;
	}


	/* Rendering */

	public draw(svg: SVGElement, config: GG.GraphConfig, expandOffset: boolean, overListener: (event: MouseEvent) => void, outListener: (event: MouseEvent) => void) {
		if (this.onBranch === null) return;

		const colour = this.isCommitted ? config.colours[this.onBranch.getColour() % config.colours.length] : '#808080';
		const cx = (this.x * config.grid.x + config.grid.offsetX).toString();
		const cy = (this.id * config.grid.y + config.grid.offsetY + (expandOffset ? config.grid.expandY : 0)).toString();

		const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
		circle.dataset.id = this.id.toString();
		circle.setAttribute('cx', cx);
		circle.setAttribute('cy', cy);
		circle.setAttribute('r', '4');
		if (this.isCurrent) {
			circle.setAttribute('class', 'current');
			circle.setAttribute('stroke', colour);
		} else {
			circle.setAttribute('fill', colour);
		}
		svg.appendChild(circle);

		if (this.isStash && !this.isCurrent) {
			circle.setAttribute('r', '4.5');
			circle.setAttribute('class', 'stashOuter');
			const innerCircle = document.createElementNS(SVG_NAMESPACE, 'circle');
			innerCircle.setAttribute('cx', cx);
			innerCircle.setAttribute('cy', cy);
			innerCircle.setAttribute('r', '2');
			innerCircle.setAttribute('class', 'stashInner');
			svg.appendChild(innerCircle);
		}

		circle.addEventListener('mouseover', overListener);
		circle.addEventListener('mouseout', outListener);
	}
}


/* Graph Class */

class Graph {
	private readonly config: GG.GraphConfig;
	private readonly muteConfig: GG.MuteCommitsConfig;
	private vertices: Vertex[] = [];
	private branches: Branch[] = [];
	private availableColours: number[] = [];
	private maxWidth: number = -1;

	private commits: ReadonlyArray<GG.GitCommit> = [];
	private commitHead: string | null = null;
	private commitLookup: { [hash: string]: number } = {};
	private onlyFollowFirstParent: boolean = false;
	private expandedCommitIndex: number = -1;

	private readonly viewElem: HTMLElement;
	private readonly contentElem: HTMLElement;
	private readonly svg: SVGElement;
	private readonly maskRect: SVGRectElement;
	private readonly gradientStop1: SVGStopElement;
	private readonly gradientStop2: SVGStopElement;
	private group: SVGGElement | null = null;

	private tooltipId: number = -1;
	private tooltipElem: HTMLElement | null = null;
	private tooltipTimeout: NodeJS.Timer | null = null;
	private tooltipVertex: HTMLElement | null = null;

	constructor(id: string, viewElem: HTMLElement, config: GG.GraphConfig, muteConfig: GG.MuteCommitsConfig) {
		this.viewElem = viewElem;
		this.config = config;
		this.muteConfig = muteConfig;

		const elem = document.getElementById(id)!;
		this.contentElem = elem.parentElement!;
		this.svg = document.createElementNS(SVG_NAMESPACE, 'svg');
		let defs = this.svg.appendChild(document.createElementNS(SVG_NAMESPACE, 'defs'));

		let linearGradient = defs.appendChild(document.createElementNS(SVG_NAMESPACE, 'linearGradient'));
		linearGradient.setAttribute('id', 'GraphGradient');
		this.gradientStop1 = linearGradient.appendChild(document.createElementNS(SVG_NAMESPACE, 'stop'));
		this.gradientStop1.setAttribute('stop-color', 'white');
		this.gradientStop2 = linearGradient.appendChild(document.createElementNS(SVG_NAMESPACE, 'stop'));
		this.gradientStop2.setAttribute('stop-color', 'black');

		let mask = defs.appendChild(document.createElementNS(SVG_NAMESPACE, 'mask'));
		mask.setAttribute('id', 'GraphMask');
		this.maskRect = mask.appendChild(document.createElementNS(SVG_NAMESPACE, 'rect'));
		this.maskRect.setAttribute('fill', 'url(#GraphGradient)');

		this.setDimensions(0, 0);
		elem.appendChild(this.svg);
	}


	/* Graph Operations */

	public loadCommits(commits: ReadonlyArray<GG.GitCommit>, commitHead: string | null, commitLookup: { [hash: string]: number }, onlyFollowFirstParent: boolean) {
		this.commits = commits;
		this.commitHead = commitHead;
		this.commitLookup = commitLookup;
		this.onlyFollowFirstParent = onlyFollowFirstParent;
		this.vertices = [];
		this.branches = [];
		this.availableColours = [];
		if (commits.length === 0) return;

		const nullVertex = new Vertex(NULL_VERTEX_ID, false);
		let i: number, j: number;
		for (i = 0; i < commits.length; i++) {
			this.vertices.push(new Vertex(i, commits[i].stash !== null));
		}
		for (i = 0; i < commits.length; i++) {
			for (j = 0; j < commits[i].parents.length; j++) {
				let parentHash = commits[i].parents[j];
				if (typeof commitLookup[parentHash] === 'number') {
					// Parent is the <commitLookup[parentHash]>th vertex
					this.vertices[i].addParent(this.vertices[commitLookup[parentHash]]);
					this.vertices[commitLookup[parentHash]].addChild(this.vertices[i]);
				} else if (!this.onlyFollowFirstParent || j === 0) {
					// Parent is not one of the vertices of the graph, and the parent isn't being hidden by the onlyFollowFirstParent condition.
					this.vertices[i].addParent(nullVertex);
				}
			}
		}

		if (commits[0].hash === UNCOMMITTED) {
			this.vertices[0].setNotCommitted();
		}

		if (commits[0].hash === UNCOMMITTED && this.config.uncommittedChanges === GG.GraphUncommittedChangesStyle.OpenCircleAtTheUncommittedChanges) {
			this.vertices[0].setCurrent();
		} else if (commitHead !== null && typeof commitLookup[commitHead] === 'number') {
			this.vertices[commitLookup[commitHead]].setCurrent();
		}

		i = 0;
		while (i < this.vertices.length) {
			if (this.vertices[i].getNextParent() !== null || this.vertices[i].isNotOnBranch()) {
				this.determinePath(i);
			} else {
				i++;
			}
		}
	}

	public render(expandedCommit: ExpandedCommit | null) {
		this.expandedCommitIndex = expandedCommit !== null ? expandedCommit.index : -1;
		let group = document.createElementNS(SVG_NAMESPACE, 'g'), i, contentWidth = this.getContentWidth();
		group.setAttribute('mask', 'url(#GraphMask)');

		for (i = 0; i < this.branches.length; i++) {
			this.branches[i].draw(group, this.config, this.expandedCommitIndex);
		}

		const overListener = (e: MouseEvent) => this.vertexOver(e), outListener = (e: MouseEvent) => this.vertexOut(e);
		for (i = 0; i < this.vertices.length; i++) {
			this.vertices[i].draw(group, this.config, expandedCommit !== null && i > expandedCommit.index, overListener, outListener);
		}

		if (this.group !== null) this.svg.removeChild(this.group);
		this.svg.appendChild(group);
		this.group = group;
		this.setDimensions(contentWidth, this.getHeight(expandedCommit));
		this.applyMaxWidth(contentWidth);
		this.closeTooltip();
	}


	/* Get */

	public getContentWidth() {
		let x = 0, i, p;
		for (i = 0; i < this.vertices.length; i++) {
			p = this.vertices[i].getNextPoint();
			if (p.x > x) x = p.x;
		}
		return 2 * this.config.grid.offsetX + (x - 1) * this.config.grid.x;
	}

	public getHeight(expandedCommit: ExpandedCommit | null) {
		return this.vertices.length * this.config.grid.y + this.config.grid.offsetY - this.config.grid.y / 2 + (expandedCommit !== null ? this.config.grid.expandY : 0);
	}

	public getVertexColours() {
		let colours = [], i;
		for (i = 0; i < this.vertices.length; i++) {
			colours[i] = this.vertices[i].getColour() % this.config.colours.length;
		}
		return colours;
	}

	public getWidthsAtVertices() {
		let widths = [], i;
		for (i = 0; i < this.vertices.length; i++) {
			widths[i] = this.config.grid.offsetX + this.vertices[i].getNextPoint().x * this.config.grid.x - 2;
		}
		return widths;
	}


	/* Graph Queries */

	/**
	 * Determine whether a commit can be dropped.
	 * @param i Index of the commit to test.
	 * @returns TRUE => Commit can be dropped, FALSE => Commit can't be dropped
	 */
	public dropCommitPossible(i: number) {
		if (!this.vertices[i].hasParents()) {
			return false; // No parents
		}

		const isPossible = (v: Vertex): boolean | null => {
			if (v.isMerge()) {
				// Commit is a merge - fails topological test
				return null;
			}

			let children = v.getChildren();
			if (children.length > 1) {
				// Commit has multiple children - fails topological test
				return null;
			} else if (children.length === 1) {
				const recursivelyPossible = isPossible(children[0]);
				if (recursivelyPossible !== false) {
					// Topological tests failed (recursivelyPossible === NULL), or the HEAD has already been found (recursivelyPossible === TRUE)
					return recursivelyPossible;
				}
			}

			// Check if the current vertex is the HEAD if it has no children, or the HEAD has not been found in its recursive children.
			return this.commits[v.id].hash === this.commitHead;
		};

		return isPossible(this.vertices[i]) || false;
	}

	private getAllChildren(i: number) {
		let visited: { [id: string]: number } = {};
		const rec = (vertex: Vertex) => {
			const idStr = vertex.id.toString();
			if (typeof visited[idStr] !== 'undefined') return;

			visited[idStr] = vertex.id;
			let children = vertex.getChildren();
			for (let i = 0; i < children.length; i++) rec(children[i]);
		};
		rec(this.vertices[i]);
		return Object.keys(visited).map((key) => visited[key]).sort((a, b) => a - b);
	}

	public getMutedCommits(currentHash: string | null) {
		const muted = [];
		for (let i = 0; i < this.commits.length; i++) {
			muted[i] = false;
		}

		// Mute any merge commits if the Extension Setting is enabled
		if (this.muteConfig.mergeCommits) {
			for (let i = 0; i < this.commits.length; i++) {
				if (this.vertices[i].isMerge() && this.commits[i].stash === null) {
					// The commit is a merge, and is not a stash
					muted[i] = true;
				}
			}
		}

		// Mute any commits that are not ancestors of the commit head if the Extension Setting is enabled, and the head commit is in the graph
		if (this.muteConfig.commitsNotAncestorsOfHead && currentHash !== null && typeof this.commitLookup[currentHash] === 'number') {
			let ancestor: boolean[] = [];
			for (let i = 0; i < this.commits.length; i++) {
				ancestor[i] = false;
			}

			// Recursively discover ancestors of commit head
			const rec = (vertex: Vertex) => {
				if (vertex.id === NULL_VERTEX_ID || ancestor[vertex.id]) return;
				ancestor[vertex.id] = true;

				let parents = vertex.getParents();
				for (let i = 0; i < parents.length; i++) rec(parents[i]);
			};
			rec(this.vertices[this.commitLookup[currentHash]]);

			for (let i = 0; i < this.commits.length; i++) {
				if (!ancestor[i] && (this.commits[i].stash === null || typeof this.commitLookup[this.commits[i].stash!.baseHash] !== 'number' || !ancestor[this.commitLookup[this.commits[i].stash!.baseHash]])) {
					// Commit i is not an ancestor of currentHash, or a stash based on an ancestor of currentHash
					muted[i] = true;
				}
			}
		}

		return muted;
	}


	/**
	 * Get the index of the first parent of the commit at the specified index.
	 * @param i The index of the commit.
	 * @returns The index of the first parent, or -1 if there is no parent.
	 */
	public getFirstParentIndex(i: number) {
		const parents = this.vertices[i].getParents();
		return parents.length > 0
			? parents[0].id
			: -1;
	}

	/**
	 * Get the index of the alternative parent of the commit at the specified index.
	 * @param i The index of the commit.
	 * @returns The index of the alternative parent, or -1 if there is no parent.
	 */
	public getAlternativeParentIndex(i: number) {
		const parents = this.vertices[i].getParents();
		return parents.length > 1
			? parents[1].id
			: parents.length === 1
				? parents[0].id
				: -1;
	}

	/**
	 * Get the index of the first child of the commit at the specified index.
	 * @param i The index of the commit.
	 * @returns The index of the first child, or -1 if there is no child.
	 */
	public getFirstChildIndex(i: number) {
		const children = this.vertices[i].getChildren();
		if (children.length > 1) {
			// The vertex has multiple children
			const branch = this.vertices[i].getBranch();
			let childOnSameBranch: Vertex | undefined;
			if (branch !== null && (childOnSameBranch = children.find((child) => child.isOnThisBranch(branch)))) {
				// If a child could be found on the same branch as the vertex
				return childOnSameBranch.id;
			} else {
				// No child could be found on the same branch as the vertex
				return Math.max(...children.map((child) => child.id));
			}
		} else if (children.length === 1) {
			// The vertex has a single child
			return children[0].id;
		} else {
			// The vertex has no children
			return -1;
		}
	}

	/**
	 * Get the index of the alternative child of the commit at the specified index.
	 * @param i The index of the commit.
	 * @returns The index of the alternative child, or -1 if there is no child.
	 */
	public getAlternativeChildIndex(i: number) {
		const children = this.vertices[i].getChildren();
		if (children.length > 1) {
			// The vertex has multiple children
			const branch = this.vertices[i].getBranch();
			let childOnSameBranch: Vertex | undefined;
			if (branch !== null && (childOnSameBranch = children.find((child) => child.isOnThisBranch(branch)))) {
				// If a child could be found on the same branch as the vertex
				return Math.max(...children.filter(child => child !== childOnSameBranch).map((child) => child.id));
			} else {
				// No child could be found on the same branch as the vertex
				const childIndexes = children.map((child) => child.id).sort();
				return childIndexes[childIndexes.length - 2];
			}
		} else if (children.length === 1) {
			// The vertex has a single child
			return children[0].id;
		} else {
			// The vertex has no children
			return -1;
		}
	}


	/* Width Adjustment Methods */

	public limitMaxWidth(maxWidth: number) {
		this.maxWidth = maxWidth;
		this.applyMaxWidth(this.getContentWidth());
	}

	private setDimensions(contentWidth: number, height: number) {
		this.setSvgWidth(contentWidth);
		this.svg.setAttribute('height', height.toString());
		this.maskRect.setAttribute('width', contentWidth.toString());
		this.maskRect.setAttribute('height', height.toString());
	}

	private applyMaxWidth(contentWidth: number) {
		this.setSvgWidth(contentWidth);
		let offset1 = this.maxWidth > -1 ? (this.maxWidth - 12) / contentWidth : 1;
		let offset2 = this.maxWidth > -1 ? this.maxWidth / contentWidth : 1;
		this.gradientStop1.setAttribute('offset', offset1.toString());
		this.gradientStop2.setAttribute('offset', offset2.toString());
	}

	private setSvgWidth(contentWidth: number) {
		let width = this.maxWidth > -1 ? Math.min(contentWidth, this.maxWidth) : contentWidth;
		this.svg.setAttribute('width', width.toString());
	}


	/* Graph Layout Methods */

	private determinePath(startAt: number) {
		let i = startAt;
		let vertex = this.vertices[i], parentVertex = this.vertices[i].getNextParent(), curVertex;
		let lastPoint = vertex.isNotOnBranch() ? vertex.getNextPoint() : vertex.getPoint(), curPoint;

		if (parentVertex !== null && parentVertex.id !== NULL_VERTEX_ID && vertex.isMerge() && !vertex.isNotOnBranch() && !parentVertex.isNotOnBranch()) {
			// Branch is a merge between two vertices already on branches
			let foundPointToParent = false, parentBranch = parentVertex.getBranch()!;
			for (i = startAt + 1; i < this.vertices.length; i++) {
				curVertex = this.vertices[i];
				curPoint = curVertex.getPointConnectingTo(parentVertex, parentBranch); // Check if there is already a point connecting the ith vertex to the required parent
				if (curPoint !== null) {
					foundPointToParent = true; // Parent was found
				} else {
					curPoint = curVertex.getNextPoint(); // Parent couldn't be found, choose the next available point for the vertex
				}
				parentBranch.addLine(lastPoint, curPoint, vertex.getIsCommitted(), !foundPointToParent && curVertex !== parentVertex ? lastPoint.x < curPoint.x : true);
				curVertex.registerUnavailablePoint(curPoint.x, parentVertex, parentBranch);
				lastPoint = curPoint;

				if (foundPointToParent) {
					vertex.registerParentProcessed();
					break;
				}
			}
		} else {
			// Branch is normal
			let branch = new Branch(this.getAvailableColour(startAt));
			vertex.addToBranch(branch, lastPoint.x);
			vertex.registerUnavailablePoint(lastPoint.x, vertex, branch);
			for (i = startAt + 1; i < this.vertices.length; i++) {
				curVertex = this.vertices[i];
				curPoint = parentVertex === curVertex && !parentVertex.isNotOnBranch() ? curVertex.getPoint() : curVertex.getNextPoint();
				branch.addLine(lastPoint, curPoint, vertex.getIsCommitted(), lastPoint.x < curPoint.x);
				curVertex.registerUnavailablePoint(curPoint.x, parentVertex, branch);
				lastPoint = curPoint;

				if (parentVertex === curVertex) {
					// The parent of <vertex> has been reached, progress <vertex> and <parentVertex> to continue building the branch
					vertex.registerParentProcessed();
					let parentVertexOnBranch = !parentVertex.isNotOnBranch();
					parentVertex.addToBranch(branch, curPoint.x);
					vertex = parentVertex;
					parentVertex = vertex.getNextParent();
					if (parentVertex === null || parentVertexOnBranch) {
						// There are no more parent vertices, or the parent was already on a branch
						break;
					}
				}
			}
			if (i === this.vertices.length && parentVertex !== null && parentVertex.id === NULL_VERTEX_ID) {
				// Vertex is the last in the graph, so no more branch can be formed to the parent
				vertex.registerParentProcessed();
			}
			branch.setEnd(i);
			this.branches.push(branch);
			this.availableColours[branch.getColour()] = i;
		}
	}

	private getAvailableColour(startAt: number) {
		for (let i = 0; i < this.availableColours.length; i++) {
			if (startAt > this.availableColours[i]) {
				return i;
			}
		}
		this.availableColours.push(0);
		return this.availableColours.length - 1;
	}


	/* Vertex Info */

	private vertexOver(event: MouseEvent) {
		if (event.target === null) return;
		this.closeTooltip();

		const vertexElem = <HTMLElement>event.target;
		const id = parseInt(vertexElem.dataset.id!);
		this.tooltipId = id;
		const commitElem = findCommitElemWithId(getCommitElems(), id);
		if (commitElem !== null) commitElem.classList.add(CLASS_GRAPH_VERTEX_ACTIVE);

		if (id < this.commits.length && this.commits[id].hash !== UNCOMMITTED) { // Only show tooltip for commits (not the uncommitted changes)
			this.tooltipTimeout = setTimeout(() => {
				this.tooltipTimeout = null;
				let vertexScreenY = vertexElem.getBoundingClientRect().top + 4; // Get center of the circle
				if (vertexScreenY >= 5 && vertexScreenY <= this.viewElem.clientHeight - 5) {
					// Vertex is completely visible on the screen (not partially off)
					this.tooltipVertex = vertexElem;
					closeDialogAndContextMenu();
					this.showTooltip(id, vertexScreenY);
				}
			}, 100);
		}
	}

	private vertexOut(event: MouseEvent) {
		if (event.target === null) return;
		this.closeTooltip();
	}

	private showTooltip(id: number, vertexScreenY: number) {
		if (this.tooltipVertex !== null) {
			this.tooltipVertex.setAttribute('r', this.tooltipVertex.classList.contains('stashOuter') ? '5.5' : '5');
		}

		const children = this.getAllChildren(id);
		let heads: string[] = [], remotes: GG.GitCommitRemote[] = [], stashes: string[] = [], tags: string[] = [], childrenIncludesHead = false;
		for (let i = 0; i < children.length; i++) {
			let commit = this.commits[children[i]];
			for (let j = 0; j < commit.heads.length; j++) heads.push(commit.heads[j]);
			for (let j = 0; j < commit.remotes.length; j++) remotes.push(commit.remotes[j]);
			for (let j = 0; j < commit.tags.length; j++) tags.push(commit.tags[j].name);
			if (commit.stash !== null) stashes.push(commit.stash.selector.substring(5));
			if (commit.hash === this.commitHead) childrenIncludesHead = true;
		}

		const getLimitedRefs = (htmlRefs: string[]) => {
			if (htmlRefs.length > 10) htmlRefs.splice(5, htmlRefs.length - 10, ' ' + ELLIPSIS + ' ');
			return htmlRefs.join('');
		};

		let html = '<div class="graphTooltipTitle">Commit ' + abbrevCommit(this.commits[id].hash) + '</div>';
		if (this.commitHead !== null && typeof this.commitLookup[this.commitHead] === 'number') {
			html += '<div class="graphTooltipSection">This commit is ' + (childrenIncludesHead ? '' : '<b><i>not</i></b> ') + 'included in <span class="graphTooltipRef">HEAD</span></div>';
		}
		if (heads.length > 0 || remotes.length > 0) {
			let branchLabels = getBranchLabels(heads, remotes), htmlRefs: string[] = [];
			branchLabels.heads.forEach((head) => {
				let html = head.remotes.reduce((prev, remote) => prev + '<span class="graphTooltipCombinedRef">' + escapeHtml(remote) + '</span>', '');
				htmlRefs.push('<span class="graphTooltipRef">' + escapeHtml(head.name) + html + '</span>');
			});
			branchLabels.remotes.forEach((remote) => htmlRefs.push('<span class="graphTooltipRef">' + escapeHtml(remote.name) + '</span>'));
			html += '<div class="graphTooltipSection">Branches: ' + getLimitedRefs(htmlRefs) + '</div>';
		}
		if (tags.length > 0) {
			let htmlRefs = tags.map((tag) => '<span class="graphTooltipRef">' + escapeHtml(tag) + '</span>');
			html += '<div class="graphTooltipSection">Tags: ' + getLimitedRefs(htmlRefs) + '</div>';
		}
		if (stashes.length > 0) {
			let htmlRefs = stashes.map((stash) => '<span class="graphTooltipRef">' + escapeHtml(stash) + '</span>');
			html += '<div class="graphTooltipSection">Stashes: ' + getLimitedRefs(htmlRefs) + '</div>';
		}

		const point = this.vertices[id].getPoint(), color = 'var(--git-graph-color' + (this.vertices[id].getColour() % this.config.colours.length) + ')';
		const anchor = document.createElement('div'), pointer = document.createElement('div'), content = document.createElement('div'), shadow = document.createElement('div');
		const pixel: Pixel = {
			x: point.x * this.config.grid.x + this.config.grid.offsetX,
			y: point.y * this.config.grid.y + this.config.grid.offsetY + (this.expandedCommitIndex > -1 && id > this.expandedCommitIndex ? this.config.grid.expandY : 0)
		};

		anchor.setAttribute('id', 'graphTooltip');
		anchor.style.opacity = '0';
		pointer.setAttribute('id', 'graphTooltipPointer');
		pointer.style.backgroundColor = color;
		content.setAttribute('id', 'graphTooltipContent');
		content.style.borderColor = color;
		content.innerHTML = html;
		content.style.maxWidth = Math.min(this.contentElem.getBoundingClientRect().width - pixel.x - 35, 600) + 'px'; // Tooltip Offset [23px] + Tooltip Border [2 * 2px] + Right Page Margin [8px] = 35px
		shadow.setAttribute('id', 'graphTooltipShadow');
		anchor.appendChild(shadow);
		anchor.appendChild(pointer);
		anchor.appendChild(content);
		anchor.style.left = pixel.x + 'px';
		anchor.style.top = pixel.y + 'px';
		this.contentElem.appendChild(anchor);
		this.tooltipElem = anchor;

		let tooltipRect = content.getBoundingClientRect();
		let relativeOffset = -tooltipRect.height / 2; // Center the tooltip vertically on the vertex
		if (vertexScreenY + relativeOffset + tooltipRect.height > this.viewElem.clientHeight - 4) {
			// Not enough height below the vertex to fit the vertex, shift it up.
			relativeOffset = (this.viewElem.clientHeight - vertexScreenY - 4) - tooltipRect.height;
		}
		if (vertexScreenY + relativeOffset < 4) {
			// Not enough height above the vertex to fit the tooltip, shift it down.
			relativeOffset = -vertexScreenY + 4;
		}
		pointer.style.top = (-relativeOffset) + 'px';
		anchor.style.top = (pixel.y + relativeOffset) + 'px';
		shadow.style.width = tooltipRect.width + 'px';
		shadow.style.height = tooltipRect.height + 'px';
		anchor.style.opacity = '1';
	}

	private closeTooltip() {
		if (this.tooltipId > -1) {
			const commitElem = findCommitElemWithId(getCommitElems(), this.tooltipId);
			if (commitElem !== null) commitElem.classList.remove(CLASS_GRAPH_VERTEX_ACTIVE);
			this.tooltipId = -1;
		}

		if (this.tooltipElem !== null) {
			this.tooltipElem.remove();
			this.tooltipElem = null;
		}

		if (this.tooltipTimeout !== null) {
			clearTimeout(this.tooltipTimeout);
			this.tooltipTimeout = null;
		}

		if (this.tooltipVertex !== null) {
			this.tooltipVertex.setAttribute('r', this.tooltipVertex.classList.contains('stashOuter') ? '4.5' : '4');
			this.tooltipVertex = null;
		}
	}
}
-e 

================================================================================
// FILE: ./web/utils.ts
================================================================================
/* Constants */
const VSCODE_API = acquireVsCodeApi();

const SVG_ICONS = {
	// The SVG icons below (alert, branch, check, commit, copy, download, eyeOpen, eyeClosed, gear, info, openFile, package, pencil, search, stash, tag, terminal, loading & refresh) were generated by the MIT licensed Software described in the file ./licenses/LICENSE_OCTICONS. The Software itself is not used in this project, only several icons generated by it are used (in the lines directly below this comment).
	alert: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"/></svg>',
	branch: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="16" viewBox="0 0 10 16"><path fill-rule="evenodd" d="M10 5c0-1.11-.89-2-2-2a1.993 1.993 0 0 0-1 3.72v.3c-.02.52-.23.98-.63 1.38-.4.4-.86.61-1.38.63-.83.02-1.48.16-2 .45V4.72a1.993 1.993 0 0 0-1-3.72C.88 1 0 1.89 0 3a2 2 0 0 0 1 1.72v6.56c-.59.35-1 .99-1 1.72 0 1.11.89 2 2 2 1.11 0 2-.89 2-2 0-.53-.2-1-.53-1.36.09-.06.48-.41.59-.47.25-.11.56-.17.94-.17 1.05-.05 1.95-.45 2.75-1.25S8.95 7.77 9 6.73h-.02C9.59 6.37 10 5.73 10 5zM2 1.8c.66 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2C1.35 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2zm0 12.41c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm6-8c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"/></svg>',
	check: '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M12 5l-8 8-4-4 1.5-1.5L4 10l6.5-6.5L12 5z"></path></svg>',
	commit: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M10.86 7c-.45-1.72-2-3-3.86-3-1.86 0-3.41 1.28-3.86 3H0v2h3.14c.45 1.72 2 3 3.86 3 1.86 0 3.41-1.28 3.86-3H14V7h-3.14zM7 10.2c-1.22 0-2.2-.98-2.2-2.2 0-1.22.98-2.2 2.2-2.2 1.22 0 2.2.98 2.2 2.2 0 1.22-.98 2.2-2.2 2.2z"/></svg>',
	copy: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z"/></svg>',
	download: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 -0.5 16 16.5"><path fill-rule="evenodd" d="M9 12h2l-3 3-3-3h2V7h2v5zm3-8c0-.44-.91-3-4.5-3C5.08 1 3 2.92 3 5 1.02 5 0 6.52 0 8c0 1.53 1 3 3 3h3V9.7H3C1.38 9.7 1.3 8.28 1.3 8c0-.17.05-1.7 1.7-1.7h1.3V5c0-1.39 1.56-2.7 3.2-2.7 2.55 0 3.13 1.55 3.2 1.8v1.2H12c.81 0 2.7.22 2.7 2.2 0 2.09-2.25 2.2-2.7 2.2h-2V11h2c2.08 0 4-1.16 4-3.5C16 5.06 14.08 4 12 4z"/></svg>',
	eyeOpen: '<svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.06 2C3 2 0 8 0 8s3 6 8.06 6C13 14 16 8 16 8s-3-6-7.94-6zM8 12c-2.2 0-4-1.78-4-4 0-2.2 1.8-4 4-4 2.22 0 4 1.8 4 4 0 2.22-1.78 4-4 4zm2-4c0 1.11-.89 2-2 2-1.11 0-2-.89-2-2 0-1.11.89-2 2-2 1.11 0 2 .89 2 2z"/></svg>',
	eyeClosed: '<svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 -1 16 16"><path fill-rule="evenodd" d="M14.822.854a.5.5 0 1 0-.707-.708l-2.11 2.11C10.89 1.483 9.565.926 8.06.926c-5.06 0-8.06 6-8.06 6s1.162 2.323 3.258 4.078l-2.064 2.065a.5.5 0 1 0 .707.707L14.822.854zM4.86 9.403L6.292 7.97A1.999 1.999 0 0 1 6 6.925c0-1.11.89-2 2-2 .384 0 .741.106 1.045.292l1.433-1.433A3.98 3.98 0 0 0 8 2.925c-2.2 0-4 1.8-4 4 0 .938.321 1.798.859 2.478zm7.005-3.514l1.993-1.992A14.873 14.873 0 0 1 16 6.925s-3 6-7.94 6a6.609 6.609 0 0 1-2.661-.57l1.565-1.566c.33.089.678.136 1.036.136 2.22 0 4-1.78 4-4 0-.358-.047-.705-.136-1.036zM9.338 8.415l.152-.151a1.996 1.996 0 0 1-.152.151z"/></svg>',
	gear: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="-1 -1 18 18"><path fill-rule="evenodd" d="M14 8.77v-1.6l-1.94-.64-.45-1.09.88-1.84-1.13-1.13-1.81.91-1.09-.45-.69-1.92h-1.6l-.63 1.94-1.11.45-1.84-.88-1.13 1.13.91 1.81-.45 1.09L0 7.23v1.59l1.94.64.45 1.09-.88 1.84 1.13 1.13 1.81-.91 1.09.45.69 1.92h1.59l.63-1.94 1.11-.45 1.84.88 1.13-1.13-.92-1.81.47-1.09L14 8.75v.02zM7 11c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg>',
	info: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"/></svg>',
	openFile: '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M8.5 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V4.5L8.5 1zM11 14H1V2h7l3 3v9zM6 4.5l4 3-4 3v-2c-.98-.02-1.84.22-2.55.7-.71.48-1.19 1.25-1.45 2.3.02-1.64.39-2.88 1.13-3.73.73-.84 1.69-1.27 2.88-1.27v-2H6z"/></svg>',
	package: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 4.27v7.47c0 .45.3.84.75.97l6.5 1.73c.16.05.34.05.5 0l6.5-1.73c.45-.13.75-.52.75-.97V4.27c0-.45-.3-.84-.75-.97l-6.5-1.74a1.4 1.4 0 0 0-.5 0L1.75 3.3c-.45.13-.75.52-.75.97zm7 9.09l-6-1.59V5l6 1.61v6.75zM2 4l2.5-.67L11 5.06l-2.5.67L2 4zm13 7.77l-6 1.59V6.61l2-.55V8.5l2-.53V5.53L15 5v6.77zm-2-7.24L6.5 2.8l2-.53L15 4l-2 .53z"/></svg>',
	pencil: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M0 12v3h3l8-8-3-3-8 8zm3 2H1v-2h1v1h1v1zm10.3-9.3L12 6 9 3l1.3-1.3a.996.996 0 0 1 1.41 0l1.59 1.59c.39.39.39 1.02 0 1.41z"/></svg>',
	search: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="-0.5 -2 18 18"><path fill-rule="evenodd" d="M15.7 13.3l-3.81-3.83A5.93 5.93 0 0 0 13 6c0-3.31-2.69-6-6-6S1 2.69 1 6s2.69 6 6 6c1.3 0 2.48-.41 3.47-1.11l3.83 3.81c.19.2.45.3.7.3.25 0 .52-.09.7-.3a.996.996 0 0 0 0-1.41v.01zM7 10.7c-2.59 0-4.7-2.11-4.7-4.7 0-2.59 2.11-4.7 4.7-4.7 2.59 0 4.7 2.11 4.7 4.7 0 2.59-2.11 4.7-4.7 4.7z"/></svg>',
	stash: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M14 9l-1.13-7.14c-.08-.48-.5-.86-1-.86H2.13c-.5 0-.92.38-1 .86L0 9v5c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V9zm-3.28.55l-.44.89c-.17.34-.52.56-.91.56H4.61c-.38 0-.72-.22-.89-.55l-.44-.91c-.17-.33-.52-.55-.89-.55H1l1-7h10l1 7h-1.38c-.39 0-.73.22-.91.55l.01.01z"/></svg>',
	tag: '<svg xmlns="http://www.w3.org/2000/svg" width="15" height="16" viewBox="0 0 15 16"><path fill-rule="evenodd" d="M7.73 1.73C7.26 1.26 6.62 1 5.96 1H3.5C2.13 1 1 2.13 1 3.5v2.47c0 .66.27 1.3.73 1.77l6.06 6.06c.39.39 1.02.39 1.41 0l4.59-4.59a.996.996 0 0 0 0-1.41L7.73 1.73zM2.38 7.09c-.31-.3-.47-.7-.47-1.13V3.5c0-.88.72-1.59 1.59-1.59h2.47c.42 0 .83.16 1.13.47l6.14 6.13-4.73 4.73-6.13-6.15zM3.01 3h2v2H3V3h.01z"/></svg>',
	terminal: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 10h4v1H7v-1zm-3 1l3-3-3-3-.75.75L5.5 8l-2.25 2.25L4 11zm10-8v10c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h12c.55 0 1 .45 1 1zm-1 0H1v10h12V3z"/></svg>',
	loading: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="32" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M10.24 7.4a4.15 4.15 0 0 1-1.2 3.6 4.346 4.346 0 0 1-5.41.54L4.8 10.4.5 9.8l.6 4.2 1.31-1.26c2.36 1.74 5.7 1.57 7.84-.54a5.876 5.876 0 0 0 1.74-4.46l-1.75-.34zM2.96 5a4.346 4.346 0 0 1 5.41-.54L7.2 5.6l4.3.6-.6-4.2-1.31 1.26c-2.36-1.74-5.7-1.57-7.85.54C.5 5.03-.06 6.65.01 8.26l1.75.35A4.17 4.17 0 0 1 2.96 5z"/></svg>',
	refresh: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M 8.244,15.672 C 11.441,15.558 14.868,13.024 14.828,8.55 14.773,6.644 13.911,4.852 12.456,3.619 l -1.648,1.198 c 1.265,0.861 2.037,2.279 2.074,3.809 0.016,2.25 -1.808,5.025 -4.707,5.077 -2.898,0.052 -4.933,-2.08 -5.047,-4.671 C 3.07,6.705 4.635,4.651 6.893,4.088 l 0.041,1.866 3.853,-3.126 -3.978,-2.772 0.032,2.077 c -3.294,0.616 -5.755,3.541 -5.667,6.982 -3.88e-4,4.233 3.873,6.670 7.07,6.557 z"/></svg>',

	// The SVG icons below (openFolder, closedFolder & file) are from https://icons8.com/icon/pack/free-icons/ios11, and are used under the licence on https://icons8.com/license, which is under https://creativecommons.org/licenses/by-nd/3.0/
	openFolder: '<svg xmlns="http://www.w3.org/2000/svg" class="openFolderIcon" viewBox="0 0 30 30"><path d="M 5 4 C 3.895 4 3 4.895 3 6 L 3 9 L 3 11 L 22 11 L 27 11 L 27 8 C 27 6.895 26.105 6 25 6 L 12.199219 6 L 11.582031 4.9707031 C 11.221031 4.3687031 10.570187 4 9.8671875 4 L 5 4 z M 2.5019531 13 C 1.4929531 13 0.77040625 13.977406 1.0664062 14.941406 L 4.0351562 24.587891 C 4.2941563 25.426891 5.0692656 26 5.9472656 26 L 15 26 L 24.052734 26 C 24.930734 26 25.705844 25.426891 25.964844 24.587891 L 28.933594 14.941406 C 29.229594 13.977406 28.507047 13 27.498047 13 L 15 13 L 2.5019531 13 z"/></svg>',
	closedFolder: '<svg xmlns="http://www.w3.org/2000/svg" class="closedFolderIcon" viewBox="0 0 30 30"><path d="M 4 3 C 2.895 3 2 3.895 2 5 L 2 8 L 13 8 L 28 8 L 28 7 C 28 5.895 27.105 5 26 5 L 11.199219 5 L 10.582031 3.9707031 C 10.221031 3.3687031 9.5701875 3 8.8671875 3 L 4 3 z M 3 10 C 2.448 10 2 10.448 2 11 L 2 23 C 2 24.105 2.895 25 4 25 L 26 25 C 27.105 25 28 24.105 28 23 L 28 11 C 28 10.448 27.552 10 27 10 L 3 10 z"/></svg>',
	file: '<svg xmlns="http://www.w3.org/2000/svg" class="fileIcon" viewBox="0 0 30 30"><path d="M24.707,8.793l-6.5-6.5C18.019,2.105,17.765,2,17.5,2H7C5.895,2,5,2.895,5,4v22c0,1.105,0.895,2,2,2h16c1.105,0,2-0.895,2-2 V9.5C25,9.235,24.895,8.981,24.707,8.793z M18,10c-0.552,0-1-0.448-1-1V3.904L23.096,10H18z"/></svg>',

	// The SVG icons below are custom made
	arrowDown: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14"><path fill-rule="evenodd" d="M6,1L6,10.1L2.7,6.8L1.3,8.2L7,13.9L12.7,8.2L11.3,6.8L8,10.1L8,1L6,1z"/></svg>',
	arrowUp: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14"><path fill-rule="evenodd" d="M6,13L6,3.9L2.7,7.2L1.3,5.8L7,0.1L12.7,5.8L11.3,7.2L8,3.9L8,13L6,13z"/></svg>',
	cdv: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14"><path fill-rule="evenodd" d="M0,2V3.5H2V2ZM3.5,2V3.5H14V2ZM0,5v7H14V5Zm1,1.5h5.5v4H1Zm6.5,0H13v4H7.5Z"/></svg>',
	close: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14"><path fill-rule="evenodd" d="M3.8,2.4L2.4,3.8L5.7,7L2.4,10.2L3.8,11.6L7,8.3L10.2,11.6L11.6,10.2L8.3,7L11.6,3.8L10.2,2.4L7,5.7L3.8,2.4z"/></svg>',
	failed: '<svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 13 13"><path fill-rule="evenodd" d="M 6.5,0 A 6.5,6.5 0 0 0 0,6.5 6.5,6.5 0 0 0 6.5,13 6.5,6.5 0 0 0 13,6.5 6.5,6.5 0 0 0 6.5,0 Z M 4.1,2.54 6.5,4.95 8.9,2.54 10.46,4.1 8.05,6.5 10.46,8.9 8.9,10.46 6.5,8.05 4.1,10.46 2.54,8.9 4.95,6.5 2.54,4.1 Z"/></svg>',
	fileList: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M 2,3 V 4.5 H 4 V 3 Z M 5.5,3 V 4.5 H 18 V 3 Z M 2,7 V 8.5 H 4 V 7 Z M 5.5,7 V 8.5 H 18 V 7 Z M 2,11 v 1.5 H 4 V 11 Z m 3.5,0 v 1.5 H 18 V 11 Z M 2,15 v 1.5 H 4 V 15 Z m 3.5,0 v 1.5 H 18 V 15 Z"/></svg>',
	fileTree: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M 2,3 V 4.5 H 4 V 3 Z M 5.5,3 V 4.5 H 14 V 3 Z M 4,7 V 8.5 H 6 V 7 Z M 7.5,7 V 8.5 H 16 V 7 Z M 6,11 v 1.5 H 8 V 11 Z m 3.5,0 v 1.5 H 18 V 11 Z M 4,15 v 1.5 H 6 V 15 Z m 3.5,0 v 1.5 H 16 V 15 Z"/></svg>',
	inconclusive: '<svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 13 13"><path fill-rule="evenodd" d="M 6.5,0 C 2.91,0 0,2.91 0,6.5 0,10.09 2.91,13 6.5,13 10.09,13 13,10.09 13,6.5 13,2.91 10.09,0 6.5,0 Z m 0.03,2.35 v 0 c 0.47,0 0.88,0.05 1.24,0.14 0.36,0.1 0.67,0.23 0.93,0.41 0.24,0.18 0.43,0.4 0.58,0.67 0.14,0.27 0.2,0.58 0.2,0.93 0,0.23 0,0.45 -0.09,0.63 C 9.3,5.31 9.14,5.49 9.05,5.62 8.91,5.79 8.9,5.82 8.7,6.02 8.53,6.2 8.35,6.36 8.15,6.5 8.03,6.6 7.94,6.7 7.85,6.79 7.77,6.88 7.7,6.97 7.65,7.08 7.6,7.18 7.56,7.29 7.53,7.4 7.5,7.52 7.5,7.54 7.5,7.67 H 5.75 c 0,-0.23 0,-0.33 0.03,-0.51 C 5.81,6.96 5.86,6.78 5.93,6.61 5.99,6.46 6.08,6.31 6.2,6.16 6.32,6.02 6.44,5.89 6.64,5.76 6.93,5.56 7.02,5.44 7.15,5.21 7.28,4.98 7.36,4.81 7.36,4.58 7.36,4.29 7.3,4.1 7.15,3.96 7.01,3.82 6.82,3.76 6.53,3.76 6.43,3.76 6.33,3.78 6.21,3.81 6.09,3.84 6.03,3.9 5.94,3.98 5.86,4.05 5.79,4.1 5.73,4.19 5.66,4.27 5.63,4.38 5.64,4.49 H 3.52 C 3.52,4.09 3.66,3.9 3.81,3.61 3.96,3.32 4.18,3.07 4.44,2.89 4.71,2.71 5.02,2.58 5.38,2.49 5.75,2.4 6.14,2.35 6.53,2.35 Z M 6.14,8.72 H 7.2 c 0.3,0 0.53,0.24 0.53,0.53 v 1.07 0 c 0,0.3 -0.23,0.53 -0.53,0.53 H 6.14 c -0.29,0 -0.53,-0.24 -0.53,-0.53 V 9.25 c 0,-0.3 0.25,-0.53 0.53,-0.53 z"/></svg>',
	linkExternal: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3,3L3,17L17,17L17,13L15.5,13L15.5,15.5L4.5,15.5L4.5,4.5L7,4.5L7,3L3,3z M10,3L10,4.5L14.4,4.5L9.3,9.7L10.3,10.7L15.5,5.6L15.5,10L17,10L17,3L10,3z"/></svg>',
	passed: '<svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 13 13"><path fill-rule="evenodd" d="M 6.5,0 A 6.5,6.5 0 0 0 0,6.5 6.5,6.5 0 0 0 6.5,13 6.5,6.5 0 0 0 13,6.5 6.5,6.5 0 0 0 6.5,0 Z M 9.64,2.95 11.2,4.5 5.02,10.68 C 3.92,9.57 2.81,8.46 1.7,7.35 L 3.26,5.8 5.02,7.57 Z"/></svg>',
	plus: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14"><path fill-rule="evenodd" d="M6,2V6H2v2h4v4H8V8h4V6H8V2Z"/></svg>',
	review: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill-rule="evenodd" d="m4,4.7 -4,7.3 4,7.3 2.5,0 -4,-7.3 4,-7.3zM11.5,6C9,5.5 6.6,7.1 6.1,9.6c-0.5,2.6 1.1,5 3.6,5.5 1,0.2 1.8,0.1 2.7,-0.3l2.5,3.3c0.1,0.1 0.3,0.2 0.5,0.3 0.2,0 0.4,0 0.6,-0.1 0.3,-0.2 0.4,-0.4 0.4,-0.6 0,-0.2 0,-0.4 -0.1,-0.6 0,-0.2 -2.4,-3.3 -2.4,-3.3 0.7,-0.6 1,-1.5 1.3,-2.4C15.7,8.9 14,6.5 11.5,6zm8.5,-1.3 -2.5,0 4,7.3 -4.2,7.3 2.5,0L24,12zm-8.8,3c1.6,0.3 2.6,1.8 2.3,3.4 -0.3,1.6 -1.8,2.6 -3.4,2.3C8.5,13 7.4,11.6 7.8,10 8,8.4 9.6,7.3 11.2,7.7z"/></svg>'
};

const GIT_FILE_CHANGE_TYPES = { 'A': 'Added', 'M': 'Modified', 'D': 'Deleted', 'R': 'Renamed', 'U': 'Untracked' };
const GIT_SIGNATURE_STATUS_DESCRIPTIONS = {
	'G': 'Valid Signature',
	'U': 'Good Signature with Unknown Validity',
	'X': 'Good Signature that has Expired',
	'Y': 'Good Signature made by an Expired Key',
	'R': 'Good Signature made by a Revoked Key',
	'E': 'Signature could not be checked',
	'B': 'Bad Signature'
};
const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const REF_INVALID_REGEX = /^[-\/].*|[\\" ><~^:?*[]|\.\.|\/\/|\/\.|@{|[.\/]$|\.lock$|^@$/g;

const HTML_ESCAPES: { [key: string]: string } = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#x27;', '/': '&#x2F;' };
const HTML_UNESCAPES: { [key: string]: string } = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', '&#x27;': '\'', '&#x2F;': '/' };
const HTML_ESCAPER_REGEX = /[&<>"'\/]/g;
const HTML_UNESCAPER_REGEX = /&lt;|&gt;|&amp;|&quot;|&#x27;|&#x2F;/g;

const ELLIPSIS = '&#8230;';
const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
const UNCOMMITTED = '*';
const SHOW_ALL_BRANCHES = '';

const COLUMN_HIDDEN = -100;
const COLUMN_AUTO = -101;

const COLUMN_MIN_WIDTH = 40;
const COLUMN_LEFT_RIGHT_PADDING = 24;

const CLASS_ACTIVE = 'active';
const CLASS_BRANCH_LABELS_ALIGNED_TO_GRAPH = 'branchLabelsAlignedToGraph';
const CLASS_COMMIT_DETAILS_OPEN = 'commitDetailsOpen';
const CLASS_DISABLED = 'disabled';
const CLASS_ENABLED = 'enabled';
const CLASS_FETCH_SUPPORTED = 'fetchSupported';
const CLASS_FOCUSSED = 'focussed';
const CLASS_LOADING = 'loading';
const CLASS_PENDING_REVIEW = 'pendingReview';
const CLASS_REFRESHING = 'refreshing';
const CLASS_REF_HEAD = 'head';
const CLASS_REF_REMOTE = 'remote';
const CLASS_REF_STASH = 'stash';
const CLASS_REF_TAG = 'tag';
const CLASS_SELECTED = 'selected';
const CLASS_TAG_LABELS_RIGHT_ALIGNED = 'tagLabelsRightAligned';
const CLASS_TRANSITION = 'transition';

const ID_EVENT_CAPTURE_ELEM = 'eventCaptureElem';

const CSS_PROP_FONT_FAMILY = '--vscode-font-family';
const CSS_PROP_EDITOR_FONT_FAMILY = '--vscode-editor-font-family';
const CSS_PROP_FIND_MATCH_HIGHLIGHT_BACKGROUND = '--vscode-editor-findMatchHighlightBackground';
const CSS_PROP_SELECTION_BACKGROUND = '--vscode-selection-background';
const CSS_PROP_LIMIT_GRAPH_WIDTH = '--limitGraphWidth';

const ATTR_ERROR = 'data-error';


/* General Helpers */

/**
 * Are two arrays equal, such that corresponding elements at each index are equal according to the `equalElements` method.
 * @param a An array.
 * @param b An array.
 * @param equalElements A function used to determine if two elements, each at the same index of `a` & `b`, are equal.
 * @returns TRUE => The arrays are equal, FALSE => The arrays are not equal
 */
function arraysEqual<T>(a: ReadonlyArray<T>, b: ReadonlyArray<T>, equalElements: (a: T, b: T) => boolean) {
	if (a.length !== b.length) return false;
	for (let i = 0; i < a.length; i++) {
		if (!equalElements(a[i], b[i])) return false;
	}
	return true;
}

/**
 * Are two arrays equal, such that corresponding elements at each index are strictly equal.
 * @param a An array.
 * @param b An array.
 * @returns TRUE => The arrays are equal, FALSE => The arrays are not equal
 */
function arraysStrictlyEqual<T>(a: ReadonlyArray<T>, b: ReadonlyArray<T>) {
	if (a.length !== b.length) return false;
	for (let i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) return false;
	}
	return true;
}

/**
 * Are two arrays equal, such that corresponding elements of each array are in strictly equal to an element in the other array (i.e. the order of elements doesn't matter).
 * @param a An array.
 * @param b An array.
 * @returns TRUE => The arrays are equal, FALSE => The arrays are not equal
 */
function arraysStrictlyEqualIgnoringOrder<T>(a: ReadonlyArray<T>, b: ReadonlyArray<T>) {
	if (a.length !== b.length) return false;
	for (let i = 0; i < a.length; i++) {
		if (b.indexOf(a[i]) === -1) return false;
	}
	return true;
}

/**
 * Modify the opacity of an RGB/RGBA/HEX colour by multiplying it by a new opacity.
 * @param colour The colour to modify.
 * @param opacity The multiplier for the opacity (between 0 & 1).
 * @returns An equivalent RGBA colour with the applied opacity.
 */
function modifyColourOpacity(colour: string, opacity: number) {
	let fadedCol = 'rgba(0,0,0,0)', match;
	if ((match = colour.match(/rgba\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)/)) !== null) {
		fadedCol = 'rgba(' + match[1] + ',' + match[2] + ',' + match[3] + ',' + (parseFloat(match[4]) * opacity).toFixed(2) + ')';
	} else if ((match = colour.match(/#\s*([0-9a-fA-F]+)/)) !== null) {
		let hex = match[1];
		let length = hex.length;
		if (length === 3 || length === 4 || length === 6 || length === 8) {
			let col = length < 5
				? { r: hex[0] + hex[0], g: hex[1] + hex[1], b: hex[2] + hex[2], a: length === 4 ? hex[3] + hex[3] : 'ff' }
				: { r: hex[0] + hex[1], g: hex[2] + hex[3], b: hex[4] + hex[5], a: length === 8 ? hex[6] + hex[7] : 'ff' };
			fadedCol = 'rgba(' + parseInt(col.r, 16) + ',' + parseInt(col.g, 16) + ',' + parseInt(col.b, 16) + ',' + (parseInt(col.a, 16) * opacity / 255).toFixed(2) + ')';
		}
	} else if ((match = colour.match(/rgb\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)/)) !== null) {
		fadedCol = 'rgba(' + match[1] + ',' + match[2] + ',' + match[3] + ',' + opacity + ')';
	}
	return fadedCol;
}

/**
 * Pad a number with a leading zero, so it contains at least two digits.
 * @param i The number to pad.
 * @returns The padded number.
 */
function pad2(i: number) {
	return i > 9 ? i : '0' + i;
}

/**
 * Get a short name for a repository.
 * @param path The path of the repository.
 * @returns The short name.
 */
function getRepoName(path: string) {
	const firstSep = path.indexOf('/');
	if (firstSep === path.length - 1 || firstSep === -1) {
		return path; // Path has no slashes, or a single trailing slash ==> use the path
	} else {
		const p = path.endsWith('/') ? path.substring(0, path.length - 1) : path; // Remove trailing slash if it exists
		return p.substring(p.lastIndexOf('/') + 1);
	}
}

/**
 * Get a sorted list of repository paths from a given GitRepoSet.
 * @param repos The set of repositories.
 * @param order The order to sort the repositories.
 * @returns An array of ordered repository paths.
 */
function getSortedRepositoryPaths(repos: GG.GitRepoSet, order: GG.RepoDropdownOrder): ReadonlyArray<string> {
	const repoPaths = Object.keys(repos);
	if (order === GG.RepoDropdownOrder.WorkspaceFullPath) {
		return repoPaths.sort((a, b) => repos[a].workspaceFolderIndex === repos[b].workspaceFolderIndex
			? a.localeCompare(b)
			: repos[a].workspaceFolderIndex === null
				? 1
				: repos[b].workspaceFolderIndex === null
					? -1
					: repos[a].workspaceFolderIndex! - repos[b].workspaceFolderIndex!
		);
	} else if (order === GG.RepoDropdownOrder.FullPath) {
		return repoPaths.sort((a, b) => a.localeCompare(b));
	} else {
		return repoPaths.map((path) => ({ name: repos[path].name || getRepoName(path), path: path }))
			.sort((a, b) => a.name !== b.name ? a.name.localeCompare(b.name) : a.path.localeCompare(b.path))
			.map((x) => x.path);
	}
}


/* HTML Escape / Unescape */

/**
 * Escape HTML in the specified string.
 * @param str The string to escape.
 * @returns The escaped string.
 */
function escapeHtml(str: string) {
	return str.replace(HTML_ESCAPER_REGEX, (match) => HTML_ESCAPES[match]);
}

/**
 * Unescape HTML in the specified string.
 * @param str The string to unescape.
 * @returns The unescaped string.
 */
function unescapeHtml(str: string) {
	return str.replace(HTML_UNESCAPER_REGEX, (match) => HTML_UNESCAPES[match]);
}


/* Formatters */

/**
 * Format an array of strings as a comma separated list.
 * @param items The array of strings.
 * @returns A formatted comma separated string (e.g. "A, B & C").
 */
function formatCommaSeparatedList(items: string[]) {
	let str = '';
	for (let i = 0; i < items.length; i++) {
		str += (i > 0 ? (i < items.length - 1 ? ', ' : ' & ') : '') + items[i];
	}
	return str;
}

/**
 * Format a date (short).
 * @param unixTimestamp The unix timestamp of the date to format.
 * @returns The formatted date.
 */
function formatShortDate(unixTimestamp: number) {
	const date = new Date(unixTimestamp * 1000), format = initialState.config.dateFormat;
	let dateStr = format.iso
		? date.getFullYear() + '-' + pad2(date.getMonth() + 1) + '-' + pad2(date.getDate())
		: date.getDate() + ' ' + MONTHS[date.getMonth()] + ' ' + date.getFullYear();
	let hourMinsStr = pad2(date.getHours()) + ':' + pad2(date.getMinutes());
	let formatted;

	if (format.type === GG.DateFormatType.DateAndTime) {
		formatted = dateStr + ' ' + hourMinsStr;
	} else if (format.type === GG.DateFormatType.DateOnly) {
		formatted = dateStr;
	} else {
		let diff = Math.round((new Date()).getTime() / 1000) - unixTimestamp, unit;
		if (diff < 60) {
			unit = 'second';
		} else if (diff < 3600) {
			unit = 'minute';
			diff /= 60;
		} else if (diff < 86400) {
			unit = 'hour';
			diff /= 3600;
		} else if (diff < 604800) {
			unit = 'day';
			diff /= 86400;
		} else if (diff < 2629800) {
			unit = 'week';
			diff /= 604800;
		} else if (diff < 31557600) {
			unit = 'month';
			diff /= 2629800;
		} else {
			unit = 'year';
			diff /= 31557600;
		}
		diff = Math.round(diff);
		formatted = diff + ' ' + unit + (diff !== 1 ? 's' : '') + ' ago';
	}
	return {
		title: dateStr + ' ' + hourMinsStr + ':' + pad2(date.getSeconds()),
		formatted: formatted
	};
}

/**
 * Format a date (long).
 * @param unixTimestamp The unix timestamp of the date to format.
 * @returns The formatted date.
 */
function formatLongDate(unixTimestamp: number) {
	const date = new Date(unixTimestamp * 1000);
	if (initialState.config.dateFormat.iso) {
		let timezoneOffset = date.getTimezoneOffset();
		let absoluteTimezoneOffset = Math.abs(timezoneOffset);
		let timezone = timezoneOffset === 0 ? 'Z' : ' ' + (timezoneOffset < 0 ? '+' : '-') + pad2(Math.floor(absoluteTimezoneOffset / 60)) + pad2(absoluteTimezoneOffset % 60);
		return date.getFullYear() + '-' + pad2(date.getMonth() + 1) + '-' + pad2(date.getDate()) + ' ' + pad2(date.getHours()) + ':' + pad2(date.getMinutes()) + ':' + pad2(date.getSeconds()) + timezone;
	} else {
		return date.toString();
	}
}


/* DOM Helpers */

/**
 * Add an event listener to all elements with a class name.
 * @param className The class name used to identify the elements to add the event listener to.
 * @param event The event to listen for on each element.
 * @param eventListener The event listener to be called when the event occurs.
 */
function addListenerToClass(className: string, event: string, eventListener: EventListener) {
	addListenerToCollectionElems(document.getElementsByClassName(className), event, eventListener);
}

/**
 * Add an event listener to all elements in a collection of elements.
 * @param elems The collection of elements to add the event listener to.
 * @param event The event to listen for on each element.
 * @param eventListener The event listener to be called when the event occurs.
 */
function addListenerToCollectionElems(elems: HTMLCollectionOf<Element>, event: string, eventListener: EventListener) {
	for (let i = 0; i < elems.length; i++) {
		elems[i].addEventListener(event, eventListener);
	}
}

/**
 * Insert an HTML Element directly after a reference HTML Element (as a sibling).
 * @param newNode The HTML Element to insert.
 * @param referenceNode The reference HTML element that `newNode` should be inserted after.
 */
function insertAfter(newNode: HTMLElement, referenceNode: HTMLElement) {
	referenceNode.parentNode!.insertBefore(newNode, referenceNode.nextSibling);
}

/**
 * Insert an HTML Element directly before the first child element with a specified class name.
 * @param newChild The HTML Element to insert.
 * @param parent The parent element that the `newChild` should be inserted into as a child.
 * @param className The class name identifying the child that `newChild` should be inserted before.
 */
function insertBeforeFirstChildWithClass(newChild: HTMLElement, parent: HTMLElement, className: string) {
	let referenceNode: Node | null = null;
	for (let i = 0; i < parent.children.length; i++) {
		if (parent.children[i].classList.contains(className)) {
			referenceNode = parent.children[i];
			break;
		}
	}
	parent.insertBefore(newChild, referenceNode);
}

/**
 * Alter an HTML Element such that it contains, or doesn't contain the specified class name.
 * @param elem The HTML Element to alter.
 * @param className The class name.
 * @param state TRUE => Ensure the HTML Element has the class name, FALSE => Ensure the HTML Element doesn't have the class name
 * @returns TRUE => The HTML Element was altered, FALSE => No change was required.
 */
function alterClass(elem: HTMLElement, className: string, state: boolean) {
	if (elem.classList.contains(className) !== state) {
		if (state) {
			elem.classList.add(className);
		} else {
			elem.classList.remove(className);
		}
		return true;
	}
	return false;
}

/**
 * Alter each HTML Element in a collection of HTML Elements, such that it contains, or doesn't contain the specified class name.
 * @param elems The collection of HTML Elements.
 * @param className The class name.
 * @param state TRUE => Ensure all HTML Elements have the class name, FALSE => Ensure no HTML Elements have the class name
 */
function alterClassOfCollection(elems: HTMLCollectionOf<HTMLElement>, className: string, state: boolean) {
	const lockedElems = [];
	for (let i = 0; i < elems.length; i++) {
		lockedElems.push(elems[i]);
	}
	for (let i = 0; i < lockedElems.length; i++) {
		alterClass(lockedElems[i], className, state);
	}
}

/**
 * Recursively get all of the child nodes of a node that have text content.
 * @param elem The node to recursively traverse.
 * @returns An array of all child nodes that have text content.
 */
function getChildNodesWithTextContent(elem: Node) {
	let textChildren: Node[] = [];
	for (let i = 0; i < elem.childNodes.length; i++) {
		if (elem.childNodes[i].childNodes.length > 0) {
			textChildren.push(...getChildNodesWithTextContent(elem.childNodes[i]));
		} else if (elem.childNodes[i].textContent !== null && elem.childNodes[i].textContent !== '') {
			textChildren.push(elem.childNodes[i]);
		}
	}
	return textChildren;
}

/**
 * Recursively get all of the child elements of an element that have the specified class name.
 * @param elem The element to recursively traverse.
 * @param className The class name to find.
 * @returns An array of all child elements that have the specified class name.
 */
function getChildrenWithClassName(elem: Element, className: string) {
	let children: Element[] = [];
	for (let i = 0; i < elem.children.length; i++) {
		if (elem.children[i].children.length > 0) {
			children.push(...getChildrenWithClassName(elem.children[i], className));
		} else if (elem.children[i].className === className) {
			children.push(elem.children[i]);
		}
	}
	return children;
}

/**
 * Get the first child of an HTML Element that is a \<ul\>.
 * @param elem The parent HTML Element.
 * @returns The HTML Element, or NULL if no child is a \<ul\>.
 */
function getChildUl(elem: HTMLElement) {
	for (let i = 0; i < elem.children.length; i++) {
		if (elem.children[i].tagName === 'UL') {
			return <HTMLUListElement>elem.children[i];
		}
	}
	return null;
}

/**
 * Initialise scrollTop, and observe scroll events for an HTML Element. Invoke callbacks when the element has been scrolled, and when scrollTop should be saved.
 * @param id The ID identifying the HTML Element.
 * @param initialScrollTop The value used to initialise scrollTop.
 * @param onScroll A callback to be invoked when the element has been scrolled.
 * @param onScrolled A callback to be invoked when scrollTop should be saved.
 */
function observeElemScroll(id: string, initialScrollTop: number, onScroll: (scrollTop: number) => void, onScrolled: () => void) {
	const elem = document.getElementById(id);
	if (elem === null) return;

	let timeout: NodeJS.Timer | null = null;
	elem.scroll(0, initialScrollTop);
	elem.addEventListener('scroll', () => {
		const elem = document.getElementById(id);
		if (elem === null) return;

		onScroll(elem.scrollTop);

		if (timeout !== null) clearTimeout(timeout);
		timeout = setTimeout(() => {
			onScrolled();
			timeout = null;
		}, 250);
	});
}

/**
 * Get all of the rendered commit HTML Elements.
 * @returns A collection of all commit HTML Elements.
 */
function getCommitElems() {
	return <HTMLCollectionOf<HTMLElement>>document.getElementsByClassName('commit');
}

/**
 * Register that an event has been handled, to prevent the default behaviour from occurring, and any further handling of the event.
 * @param event The event.
 */
function handledEvent(event: Event) {
	event.preventDefault();
	event.stopPropagation();
}


/* State Helpers */

/**
 * Update a key-value pair in the Global View State.
 * @param key The key identifying the value to update.
 * @param value The new value.
 */
function updateGlobalViewState<K extends keyof GG.GitGraphViewGlobalState>(key: K, value: GG.GitGraphViewGlobalState[K]) {
	(<GG.DeepWriteable<GG.GitGraphViewGlobalState>>globalState)[key] = value;
	sendMessage({ command: 'setGlobalViewState', state: globalState });
}

/**
 * Update a key-value pair in the Workspace View State.
 * @param key The key identifying the value to update.
 * @param value The new value.
 */
function updateWorkspaceViewState<K extends keyof GG.GitGraphViewWorkspaceState>(key: K, value: GG.GitGraphViewWorkspaceState[K]) {
	(<GG.DeepWriteable<GG.GitGraphViewWorkspaceState>>workspaceState)[key] = value;
	sendMessage({ command: 'setWorkspaceViewState', state: workspaceState });
}


/* VSCode Helpers */

/**
 * Send a message to the extension's back-end (typically to request data, or perform an action).
 * @param msg The message to send.
 */
function sendMessage(msg: GG.RequestMessage) {
	VSCODE_API.postMessage(msg);
}

/**
 * Show a Visual Studio Code Error Message.
 * @param message The message to display.
 */
function showErrorMessage(message: string) {
	sendMessage({ command: 'showErrorMessage', message: message });
}

/**
 * Get the value of a Visual Studio Code style variable.
 * @param name The name of the style variable.
 * @returns The value of the style variable.
 */
function getVSCodeStyle(name: string) {
	return document.documentElement.style.getPropertyValue(name);
}


/**
 * Resizes images for the view (e.g. commit author avatars).
 */
class ImageResizer {
	private canvas: HTMLCanvasElement | null = null;
	private context: CanvasRenderingContext2D | null = null;

	/**
	 * Resize an image to have an effective resolution of 18px x 18px. The actual resolution varies depending of the user's screen pixel ratio.
	 * @param dataUri The data URI containing the image data.
	 * @param callback A callback to be invoked once the image has been resized, with the resized image.
	 */
	public resize(dataUri: string, callback: (dataUri: string) => void) {
		if (this.canvas === null) this.canvas = document.createElement('canvas');
		if (this.context === null) this.context = this.canvas.getContext('2d');
		if (this.context === null) {
			callback(dataUri);
			return;
		}

		let image = new Image();
		image.onload = () => {
			let outputDataUri = '';
			if (this.canvas === null || this.context === null) {
				outputDataUri = dataUri;
			} else {
				let size = Math.ceil(18 * window.devicePixelRatio);
				if (this.canvas.width !== size) this.canvas.width = size;
				if (this.canvas.height !== size) this.canvas.height = size;
				this.context.clearRect(0, 0, size, size);
				this.context.drawImage(image, 0, 0, size, size);
				outputDataUri = this.canvas.toDataURL();
			}
			callback(outputDataUri);
		};
		image.src = dataUri;
	}
}


/**
 * Implements an Event Overlay, which is used for blocking and/or capturing mouse events in the view.
 */
class EventOverlay {
	private move: EventListener | null = null;
	private stop: EventListener | null = null;

	/**
	 * Create an event overlay.
	 * @param className The class name to be used for the event overlay.
	 * @param move A callback to be invoked if the user moves the mouse over the event overlay.
	 * @param stop A callback to be invoked if the user moves the mouse off the event overlay.
	 */
	public create(className: string, move: EventListener | null, stop: EventListener | null) {
		if (document.getElementById(ID_EVENT_CAPTURE_ELEM) !== null) this.remove();

		const eventOverlayElem = document.createElement('div');
		eventOverlayElem.id = ID_EVENT_CAPTURE_ELEM;
		eventOverlayElem.className = className;

		this.move = move;
		this.stop = stop;
		if (this.move !== null) {
			eventOverlayElem.addEventListener('mousemove', this.move);
		}
		if (this.stop !== null) {
			eventOverlayElem.addEventListener('mouseup', this.stop);
			eventOverlayElem.addEventListener('mouseleave', this.stop);
		}

		if (contextMenu.isOpen()) {
			contextMenu.close();
		}

		document.body.appendChild(eventOverlayElem);
	}

	/**
	 * Remove the event overlay that is currently active in the view.
	 */
	public remove() {
		let eventOverlayElem = document.getElementById(ID_EVENT_CAPTURE_ELEM);
		if (eventOverlayElem === null) return;

		if (this.move !== null) {
			eventOverlayElem.removeEventListener('mousemove', this.move);
			this.move = null;
		}
		if (this.stop !== null) {
			eventOverlayElem.removeEventListener('mouseup', this.stop);
			eventOverlayElem.removeEventListener('mouseleave', this.stop);
			this.stop = null;
		}

		document.body.removeChild(eventOverlayElem);
	}
}
-e 

================================================================================
// FILE: ./web/contextMenu.ts
================================================================================
const CLASS_CONTEXT_MENU_ACTIVE = 'contextMenuActive';

interface ContextMenuAction {
	readonly title: string;
	readonly visible: boolean;
	readonly onClick: () => void;
	readonly checked?: boolean; // Required in checked context menus
}

type ContextMenuActions = ReadonlyArray<ReadonlyArray<ContextMenuAction>>;

type ContextMenuTarget = {
	type: TargetType.Commit | TargetType.Ref | TargetType.CommitDetailsView;
	elem: HTMLElement;
	hash: string;
	index: number;
	ref?: string;
} | RepoTarget;

/**
 * Implements the Git Graph View's context menus.
 */
class ContextMenu {
	private elem: HTMLElement | null = null;
	private onClose: (() => void) | null = null;
	private target: ContextMenuTarget | null = null;

	/**
	 * Construct a new ContextMenu instance.
	 * @returns The ContextMenu instance.
	 */
	constructor() {
		const listener = () => this.close();
		document.addEventListener('click', listener);
		document.addEventListener('contextmenu', listener);
	}

	/**
	 * Show a context menu in the Git Graph View.
	 * @param actions The collection of actions to display in the context menu.
	 * @param checked Should the context menu display checks to the left of each action.
	 * @param target The target that the context menu was triggered on.
	 * @param event The mouse event that triggered the context menu.
	 * @param frameElem The HTML Element that the context menu should be rendered within (and be positioned relative to it's content).
	 * @param onClose An optional callback to be invoked when the context menu is closed.
	 * @param className An optional class name to add to the context menu.
	 */
	public show(actions: ContextMenuActions, checked: boolean, target: ContextMenuTarget | null, event: MouseEvent, frameElem: HTMLElement, onClose: (() => void) | null = null, className: string | null = null) {
		let html = '', handlers: (() => void)[] = [], handlerId = 0;
		this.close();

		for (let i = 0; i < actions.length; i++) {
			let groupHtml = '';
			for (let j = 0; j < actions[i].length; j++) {
				if (actions[i][j].visible) {
					groupHtml += '<li class="contextMenuItem" data-index="' + handlerId++ + '">' + (checked ? '<span class="contextMenuItemCheck">' + (actions[i][j].checked ? SVG_ICONS.check : '') + '</span>' : '') + actions[i][j].title + '</li>';
					handlers.push(actions[i][j].onClick);
				}
			}

			if (groupHtml !== '') {
				if (html !== '') html += '<li class="contextMenuDivider"></li>';
				html += groupHtml;
			}
		}

		if (handlers.length === 0) return; // No context menu actions are visible

		const menu = document.createElement('ul');
		menu.className = 'contextMenu' + (checked ? ' checked' : '') + (className !== null ? ' ' + className : '');
		menu.style.opacity = '0';
		menu.innerHTML = html;
		frameElem.appendChild(menu);
		const menuBounds = menu.getBoundingClientRect(), frameBounds = frameElem.getBoundingClientRect();
		const relativeX = event.pageX + menuBounds.width < frameBounds.right
			? -2 // context menu fits to the right
			: event.pageX - menuBounds.width > frameBounds.left
				? 2 - menuBounds.width // context menu fits to the left
				: -2 - (menuBounds.width - (frameBounds.width - (event.pageX - frameBounds.left))); // Overlap the context menu horizontally with the cursor
		const relativeY = event.pageY + menuBounds.height < frameBounds.bottom
			? -2 // context menu fits below
			: event.pageY - menuBounds.height > frameBounds.top
				? 2 - menuBounds.height // context menu fits above
				: -2 - (menuBounds.height - (frameBounds.height - (event.pageY - frameBounds.top))); // Overlap the context menu vertically with the cursor
		menu.style.left = (frameElem.scrollLeft + Math.max(event.pageX - frameBounds.left + relativeX, 2)) + 'px';
		menu.style.top = (frameElem.scrollTop + Math.max(event.pageY - frameBounds.top + relativeY, 2)) + 'px';
		menu.style.opacity = '1';
		this.elem = menu;
		this.onClose = onClose;

		addListenerToClass('contextMenuItem', 'click', (e) => {
			// The user clicked on a context menu item => call the corresponding handler
			e.stopPropagation();
			this.close();
			handlers[parseInt((<HTMLElement>(<Element>e.target).closest('.contextMenuItem')!).dataset.index!)]();
		});

		menu.addEventListener('click', (e) => {
			// The user clicked on the context menu (but not a specific item) => keep the context menu open to allow the user to reattempt clicking on a specific item
			e.stopPropagation();
		});

		this.target = target;
		if (this.target !== null && this.target.type !== TargetType.Repo) {
			alterClass(this.target.elem, CLASS_CONTEXT_MENU_ACTIVE, true);
		}
	}

	/**
	 * Close the context menu (if one is currently open in the Git Graph View).
	 */
	public close() {
		if (this.elem !== null) {
			this.elem.remove();
			this.elem = null;
		}
		alterClassOfCollection(<HTMLCollectionOf<HTMLElement>>document.getElementsByClassName(CLASS_CONTEXT_MENU_ACTIVE), CLASS_CONTEXT_MENU_ACTIVE, false);
		if (this.onClose !== null) {
			this.onClose();
			this.onClose = null;
		}
		this.target = null;
	}

	/**
	 * Refresh the context menu (if one is currently open in the Git Graph View). If the context menu has a dynamic source,
	 * re-link it to the newly rendered HTML Element, or close it if the target is no longer visible in the Git Graph View.
	 * @param commits The new array of commits that is rendered in the Git Graph View.
	 */
	public refresh(commits: ReadonlyArray<GG.GitCommit>) {
		if (!this.isOpen() || this.target === null || this.target.type === TargetType.Repo) {
			// Don't need to refresh if no context menu is open, or it is not dynamic
			return;
		}

		if (this.target.index < commits.length && commits[this.target.index].hash === this.target.hash) {
			// The commit still exists at the same index

			const commitElem = findCommitElemWithId(getCommitElems(), this.target.index);
			if (commitElem !== null) {
				if (typeof this.target.ref === 'undefined') {
					// ContextMenu is only dependent on the commit itself
					if (this.target.type !== TargetType.CommitDetailsView) {
						this.target.elem = commitElem;
						alterClass(this.target.elem, CLASS_CONTEXT_MENU_ACTIVE, true);
					}
					return;
				} else {
					// ContextMenu is dependent on the commit and ref
					const elems = <NodeListOf<HTMLElement>>commitElem.querySelectorAll('[data-fullref]');
					for (let i = 0; i < elems.length; i++) {
						if (elems[i].dataset.fullref! === this.target.ref) {
							this.target.elem = this.target.type === TargetType.Ref ? elems[i] : commitElem;
							alterClass(this.target.elem, CLASS_CONTEXT_MENU_ACTIVE, true);
							return;
						}
					}
				}
			}
		}

		this.close();
	}

	/**
	 * Is a context menu currently open in the Git Graph View.
	 * @returns TRUE => A context menu is open, FALSE => No context menu is open
	 */
	public isOpen() {
		return this.elem !== null;
	}

	/**
	 * Is the target of the context menu dynamic (i.e. is it tied to a Git object & HTML Element in the Git Graph View).
	 * @returns TRUE => The context menu is dynamic, FALSE => The context menu is not dynamic
	 */
	public isTargetDynamicSource() {
		return this.isOpen() && this.target !== null;
	}
}
-e 

================================================================================
// FILE: ./web/settingsWidget.ts
================================================================================
interface SettingsWidgetState {
	readonly currentRepo: string | null;
	readonly scrollTop: number;
}

/**
 * Implements the Git Graph View's Settings Widget.
 */
class SettingsWidget {
	private readonly view: GitGraphView;

	private currentRepo: string | null = null;
	private repo: Readonly<GG.GitRepoState> | null = null;
	private config: Readonly<GG.GitRepoConfig> | null = null;
	private loading: boolean = false;
	private scrollTop: number = 0;

	private readonly widgetElem: HTMLElement;
	private readonly contentsElem: HTMLElement;
	private readonly loadingElem: HTMLElement;

	/**
	 * Construct a new SettingsWidget instance.
	 * @param view The Git Graph View that the SettingsWidget is for.
	 * @returns The SettingsWidget instance.
	 */
	constructor(view: GitGraphView) {
		this.view = view;

		this.widgetElem = document.createElement('div');
		this.widgetElem.id = 'settingsWidget';
		this.widgetElem.innerHTML = '<h2>Repository Settings</h2><div id="settingsContent"></div><div id="settingsLoading"></div><div id="settingsClose"></div>';
		document.body.appendChild(this.widgetElem);

		observeElemScroll('settingsWidget', this.scrollTop, (scrollTop) => {
			this.scrollTop = scrollTop;
		}, () => {
			if (this.currentRepo !== null) {
				this.view.saveState();
			}
		});

		this.contentsElem = document.getElementById('settingsContent')!;
		this.loadingElem = document.getElementById('settingsLoading')!;

		const settingsClose = document.getElementById('settingsClose')!;
		settingsClose.innerHTML = SVG_ICONS.close;
		settingsClose.addEventListener('click', () => this.close());
	}

	/**
	 * Show the Settings Widget.
	 * @param currentRepo The repository that is currently loaded in the view.
	 * @param isInitialLoad Is this the initial load of the Setting Widget, or is it being shown when restoring a previous state.
	 * @param scrollTop The scrollTop the Settings Widget should initially be set to.
	 */
	public show(currentRepo: string, isInitialLoad: boolean = true, scrollTop: number = 0) {
		if (this.currentRepo !== null) return;
		this.currentRepo = currentRepo;
		this.scrollTop = scrollTop;
		alterClass(this.widgetElem, CLASS_TRANSITION, isInitialLoad);
		this.widgetElem.classList.add(CLASS_ACTIVE);
		this.view.saveState();
		this.refresh();
		if (isInitialLoad) {
			this.view.requestLoadConfig();
		}
	}

	/**
	 * Refresh the Settings Widget after an action affecting it's content has completed.
	 */
	public refresh() {
		if (this.currentRepo === null) return;
		this.repo = this.view.getRepoState(this.currentRepo);
		this.config = this.view.getRepoConfig();
		this.loading = this.view.isConfigLoading();
		this.render();
	}

	/**
	 * Close the Settings Widget, sliding it up out of view.
	 */
	public close() {
		if (this.currentRepo === null) return;
		this.currentRepo = null;
		this.repo = null;
		this.config = null;
		this.loading = false;
		this.widgetElem.classList.add(CLASS_TRANSITION);
		this.widgetElem.classList.remove(CLASS_ACTIVE);
		this.widgetElem.classList.remove(CLASS_LOADING);
		this.contentsElem.innerHTML = '';
		this.loadingElem.innerHTML = '';
		this.view.saveState();
	}


	/* State */

	/**
	 * Get the current state of the Settings Widget.
	 */
	public getState(): SettingsWidgetState {
		return {
			currentRepo: this.currentRepo,
			scrollTop: this.scrollTop
		};
	}

	/**
	 * Restore the Settings Widget to an existing state.
	 * @param state The previous Settings Widget state.
	 */
	public restoreState(state: SettingsWidgetState) {
		if (state.currentRepo === null) return;
		this.show(state.currentRepo, false, state.scrollTop);
	}

	/**
	 * Is the Settings Widget currently visible.
	 * @returns TRUE => The Settings Widget is visible, FALSE => The Settings Widget is not visible
	 */
	public isVisible() {
		return this.currentRepo !== null;
	}


	/* Render Methods */

	/**
	 * Render the Settings Widget.
	 */
	private render() {
		if (this.currentRepo !== null && this.repo !== null) {
			const escapedRepoName = escapeHtml(this.repo.name || getRepoName(this.currentRepo));

			const initialBranchesLocallyConfigured = this.repo.onRepoLoadShowCheckedOutBranch !== GG.BooleanOverride.Default || this.repo.onRepoLoadShowSpecificBranches !== null;
			const initialBranches: string[] = [];
			if (getOnRepoLoadShowCheckedOutBranch(this.repo.onRepoLoadShowCheckedOutBranch)) {
				initialBranches.push('Checked Out');
			}
			const branchOptions = this.view.getBranchOptions();
			getOnRepoLoadShowSpecificBranches(this.repo.onRepoLoadShowSpecificBranches).forEach((branch) => {
				const option = branchOptions.find((option) => option.value === branch);
				if (option) {
					initialBranches.push(option.name);
				}
			});
			const initialBranchesStr = initialBranches.length > 0
				? escapeHtml(formatCommaSeparatedList(initialBranches))
				: 'Show All';

			let html = '<div class="settingsSection general"><h3>General</h3>' +
				'<table>' +
				'<tr class="lineAbove"><td class="left">Name:</td><td class="leftWithEllipsis" title="' + escapedRepoName + (this.repo.name === null ? ' (Default Name from the File System)' : '') + '">' + escapedRepoName + '</td><td class="btns right"><div id="editRepoName" title="Edit Name' + ELLIPSIS + '">' + SVG_ICONS.pencil + '</div>' + (this.repo.name !== null ? ' <div id="deleteRepoName" title="Delete Name' + ELLIPSIS + '">' + SVG_ICONS.close + '</div>' : '') + '</td></tr>' +
				'<tr class="lineAbove lineBelow"><td class="left">Initial Branches:</td><td class="leftWithEllipsis" title="' + initialBranchesStr + ' (' + (initialBranchesLocallyConfigured ? 'Local' : 'Global') + ')">' + initialBranchesStr + '</td><td class="btns right"><div id="editInitialBranches" title="Edit Initial Branches' + ELLIPSIS + '">' + SVG_ICONS.pencil + '</div>' + (initialBranchesLocallyConfigured ? ' <div id="clearInitialBranches" title="Clear Initial Branches' + ELLIPSIS + '">' + SVG_ICONS.close + '</div>' : '') + '</td></tr>' +
				'</table>' +
				'<label id="settingsShowStashes"><input type="checkbox" id="settingsShowStashesCheckbox" tabindex="-1"><span class="customCheckbox"></span>Show Stashes</label><br/>' +
				'<label id="settingsShowTags"><input type="checkbox" id="settingsShowTagsCheckbox" tabindex="-1"><span class="customCheckbox"></span>Show Tags</label><br/>' +
				'<label id="settingsIncludeCommitsMentionedByReflogs"><input type="checkbox" id="settingsIncludeCommitsMentionedByReflogsCheckbox" tabindex="-1"><span class="customCheckbox"></span>Include commits only mentioned by reflogs</label><span class="settingsWidgetInfo" title="Only applies when showing all branches.">' + SVG_ICONS.info + '</span><br/>' +
				'<label id="settingsOnlyFollowFirstParent"><input type="checkbox" id="settingsOnlyFollowFirstParentCheckbox" tabindex="-1"><span class="customCheckbox"></span>Only follow the first parent of commits</label><span class="settingsWidgetInfo" title="Instead of following all parents of commits, only follow the first parent when discovering the commits to load.">' + SVG_ICONS.info + '</span>' +
				'</div>';

			let userNameSet = false, userEmailSet = false;
			if (this.config !== null) {
				html += '<div class="settingsSection centered"><h3>User Details</h3>';
				const userName = this.config.user.name, userEmail = this.config.user.email;
				userNameSet = userName.local !== null || userName.global !== null;
				userEmailSet = userEmail.local !== null || userEmail.global !== null;
				if (userNameSet || userEmailSet) {
					const escapedUserName = escapeHtml(userName.local ?? userName.global ?? 'Not Set');
					const escapedUserEmail = escapeHtml(userEmail.local ?? userEmail.global ?? 'Not Set');
					html += '<table>' +
						'<tr><td class="left">User Name:</td><td class="leftWithEllipsis" title="' + escapedUserName + (userNameSet ? ' (' + (userName.local !== null ? 'Local' : 'Global') + ')' : '') + '">' + escapedUserName + '</td></tr>' +
						'<tr><td class="left">User Email:</td><td class="leftWithEllipsis" title="' + escapedUserEmail + (userEmailSet ? ' (' + (userEmail.local !== null ? 'Local' : 'Global') + ')' : '') + '">' + escapedUserEmail + '</td></tr>' +
						'</table>' +
						'<div class="settingsSectionButtons"><div id="editUserDetails" class="editBtn">' + SVG_ICONS.pencil + 'Edit</div><div id="removeUserDetails" class="removeBtn">' + SVG_ICONS.close + 'Remove</div></div>';
				} else {
					html += '<span>User Details (such as name and email) are used by Git to record the Author and Committer of commit objects.</span>' +
						'<div class="settingsSectionButtons"><div id="editUserDetails" class="addBtn">' + SVG_ICONS.plus + 'Add User Details</div></div>';
				}
				html += '</div>';

				html += '<div class="settingsSection"><h3>Remote Configuration</h3><table><tr><th>Remote</th><th>URL</th><th>Type</th><th>Action</th></tr>';
				if (this.config.remotes.length > 0) {
					const hideRemotes = this.repo.hideRemotes;
					this.config.remotes.forEach((remote, i) => {
						const hidden = hideRemotes.includes(remote.name);
						const fetchUrl = escapeHtml(remote.url || 'Not Set'), pushUrl = escapeHtml(remote.pushUrl || remote.url || 'Not Set');
						html += '<tr class="lineAbove">' +
							'<td class="left" rowspan="2"><span class="hideRemoteBtn" data-index="' + i + '" title="Click to ' + (hidden ? 'show' : 'hide') + ' branches of this remote.">' + (hidden ? SVG_ICONS.eyeClosed : SVG_ICONS.eyeOpen) + '</span>' + escapeHtml(remote.name) + '</td>' +
							'<td class="leftWithEllipsis" title="Fetch URL: ' + fetchUrl + '">' + fetchUrl + '</td><td>Fetch</td>' +
							'<td class="btns remoteBtns" rowspan="2" data-index="' + i + '"><div class="fetchRemote" title="Fetch from Remote' + ELLIPSIS + '">' + SVG_ICONS.download + '</div> <div class="pruneRemote" title="Prune Remote' + ELLIPSIS + '">' + SVG_ICONS.branch + '</div><br><div class="editRemote" title="Edit Remote' + ELLIPSIS + '">' + SVG_ICONS.pencil + '</div> <div class="deleteRemote" title="Delete Remote' + ELLIPSIS + '">' + SVG_ICONS.close + '</div></td>' +
							'</tr><tr><td class="leftWithEllipsis" title="Push URL: ' + pushUrl + '">' + pushUrl + '</td><td>Push</td></tr>';
					});
				} else {
					html += '<tr class="lineAbove"><td colspan="4">There are no remotes configured for this repository.</td></tr>';
				}
				html += '</table><div class="settingsSectionButtons lineAbove"><div id="settingsAddRemote" class="addBtn">' + SVG_ICONS.plus + 'Add Remote</div></div></div>';
			}

			html += '<div class="settingsSection centered"><h3>Issue Linking</h3>';
			const issueLinkingConfig = this.repo.issueLinkingConfig || globalState.issueLinkingConfig;
			if (issueLinkingConfig !== null) {
				const escapedIssue = escapeHtml(issueLinkingConfig.issue), escapedUrl = escapeHtml(issueLinkingConfig.url);
				html += '<table><tr><td class="left">Issue Regex:</td><td class="leftWithEllipsis" title="' + escapedIssue + '">' + escapedIssue + '</td></tr><tr><td class="left">Issue URL:</td><td class="leftWithEllipsis" title="' + escapedUrl + '">' + escapedUrl + '</td></tr></table>' +
					'<div class="settingsSectionButtons"><div id="editIssueLinking" class="editBtn">' + SVG_ICONS.pencil + 'Edit</div><div id="removeIssueLinking" class="removeBtn">' + SVG_ICONS.close + 'Remove</div></div>';
			} else {
				html += '<span>Issue Linking converts issue numbers in commit &amp; tag messages into hyperlinks, that open the issue in your issue tracking system. If a branch\'s name contains an issue number, the issue can be viewed via the branch\'s context menu.</span>' +
					'<div class="settingsSectionButtons"><div id="editIssueLinking" class="addBtn">' + SVG_ICONS.plus + 'Add Issue Linking</div></div>';
			}
			html += '</div>';

			if (this.config !== null) {
				html += '<div class="settingsSection centered"><h3>Pull Request Creation</h3>';
				const pullRequestConfig = this.repo.pullRequestConfig;
				if (pullRequestConfig !== null) {
					const provider = escapeHtml((pullRequestConfig.provider === GG.PullRequestProvider.Bitbucket
						? 'Bitbucket'
						: pullRequestConfig.provider === GG.PullRequestProvider.Custom
							? pullRequestConfig.custom.name
							: pullRequestConfig.provider === GG.PullRequestProvider.GitHub
								? 'GitHub'
								: 'GitLab'
					) + ' (' + pullRequestConfig.hostRootUrl + ')');
					const source = escapeHtml(pullRequestConfig.sourceOwner + '/' + pullRequestConfig.sourceRepo + ' (' + pullRequestConfig.sourceRemote + ')');
					const destination = escapeHtml(pullRequestConfig.destOwner + '/' + pullRequestConfig.destRepo + (pullRequestConfig.destRemote !== null ? ' (' + pullRequestConfig.destRemote + ')' : ''));
					const destinationBranch = escapeHtml(pullRequestConfig.destBranch);
					html += '<table><tr><td class="left">Provider:</td><td class="leftWithEllipsis" title="' + provider + '">' + provider + '</td></tr>' +
						'<tr><td class="left">Source Repo:</td><td class="leftWithEllipsis" title="' + source + '">' + source + '</td></tr>' +
						'<tr><td class="left">Destination Repo:</td><td class="leftWithEllipsis" title="' + destination + '">' + destination + '</td></tr>' +
						'<tr><td class="left">Destination Branch:</td><td class="leftWithEllipsis" title="' + destinationBranch + '">' + destinationBranch + '</td></tr></table>' +
						'<div class="settingsSectionButtons"><div id="editPullRequestIntegration" class="editBtn">' + SVG_ICONS.pencil + 'Edit</div><div id="removePullRequestIntegration" class="removeBtn">' + SVG_ICONS.close + 'Remove</div></div>';
				} else {
					html += '<span>Pull Request Creation automates the opening and pre-filling of a Pull Request form, directly from a branch\'s context menu.</span>' +
						'<div class="settingsSectionButtons"><div id="editPullRequestIntegration" class="addBtn">' + SVG_ICONS.plus + 'Configure "Pull Request Creation" Integration</div></div>';
				}
				html += '</div>';
			}

			html += '<div class="settingsSection"><h3>Git Graph Configuration</h3><div class="settingsSectionButtons">' +
				'<div id="openExtensionSettings">' + SVG_ICONS.gear + 'Open Git Graph Extension Settings</div><br/>' +
				'<div id="exportRepositoryConfig">' + SVG_ICONS.package + 'Export Repository Configuration</div>' +
				'</div></div>';

			this.contentsElem.innerHTML = html;

			document.getElementById('editRepoName')!.addEventListener('click', () => {
				if (this.currentRepo === null || this.repo === null) return;
				dialog.showForm('Specify a Name for this Repository:', [
					{ type: DialogInputType.Text, name: 'Name', default: this.repo.name || '', placeholder: getRepoName(this.currentRepo) }
				], 'Save Name', (values) => {
					if (this.currentRepo === null) return;
					this.view.saveRepoStateValue(this.currentRepo, 'name', <string>values[0] || null);
					this.view.renderRepoDropdownOptions();
					this.render();
				}, null);
			});

			if (this.repo.name !== null) {
				document.getElementById('deleteRepoName')!.addEventListener('click', () => {
					if (this.currentRepo === null || this.repo === null || this.repo.name === null) return;
					dialog.showConfirmation('Are you sure you want to delete the manually configured name <b><i>' + escapeHtml(this.repo.name) + '</i></b> for this repository, and use the default name from the File System <b><i>' + escapeHtml(getRepoName(this.currentRepo)) + '</i></b>?', 'Yes, delete', () => {
						if (this.currentRepo === null) return;
						this.view.saveRepoStateValue(this.currentRepo, 'name', null);
						this.view.renderRepoDropdownOptions();
						this.render();
					}, null);
				});
			}

			document.getElementById('editInitialBranches')!.addEventListener('click', () => {
				if (this.repo === null) return;
				const showCheckedOutBranch = getOnRepoLoadShowCheckedOutBranch(this.repo.onRepoLoadShowCheckedOutBranch);
				const showSpecificBranches = getOnRepoLoadShowSpecificBranches(this.repo.onRepoLoadShowSpecificBranches);
				dialog.showForm('<b>Configure Initial Branches</b><p style="margin:6px 0;">Configure the branches that are initially shown when this repository is loaded in the Git Graph View.</p><p style="font-size:12px; margin:6px 0 0 0;">Note: When "Checked Out Branch" is Disabled, and no "Specific Branches" are selected, all branches will be shown.</p>', [
					{ type: DialogInputType.Checkbox, name: 'Checked Out Branch', value: showCheckedOutBranch },
					{ type: DialogInputType.Select, name: 'Specific Branches', options: this.view.getBranchOptions(), defaults: showSpecificBranches, multiple: true }
				], 'Save Configuration', (values) => {
					if (this.currentRepo === null) return;
					if (showCheckedOutBranch !== values[0] || !arraysStrictlyEqualIgnoringOrder(showSpecificBranches, <string[]>values[1])) {
						this.view.saveRepoStateValue(this.currentRepo, 'onRepoLoadShowCheckedOutBranch', values[0] ? GG.BooleanOverride.Enabled : GG.BooleanOverride.Disabled);
						this.view.saveRepoStateValue(this.currentRepo, 'onRepoLoadShowSpecificBranches', <string[]>values[1]);
						this.render();
					}
				}, null, 'Cancel', null, false);
			});

			if (initialBranchesLocallyConfigured) {
				document.getElementById('clearInitialBranches')!.addEventListener('click', () => {
					dialog.showConfirmation('Are you sure you want to clear the branches that are initially shown when this repository is loaded in the Git Graph View?', 'Yes, clear', () => {
						if (this.currentRepo === null) return;
						this.view.saveRepoStateValue(this.currentRepo, 'onRepoLoadShowCheckedOutBranch', GG.BooleanOverride.Default);
						this.view.saveRepoStateValue(this.currentRepo, 'onRepoLoadShowSpecificBranches', null);
						this.render();
					}, null);
				});
			}

			const showStashesElem = <HTMLInputElement>document.getElementById('settingsShowStashesCheckbox');
			showStashesElem.checked = getShowStashes(this.repo.showStashes);
			showStashesElem.addEventListener('change', () => {
				if (this.currentRepo === null) return;
				const elem = <HTMLInputElement | null>document.getElementById('settingsShowStashesCheckbox');
				if (elem === null) return;
				this.view.saveRepoStateValue(this.currentRepo, 'showStashes', elem.checked ? GG.BooleanOverride.Enabled : GG.BooleanOverride.Disabled);
				this.view.refresh(true);
			});

			const showTagsElem = <HTMLInputElement>document.getElementById('settingsShowTagsCheckbox');
			showTagsElem.checked = getShowTags(this.repo.showTags);
			showTagsElem.addEventListener('change', () => {
				if (this.currentRepo === null) return;
				const elem = <HTMLInputElement | null>document.getElementById('settingsShowTagsCheckbox');
				if (elem === null) return;
				this.view.saveRepoStateValue(this.currentRepo, 'showTags', elem.checked ? GG.BooleanOverride.Enabled : GG.BooleanOverride.Disabled);
				this.view.refresh(true);
			});

			const includeCommitsMentionedByReflogsElem = <HTMLInputElement>document.getElementById('settingsIncludeCommitsMentionedByReflogsCheckbox');
			includeCommitsMentionedByReflogsElem.checked = getIncludeCommitsMentionedByReflogs(this.repo.includeCommitsMentionedByReflogs);
			includeCommitsMentionedByReflogsElem.addEventListener('change', () => {
				if (this.currentRepo === null) return;
				const elem = <HTMLInputElement | null>document.getElementById('settingsIncludeCommitsMentionedByReflogsCheckbox');
				if (elem === null) return;
				this.view.saveRepoStateValue(this.currentRepo, 'includeCommitsMentionedByReflogs', elem.checked ? GG.BooleanOverride.Enabled : GG.BooleanOverride.Disabled);
				this.view.refresh(true);
			});

			const settingsOnlyFollowFirstParentElem = <HTMLInputElement>document.getElementById('settingsOnlyFollowFirstParentCheckbox');
			settingsOnlyFollowFirstParentElem.checked = getOnlyFollowFirstParent(this.repo.onlyFollowFirstParent);
			settingsOnlyFollowFirstParentElem.addEventListener('change', () => {
				if (this.currentRepo === null) return;
				const elem = <HTMLInputElement | null>document.getElementById('settingsOnlyFollowFirstParentCheckbox');
				if (elem === null) return;
				this.view.saveRepoStateValue(this.currentRepo, 'onlyFollowFirstParent', elem.checked ? GG.BooleanOverride.Enabled : GG.BooleanOverride.Disabled);
				this.view.refresh(true);
			});

			if (this.config !== null) {
				document.getElementById('editUserDetails')!.addEventListener('click', () => {
					if (this.config === null) return;
					const userName = this.config.user.name, userEmail = this.config.user.email;
					dialog.showForm('Set the user name and email used by Git to record the Author and Committer of commit objects:', [
						{ type: DialogInputType.Text, name: 'User Name', default: userName.local ?? userName.global ?? '', placeholder: null },
						{ type: DialogInputType.Text, name: 'User Email', default: userEmail.local ?? userEmail.global ?? '', placeholder: null },
						{ type: DialogInputType.Checkbox, name: 'Use Globally', value: userName.local === null && userEmail.local === null, info: 'Use the "User Name" and "User Email" globally for all Git repositories (it can be overridden per repository).' }
					], 'Set User Details', (values) => {
						if (this.currentRepo === null) return;
						const useGlobally = <boolean>values[2];
						runAction({
							command: 'editUserDetails',
							repo: this.currentRepo,
							name: <string>values[0],
							email: <string>values[1],
							location: useGlobally ? GG.GitConfigLocation.Global : GG.GitConfigLocation.Local,
							deleteLocalName: useGlobally && userName.local !== null,
							deleteLocalEmail: useGlobally && userEmail.local !== null
						}, 'Setting User Details');
					}, null);
				});

				if (userNameSet || userEmailSet) {
					document.getElementById('removeUserDetails')!.addEventListener('click', () => {
						if (this.config === null) return;
						const userName = this.config.user.name, userEmail = this.config.user.email;
						const isGlobal = userName.local === null && userEmail.local === null;
						dialog.showConfirmation('Are you sure you want to remove the <b>' + (isGlobal ? 'globally' : 'locally') + ' configured</b> user name and email, which are used by Git to record the Author and Committer of commit objects?', 'Yes, remove', () => {
							if (this.currentRepo === null) return;
							runAction({
								command: 'deleteUserDetails',
								repo: this.currentRepo,
								name: (isGlobal ? userName.global : userName.local) !== null,
								email: (isGlobal ? userEmail.global : userEmail.local) !== null,
								location: isGlobal ? GG.GitConfigLocation.Global : GG.GitConfigLocation.Local
							}, 'Removing User Details');
						}, null);
					});
				}

				const pushUrlPlaceholder = 'Leave blank to use the Fetch URL';
				document.getElementById('settingsAddRemote')!.addEventListener('click', () => {
					dialog.showForm('Add a new remote to this repository:', [
						{ type: DialogInputType.Text, name: 'Name', default: '', placeholder: null },
						{ type: DialogInputType.Text, name: 'Fetch URL', default: '', placeholder: null },
						{ type: DialogInputType.Text, name: 'Push URL', default: '', placeholder: pushUrlPlaceholder },
						{ type: DialogInputType.Checkbox, name: 'Fetch Immediately', value: true }
					], 'Add Remote', (values) => {
						if (this.currentRepo === null) return;
						runAction({ command: 'addRemote', repo: this.currentRepo, name: <string>values[0], url: <string>values[1], pushUrl: <string>values[2] !== '' ? <string>values[2] : null, fetch: <boolean>values[3] }, 'Adding Remote');
					}, { type: TargetType.Repo });
				});

				addListenerToClass('editRemote', 'click', (e) => {
					const remote = this.getRemoteForBtnEvent(e);
					if (remote === null) return;
					dialog.showForm('Edit the remote <b><i>' + escapeHtml(remote.name) + '</i></b>:', [
						{ type: DialogInputType.Text, name: 'Name', default: remote.name, placeholder: null },
						{ type: DialogInputType.Text, name: 'Fetch URL', default: remote.url !== null ? remote.url : '', placeholder: null },
						{ type: DialogInputType.Text, name: 'Push URL', default: remote.pushUrl !== null ? remote.pushUrl : '', placeholder: pushUrlPlaceholder }
					], 'Save Changes', (values) => {
						if (this.currentRepo === null) return;
						runAction({ command: 'editRemote', repo: this.currentRepo, nameOld: remote.name, nameNew: <string>values[0], urlOld: remote.url, urlNew: <string>values[1] !== '' ? <string>values[1] : null, pushUrlOld: remote.pushUrl, pushUrlNew: <string>values[2] !== '' ? <string>values[2] : null }, 'Saving Changes to Remote');
					}, { type: TargetType.Repo });
				});

				addListenerToClass('deleteRemote', 'click', (e) => {
					const remote = this.getRemoteForBtnEvent(e);
					if (remote === null) return;
					dialog.showConfirmation('Are you sure you want to delete the remote <b><i>' + escapeHtml(remote.name) + '</i></b>?', 'Yes, delete', () => {
						if (this.currentRepo === null) return;
						runAction({ command: 'deleteRemote', repo: this.currentRepo, name: remote.name }, 'Deleting Remote');
					}, { type: TargetType.Repo });
				});

				addListenerToClass('fetchRemote', 'click', (e) => {
					const remote = this.getRemoteForBtnEvent(e);
					if (remote === null) return;
					dialog.showForm('Are you sure you want to fetch from the remote <b><i>' + escapeHtml(remote.name) + '</i></b>?', [
						{ type: DialogInputType.Checkbox, name: 'Prune', value: initialState.config.dialogDefaults.fetchRemote.prune, info: 'Before fetching, remove any remote-tracking references that no longer exist on the remote.' },
						{ type: DialogInputType.Checkbox, name: 'Prune Tags', value: initialState.config.dialogDefaults.fetchRemote.pruneTags, info: 'Before fetching, remove any local tags that no longer exist on the remote. Requires Git >= 2.17.0, and "Prune" to be enabled.' }
					], 'Yes, fetch', (values) => {
						if (this.currentRepo === null) return;
						runAction({ command: 'fetch', repo: this.currentRepo, name: remote.name, prune: <boolean>values[0], pruneTags: <boolean>values[1] }, 'Fetching from Remote');
					}, { type: TargetType.Repo });
				});

				addListenerToClass('pruneRemote', 'click', (e) => {
					const remote = this.getRemoteForBtnEvent(e);
					if (remote === null) return;
					dialog.showConfirmation('Are you sure you want to prune remote-tracking references that no longer exist on the remote <b><i>' + escapeHtml(remote.name) + '</i></b>?', 'Yes, prune', () => {
						if (this.currentRepo === null) return;
						runAction({ command: 'pruneRemote', repo: this.currentRepo, name: remote.name }, 'Pruning Remote');
					}, { type: TargetType.Repo });
				});

				addListenerToClass('hideRemoteBtn', 'click', (e) => {
					if (this.currentRepo === null || this.repo === null || this.config === null) return;
					const source = <HTMLElement>(<Element>e.target).closest('.hideRemoteBtn')!;
					const remote = this.config.remotes[parseInt(source.dataset.index!)].name;
					const hideRemote = !this.repo.hideRemotes.includes(remote);
					source.title = 'Click to ' + (hideRemote ? 'show' : 'hide') + ' branches of this remote.';
					source.innerHTML = hideRemote ? SVG_ICONS.eyeClosed : SVG_ICONS.eyeOpen;
					if (hideRemote) {
						this.repo.hideRemotes.push(remote);
					} else {
						this.repo.hideRemotes.splice(this.repo.hideRemotes.indexOf(remote), 1);
					}
					this.view.saveRepoStateValue(this.currentRepo, 'hideRemotes', this.repo.hideRemotes);
					this.view.refresh(true);
				});
			}

			document.getElementById('editIssueLinking')!.addEventListener('click', () => {
				if (this.repo === null) return;
				const issueLinkingConfig = this.repo.issueLinkingConfig || globalState.issueLinkingConfig;
				if (issueLinkingConfig !== null) {
					this.showIssueLinkingDialog(issueLinkingConfig.issue, issueLinkingConfig.url, this.repo.issueLinkingConfig === null && globalState.issueLinkingConfig !== null, true);
				} else {
					this.showIssueLinkingDialog(null, null, false, false);
				}
			});

			if (this.repo.issueLinkingConfig !== null || globalState.issueLinkingConfig !== null) {
				document.getElementById('removeIssueLinking')!.addEventListener('click', () => {
					if (this.repo === null) return;
					const locallyConfigured = this.repo.issueLinkingConfig !== null;
					dialog.showConfirmation('Are you sure you want to remove ' + (locallyConfigured ? (globalState.issueLinkingConfig !== null ? 'the <b>locally configured</b> ' : '') + 'Issue Linking from this repository' : 'the <b>globally configured</b> Issue Linking in Git Graph') + '?', 'Yes, remove', () => {
						this.setIssueLinkingConfig(null, !locallyConfigured);
					}, null);
				});
			}

			if (this.config !== null) {
				document.getElementById('editPullRequestIntegration')!.addEventListener('click', () => {
					if (this.repo === null || this.config === null) return;

					if (this.config.remotes.length === 0) {
						dialog.showError('Unable to configure the "Pull Request Creation" Integration', 'The repository must have at least one remote to configure the "Pull Request Creation" Integration. There are no remotes in the current repository.', null, null);
						return;
					}

					let config: GG.DeepWriteable<GG.PullRequestConfig>;
					if (this.repo.pullRequestConfig === null) {
						let originIndex = this.config.remotes.findIndex((remote) => remote.name === 'origin');
						let sourceRemoteUrl = this.config.remotes[originIndex > -1 ? originIndex : 0].url;
						let provider: GG.PullRequestProvider;
						if (sourceRemoteUrl !== null) {
							if (sourceRemoteUrl.match(/^(https?:\/\/|git@)[^/]*github/) !== null) {
								provider = GG.PullRequestProvider.GitHub;
							} else if (sourceRemoteUrl.match(/^(https?:\/\/|git@)[^/]*gitlab/) !== null) {
								provider = GG.PullRequestProvider.GitLab;
							} else {
								provider = GG.PullRequestProvider.Bitbucket;
							}
						} else {
							provider = GG.PullRequestProvider.Bitbucket;
						}
						config = {
							provider: provider, hostRootUrl: '',
							sourceRemote: '', sourceOwner: '', sourceRepo: '',
							destRemote: '', destOwner: '', destRepo: '', destProjectId: '', destBranch: '',
							custom: null
						};
					} else {
						config = Object.assign({}, this.repo.pullRequestConfig);
					}
					this.showCreatePullRequestIntegrationDialog1(config);
				});

				if (this.repo.pullRequestConfig !== null) {
					document.getElementById('removePullRequestIntegration')!.addEventListener('click', () => {
						dialog.showConfirmation('Are you sure you want to remove the configured "Pull Request Creation" Integration?', 'Yes, remove', () => {
							this.setPullRequestConfig(null);
						}, null);
					});
				}
			}

			document.getElementById('openExtensionSettings')!.addEventListener('click', () => {
				sendMessage({ command: 'openExtensionSettings' });
			});

			document.getElementById('exportRepositoryConfig')!.addEventListener('click', () => {
				dialog.showConfirmation('Exporting the Git Graph Repository Configuration will generate a file that can be committed in this repository. It allows others working in this repository to use the same configuration.', 'Yes, export', () => {
					if (this.currentRepo === null) return;
					runAction({ command: 'exportRepoConfig', repo: this.currentRepo }, 'Exporting Repository Configuration');
				}, null);
			});
		}

		alterClass(this.widgetElem, CLASS_LOADING, this.loading);
		this.loadingElem.innerHTML = this.loading ? '<span>' + SVG_ICONS.loading + 'Loading ...</span>' : '';
		this.widgetElem.scrollTop = this.scrollTop;
		this.loadingElem.style.top = (this.scrollTop + (this.widgetElem.clientHeight / 2) - 12) + 'px';
	}


	/* Private Helper Methods */

	/**
	 * Save the issue linking configuration for this repository, and refresh the view so these changes are taken into affect.
	 * @param config The issue linking configuration to save.
	 * @param global Should this configuration be set globally for all repositories, or locally for this specific repository.
	 */
	private setIssueLinkingConfig(config: GG.IssueLinkingConfig | null, global: boolean) {
		if (this.currentRepo === null || this.repo === null) return;

		if (global) {
			if (this.repo.issueLinkingConfig !== null) {
				this.view.saveRepoStateValue(this.currentRepo, 'issueLinkingConfig', null);
			}
			updateGlobalViewState('issueLinkingConfig', config);
		} else {
			this.view.saveRepoStateValue(this.currentRepo, 'issueLinkingConfig', config);
		}

		this.view.refresh(true);
		this.render();
	}

	/**
	 * Save the pull request configuration for this repository.
	 * @param config The pull request configuration to save.
	 */
	private setPullRequestConfig(config: GG.PullRequestConfig | null) {
		if (this.currentRepo === null) return;
		this.view.saveRepoStateValue(this.currentRepo, 'pullRequestConfig', config);
		this.render();
	}

	/**
	 * Show the dialog allowing the user to configure the issue linking for this repository.
	 * @param defaultIssueRegex The default regular expression used to match issue numbers.
	 * @param defaultIssueUrl The default URL for the issue number to be substituted into.
	 * @param defaultUseGlobally The default value for the checkbox determining whether the issue linking configuration should be used globally (for all repositories).
	 * @param isEdit Is the dialog editing an existing issue linking configuration.
	 */
	private showIssueLinkingDialog(defaultIssueRegex: string | null, defaultIssueUrl: string | null, defaultUseGlobally: boolean, isEdit: boolean) {
		let html = '<b>' + (isEdit ? 'Edit Issue Linking for' : 'Add Issue Linking to') + ' this Repository</b>';
		html += '<p style="font-size:12px; margin:6px 0;">The following example links <b>#123</b> in commit messages to <b>https://github.com/mhutchie/repo/issues/123</b>:</p>';
		html += '<table style="display:inline-table; width:360px; text-align:left; font-size:12px; margin-bottom:2px;"><tr><td>Issue Regex:</td><td>#(\\d+)</td></tr><tr><td>Issue URL:</td><td>https://github.com/mhutchie/repo/issues/$1</td></tr></tbody></table>';

		if (!isEdit && defaultIssueRegex === null && defaultIssueUrl === null) {
			defaultIssueRegex = SettingsWidget.autoDetectIssueRegex(this.view.getCommits());
			if (defaultIssueRegex !== null) {
				html += '<p style="font-size:12px"><i>The prefilled Issue Regex was detected in commit messages in this repository. Review and/or correct it if necessary.</i></p>';
			}
		}

		dialog.showForm(html, [
			{ type: DialogInputType.Text, name: 'Issue Regex', default: defaultIssueRegex !== null ? defaultIssueRegex : '', placeholder: null, info: 'A regular expression that matches your issue numbers, with one or more capturing groups ( ) that will be substituted into the "Issue URL".' },
			{ type: DialogInputType.Text, name: 'Issue URL', default: defaultIssueUrl !== null ? defaultIssueUrl : '', placeholder: null, info: 'The issue\'s URL in your issue tracking system, with placeholders ($1, $2, etc.) for the groups captured ( ) in the "Issue Regex".' },
			{ type: DialogInputType.Checkbox, name: 'Use Globally', value: defaultUseGlobally, info: 'Use the "Issue Regex" and "Issue URL" for all repositories by default (it can be overridden per repository). Note: "Use Globally" is only suitable if identical Issue Linking applies to the majority of your repositories (e.g. when using JIRA or Pivotal Tracker).' }
		], 'Save', (values) => {
			let issueRegex = (<string>values[0]).trim(), issueUrl = (<string>values[1]).trim(), useGlobally = <boolean>values[2];
			let regExpParseError = null;
			try {
				if (issueRegex.indexOf('(') === -1 || issueRegex.indexOf(')') === -1) {
					regExpParseError = 'The regular expression does not contain a capturing group ( ).';
				} else if (new RegExp(issueRegex, 'gu')) {
					regExpParseError = null;
				}
			} catch (e) {
				regExpParseError = e.message;
			}
			if (regExpParseError !== null) {
				dialog.showError('Invalid Issue Regex', regExpParseError, 'Go Back', () => {
					this.showIssueLinkingDialog(issueRegex, issueUrl, useGlobally, isEdit);
				});
			} else if (!(/\$([1-9][0-9]*)/.test(issueUrl))) {
				dialog.showError('Invalid Issue URL', 'The Issue URL does not contain any placeholders ($1, $2, etc.) for the issue number components captured in the Issue Regex.', 'Go Back', () => {
					this.showIssueLinkingDialog(issueRegex, issueUrl, useGlobally, isEdit);
				});
			} else {
				this.setIssueLinkingConfig({ issue: issueRegex, url: issueUrl }, useGlobally);
			}
		}, null, 'Cancel', null, false);
	}

	/**
	 * Show the first dialog for configuring the pull request integration.
	 * @param config The pull request configuration.
	 */
	private showCreatePullRequestIntegrationDialog1(config: GG.DeepWriteable<GG.PullRequestConfig>) {
		if (this.config === null) return;

		let originIndex = this.config.remotes.findIndex((remote) => remote.name === 'origin');
		let upstreamIndex = this.config.remotes.findIndex((remote) => remote.name === 'upstream');
		let sourceRemoteIndex = this.config.remotes.findIndex((remote) => remote.name === config.sourceRemote);
		let destRemoteIndex = this.config.remotes.findIndex((remote) => remote.name === config.destRemote);

		if (config.sourceRemote === '' || sourceRemoteIndex === -1) {
			sourceRemoteIndex = originIndex > -1 ? originIndex : 0;
		}
		if (config.destRemote === '') {
			destRemoteIndex = upstreamIndex > -1 ? upstreamIndex : originIndex > -1 ? originIndex : 0;
		}

		let defaultProvider = config.provider.toString();
		let providerOptions = [
			{ name: 'Bitbucket', value: (GG.PullRequestProvider.Bitbucket).toString() },
			{ name: 'GitHub', value: (GG.PullRequestProvider.GitHub).toString() },
			{ name: 'GitLab', value: (GG.PullRequestProvider.GitLab).toString() }
		];
		let providerTemplateLookup: { [name: string]: string } = {};
		initialState.config.customPullRequestProviders.forEach((provider) => {
			providerOptions.push({ name: provider.name, value: (providerOptions.length + 1).toString() });
			providerTemplateLookup[provider.name] = provider.templateUrl;
		});
		if (config.provider === GG.PullRequestProvider.Custom) {
			if (!providerOptions.some((provider) => provider.name === config.custom.name)) {
				// The existing custom Pull Request provider no longer exists, so add it.
				providerOptions.push({ name: config.custom.name, value: (providerOptions.length + 1).toString() });
				providerTemplateLookup[config.custom.name] = config.custom.templateUrl;
			}
			defaultProvider = providerOptions.find((provider) => provider.name === config.custom.name)!.value;
		}
		providerOptions.sort((a, b) => a.name.localeCompare(b.name));

		let sourceRemoteOptions = this.config.remotes.map((remote, index) => ({ name: remote.name, value: index.toString() }));
		let destRemoteOptions = sourceRemoteOptions.map((option) => option);
		destRemoteOptions.push({ name: 'Not a remote', value: '-1' });

		dialog.showForm('Configure "Pull Request Creation" Integration (Step&nbsp;1/2)', [
			{
				type: DialogInputType.Select, name: 'Provider',
				options: providerOptions, default: defaultProvider,
				info: 'In addition to the built-in publicly hosted Pull Request providers, custom providers can be configured using the Extension Setting "git-graph.customPullRequestProviders" (e.g. for use with privately hosted Pull Request providers).'
			},
			{
				type: DialogInputType.Select, name: 'Source Remote',
				options: sourceRemoteOptions, default: sourceRemoteIndex.toString(),
				info: 'The remote that corresponds to the source of the Pull Request.'
			},
			{
				type: DialogInputType.Select, name: 'Destination Remote',
				options: destRemoteOptions, default: destRemoteIndex.toString(),
				info: 'The remote that corresponds to the destination / target of the Pull Request.'
			}
		], 'Next', (values) => {
			if (this.config === null) return;

			let newProvider = <GG.PullRequestProvider>parseInt(<string>values[0]);
			if (newProvider > 3) newProvider = GG.PullRequestProvider.Custom;

			const newSourceRemoteIndex = parseInt(<string>values[1]);
			const newDestRemoteIndex = parseInt(<string>values[2]);
			const newSourceRemote = this.config.remotes[newSourceRemoteIndex].name;
			const newDestRemote = newDestRemoteIndex > -1 ? this.config.remotes[newDestRemoteIndex].name : null;
			const newSourceUrl = this.config.remotes[newSourceRemoteIndex].url;
			const newDestUrl = newDestRemoteIndex > -1 ? this.config.remotes[newDestRemoteIndex].url : null;

			if (config.hostRootUrl === '' || config.provider !== newProvider) {
				const remoteUrlForHost = newSourceUrl !== null ? newSourceUrl : newDestUrl;
				if (remoteUrlForHost !== null) {
					const match = remoteUrlForHost.match(/^(https?:\/\/|git@)((?=[^/]+@)[^@]+@|(?![^/]+@))([^/:]+)/);
					config.hostRootUrl = match !== null ? 'https://' + match[3] : '';
				} else {
					config.hostRootUrl = '';
				}
			}

			if (newProvider === GG.PullRequestProvider.Custom) {
				const customProviderName = providerOptions.find((provider) => provider.value === <string>values[0])!.name;
				config.custom = { name: customProviderName, templateUrl: providerTemplateLookup[customProviderName] };
			} else {
				config.custom = null;
			}
			config.provider = newProvider;

			if (config.sourceRemote !== newSourceRemote) {
				config.sourceRemote = newSourceRemote;
				const match = newSourceUrl !== null ? newSourceUrl.match(/^(https?:\/\/|git@)[^/:]+[/:]([^/]+)\/([^/]*?)(.git|)$/) : null;
				config.sourceOwner = match !== null ? match[2] : '';
				config.sourceRepo = match !== null ? match[3] : '';
			}

			if (config.provider !== GG.PullRequestProvider.GitLab || config.destRemote !== newDestRemote) {
				config.destProjectId = '';
			}

			if (config.destRemote !== newDestRemote) {
				config.destRemote = newDestRemote;
				if (newDestRemote !== null) {
					const match = newDestUrl !== null ? newDestUrl.match(/^(https?:\/\/|git@)[^/:]+[/:]([^/]+)\/([^/]*?)(.git|)$/) : null;
					config.destOwner = match !== null ? match[2] : '';
					config.destRepo = match !== null ? match[3] : '';
					const branches = this.view.getBranches()
						.filter((branch) => branch.startsWith('remotes/' + newDestRemote + '/') && branch !== ('remotes/' + newDestRemote + '/HEAD'))
						.map((branch) => branch.substring(newDestRemote.length + 9));
					config.destBranch = branches.length > 0 ? branches.includes('master') ? 'master' : branches[0] : '';
				} else {
					config.destOwner = '';
					config.destRepo = '';
					config.destBranch = '';
				}
			}

			this.showCreatePullRequestIntegrationDialog2(config);
		}, { type: TargetType.Repo });
	}

	/**
	 * Show the second dialog for configuring the pull request integration.
	 * @param config The pull request configuration.
	 */
	private showCreatePullRequestIntegrationDialog2(config: GG.DeepWriteable<GG.PullRequestConfig>) {
		if (this.config === null) return;

		const destBranches = config.destRemote !== null
			? this.view.getBranches()
				.filter((branch) => branch.startsWith('remotes/' + config.destRemote + '/') && branch !== ('remotes/' + config.destRemote + '/HEAD'))
				.map((branch) => branch.substring(config.destRemote!.length + 9))
			: [];
		const destBranchInfo = 'The name of the branch that is the destination / target of the Pull Request.';

		const updateConfigWithFormValues = (values: DialogInputValue[]) => {
			const hostRootUri = <string>values[0];
			config.hostRootUrl = hostRootUri.endsWith('/') ? hostRootUri.substring(0, hostRootUri.length - 1) : hostRootUri;
			config.sourceOwner = <string>values[1];
			config.sourceRepo = <string>values[2];
			config.destOwner = <string>values[3];
			config.destRepo = <string>values[4];
			config.destProjectId = config.provider === GG.PullRequestProvider.GitLab ? <string>values[5] : '';
			const destBranch = <string>values[config.provider === GG.PullRequestProvider.GitLab ? 6 : 5];
			config.destBranch = config.destRemote === null || destBranches.length === 0
				? destBranch
				: destBranches[parseInt(destBranch)];
		};

		const inputs: DialogInput[] = [
			{ type: DialogInputType.Text, name: 'Host Root URL', default: config.hostRootUrl, placeholder: null, info: 'The Pull Request provider\'s Host Root URL (e.g. https://github.com).' },
			{ type: DialogInputType.Text, name: 'Source Owner', default: config.sourceOwner, placeholder: null, info: 'The owner of the repository that is the source of the Pull Request.' },
			{ type: DialogInputType.Text, name: 'Source Repo', default: config.sourceRepo, placeholder: null, info: 'The name of the repository that is the source of the Pull Request.' },
			{ type: DialogInputType.Text, name: 'Destination Owner', default: config.destOwner, placeholder: null, info: 'The owner of the repository that is the destination / target of the Pull Request.' },
			{ type: DialogInputType.Text, name: 'Destination Repo', default: config.destRepo, placeholder: null, info: 'The name of the repository that is the destination / target of the Pull Request.' }
		];
		if (config.provider === GG.PullRequestProvider.GitLab) {
			inputs.push({ type: DialogInputType.Text, name: 'Destination Project ID', default: config.destProjectId, placeholder: null, info: 'The GitLab Project ID of the destination / target of the Pull Request. Leave this field blank to use the default destination / target configured in GitLab.' });
		}
		inputs.push(config.destRemote === null || destBranches.length === 0
			? { type: DialogInputType.Text, name: 'Destination Branch', default: config.destBranch, placeholder: null, info: destBranchInfo }
			: {
				type: DialogInputType.Select,
				name: 'Destination Branch',
				options: destBranches.map((branch, index) => ({ name: branch, value: index.toString() })),
				default: destBranches.includes(config.destBranch) ? destBranches.indexOf(config.destBranch).toString() : '0',
				info: destBranchInfo
			}
		);

		dialog.showForm('Configure "Pull Request Creation" Integration (Step&nbsp;2/2)', inputs, 'Save Configuration', (values) => {
			updateConfigWithFormValues(values);
			this.setPullRequestConfig(config);
		}, { type: TargetType.Repo }, 'Back', (values) => {
			updateConfigWithFormValues(values);
			this.showCreatePullRequestIntegrationDialog1(config);
		});
	}

	/**
	 * Get the remote details corresponding to a mouse event.
	 * @param e The mouse event.
	 * @returns The details of the remote.
	 */
	private getRemoteForBtnEvent(e: Event) {
		return this.config !== null
			? this.config.remotes[parseInt((<HTMLElement>(<Element>e.target).closest('.remoteBtns')!).dataset.index!)]
			: null;
	}

	/**
	 * Automatically detect common issue number formats in the specified commits, returning the most common.
	 * @param commits The commits to analyse.
	 * @returns The regular expression of the most likely issue number format.
	 */
	private static autoDetectIssueRegex(commits: ReadonlyArray<GG.GitCommit>) {
		const patterns = ['#(\\d+)', '^(\\d+)\\.(?=\\s|$)', '^(\\d+):(?=\\s|$)', '([A-Za-z]+-\\d+)'].map((pattern) => {
			const regexp = new RegExp(pattern);
			return {
				pattern: pattern,
				matches: commits.filter((commit) => regexp.test(commit.message)).length
			};
		}).sort((a, b) => b.matches - a.matches);

		if (patterns[0].matches > 0.1 * commits.length) {
			// If the most common pattern was matched in more than 10% of commits, return the pattern
			return patterns[0].pattern;
		}
		return null;
	}
}
-e 

================================================================================
// FILE: ./web/dialog.ts
================================================================================
const CLASS_DIALOG_ACTIVE = 'dialogActive';
const CLASS_DIALOG_INPUT_INVALID = 'inputInvalid';
const CLASS_DIALOG_NO_INPUT = 'noInput';

const enum DialogType {
	Form,
	ActionRunning,
	Message
}

const enum DialogInputType {
	Text,
	TextRef,
	Select,
	Radio,
	Checkbox
}

interface DialogTextInput {
	readonly type: DialogInputType.Text;
	readonly name: string;
	readonly default: string;
	readonly placeholder: string | null;
	readonly info?: string;
}

interface DialogTextRefInput {
	readonly type: DialogInputType.TextRef;
	readonly name: string;
	readonly default: string;
	readonly info?: string;
}

type DialogSelectInput = {
	readonly type: DialogInputType.Select;
	readonly name: string;
	readonly options: ReadonlyArray<DialogSelectInputOption>;
	readonly default: string;
	readonly multiple?: false;
	readonly info?: string;
} | {
	readonly type: DialogInputType.Select;
	readonly name: string;
	readonly options: ReadonlyArray<DialogSelectInputOption>;
	readonly defaults: ReadonlyArray<string>;
	readonly multiple: true;
	readonly info?: string;
};

interface DialogRadioInput {
	readonly type: DialogInputType.Radio;
	readonly name: string;
	readonly options: ReadonlyArray<DialogRadioInputOption>;
	readonly default: string;
}

interface DialogCheckboxInput {
	readonly type: DialogInputType.Checkbox;
	readonly name: string;
	readonly value: boolean;
	readonly info?: string;
}

interface DialogSelectInputOption {
	readonly name: string;
	readonly value: string;
}

interface DialogRadioInputOption {
	readonly name: string;
	readonly value: string;
}

type DialogInput = DialogTextInput | DialogTextRefInput | DialogSelectInput | DialogRadioInput | DialogCheckboxInput;
type DialogInputValue = string | string[] | boolean;

type DialogTarget = {
	type: TargetType.Commit | TargetType.Ref | TargetType.CommitDetailsView;
	elem: HTMLElement;
	hash: string;
	ref?: string;
} | RepoTarget;

/**
 * Implements the Git Graph View's dialogs.
 */
class Dialog {
	private elem: HTMLElement | null = null;
	private target: DialogTarget | null = null;
	private actioned: (() => void) | null = null;
	private type: DialogType | null = null;
	private customSelects: { [inputIndex: string]: CustomSelect } = {};

	private static readonly WHITESPACE_REGEXP = /\s/gu;

	/**
	 * Show a confirmation dialog to the user.
	 * @param message A message outlining what the user is being asked to confirm.
	 * @param actionName The name of the affirmative action (e.g. "Yes, \<verb\>").
	 * @param actioned A callback to be invoked if the user takes the affirmative action.
	 * @param target The target that the dialog was triggered on.
	 */
	public showConfirmation(message: string, actionName: string, actioned: () => void, target: DialogTarget | null) {
		this.show(DialogType.Form, message, actionName, 'Cancel', () => {
			this.close();
			actioned();
		}, null, target);
	}

	/**
	 * Show a dialog presenting two options to the user.
	 * @param message A message outlining the decision the user has.
	 * @param buttonLabel1 The label for the primary (default) action.
	 * @param buttonAction1 A callback to be invoked when the primary (default) action is selected by the user.
	 * @param buttonLabel2 The label for the secondary action.
	 * @param buttonAction2 A callback to be invoked when the secondary action is selected by the user.
	 * @param target The target that the dialog was triggered on.
	 */
	public showTwoButtons(message: string, buttonLabel1: string, buttonAction1: () => void, buttonLabel2: string, buttonAction2: () => void, target: DialogTarget | null) {
		this.show(DialogType.Form, message, buttonLabel1, buttonLabel2, () => {
			this.close();
			buttonAction1();
		}, () => {
			this.close();
			buttonAction2();
		}, target);
	}

	/**
	 * Show a dialog asking the user to enter the name for a Git reference. The reference name will be validated before the dialog can be actioned.
	 * @param message A message outlining the purpose of the reference.
	 * @param defaultValue The default name of the reference.
	 * @param actionName The name of the action that the user must choose to proceed.
	 * @param actioned A callback to be invoked when the action is triggered (with the reference name as the first argument).
	 * @param target The target that the dialog was triggered on.
	 */
	public showRefInput(message: string, defaultValue: string, actionName: string, actioned: (value: string) => void, target: DialogTarget | null) {
		this.showForm(message, [
			{ type: DialogInputType.TextRef, name: '', default: defaultValue }
		], actionName, (values) => actioned(<string>values[0]), target);
	}

	/**
	 * Show a dialog to the user with a single checkbox input.
	 * @param message A message outlining the purpose of the dialog.
	 * @param checkboxLabel The label to be displayed alongside the checkbox.
	 * @param checkboxValue The default value of the checkbox.
	 * @param actionName The name of the action that the user must choose to proceed.
	 * @param actioned A callback to be invoked when the action is triggered (with the checkbox value as the first argument).
	 * @param target The target that the dialog was triggered on.
	 */
	public showCheckbox(message: string, checkboxLabel: string, checkboxValue: boolean, actionName: string, actioned: (value: boolean) => void, target: DialogTarget | null) {
		this.showForm(message, [
			{ type: DialogInputType.Checkbox, name: checkboxLabel, value: checkboxValue }
		], actionName, (values) => actioned(<boolean>values[0]), target);
	}

	/**
	 * Show a dialog to the user with a single select input.
	 * @param message A message outlining the purpose of the dialog.
	 * @param defaultValue The default value for the select input.
	 * @param options An array containing the options for the select input.
	 * @param actionName The name of the action that the user must choose to proceed.
	 * @param actioned A callback to be invoked when the action is triggered (with the selected value as the first argument).
	 * @param target The target that the dialog was triggered on.
	 */
	public showSelect(message: string, defaultValue: string, options: ReadonlyArray<DialogSelectInputOption>, actionName: string, actioned: (value: string) => void, target: DialogTarget | null) {
		this.showForm(message, [
			{ type: DialogInputType.Select, name: '', options: options, default: defaultValue }
		], actionName, (values) => actioned(<string>values[0]), target);
	}

	/**
	 * Show a dialog to the user with a single multi-select input.
	 * @param message A message outlining the purpose of the dialog.
	 * @param defaultValue The default value(s) for the select input.
	 * @param options An array containing the options for the select input.
	 * @param actionName The name of the action that the user must choose to proceed.
	 * @param actioned A callback to be invoked when the action is triggered (with the selected value(s) as the first argument).
	 * @param target The target that the dialog was triggered on.
	 */
	public showMultiSelect(message: string, defaultValues: ReadonlyArray<string>, options: ReadonlyArray<DialogSelectInputOption>, actionName: string, actioned: (value: string[]) => void, target: DialogTarget | null) {
		this.showForm(message, [
			{ type: DialogInputType.Select, name: '', options: options, defaults: defaultValues, multiple: true }
		], actionName, (values) => actioned(<string[]>values[0]), target);
	}

	/**
	 * Show a dialog to the user which can include any number of form inputs.
	 * @param message A message outlining the purpose of the dialog.
	 * @param inputs An array defining the form inputs to display in the dialog.
	 * @param actionName The name of the action that the user must choose to proceed.
	 * @param actioned A callback to be invoked when the action is triggered (with the form values as the first argument).
	 * @param target The target that the dialog was triggered on.
	 * @param secondaryActionName An optional name for the secondary action.
	 * @param secondaryActioned An optional callback to be invoked when the secondary action is selected by the user.
	 * @param includeLineBreak Should a line break be added between the message and form inputs.
	 */
	public showForm(message: string, inputs: ReadonlyArray<DialogInput>, actionName: string, actioned: (values: DialogInputValue[]) => void, target: DialogTarget | null, secondaryActionName: string = 'Cancel', secondaryActioned: ((values: DialogInputValue[]) => void) | null = null, includeLineBreak: boolean = true) {
		const multiElement = inputs.length > 1;
		const multiCheckbox = multiElement && inputs.every((input) => input.type === DialogInputType.Checkbox);
		const infoColRequired = inputs.some((input) => input.type !== DialogInputType.Checkbox && input.type !== DialogInputType.Radio && input.info);
		const inputRowsHtml = inputs.map((input, id) => {
			let inputHtml;
			if (input.type === DialogInputType.Radio) {
				inputHtml = '<td class="inputCol"' + (infoColRequired ? ' colspan="2"' : '') + '><span class="dialogFormRadio">' +
					input.options.map((option, optionId) => '<label><input type="radio" name="dialogInput' + id + '" value="' + optionId + '"' + (option.value === input.default ? ' checked' : '') + ' tabindex="' + (id + 1) + '"/><span class="customRadio"></span>' + escapeHtml(option.name) + '</label>').join('<br>') +
					'</span></td>';
			} else {
				const infoHtml = input.info ? '<span class="dialogInfo" title="' + escapeHtml(input.info) + '">' + SVG_ICONS.info + '</span>' : '';
				if (input.type === DialogInputType.Select) {
					inputHtml = '<td class="inputCol"><div id="dialogFormSelect' + id + '"></div></td>' + (infoColRequired ? '<td>' + infoHtml + '</td>' : '');
				} else if (input.type === DialogInputType.Checkbox) {
					inputHtml = '<td class="inputCol"' + (infoColRequired ? ' colspan="2"' : '') + '><span class="dialogFormCheckbox"><label><input id="dialogInput' + id + '" type="checkbox"' + (input.value ? ' checked' : '') + ' tabindex="' + (id + 1) + '"/><span class="customCheckbox"></span>' + (multiElement && !multiCheckbox ? '' : input.name) + infoHtml + '</label></span></td>';
				} else {
					inputHtml = '<td class="inputCol"><input id="dialogInput' + id + '" type="text" value="' + escapeHtml(input.default) + '"' + (input.type === DialogInputType.Text && input.placeholder !== null ? ' placeholder="' + escapeHtml(input.placeholder) + '"' : '') + ' tabindex="' + (id + 1) + '"/></td>' + (infoColRequired ? '<td>' + infoHtml + '</td>' : '');
				}
			}
			return '<tr' + (input.type === DialogInputType.Radio ? ' class="mediumField"' : input.type !== DialogInputType.Checkbox ? ' class="largeField"' : '') + '>' + (multiElement && !multiCheckbox ? '<td>' + input.name + ': </td>' : '') + inputHtml + '</tr>';
		});

		const html = message + (includeLineBreak ? '<br>' : '') +
			'<table class="dialogForm ' + (multiElement ? multiCheckbox ? 'multiCheckbox' : 'multi' : 'single') + '">' +
			inputRowsHtml.join('') +
			'</table>';

		const areFormValuesInvalid = () => this.elem === null || this.elem.classList.contains(CLASS_DIALOG_NO_INPUT) || this.elem.classList.contains(CLASS_DIALOG_INPUT_INVALID);
		const getFormValues = () => inputs.map((input, index) => {
			if (input.type === DialogInputType.Radio) {
				// Iterate through all of the radio options to get the checked value
				const elems = <NodeListOf<HTMLInputElement>>document.getElementsByName('dialogInput' + index);
				for (let i = 0; i < elems.length; i++) {
					if (elems[i].checked) {
						return input.options[parseInt(elems[i].value)].value;
					}
				}
				return input.default; // If no option is checked, return the default value
			} else if (input.type === DialogInputType.Select) {
				return this.customSelects[index.toString()].getValue();
			} else {
				const elem = <HTMLInputElement>document.getElementById('dialogInput' + index);
				return input.type === DialogInputType.Checkbox
					? elem.checked // Checkboxes return a boolean indicating if the value is checked
					: elem.value; // All other fields return the value as a string
			}
		});

		this.show(DialogType.Form, html, actionName, secondaryActionName, () => {
			if (areFormValuesInvalid()) return;
			const values = getFormValues();
			this.close();
			actioned(values);
		}, secondaryActioned !== null ? () => {
			if (areFormValuesInvalid()) return;
			const values = getFormValues();
			this.close();
			secondaryActioned(values);
		} : null, target);

		// Create custom select inputs
		inputs.forEach((input, index) => {
			if (input.type === DialogInputType.Select) {
				this.customSelects[index.toString()] = new CustomSelect(input, 'dialogFormSelect' + index, index + 1, this.elem!);
			}
		});

		// If the dialog contains a TextRef input, attach event listeners for validation
		const textRefInput = inputs.findIndex((input) => input.type === DialogInputType.TextRef);
		if (textRefInput > -1) {
			let dialogInput = <HTMLInputElement>document.getElementById('dialogInput' + textRefInput), dialogAction = document.getElementById('dialogAction')!;
			if (dialogInput.value === '') this.elem!.classList.add(CLASS_DIALOG_NO_INPUT);
			dialogInput.addEventListener('keyup', () => {
				if (this.elem === null) return;
				if (initialState.config.dialogDefaults.general.referenceInputSpaceSubstitution !== null) {
					const selectionStart = dialogInput.selectionStart, selectionEnd = dialogInput.selectionEnd;
					dialogInput.value = dialogInput.value.replace(Dialog.WHITESPACE_REGEXP, initialState.config.dialogDefaults.general.referenceInputSpaceSubstitution);
					dialogInput.selectionStart = selectionStart;
					dialogInput.selectionEnd = selectionEnd;
				}
				const noInput = dialogInput.value === '', invalidInput = dialogInput.value.match(REF_INVALID_REGEX) !== null;
				alterClass(this.elem, CLASS_DIALOG_NO_INPUT, noInput);
				if (alterClass(this.elem, CLASS_DIALOG_INPUT_INVALID, !noInput && invalidInput)) {
					dialogAction.title = invalidInput ? 'Unable to ' + actionName + ', one or more invalid characters entered.' : '';
				}
			});
		}

		if (inputs.length > 0 && (inputs[0].type === DialogInputType.Text || inputs[0].type === DialogInputType.TextRef)) {
			// If the first input is a text field, set focus to it.
			(<HTMLInputElement>document.getElementById('dialogInput0')).focus();
		}
	}

	/**
	 * Show a message to the user in a dialog.
	 * @param html The HTML to display in the dialog.
	 */
	public showMessage(html: string) {
		this.show(DialogType.Message, html, null, 'Close', null, null, null);
	}

	/**
	 * Show an error to the user in a dialog.
	 * @param message The high-level category of the error.
	 * @param reason The error details.
	 * @param actionName An optional name for a primary action (if one is required).
	 * @param actioned An optional callback to be invoked when the primary action is triggered.
	 */
	public showError(message: string, reason: GG.ErrorInfo, actionName: string | null, actioned: (() => void) | null) {
		this.show(DialogType.Message, '<span class="dialogAlert">' + SVG_ICONS.alert + 'Error: ' + message + '</span>' + (reason !== null ? '<br><span class="messageContent errorContent">' + escapeHtml(reason).split('\n').join('<br>') + '</span>' : ''), actionName, 'Dismiss', () => {
			this.close();
			if (actioned !== null) actioned();
		}, null, null);
	}

	/**
	 * Show a dialog to indicate that an action is currently running.
	 * @param action A short name that identifies the action that is running.
	 */
	public showActionRunning(action: string) {
		this.show(DialogType.ActionRunning, '<span class="actionRunning">' + SVG_ICONS.loading + action + ' ...</span>', null, 'Dismiss', null, null, null);
	}

	/**
	 * Show a dialog in the Git Graph View.
	 * @param type The type of dialog being shown.
	 * @param html The HTML content for the dialog.
	 * @param actionName The name of the primary (default) action.
	 * @param secondaryActionName The name of the secondary action.
	 * @param actioned A callback to be invoked when the primary (default) action is selected by the user.
	 * @param secondaryActioned A callback to be invoked when the secondary action is selected by the user.
	 * @param target The target that the dialog was triggered on.
	 */
	private show(type: DialogType, html: string, actionName: string | null, secondaryActionName: string, actioned: (() => void) | null, secondaryActioned: (() => void) | null, target: DialogTarget | null) {
		closeDialogAndContextMenu();

		this.type = type;
		this.target = target;
		eventOverlay.create('dialogBacking', null, null);

		const dialog = document.createElement('div'), dialogContent = document.createElement('div');
		dialog.className = 'dialog';
		dialogContent.className = 'dialogContent';
		dialogContent.innerHTML = html + '<br>' + (actionName !== null ? '<div id="dialogAction" class="roundedBtn">' + actionName + '</div>' : '') + '<div id="dialogSecondaryAction" class="roundedBtn">' + secondaryActionName + '</div>';
		dialog.appendChild(dialogContent);
		this.elem = dialog;
		document.body.appendChild(dialog);

		let docHeight = document.body.clientHeight, dialogHeight = dialog.clientHeight + 2;
		if (type !== DialogType.Form && dialogHeight > 0.8 * docHeight) {
			dialogContent.style.height = Math.round(0.8 * docHeight - 22) + 'px';
			dialogHeight = Math.round(0.8 * docHeight);
		}
		dialog.style.top = Math.max(Math.round((docHeight - dialogHeight) / 2), 10) + 'px';
		if (actionName !== null && actioned !== null) {
			document.getElementById('dialogAction')!.addEventListener('click', actioned);
			this.actioned = actioned;
		}
		document.getElementById('dialogSecondaryAction')!.addEventListener('click', secondaryActioned !== null ? secondaryActioned : () => this.close());

		if (this.target !== null && this.target.type !== TargetType.Repo) {
			alterClass(this.target.elem, CLASS_DIALOG_ACTIVE, true);
		}
	}

	/**
	 * Close the dialog (if one is currently open in the Git Graph View).
	 */
	public close() {
		eventOverlay.remove();
		if (this.elem !== null) {
			this.elem.remove();
			this.elem = null;
		}
		alterClassOfCollection(<HTMLCollectionOf<HTMLElement>>document.getElementsByClassName(CLASS_DIALOG_ACTIVE), CLASS_DIALOG_ACTIVE, false);
		this.target = null;
		Object.keys(this.customSelects).forEach((index) => this.customSelects[index].remove());
		this.customSelects = {};
		this.actioned = null;
		this.type = null;
	}

	/**
	 * Close the action running dialog (if one is currently open in the Git Graph View).
	 */
	public closeActionRunning() {
		if (this.type === DialogType.ActionRunning) this.close();
	}

	/**
	 * Submit the primary action of the dialog.
	 */
	public submit() {
		if (this.actioned !== null) this.actioned();
	}

	/**
	 * Refresh the dialog (if one is currently open in the Git Graph View). If the dialog has a dynamic source, re-link
	 * it to the newly rendered HTML Element, or close it if the target is no longer visible in the Git Graph View.
	 * @param commits The new array of commits that is rendered in the Git Graph View.
	 */
	public refresh(commits: ReadonlyArray<GG.GitCommit>) {
		if (!this.isOpen() || this.target === null || this.target.type === TargetType.Repo) {
			// Don't need to refresh if: no dialog is open, it is not dynamic, or it is not reliant on commit changes
			return;
		}

		const commitIndex = commits.findIndex((commit) => commit.hash === (<CommitTarget | RefTarget>this.target).hash);
		if (commitIndex > -1) {
			// The commit still exists

			const commitElem = findCommitElemWithId(getCommitElems(), commitIndex);
			if (commitElem !== null) {
				if (typeof this.target.ref === 'undefined') {
					// Dialog is only dependent on the commit itself
					if (this.target.type !== TargetType.CommitDetailsView) {
						this.target.elem = commitElem;
						alterClass(this.target.elem, CLASS_DIALOG_ACTIVE, true);
					}
					return;
				} else {
					// Dialog is dependent on the commit and ref
					const elems = <NodeListOf<HTMLElement>>commitElem.querySelectorAll('[data-fullref]');
					for (let i = 0; i < elems.length; i++) {
						if (elems[i].dataset.fullref! === this.target.ref) {
							this.target.elem = this.target.type === TargetType.Ref ? elems[i] : commitElem;
							alterClass(this.target.elem, CLASS_DIALOG_ACTIVE, true);
							return;
						}
					}
				}
			}
		}

		this.close();
	}

	/**
	 * Is a dialog currently open in the Git Graph View.
	 * @returns TRUE => A dialog is open, FALSE => No dialog is open
	 */
	public isOpen() {
		return this.elem !== null;
	}

	/**
	 * Is the target of the dialog dynamic (i.e. is it tied to a Git object & HTML Element in the Git Graph View).
	 * @returns TRUE => The dialog is dynamic, FALSE => The dialog is not dynamic
	 */
	public isTargetDynamicSource() {
		return this.isOpen() && this.target !== null;
	}

	/**
	 * Get the type of the dialog that is currently open.
	 * @returns The type of the dialog.
	 */
	public getType() {
		return this.type;
	}
}

/**
 * Implements the Custom Select inputs used in dialogs.
 */
class CustomSelect {
	private readonly data: DialogSelectInput;
	private readonly selected: boolean[];
	private lastSelected: number = -1;
	private focussed: number = -1;
	private open: boolean;

	private dialogElem: HTMLElement | null;
	private elem: HTMLElement | null;
	private currentElem: HTMLElement | null;
	private optionsElem: HTMLElement | null = null;
	private clickHandler: ((e: MouseEvent) => void) | null;

	/**
	 * Construct a new CustomSelect instance.
	 * @param data The data configuring the CustomSelect input.
	 * @param containerId The ID of the container to render the select input in.
	 * @param tabIndex The tabIndex of the select input.
	 * @param dialogElem The HTML Element of the dialog that the CustomSelect is being rendered in.
	 * @returns The CustomSelect instance.
	 */
	constructor(data: DialogSelectInput, containerId: string, tabIndex: number, dialogElem: HTMLElement) {
		this.data = data;
		this.selected = data.options.map(() => false);
		this.open = false;
		this.dialogElem = dialogElem;

		const container = document.getElementById(containerId)!;
		container.className = 'customSelectContainer';
		this.elem = container;

		const currentElem = document.createElement('div');
		currentElem.className = 'customSelectCurrent';
		currentElem.tabIndex = tabIndex;
		this.currentElem = currentElem;
		container.appendChild(currentElem);

		this.clickHandler = (e: MouseEvent) => {
			if (!e.target) return;
			const targetElem = <HTMLElement>e.target;
			if (targetElem.closest('.customSelectContainer') !== this.elem && (this.optionsElem === null || targetElem.closest('.customSelectOptions') !== this.optionsElem)) {
				this.render(false);
				return;
			}

			if (targetElem.className === 'customSelectCurrent') {
				this.render(!this.open);
			} else if (this.open) {
				const optionElem = <HTMLElement | null>targetElem.closest('.customSelectOption');
				if (optionElem !== null) {
					const selectedOptionIndex = parseInt(optionElem.dataset.index!);
					this.setItemSelectedState(selectedOptionIndex, data.multiple ? !this.selected[selectedOptionIndex] : true);
					if (!this.data.multiple) {
						this.render(false);
					}
					if (this.currentElem !== null) {
						this.currentElem.focus();
					}
				}
			}
		};
		document.addEventListener('click', this.clickHandler, true);

		currentElem.addEventListener('keydown', (e) => {
			if (this.open && e.key === 'Tab') {
				this.render(false);
			} else if (this.open && (e.key === 'Enter' || e.key === 'Escape')) {
				this.render(false);
				handledEvent(e);
			} else if (this.data.multiple) {
				if (e.key === ' ' && this.focussed > -1) {
					this.setItemSelectedState(this.focussed, !this.selected[this.focussed]);
					handledEvent(e);
				} else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
					if (!this.open) {
						this.render(true);
					}
					this.setFocussed(this.focussed > 0 ? this.focussed - 1 : this.data.options.length - 1);
					this.scrollOptionIntoView(this.focussed);
					handledEvent(e);
				} else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
					if (!this.open) {
						this.render(true);
					}
					this.setFocussed(this.focussed < this.data.options.length - 1 ? this.focussed + 1 : 0);
					this.scrollOptionIntoView(this.focussed);
					handledEvent(e);
				}
			} else {
				if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
					this.setItemSelectedState(this.lastSelected > 0 ? this.lastSelected - 1 : this.data.options.length - 1, true);
					this.scrollOptionIntoView(this.lastSelected);
					handledEvent(e);
				} else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
					this.setItemSelectedState(this.lastSelected < this.data.options.length - 1 ? this.lastSelected + 1 : 0, true);
					this.scrollOptionIntoView(this.lastSelected);
					handledEvent(e);
				}
			}
		});

		if (data.multiple) {
			for (let i = data.options.length - 1; i >= 0; i--) {
				if (data.defaults.includes(data.options[i].value)) {
					this.setItemSelectedState(i, true);
				}
			}
		} else {
			const defaultIndex = data.options.findIndex((option) => option.value === data.default);
			this.setItemSelectedState(defaultIndex > -1 ? defaultIndex : 0, true);
		}
		this.renderCurrentValue();
	}

	/**
	 * Remove a CustomSelect instance, cleaning up all resources that is linked to it.
	 */
	public remove() {
		this.dialogElem = null;
		if (this.elem !== null) {
			this.elem.remove();
			this.elem = null;
		}
		if (this.currentElem !== null) {
			this.currentElem.remove();
			this.currentElem = null;
		}
		if (this.optionsElem !== null) {
			this.optionsElem.remove();
			this.optionsElem = null;
		}
		if (this.clickHandler !== null) {
			document.removeEventListener('click', this.clickHandler, true);
			this.clickHandler = null;
		}
	}

	/**
	 * Get the value(s) selected by the user.
	 * @returns The selected value(s).
	 */
	public getValue() {
		const values = this.data.options.map((option) => option.value).filter((_, index) => this.selected[index]);
		return this.data.multiple ? values : values[0];
	}

	/**
	 * Set whether an item is selected.
	 * @param index The index of the item to alter.
	 * @param state The new state for whether the item is selected or not (TRUE => Selected, FALSE => Not Selected).
	 */
	private setItemSelectedState(index: number, state: boolean) {
		if (!this.data.multiple && this.lastSelected > -1) {
			this.selected[this.lastSelected] = false;
		}
		this.selected[index] = state;
		this.lastSelected = index;
		this.renderCurrentValue();
		this.renderOptionsStates();
	}

	/**
	 * Set the focused item of the select input.
	 * @param index The index of the item that should be focussed.
	 */
	private setFocussed(index: number) {
		if (this.focussed !== index) {
			if (this.focussed > -1) {
				const currentlyFocussedOption = this.getOptionElem(this.focussed);
				if (currentlyFocussedOption !== null) {
					alterClass(currentlyFocussedOption, CLASS_FOCUSSED, false);
				}
			}
			this.focussed = index;
			const newlyFocussedOption = this.getOptionElem(this.focussed);
			if (newlyFocussedOption !== null) {
				alterClass(newlyFocussedOption, CLASS_FOCUSSED, true);
			}
		}
	}

	/**
	 * Render the select input.
	 * @param open Should the select be open (displaying the select options list).
	 */
	private render(open: boolean) {
		if (this.elem === null || this.currentElem === null || this.dialogElem === null) return;

		if (this.open !== open) {
			this.open = open;
			if (open) {
				if (this.optionsElem !== null) {
					this.optionsElem.remove();
				}
				this.optionsElem = document.createElement('div');
				const currentElemRect = this.currentElem.getBoundingClientRect(), dialogElemRect = this.dialogElem.getBoundingClientRect();
				this.optionsElem.style.top = (currentElemRect.top - dialogElemRect.top + currentElemRect.height - 2) + 'px';
				this.optionsElem.style.left = (currentElemRect.left - dialogElemRect.left - 1) + 'px';
				this.optionsElem.style.width = currentElemRect.width + 'px';
				this.optionsElem.style.maxHeight = Math.max(document.body.clientHeight - currentElemRect.top - currentElemRect.height - 2, 50) + 'px';
				this.optionsElem.className = 'customSelectOptions' + (this.data.multiple ? ' multiple' : '');
				const icon = this.data.multiple ? '<div class="selectedIcon">' + SVG_ICONS.check + '</div>' : '';
				this.optionsElem.innerHTML = this.data.options.map((option, index) =>
					'<div class="customSelectOption" data-index="' + index + '">' + icon + escapeHtml(option.name) + '</div>'
				).join('');
				addListenerToCollectionElems(this.optionsElem.children, 'mousemove', (e) => {
					if (!e.target) return;
					const elem = (<HTMLElement>e.target).closest('.customSelectOption');
					if (elem === null) return;
					this.setFocussed(parseInt((<HTMLElement>elem).dataset.index!));
				});
				this.optionsElem.addEventListener('mouseleave', () => this.setFocussed(-1));
				this.dialogElem.appendChild(this.optionsElem);
			} else {
				if (this.optionsElem !== null) {
					this.optionsElem.remove();
					this.optionsElem = null;
				}
				this.setFocussed(-1);
			}
			alterClass(this.elem, 'open', open);
		}

		if (open) {
			this.renderOptionsStates();
		}
	}

	/**
	 * Render the current value of the select input.
	 */
	private renderCurrentValue() {
		if (this.currentElem === null) return;
		const value = formatCommaSeparatedList(this.data.options.filter((_, index) => this.selected[index]).map((option) => option.name)) || 'None';
		this.currentElem.title = value;
		this.currentElem.innerHTML = escapeHtml(value);
	}

	/**
	 * Render the selected & focussed states of each option with it's corresponding HTML Element.
	 */
	private renderOptionsStates() {
		if (this.optionsElem !== null) {
			let optionElems = this.optionsElem.children, elemIndex: number;
			for (let i = 0; i < optionElems.length; i++) {
				elemIndex = parseInt((<HTMLElement>optionElems[i]).dataset.index!);
				alterClass(<HTMLElement>optionElems[i], CLASS_SELECTED, this.selected[elemIndex]);
				alterClass(<HTMLElement>optionElems[i], CLASS_FOCUSSED, this.focussed === elemIndex);
			}
		}
	}

	/**
	 * Get the HTML Element of the option at the specified index.
	 * @param index The index of the item.
	 * @returns The HTML Element.
	 */
	private getOptionElem(index: number) {
		if (this.optionsElem !== null && index > -1) {
			const optionElems = this.optionsElem.children, indexStr = index.toString();
			for (let i = 0; i < optionElems.length; i++) {
				if ((<HTMLElement>optionElems[i]).dataset.index === indexStr) {
					return <HTMLElement>optionElems[i];
				}
			}
		}
		return null;
	}

	/**
	 * Scroll the HTML Element of an option to be visible in the options list.
	 * @param index The index of the option to scroll into view.
	 */
	private scrollOptionIntoView(index: number) {
		const elem = this.getOptionElem(index);
		if (this.optionsElem !== null && elem !== null) {
			const elemOffsetTop = elem.offsetTop, elemHeight = elem.clientHeight;
			const optionsScrollTop = this.optionsElem.scrollTop, optionsHeight = this.optionsElem.clientHeight;
			if (elemOffsetTop < optionsScrollTop) {
				this.optionsElem.scroll(0, elemOffsetTop);
			} else if (elemOffsetTop + elemHeight > optionsScrollTop + optionsHeight) {
				this.optionsElem.scroll(0, Math.max(elemOffsetTop + elemHeight - optionsHeight, 0));
			}
		}
	}
}
-e 

================================================================================
// FILE: ./web/textFormatter.ts
================================================================================
const CLASS_EXTERNAL_URL = 'externalUrl';
const CLASS_INTERNAL_URL = 'internalUrl';

namespace TF {
	export const enum NodeType {
		Asterisk,
		Code,
		CommitHash,
		DoubleAsterisk,
		DoubleUnderscore,
		Emoji,
		Plain,
		Root,
		Underscore,
		Url
	}

	interface BaseNode {
		type: NodeType;
		start: number;
		end: number;
		contains: Node[]
	}

	interface BaseValueNode extends BaseNode {
		value: string;
	}

	interface AsteriskNode extends BaseNode {
		type: NodeType.Asterisk | NodeType.DoubleAsterisk;
	}

	interface CodeNode extends BaseValueNode {
		type: NodeType.Code;
	}

	interface CommitHashNode extends BaseNode {
		type: NodeType.CommitHash;
		commit: string;
	}

	interface EmojiNode extends BaseNode {
		type: NodeType.Emoji;
		emoji: string;
	}

	interface PlainNode extends BaseValueNode {
		type: NodeType.Plain;
	}

	interface UnderscoreNode extends BaseNode {
		type: NodeType.Underscore | NodeType.DoubleUnderscore;
	}

	interface UrlNode extends BaseNode {
		type: NodeType.Url;
		url: string;
		displayText: string;
	}

	export interface RootNode extends BaseNode {
		type: NodeType.Root;
	}

	export type Node = AsteriskNode | CodeNode | CommitHashNode | EmojiNode | PlainNode | RootNode | UnderscoreNode | UrlNode;

	export const enum EmphasisDelimiterType {
		Asterisk = '*',
		Underscore = '_'
	}

	export interface EmphasisDelimiter {
		index: number;
		run: number;
	}

	export interface EmphasisRun {
		type: EmphasisDelimiterType;
		size: number;
		open: boolean;
		close: boolean;
		both: boolean;
	}

	export interface BacktickDelimiter {
		index: number;
		run: string;
	}

	export interface Config {
		commits?: boolean;
		emoji?: boolean;
		issueLinking?: boolean;
		markdown?: boolean;
		multiline?: boolean;
		urls?: boolean;
	}
}

/**
 * Parses text, and produces formatted HTML for the Git Graph View.
 */
class TextFormatter {
	private readonly config: Readonly<{
		commits: boolean,
		emoji: boolean,
		issueLinking: boolean,
		markdown: boolean,
		multiline: boolean,
		urls: boolean
	}>;
	private readonly commits: ReadonlyArray<GG.GitCommit>;
	private readonly issueLinking: IssueLinking | null = null;

	private static readonly BACKTICK_REGEXP: RegExp = /(\\*)(`+)/gu;
	private static readonly BACKSLASH_ESCAPE_REGEXP: RegExp = /\\[\u0021-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E]/gu;
	private static readonly COMMIT_REGEXP: RegExp = /\b([0-9a-fA-F]{6,})\b/gu;
	private static readonly EMOJI_REGEXP: RegExp = /:([A-Za-z0-9-_]+):/gu;
	private static readonly EMPHASIS_REGEXP: RegExp = /(\\+|[^*_]?)([*_]+)(.?)/gu;
	private static readonly INDENT_REGEXP: RegExp = /^[ \t]+/u;
	private static readonly PUNCTUATION_REGEXP: RegExp = /[\u0021-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/u;
	private static readonly URL_REGEXP: RegExp = /https?:\/\/\S+[^,.?!'":;\s]/gu;
	private static readonly WHITESPACE_REGEXP: RegExp = /^([\u0009\u000A\u000C\u000D\u0020\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]|)$/u;
	private static readonly EMOJI_MAPPINGS: { [shortcode: string]: string } = { 'adhesive_bandage': '', 'alembic': '', 'alien': '', 'ambulance': '', 'apple': '', 'arrow_down': '', 'arrow_up': '', 'art': '', 'beers': '', 'bento': '', 'bookmark': '', 'books': '', 'boom': '', 'bug': '', 'building_construction': '', 'bulb': '', 'busts_in_silhouette': '', 'camera_flash': '', 'card_file_box': '', 'card_index': '', 'chart_with_upwards_trend': '', 'checkered_flag': '', 'children_crossing': '', 'clown_face': '', 'construction': '', 'construction_worker': '', 'dizzy': '', 'egg': '', 'exclamation': '', 'fire': '', 'globe_with_meridians': '', 'goal_net': '', 'green_apple': '', 'green_heart': '', 'hammer': '', 'heavy_check_mark': '', 'heavy_minus_sign': '', 'heavy_plus_sign': '', 'iphone': '', 'label': '', 'lipstick': '', 'lock': '', 'loud_sound': '', 'mag': '', 'memo': '', 'mute': '', 'new': '', 'ok_hand': '', 'package': '', 'page_facing_up': '', 'passport_control': '', 'pencil': '', 'pencil2': '', 'penguin': '', 'poop': '', 'pushpin': '', 'racehorse': '', 'recycle': '', 'rewind': '', 'robot': '', 'rocket': '', 'rotating_light': '', 'see_no_evil': '', 'seedling': '', 'shirt': '', 'sparkles': '', 'speech_balloon': '', 'tada': '', 'triangular_flag_on_post': '', 'triangular_ruler': '', 'truck': '', 'twisted_rightwards_arrows': '', 'video_game': '', 'wastebasket': '', 'whale': '', 'wheel_of_dharma': '', 'wheelchair': '', 'white_check_mark': '', 'wrench': '', 'zap': '' };
	private static readonly ENCLOSING_GROUPS: { [close: string]: string } = { ')': '(', ']': '[', '}': '{', '>': '<', '*': '*', '_': '_' };

	/**
	 * Construct a TextFormatter instance.
	 * @param commits The array of commits currently loaded in the Git Graph View.
	 * @param repoIssueLinkingConfig The Issue Linking Configuration of the current repository.
	 * @param config The configuration of the TextFormatter, to determine which types of formatting should be performed.
	 * @returns The TextFormatter instance.
	 */
	constructor(commits: ReadonlyArray<GG.GitCommit>, repoIssueLinkingConfig: GG.IssueLinkingConfig | null, config: TF.Config) {
		this.config = Object.assign({ commits: false, emoji: false, issueLinking: false, markdown: false, multiline: false, urls: false }, config);
		this.commits = commits;
		const issueLinkingConfig = repoIssueLinkingConfig !== null
			? repoIssueLinkingConfig
			: globalState.issueLinkingConfig;

		if (this.config.issueLinking) {
			this.issueLinking = parseIssueLinkingConfig(issueLinkingConfig);
		}
	}

	/**
	 * Convert input plain text into formatted HTML.
	 * @param input The input plain text.
	 * @returns The formatted HTML.
	 */
	public format(input: string) {
		if (this.config.multiline) {
			let html = [], lines = input.split('\n'), i, j, match;
			for (i = 0; i < lines.length; i++) {
				if (i > 0) {
					html.push('<br/>');
				}

				j = 0;
				if (match = lines[i].match(TextFormatter.INDENT_REGEXP)) {
					for (j = 0; j < match[0].length; j++) {
						html.push(match[0][j] === '\t' ? '&nbsp;&nbsp;&nbsp;&nbsp;' : '&nbsp;');
					}
				}

				html.push(this.formatLine(j > 0 ? lines[i].substring(j) : lines[i]));
			}
			return html.join('');
		} else {
			return this.formatLine(input);
		}
	}

	/**
	 * Convert a single line of input text into formatted HTML.
	 * @param input The input plain text.
	 * @returns The formatted HTML.
	 */
	private formatLine(input: string) {
		const tree: TF.RootNode = {
			type: TF.NodeType.Root,
			start: -1,
			end: input.length,
			contains: []
		};

		let match: RegExpExecArray | null;

		if (this.config.markdown) {
			// Backtick Code Blocks
			const backTickStack: TF.BacktickDelimiter[] = [];
			TextFormatter.BACKTICK_REGEXP.lastIndex = 0;
			while (match = TextFormatter.BACKTICK_REGEXP.exec(input)) {
				let backtick = { index: match.index + match[1].length, run: match[2] }, i;
				if (backTickStack.length === 0) {
					if (match[1].length % 2 === 1) {
						if (backtick.run.length > 1) {
							backtick.index++;
							backtick.run = backtick.run.substring(1);
						} else {
							continue;
						}
					}
				}

				for (i = backTickStack.length - 1; i >= 0; i--) {
					if (backTickStack[i].run === backtick.run) {
						let value = input.substring(backTickStack[i].index + backtick.run.length, backtick.index);
						if (value.startsWith(' ') && value.endsWith(' ') && /[^ ]/.test(value)) {
							value = value.substring(1, value.length - 1);
						}
						TextFormatter.insertIntoTree(tree, {
							type: TF.NodeType.Code,
							start: backTickStack[i].index,
							end: backtick.index + backtick.run.length - 1,
							value: value,
							contains: []
						});
						backTickStack.splice(i);
						break;
					}
				}
				if (i === -1) {
					backTickStack.push(backtick);
				}
			}
		}

		if (this.config.urls) {
			// Url Links
			TextFormatter.URL_REGEXP.lastIndex = 0;
			while (match = TextFormatter.URL_REGEXP.exec(input)) {
				let url = match[0];
				const suffix = url.substring(url.length - 1);
				if (match.index > 0 && typeof TextFormatter.ENCLOSING_GROUPS[suffix] === 'string' && input.substring(match.index - 1, match.index) === TextFormatter.ENCLOSING_GROUPS[suffix]) {
					url = url.substring(0, url.length - 1);
					TextFormatter.URL_REGEXP.lastIndex--;
				}
				TextFormatter.insertIntoTreeIfNoOverlap(tree, {
					type: TF.NodeType.Url,
					start: match.index,
					end: TextFormatter.URL_REGEXP.lastIndex - 1,
					url: url,
					displayText: url,
					contains: []
				});
			}
		}

		if (this.issueLinking !== null) {
			// Issue Links
			this.issueLinking.regexp.lastIndex = 0;
			while (match = this.issueLinking.regexp.exec(input)) {
				if (match[0].length === 0) break;
				TextFormatter.insertIntoTreeIfNoOverlap(tree, {
					type: TF.NodeType.Url,
					start: match.index,
					end: this.issueLinking.regexp.lastIndex - 1,
					url: generateIssueLinkFromMatch(match, this.issueLinking),
					displayText: match[0],
					contains: []
				});
			}
		}

		if (this.config.commits) {
			// Commit Hash Links
			TextFormatter.COMMIT_REGEXP.lastIndex = 0;
			while (match = TextFormatter.COMMIT_REGEXP.exec(input)) {
				const hash = match[0].toLowerCase();
				const commit = this.commits.find((commit) => commit.hash.toLowerCase().startsWith(hash));
				if (commit) {
					TextFormatter.insertIntoTreeIfNoOverlap(tree, {
						type: TF.NodeType.CommitHash,
						commit: commit.hash,
						start: match.index,
						end: TextFormatter.COMMIT_REGEXP.lastIndex - 1,
						contains: []
					});
				}
			}
		}

		if (this.config.markdown) {
			// Backslash Characters
			TextFormatter.BACKSLASH_ESCAPE_REGEXP.lastIndex = 0;
			while (match = TextFormatter.BACKSLASH_ESCAPE_REGEXP.exec(input)) {
				TextFormatter.insertIntoTreeIfNoOverlap(tree, {
					type: TF.NodeType.Plain,
					start: match.index,
					end: TextFormatter.BACKSLASH_ESCAPE_REGEXP.lastIndex - 1,
					value: match[0].substring(1),
					contains: []
				});
			}
		}

		if (this.config.emoji) {
			// Emoji Shortcode
			TextFormatter.EMOJI_REGEXP.lastIndex = 0;
			while (match = TextFormatter.EMOJI_REGEXP.exec(input)) {
				if (typeof TextFormatter.EMOJI_MAPPINGS[match[1]] === 'string') {
					TextFormatter.insertIntoTreeIfNoOverlap(tree, {
						type: TF.NodeType.Emoji,
						start: match.index,
						end: TextFormatter.EMOJI_REGEXP.lastIndex - 1,
						emoji: TextFormatter.EMOJI_MAPPINGS[match[1]],
						contains: []
					});
				}
			}
		}

		if (this.config.markdown) {
			// Emphasis
			const emphasisTokens: TF.EmphasisDelimiter[] = [], emphasisRuns: TF.EmphasisRun[] = [];
			let runLength: number, whitespaceBefore: boolean, whitespaceAfter: boolean, punctuationBefore: boolean, punctuationAfter: boolean, isLeft: boolean, isRight: boolean, isOpen: boolean, isClosed: boolean;
			TextFormatter.EMPHASIS_REGEXP.lastIndex = 0;
			while (match = TextFormatter.EMPHASIS_REGEXP.exec(input)) {
				let prev = 0, cur = 1, next = 2, index = match.index;
				const seq = [match[1]];
				seq.push(...match[2].split(''));
				seq.push(match[3]);

				if (seq[0].startsWith('\\')) {
					if (seq[0].length % 2 === 1) {
						index += seq[0].length;
						seq.shift();
					} else {
						index += seq[0].length - 1;
						seq[0] = '\\';
					}
				}

				index += seq[prev].length;
				while (cur < seq.length - 1) {
					while (next < seq.length - 1 && seq[cur] === seq[next]) next++;

					runLength = next - cur;
					whitespaceBefore = TextFormatter.WHITESPACE_REGEXP.test(seq[prev]);
					whitespaceAfter = TextFormatter.WHITESPACE_REGEXP.test(seq[next]);
					punctuationBefore = TextFormatter.PUNCTUATION_REGEXP.test(seq[prev]);
					punctuationAfter = TextFormatter.PUNCTUATION_REGEXP.test(seq[next]);
					isLeft = !whitespaceAfter && (!punctuationAfter || (punctuationAfter && (whitespaceBefore || punctuationBefore)));
					isRight = !whitespaceBefore && (!punctuationBefore || (punctuationBefore && (whitespaceAfter || punctuationAfter)));

					if (seq[cur] === TF.EmphasisDelimiterType.Asterisk) {
						isOpen = isLeft;
						isClosed = isRight;
					} else {
						isOpen = isLeft && (!isRight || punctuationBefore);
						isClosed = isRight && (!isLeft || punctuationAfter);
					}

					for (let i = 0; i < runLength; i++) {
						if (!TextFormatter.isInTree(tree, index + i, index + i)) {
							emphasisTokens.push({ index: index + i, run: emphasisRuns.length });
						}
					}

					emphasisRuns.push({
						type: <TF.EmphasisDelimiterType>seq[cur],
						size: runLength,
						open: isOpen,
						close: isClosed,
						both: isOpen && isClosed
					});

					index += runLength;
					prev = cur;
					cur = next;
					next = cur + 1;
				}

				TextFormatter.EMPHASIS_REGEXP.lastIndex -= seq[seq.length - 1].length;
			}
			const emphasisStack: TF.EmphasisDelimiter[] = [];
			let stackMatch: number;
			for (let i = 0; i < emphasisTokens.length; i++) {
				const delimiter = emphasisTokens[i];
				const run = emphasisRuns[delimiter.run];
				if (run.close && (stackMatch = TextFormatter.findOpenEmphasis(delimiter, run, emphasisRuns, emphasisStack)) > -1) {
					TextFormatter.insertIntoTree(tree, {
						type: emphasisRuns[emphasisStack[stackMatch].run].type === TF.EmphasisDelimiterType.Asterisk ? TF.NodeType.Asterisk : TF.NodeType.Underscore,
						start: emphasisStack[stackMatch].index,
						end: delimiter.index,
						contains: []
					});
					emphasisStack.splice(stackMatch);
				} else if (run.open) {
					emphasisStack.push(delimiter);
				}
			}
			TextFormatter.combineNestedEmphasis(tree);
		}

		// Generate HTML
		const html = [];
		let nextHtmlIndex = 0;
		const rec = (node: TF.Node) => {
			if (nextHtmlIndex < node.start) {
				html.push(escapeHtml(input.substring(nextHtmlIndex, node.start)));
			}
			switch (node.type) {
				case TF.NodeType.Asterisk:
				case TF.NodeType.Underscore:
					nextHtmlIndex = node.start + 1;
					html.push('<em>');
					node.contains.forEach(rec);
					if (nextHtmlIndex < node.end) {
						html.push(escapeHtml(input.substring(nextHtmlIndex, node.end)));
					}
					html.push('</em>');
					break;
				case TF.NodeType.DoubleAsterisk:
				case TF.NodeType.DoubleUnderscore:
					nextHtmlIndex = node.start + 2;
					html.push('<strong>');
					node.contains.forEach(rec);
					if (nextHtmlIndex < node.end - 1) {
						html.push(escapeHtml(input.substring(nextHtmlIndex, node.end - 1)));
					}
					html.push('</strong>');
					break;
				case TF.NodeType.Plain:
					html.push(escapeHtml(node.value));
					break;
				case TF.NodeType.Code:
					html.push('<code>', escapeHtml(node.value), '</code>');
					break;
				case TF.NodeType.CommitHash:
					html.push('<span class="', CLASS_INTERNAL_URL, '" data-type="commit" data-value="', escapeHtml(node.commit), '" tabindex="-1">', escapeHtml(input.substring(node.start, node.end + 1)), '</span>');
					break;
				case TF.NodeType.Url:
					html.push('<a class="', CLASS_EXTERNAL_URL, '" href="', escapeHtml(node.url), '" tabindex="-1">', escapeHtml(node.displayText), '</a>');
					break;
				case TF.NodeType.Emoji:
					html.push(node.emoji);
					break;
			}
			nextHtmlIndex = node.end + 1;
		};
		tree.contains.forEach(rec);
		if (nextHtmlIndex < input.length) {
			html.push(escapeHtml(input.substring(nextHtmlIndex)));
		}
		return html.join('');
	}

	/**
	 * Register user-defined custom emoji mappings.
	 * @param mappings The user-defined mappings.
	 */
	public static registerCustomEmojiMappings(mappings: ReadonlyArray<GG.CustomEmojiShortcodeMapping>) {
		const validShortcodeRegExp = /^:[A-Za-z0-9-_]+:$/;
		for (let i = 0; i < mappings.length; i++) {
			if (validShortcodeRegExp.test(mappings[i].shortcode)) {
				TextFormatter.EMOJI_MAPPINGS[mappings[i].shortcode.substring(1, mappings[i].shortcode.length - 1)] = mappings[i].emoji;
			}
		}
	}

	/**
	 * Find the matching open emphasis delimiter in a stack.
	 * @param delimiter The closing emphasis.
	 * @param run The emphasis run containing the closing emphasis.
	 * @param runs An array of all known emphasis runs.
	 * @param stack The stack of open emphasis delimiters.
	 * @returns The stack index of the matching open emphasis delimiter, or -1 if no match could be found.
	 */
	private static findOpenEmphasis(delimiter: TF.EmphasisDelimiter, run: TF.EmphasisRun, runs: TF.EmphasisRun[], stack: TF.EmphasisDelimiter[]) {
		let i = stack.length - 1;
		while (i >= 0) {
			if (stack[i].run !== delimiter.run && runs[stack[i].run].type === run.type && (!(runs[stack[i].run].both || run.both) || ((runs[stack[i].run].size + run.size) % 3 !== 0) || ((runs[stack[i].run].size % 3 === 0) && (run.size % 3 === 0)))) {
				return i;
			}
			i--;
		}
		return -1;
	}

	/**
	 * Recursively traverse the tree, and combine directly nested emphasis (asterisks & underscores) into double asterisks and double underscores where possible.
	 * @param tree The tree to traverse.
	 */
	private static combineNestedEmphasis(tree: TF.Node) {
		tree.contains.forEach(TextFormatter.combineNestedEmphasis);
		if (tree.contains.length === 1 && tree.type === tree.contains[0].type && (tree.type === TF.NodeType.Asterisk || tree.type === TF.NodeType.Underscore) && tree.start + 1 === tree.contains[0].start && tree.contains[0].end === tree.end - 1) {
			tree.type = tree.type === TF.NodeType.Asterisk
				? TF.NodeType.DoubleAsterisk
				: TF.NodeType.DoubleUnderscore;
			tree.contains = tree.contains[0].contains;
		}
	}

	/**
	 * Inserts a node into a tree of nodes (according to it's start and end).
	 * @param tree The tree the node should be inserted in.
	 * @param node The node to insert.
	 */
	private static insertIntoTree(tree: TF.Node, node: TF.Node) {
		let firstChildIndexOfNode = -1, lastChildIndexOfNode = -1, curNode;
		for (let i = 0; i < tree.contains.length; i++) {
			curNode = tree.contains[i];
			if (node.start < curNode.start && firstChildIndexOfNode === -1) {
				firstChildIndexOfNode = i;
			}
			if (curNode.end < node.end) {
				lastChildIndexOfNode = i;
			} else {
				break;
			}
		}
		if (firstChildIndexOfNode === -1) {
			tree.contains.push(node);
		} else if (lastChildIndexOfNode === -1) {
			tree.contains.unshift(node);
		} else {
			node.contains = tree.contains.slice(firstChildIndexOfNode, lastChildIndexOfNode + 1);
			tree.contains.splice(firstChildIndexOfNode, lastChildIndexOfNode - firstChildIndexOfNode + 1, node);
		}
	}

	/**
	 * Inserts a node into a tree of nodes (according to it's start and end), only if it doesn't overlap with an existing node in the tree.
	 * @param tree The tree the node should be inserted in.
	 * @param node The node to insert.
	 */
	private static insertIntoTreeIfNoOverlap(tree: TF.RootNode, node: TF.Node) {
		let curNode: TF.Node, insertAtIndex = tree.contains.length;
		for (let i = 0; i < tree.contains.length; i++) {
			curNode = tree.contains[i];
			if ((curNode.start <= node.start && node.start <= curNode.end) || (curNode.start <= node.end && node.end <= curNode.end) || (node.start <= curNode.start && curNode.end <= node.end)) {
				return;
			} else if (node.end < curNode.start) {
				insertAtIndex = i;
				break;
			}
		}
		tree.contains.splice(insertAtIndex, 0, node);
	}

	/**
	 * Is a range included (partially or completely) within a tree.
	 * @param tree The tree to check.
	 * @param start The index defining the start of the range.
	 * @param end The index defining the end of the range.
	 * @returns TRUE => The range overlaps with node(s) in the tree, FALSE => There is no overlap between the range and any node in the tree.
	 */
	private static isInTree(tree: TF.RootNode, start: number, end: number) {
		return tree.contains.some((node) => (node.start <= start && start <= node.end) || (node.start <= end && end <= node.end) || (start <= node.start && node.end <= end));
	}
}


/* URL Element Methods */

/**
 * Is an element an external or internal URL.
 * @param elem The element to check.
 * @returns TRUE => The element is an external or internal URL, FALSE => The element isn't an external or internal URL
 */
function isUrlElem(elem: Element) {
	return elem.classList.contains(CLASS_EXTERNAL_URL) || elem.classList.contains(CLASS_INTERNAL_URL);
}

/**
 * Is an element an external URL.
 * @param elem The element to check.
 * @returns TRUE => The element is an external URL, FALSE => The element isn't an external URL
 */
function isExternalUrlElem(elem: Element) {
	return elem.classList.contains(CLASS_EXTERNAL_URL);
}

/**
 * Is an element an internal URL.
 * @param elem The element to check.
 * @returns TRUE => The element is an internal URL, FALSE => The element isn't an internal URL
 */
function isInternalUrlElem(elem: Element) {
	return elem.classList.contains(CLASS_INTERNAL_URL);
}


/* Issue Linking Methods */

interface IssueLinking {
	readonly regexp: RegExp;
	readonly url: string;
}

const ISSUE_LINKING_ARGUMENT_REGEXP = /\$([1-9][0-9]*)/g;

/**
 * Parses the Issue Linking Configuration of a repository, so it's ready to be used for detecting issues and generating links.
 * @param issueLinkingConfig The Issue Linking Configuration.
 * @returns The parsed Issue Linking, or `NULL` if it's not available.
 */
function parseIssueLinkingConfig(issueLinkingConfig: GG.IssueLinkingConfig | null): IssueLinking | null {
	if (issueLinkingConfig !== null) {
		try {
			return {
				regexp: new RegExp(issueLinkingConfig.issue, 'gu'),
				url: issueLinkingConfig.url
			};
		} catch (_) { }
	}
	return null;
}

/**
 * Generate the URL for an issue link, performing all variable substitutions from a match.
 * @param match The match produced by `IssueLinking.regexp`.
 * @param issueLinking The Issue Linking.
 * @returns The URL for the issue link.
 */
function generateIssueLinkFromMatch(match: RegExpExecArray, issueLinking: IssueLinking) {
	return match.length > 1
		? issueLinking.url.replace(ISSUE_LINKING_ARGUMENT_REGEXP, (placeholder, index) => {
			const i = parseInt(index);
			return i < match.length ? match[i] : placeholder;
		})
		: issueLinking.url;
}
-e 

================================================================================
// FILE: ./web/dropdown.ts
================================================================================
interface DropdownOption {
	readonly name: string;
	readonly value: string;
	readonly hint?: string;
}

/**
 * Implements the dropdown inputs used in the Git Graph View's top control bar.
 */
class Dropdown {
	private readonly showInfo: boolean;
	private readonly multipleAllowed: boolean;
	private readonly changeCallback: (values: string[]) => void;

	private options: ReadonlyArray<DropdownOption> = [];
	private optionsSelected: boolean[] = [];
	private lastSelected: number = 0; // Only used when multipleAllowed === false
	private dropdownVisible: boolean = false;
	private lastClicked: number = 0;
	private doubleClickTimeout: NodeJS.Timer | null = null;

	private readonly elem: HTMLElement;
	private readonly currentValueElem: HTMLDivElement;
	private readonly menuElem: HTMLDivElement;
	private readonly optionsElem: HTMLDivElement;
	private readonly noResultsElem: HTMLDivElement;
	private readonly filterInput: HTMLInputElement;

	/**
	 * Constructs a Dropdown instance.
	 * @param id The ID of the HTML Element that the dropdown should be rendered in.
	 * @param showInfo Should an information icon be shown on the right of each dropdown item.
	 * @param multipleAllowed Can multiple items be selected.
	 * @param dropdownType The type of content the dropdown is being used for.
	 * @param changeCallback A callback to be invoked when the selected item(s) of the dropdown changes.
	 * @returns The Dropdown instance.
	 */
	constructor(id: string, showInfo: boolean, multipleAllowed: boolean, dropdownType: string, changeCallback: (values: string[]) => void) {
		this.showInfo = showInfo;
		this.multipleAllowed = multipleAllowed;
		this.changeCallback = changeCallback;
		this.elem = document.getElementById(id)!;

		this.menuElem = document.createElement('div');
		this.menuElem.className = 'dropdownMenu';

		let filter = this.menuElem.appendChild(document.createElement('div'));
		filter.className = 'dropdownFilter';

		this.filterInput = filter.appendChild(document.createElement('input'));
		this.filterInput.className = 'dropdownFilterInput';
		this.filterInput.placeholder = 'Filter ' + dropdownType + '...';

		this.optionsElem = this.menuElem.appendChild(document.createElement('div'));
		this.optionsElem.className = 'dropdownOptions';

		this.noResultsElem = this.menuElem.appendChild(document.createElement('div'));
		this.noResultsElem.className = 'dropdownNoResults';
		this.noResultsElem.innerHTML = 'No results found.';

		this.currentValueElem = this.elem.appendChild(document.createElement('div'));
		this.currentValueElem.className = 'dropdownCurrentValue';

		alterClass(this.elem, 'multi', multipleAllowed);
		this.elem.appendChild(this.menuElem);

		document.addEventListener('click', (e) => {
			if (!e.target) return;
			if (e.target === this.currentValueElem) {
				this.dropdownVisible = !this.dropdownVisible;
				if (this.dropdownVisible) {
					this.filterInput.value = '';
					this.filter();
				}
				this.elem.classList.toggle('dropdownOpen');
				if (this.dropdownVisible) this.filterInput.focus();
			} else if (this.dropdownVisible) {
				if ((<HTMLElement>e.target).closest('.dropdown') !== this.elem) {
					this.close();
				} else {
					const option = <HTMLElement | null>(<HTMLElement>e.target).closest('.dropdownOption');
					if (option !== null && option.parentNode === this.optionsElem && typeof option.dataset.id !== 'undefined') {
						this.onOptionClick(parseInt(option.dataset.id!));
					}
				}
			}
		}, true);
		document.addEventListener('contextmenu', () => this.close(), true);
		this.filterInput.addEventListener('keyup', () => this.filter());
	}

	/**
	 * Set the options that should be displayed in the dropdown.
	 * @param options An array of the options to display in the dropdown.
	 * @param optionsSelected An array of the selected options in the dropdown.
	 */
	public setOptions(options: ReadonlyArray<DropdownOption>, optionsSelected: string[]) {
		this.options = options;
		this.optionsSelected = [];
		let selectedOption = -1, isSelected;
		for (let i = 0; i < options.length; i++) {
			isSelected = optionsSelected.includes(options[i].value);
			this.optionsSelected[i] = isSelected;
			if (isSelected) {
				selectedOption = i;
			}
		}
		if (selectedOption === -1) {
			selectedOption = 0;
			this.optionsSelected[selectedOption] = true;
		}
		this.lastSelected = selectedOption;
		if (this.dropdownVisible && options.length <= 1) this.close();
		this.render();
		this.clearDoubleClickTimeout();
	}

	/**
	 * Is a value selected in the dropdown (respecting "Show All")
	 * @param value The value to check.
	 * @returns TRUE => The value is selected, FALSE => The value is not selected.
	 */
	public isSelected(value: string) {
		if (this.options.length > 0) {
			if (this.multipleAllowed && this.optionsSelected[0]) {
				// Multiple options can be selected, and "Show All" is selected.
				return true;
			}
			const optionIndex = this.options.findIndex((option) => option.value === value);
			if (optionIndex > -1 && this.optionsSelected[optionIndex]) {
				// The specific option is selected
				return true;
			}
		}
		return false;
	}

	/**
	 * Select a specific value in the dropdown.
	 * @param value The value to select.
	 */
	public selectOption(value: string) {
		const optionIndex = this.options.findIndex((option) => value === option.value);
		if (this.multipleAllowed && optionIndex > -1 && !this.optionsSelected[0] && !this.optionsSelected[optionIndex]) {
			// Select the option with the specified value
			this.optionsSelected[optionIndex] = true;

			// A change has occurred, re-render the dropdown options
			const menuScroll = this.menuElem.scrollTop;
			this.render();
			if (this.dropdownVisible) {
				this.menuElem.scroll(0, menuScroll);
			}
			this.changeCallback(this.getSelectedOptions(false));
		}
	}

	/**
	 * Unselect a specific value in the dropdown.
	 * @param value The value to unselect.
	 */
	public unselectOption(value: string) {
		const optionIndex = this.options.findIndex((option) => value === option.value);
		if (this.multipleAllowed && optionIndex > -1 && (this.optionsSelected[0] || this.optionsSelected[optionIndex])) {
			if (this.optionsSelected[0]) {
				// Show All is currently selected, so unselect it, and select all branch options
				this.optionsSelected[0] = false;
				for (let i = 1; i < this.optionsSelected.length; i++) {
					this.optionsSelected[i] = true;
				}
			}

			// Unselect the option with the specified value
			this.optionsSelected[optionIndex] = false;
			if (this.optionsSelected.every(selected => !selected)) {
				// All items have been unselected, select "Show All"
				this.optionsSelected[0] = true;
			}

			// A change has occurred, re-render the dropdown options
			const menuScroll = this.menuElem.scrollTop;
			this.render();
			if (this.dropdownVisible) {
				this.menuElem.scroll(0, menuScroll);
			}
			this.changeCallback(this.getSelectedOptions(false));
		}
	}

	/**
	 * Refresh the rendered dropdown to apply style changes.
	 */
	public refresh() {
		if (this.options.length > 0) this.render();
	}

	/**
	 * Is the dropdown currently open (i.e. is the list of options visible).
	 * @returns TRUE => The dropdown is open, FALSE => The dropdown is not open
	 */
	public isOpen() {
		return this.dropdownVisible;
	}

	/**
	 * Close the dropdown.
	 */
	public close() {
		this.elem.classList.remove('dropdownOpen');
		this.dropdownVisible = false;
		this.clearDoubleClickTimeout();
	}

	/**
	 * Render the dropdown.
	 */
	private render() {
		this.elem.classList.add('loaded');

		const curValueText = formatCommaSeparatedList(this.getSelectedOptions(true));
		this.currentValueElem.title = curValueText;
		this.currentValueElem.innerHTML = escapeHtml(curValueText);

		let html = '';
		for (let i = 0; i < this.options.length; i++) {
			const escapedName = escapeHtml(this.options[i].name);
			html += '<div class="dropdownOption' + (this.optionsSelected[i] ? ' ' + CLASS_SELECTED : '') + '" data-id="' + i + '" title="' + escapedName + '">' +
				(this.multipleAllowed && this.optionsSelected[i] ? '<div class="dropdownOptionMultiSelected">' + SVG_ICONS.check + '</div>' : '') +
				escapedName + (typeof this.options[i].hint === 'string' && this.options[i].hint !== '' ? '<span class="dropdownOptionHint">' + escapeHtml(this.options[i].hint!) + '</span>' : '') +
				(this.showInfo ? '<div class="dropdownOptionInfo" title="' + escapeHtml(this.options[i].value) + '">' + SVG_ICONS.info + '</div>' : '') +
				'</div>';
		}
		this.optionsElem.className = 'dropdownOptions' + (this.showInfo ? ' showInfo' : '');
		this.optionsElem.innerHTML = html;
		this.filterInput.style.display = 'none';
		this.noResultsElem.style.display = 'none';
		this.menuElem.style.cssText = 'opacity:0; display:block;';
		// Width must be at least 138px for the filter element.
		// Don't need to add 12px if showing (info icons or multi checkboxes) and the scrollbar isn't needed. The scrollbar isn't needed if: menuElem height + filter input (25px) < 297px
		const menuElemRect = this.menuElem.getBoundingClientRect();
		this.currentValueElem.style.width = Math.max(Math.ceil(menuElemRect.width) + ((this.showInfo || this.multipleAllowed) && menuElemRect.height < 272 ? 0 : 12), 138) + 'px';
		this.menuElem.style.cssText = 'right:0; overflow-y:auto; max-height:297px;'; // Max height for the dropdown is [filter (31px) + 9.5 * dropdown item (28px) = 297px]
		if (this.dropdownVisible) this.filter();
	}

	/**
	 * Filter the options displayed in the dropdown list, based on the filter criteria specified by the user.
	 */
	private filter() {
		let val = this.filterInput.value.toLowerCase(), match, matches = false;
		for (let i = 0; i < this.options.length; i++) {
			match = this.options[i].name.toLowerCase().indexOf(val) > -1;
			(<HTMLElement>this.optionsElem.children[i]).style.display = match ? 'block' : 'none';
			if (match) matches = true;
		}
		this.filterInput.style.display = 'block';
		this.noResultsElem.style.display = matches ? 'none' : 'block';
	}

	/**
	 * Get an array of the selected dropdown options.
	 * @param names TRUE => Return the names of the selected options, FALSE => Return the values of the selected options.
	 * @returns The array of the selected options.
	 */
	private getSelectedOptions(names: boolean) {
		let selected = [];
		if (this.multipleAllowed && this.optionsSelected[0]) {
			// Note: Show All is always the first option (0 index) when multiple selected items are allowed
			return [names ? this.options[0].name : this.options[0].value];
		}
		for (let i = 0; i < this.options.length; i++) {
			if (this.optionsSelected[i]) selected.push(names ? this.options[i].name : this.options[i].value);
		}
		return selected;
	}

	/**
	 * Select a dropdown option.
	 * @param option The index of the option to select.
	 */
	private onOptionClick(option: number) {
		// Note: Show All is always the first option (0 index) when multiple selected items are allowed
		let change = false;
		let doubleClick = this.doubleClickTimeout !== null && this.lastClicked === option;
		if (this.doubleClickTimeout !== null) this.clearDoubleClickTimeout();

		if (doubleClick) {
			// Double click
			if (this.multipleAllowed && option === 0) {
				for (let i = 1; i < this.optionsSelected.length; i++) {
					this.optionsSelected[i] = !this.optionsSelected[i];
				}
				change = true;
			}
		} else {
			// Single Click
			if (this.multipleAllowed) {
				// Multiple dropdown options can be selected
				if (option === 0) {
					// Show All was selected
					if (!this.optionsSelected[0]) {
						this.optionsSelected[0] = true;
						for (let i = 1; i < this.optionsSelected.length; i++) {
							this.optionsSelected[i] = false;
						}
						change = true;
					}
				} else {
					if (this.optionsSelected[0]) {
						// Deselect "Show All" if it is enabled
						this.optionsSelected[0] = false;
					}

					this.optionsSelected[option] = !this.optionsSelected[option];

					if (this.optionsSelected.every(selected => !selected)) {
						// All items have been unselected, select "Show All"
						this.optionsSelected[0] = true;
					}
					change = true;
				}
			} else {
				// Only a single dropdown option can be selected
				this.close();
				if (this.lastSelected !== option) {
					this.optionsSelected[this.lastSelected] = false;
					this.optionsSelected[option] = true;
					this.lastSelected = option;
					change = true;
				}
			}

			if (change) {
				// If a change has occurred, trigger the callback
				this.changeCallback(this.getSelectedOptions(false));
			}
		}

		if (change) {
			// If a change has occurred, re-render the dropdown elements
			let menuScroll = this.menuElem.scrollTop;
			this.render();
			if (this.dropdownVisible) this.menuElem.scroll(0, menuScroll);
		}

		this.lastClicked = option;
		this.doubleClickTimeout = setTimeout(() => {
			this.clearDoubleClickTimeout();
		}, 500);
	}

	/**
	 * Clear the timeout used to detect double clicks.
	 */
	private clearDoubleClickTimeout() {
		if (this.doubleClickTimeout !== null) {
			clearTimeout(this.doubleClickTimeout);
			this.doubleClickTimeout = null;
		}
	}
}
-e 

================================================================================
// FILE: ./web/global.d.ts
================================================================================
import * as GG from '../out/types'; // Import types from back-end (requires `npm run compile-src`)

declare global {

	/* Visual Studio Code API Types */

	function acquireVsCodeApi(): {
		getState: () => WebViewState | null,
		postMessage: (message: GG.RequestMessage) => void,
		setState: (state: WebViewState) => void
	};


	/* State Types */

	type Config = GG.GitGraphViewConfig;

	const initialState: GG.GitGraphViewInitialState;
	const globalState: GG.DeepReadonly<GG.GitGraphViewGlobalState>;
	const workspaceState: GG.DeepReadonly<GG.GitGraphViewWorkspaceState>;

	type AvatarImageCollection = { [email: string]: string };

	interface ExpandedCommit {
		index: number;
		commitHash: string;
		commitElem: HTMLElement | null;
		compareWithHash: string | null;
		compareWithElem: HTMLElement | null;
		commitDetails: GG.GitCommitDetails | null;
		fileChanges: ReadonlyArray<GG.GitFileChange> | null;
		fileTree: FileTreeFolder | null;
		avatar: string | null;
		codeReview: GG.CodeReview | null;
		lastViewedFile: string | null;
		loading: boolean;
		scrollTop: {
			summary: number,
			fileView: number
		};
		contextMenuOpen: {
			summary: boolean,
			fileView: number
		};
	}

	interface WebViewState {
		readonly currentRepo: string;
		readonly currentRepoLoading: boolean;
		readonly gitRepos: GG.GitRepoSet;
		readonly gitBranches: ReadonlyArray<string>;
		readonly gitBranchHead: string | null;
		readonly gitConfig: GG.GitRepoConfig | null;
		readonly gitRemotes: ReadonlyArray<string>;
		readonly gitStashes: ReadonlyArray<GG.GitStash>;
		readonly gitTags: ReadonlyArray<string>;
		readonly commits: GG.GitCommit[];
		readonly commitHead: string | null;
		readonly avatars: AvatarImageCollection;
		readonly currentBranches: string[] | null;
		readonly moreCommitsAvailable: boolean;
		readonly maxCommits: number;
		readonly onlyFollowFirstParent: boolean;
		readonly expandedCommit: ExpandedCommit | null;
		readonly scrollTop: number;
		readonly findWidget: FindWidgetState;
		readonly settingsWidget: SettingsWidgetState;
	}


	/* Commit Details / Comparison View File Tree Types */

	interface FileTreeFile {
		readonly type: 'file';
		readonly name: string;
		readonly index: number;
		reviewed: boolean;
	}

	interface FileTreeRepo {
		readonly type: 'repo';
		readonly name: string;
		readonly path: string;
	}

	interface FileTreeFolder {
		readonly type: 'folder';
		readonly name: string;
		readonly folderPath: string;
		readonly contents: FileTreeFolderContents;
		open: boolean;
		reviewed: boolean;
	}

	type FileTreeLeaf = FileTreeFile | FileTreeRepo;
	type FileTreeNode = FileTreeFolder | FileTreeLeaf;
	type FileTreeFolderContents = { [name: string]: FileTreeNode };


	/* Dialog & ContextMenu shared base Target interfaces */

	const enum TargetType {
		Commit = 'commit',
		CommitDetailsView = 'cdv',
		Ref = 'ref',
		Repo = 'repo'
	}

	interface CommitOrRefTarget {
		type: TargetType.Commit | TargetType.Ref | TargetType.CommitDetailsView;
		elem: HTMLElement;
	}

	interface RepoTarget {
		type: TargetType.Repo;
	}

	interface CommitTarget extends CommitOrRefTarget {
		hash: string;
	}

	interface RefTarget extends CommitTarget {
		ref: string;
	}
}

export as namespace GG;
export = GG;
-e 

================================================================================
// FILE: ./src/commands.ts
================================================================================
import * as os from 'os';
import * as vscode from 'vscode';
import { AvatarManager } from './avatarManager';
import { getConfig } from './config';
import { DataSource } from './dataSource';
import { DiffDocProvider, decodeDiffDocUri } from './diffDocProvider';
import { CodeReviewData, CodeReviews, ExtensionState } from './extensionState';
import { GitGraphView } from './gitGraphView';
import { Logger } from './logger';
import { RepoManager } from './repoManager';
import { GitExecutable, UNABLE_TO_FIND_GIT_MSG, VsCodeVersionRequirement, abbrevCommit, abbrevText, copyToClipboard, doesVersionMeetRequirement, getExtensionVersion, getPathFromUri, getRelativeTimeDiff, getRepoName, getSortedRepositoryPaths, isPathInWorkspace, openFile, resolveToSymbolicPath, showErrorMessage, showInformationMessage } from './utils';
import { Disposable } from './utils/disposable';
import { Event } from './utils/event';

/**
 * Manages the registration and execution of Git Graph Commands.
 */
export class CommandManager extends Disposable {
	private readonly context: vscode.ExtensionContext;
	private readonly avatarManager: AvatarManager;
	private readonly dataSource: DataSource;
	private readonly extensionState: ExtensionState;
	private readonly logger: Logger;
	private readonly repoManager: RepoManager;
	private gitExecutable: GitExecutable | null;

	/**
	 * Creates the Git Graph Command Manager.
	 * @param extensionPath The absolute file path of the directory containing the extension.
	 * @param avatarManger The Git Graph AvatarManager instance.
	 * @param dataSource The Git Graph DataSource instance.
	 * @param extensionState The Git Graph ExtensionState instance.
	 * @param repoManager The Git Graph RepoManager instance.
	 * @param gitExecutable The Git executable available to Git Graph at startup.
	 * @param onDidChangeGitExecutable The Event emitting the Git executable for Git Graph to use.
	 * @param logger The Git Graph Logger instance.
	 */
	constructor(context: vscode.ExtensionContext, avatarManger: AvatarManager, dataSource: DataSource, extensionState: ExtensionState, repoManager: RepoManager, gitExecutable: GitExecutable | null, onDidChangeGitExecutable: Event<GitExecutable>, logger: Logger) {
		super();
		this.context = context;
		this.avatarManager = avatarManger;
		this.dataSource = dataSource;
		this.extensionState = extensionState;
		this.logger = logger;
		this.repoManager = repoManager;
		this.gitExecutable = gitExecutable;

		// Register Extension Commands
		this.registerCommand('git-graph.view', (arg) => this.view(arg));
		this.registerCommand('git-graph.addGitRepository', () => this.addGitRepository());
		this.registerCommand('git-graph.removeGitRepository', () => this.removeGitRepository());
		this.registerCommand('git-graph.clearAvatarCache', () => this.clearAvatarCache());
		this.registerCommand('git-graph.fetch', () => this.fetch());
		this.registerCommand('git-graph.endAllWorkspaceCodeReviews', () => this.endAllWorkspaceCodeReviews());
		this.registerCommand('git-graph.endSpecificWorkspaceCodeReview', () => this.endSpecificWorkspaceCodeReview());
		this.registerCommand('git-graph.resumeWorkspaceCodeReview', () => this.resumeWorkspaceCodeReview());
		this.registerCommand('git-graph.version', () => this.version());
		this.registerCommand('git-graph.openFile', (arg) => this.openFile(arg));

		this.registerDisposable(
			onDidChangeGitExecutable((gitExecutable) => {
				this.gitExecutable = gitExecutable;
			})
		);

		// Register Extension Contexts
		try {
			this.registerContext('git-graph:codiconsSupported', doesVersionMeetRequirement(vscode.version, VsCodeVersionRequirement.Codicons));
		} catch (_) {
			this.logger.logError('Unable to set Visual Studio Code Context "git-graph:codiconsSupported"');
		}
	}

	/**
	 * Register a Git Graph command with Visual Studio Code.
	 * @param command A unique identifier for the command.
	 * @param callback A command handler function.
	 */
	private registerCommand(command: string, callback: (...args: any[]) => any) {
		this.registerDisposable(
			vscode.commands.registerCommand(command, (...args: any[]) => {
				this.logger.log('Command Invoked: ' + command);
				callback(...args);
			})
		);
	}

	/**
	 * Register a context with Visual Studio Code.
	 * @param key The Context Key.
	 * @param value The Context Value.
	 */
	private registerContext(key: string, value: any) {
		return vscode.commands.executeCommand('setContext', key, value).then(
			() => this.logger.log('Successfully set Visual Studio Code Context "' + key + '" to "' + JSON.stringify(value) + '"'),
			() => this.logger.logError('Failed to set Visual Studio Code Context "' + key + '" to "' + JSON.stringify(value) + '"')
		);
	}


	/* Commands */

	/**
	 * The method run when the `git-graph.view` command is invoked.
	 * @param arg An optional argument passed to the command (when invoked from the Visual Studio Code Git Extension).
	 */
	private async view(arg: any) {
		let loadRepo: string | null = null;

		if (typeof arg === 'object' && arg.rootUri) {
			// If command is run from the Visual Studio Code Source Control View, load the specific repo
			const repoPath = getPathFromUri(arg.rootUri);
			loadRepo = await this.repoManager.getKnownRepo(repoPath);
			if (loadRepo === null) {
				// The repo is not currently known, add it
				loadRepo = (await this.repoManager.registerRepo(await resolveToSymbolicPath(repoPath), true)).root;
			}
		} else if (getConfig().openToTheRepoOfTheActiveTextEditorDocument && vscode.window.activeTextEditor) {
			// If the config setting is enabled, load the repo containing the active text editor document
			loadRepo = this.repoManager.getRepoContainingFile(getPathFromUri(vscode.window.activeTextEditor.document.uri));
		}

		GitGraphView.createOrShow(this.context.extensionPath, this.dataSource, this.extensionState, this.avatarManager, this.repoManager, this.logger, loadRepo !== null ? { repo: loadRepo } : null);
	}

	/**
	 * The method run when the `git-graph.addGitRepository` command is invoked.
	 */
	private addGitRepository() {
		if (this.gitExecutable === null) {
			showErrorMessage(UNABLE_TO_FIND_GIT_MSG);
			return;
		}

		vscode.window.showOpenDialog({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false }).then(uris => {
			if (uris && uris.length > 0) {
				let path = getPathFromUri(uris[0]);
				if (isPathInWorkspace(path)) {
					this.repoManager.registerRepo(path, false).then(status => {
						if (status.error === null) {
							showInformationMessage('The repository "' + status.root! + '" was added to Git Graph.');
						} else {
							showErrorMessage(status.error + ' Therefore it could not be added to Git Graph.');
						}
					});
				} else {
					showErrorMessage('The folder "' + path + '" is not within the opened Visual Studio Code workspace, and therefore could not be added to Git Graph.');
				}
			}
		}, () => { });
	}

	/**
	 * The method run when the `git-graph.removeGitRepository` command is invoked.
	 */
	private removeGitRepository() {
		if (this.gitExecutable === null) {
			showErrorMessage(UNABLE_TO_FIND_GIT_MSG);
			return;
		}

		const repos = this.repoManager.getRepos();
		const items: vscode.QuickPickItem[] = getSortedRepositoryPaths(repos, getConfig().repoDropdownOrder).map((path) => ({
			label: repos[path].name || getRepoName(path),
			description: path
		}));

		vscode.window.showQuickPick(items, {
			placeHolder: 'Select a repository to remove from Git Graph:',
			canPickMany: false
		}).then((item) => {
			if (item && item.description !== undefined) {
				if (this.repoManager.ignoreRepo(item.description)) {
					showInformationMessage('The repository "' + item.label + '" was removed from Git Graph.');
				} else {
					showErrorMessage('The repository "' + item.label + '" is not known to Git Graph.');
				}
			}
		}, () => { });
	}

	/**
	 * The method run when the `git-graph.clearAvatarCache` command is invoked.
	 */
	private clearAvatarCache() {
		this.avatarManager.clearCache().then((errorInfo) => {
			if (errorInfo === null) {
				showInformationMessage('The Avatar Cache was successfully cleared.');
			} else {
				showErrorMessage(errorInfo);
			}
		}, () => {
			showErrorMessage('An unexpected error occurred while running the command "Clear Avatar Cache".');
		});
	}

	/**
	 * The method run when the `git-graph.fetch` command is invoked.
	 */
	private fetch() {
		const repos = this.repoManager.getRepos();
		const repoPaths = getSortedRepositoryPaths(repos, getConfig().repoDropdownOrder);

		if (repoPaths.length > 1) {
			const items: vscode.QuickPickItem[] = repoPaths.map((path) => ({
				label: repos[path].name || getRepoName(path),
				description: path
			}));

			const lastActiveRepo = this.extensionState.getLastActiveRepo();
			if (lastActiveRepo !== null) {
				let lastActiveRepoIndex = items.findIndex((item) => item.description === lastActiveRepo);
				if (lastActiveRepoIndex > -1) {
					const item = items.splice(lastActiveRepoIndex, 1)[0];
					items.unshift(item);
				}
			}

			vscode.window.showQuickPick(items, {
				placeHolder: 'Select the repository you want to open in Git Graph, and fetch from remote(s):',
				canPickMany: false
			}).then((item) => {
				if (item && item.description) {
					GitGraphView.createOrShow(this.context.extensionPath, this.dataSource, this.extensionState, this.avatarManager, this.repoManager, this.logger, {
						repo: item.description,
						runCommandOnLoad: 'fetch'
					});
				}
			}, () => {
				showErrorMessage('An unexpected error occurred while running the command "Fetch from Remote(s)".');
			});
		} else if (repoPaths.length === 1) {
			GitGraphView.createOrShow(this.context.extensionPath, this.dataSource, this.extensionState, this.avatarManager, this.repoManager, this.logger, {
				repo: repoPaths[0],
				runCommandOnLoad: 'fetch'
			});
		} else {
			GitGraphView.createOrShow(this.context.extensionPath, this.dataSource, this.extensionState, this.avatarManager, this.repoManager, this.logger, null);
		}
	}

	/**
	 * The method run when the `git-graph.endAllWorkspaceCodeReviews` command is invoked.
	 */
	private endAllWorkspaceCodeReviews() {
		this.extensionState.endAllWorkspaceCodeReviews();
		showInformationMessage('Ended All Code Reviews in Workspace');
	}

	/**
	 * The method run when the `git-graph.endSpecificWorkspaceCodeReview` command is invoked.
	 */
	private endSpecificWorkspaceCodeReview() {
		const codeReviews = this.extensionState.getCodeReviews();
		if (Object.keys(codeReviews).length === 0) {
			showErrorMessage('There are no Code Reviews in progress within the current workspace.');
			return;
		}

		vscode.window.showQuickPick(this.getCodeReviewQuickPickItems(codeReviews), {
			placeHolder: 'Select the Code Review you want to end:',
			canPickMany: false
		}).then((item) => {
			if (item) {
				this.extensionState.endCodeReview(item.codeReviewRepo, item.codeReviewId).then((errorInfo) => {
					if (errorInfo === null) {
						showInformationMessage('Successfully ended Code Review "' + item.label + '".');
					} else {
						showErrorMessage(errorInfo);
					}
				}, () => { });
			}
		}, () => {
			showErrorMessage('An unexpected error occurred while running the command "End a specific Code Review in Workspace...".');
		});
	}

	/**
	 * The method run when the `git-graph.resumeWorkspaceCodeReview` command is invoked.
	 */
	private resumeWorkspaceCodeReview() {
		const codeReviews = this.extensionState.getCodeReviews();
		if (Object.keys(codeReviews).length === 0) {
			showErrorMessage('There are no Code Reviews in progress within the current workspace.');
			return;
		}

		vscode.window.showQuickPick(this.getCodeReviewQuickPickItems(codeReviews), {
			placeHolder: 'Select the Code Review you want to resume:',
			canPickMany: false
		}).then((item) => {
			if (item) {
				const commitHashes = item.codeReviewId.split('-');
				GitGraphView.createOrShow(this.context.extensionPath, this.dataSource, this.extensionState, this.avatarManager, this.repoManager, this.logger, {
					repo: item.codeReviewRepo,
					commitDetails: {
						commitHash: commitHashes[commitHashes.length > 1 ? 1 : 0],
						compareWithHash: commitHashes.length > 1 ? commitHashes[0] : null
					}
				});
			}
		}, () => {
			showErrorMessage('An unexpected error occurred while running the command "Resume a specific Code Review in Workspace...".');
		});
	}

	/**
	 * The method run when the `git-graph.version` command is invoked.
	 */
	private async version() {
		try {
			const gitGraphVersion = await getExtensionVersion(this.context);
			const information = 'Git Graph: ' + gitGraphVersion + '\nVisual Studio Code: ' + vscode.version + '\nOS: ' + os.type() + ' ' + os.arch() + ' ' + os.release() + '\nGit: ' + (this.gitExecutable !== null ? this.gitExecutable.version : '(none)');
			vscode.window.showInformationMessage(information, { modal: true }, 'Copy').then((selectedItem) => {
				if (selectedItem === 'Copy') {
					copyToClipboard(information).then((result) => {
						if (result !== null) {
							showErrorMessage(result);
						}
					});
				}
			}, () => { });
		} catch (_) {
			showErrorMessage('An unexpected error occurred while retrieving version information.');
		}
	}

	/**
	 * Opens a file in Visual Studio Code, based on a Git Graph URI (from the Diff View).
	 * The method run when the `git-graph.openFile` command is invoked.
	 * @param arg The Git Graph URI.
	 */
	private openFile(arg?: vscode.Uri) {
		const uri = arg || vscode.window.activeTextEditor?.document.uri;
		if (typeof uri === 'object' && uri && uri.scheme === DiffDocProvider.scheme) {
			// A Git Graph URI has been provided
			const request = decodeDiffDocUri(uri);
			return openFile(request.repo, request.filePath, request.commit, this.dataSource, vscode.ViewColumn.Active).then((errorInfo) => {
				if (errorInfo !== null) {
					return showErrorMessage('Unable to Open File: ' + errorInfo);
				}
			});
		} else {
			return showErrorMessage('Unable to Open File: The command was not called with the required arguments.');
		}
	}


	/* Helper Methods */

	/**
	 * Transform a set of Code Reviews into a list of Quick Pick items for use with `vscode.window.showQuickPick`.
	 * @param codeReviews A set of Code Reviews.
	 * @returns A list of Quick Pick items.
	 */
	private getCodeReviewQuickPickItems(codeReviews: CodeReviews): Promise<CodeReviewQuickPickItem[]> {
		const repos = this.repoManager.getRepos();
		const enrichedCodeReviews: { repo: string, id: string, review: CodeReviewData, fromCommitHash: string, toCommitHash: string }[] = [];
		const fetchCommits: { repo: string, commitHash: string }[] = [];

		Object.keys(codeReviews).forEach((repo) => {
			if (typeof repos[repo] === 'undefined') return;
			Object.keys(codeReviews[repo]).forEach((id) => {
				const commitHashes = id.split('-');
				commitHashes.forEach((commitHash) => fetchCommits.push({ repo: repo, commitHash: commitHash }));
				enrichedCodeReviews.push({
					repo: repo, id: id, review: codeReviews[repo][id],
					fromCommitHash: commitHashes[0], toCommitHash: commitHashes[commitHashes.length > 1 ? 1 : 0]
				});
			});
		});

		return Promise.all(fetchCommits.map((fetch) => this.dataSource.getCommitSubject(fetch.repo, fetch.commitHash))).then(
			(subjects) => {
				const commitSubjects: { [repo: string]: { [commitHash: string]: string } } = {};
				subjects.forEach((subject, i) => {
					if (typeof commitSubjects[fetchCommits[i].repo] === 'undefined') {
						commitSubjects[fetchCommits[i].repo] = {};
					}
					commitSubjects[fetchCommits[i].repo][fetchCommits[i].commitHash] = subject !== null ? subject : '<Unknown Commit Subject>';
				});

				return enrichedCodeReviews.sort((a, b) => b.review.lastActive - a.review.lastActive).map((codeReview) => {
					const fromSubject = commitSubjects[codeReview.repo][codeReview.fromCommitHash];
					const toSubject = commitSubjects[codeReview.repo][codeReview.toCommitHash];
					const isComparison = codeReview.fromCommitHash !== codeReview.toCommitHash;
					return {
						codeReviewRepo: codeReview.repo,
						codeReviewId: codeReview.id,
						label: (repos[codeReview.repo].name || getRepoName(codeReview.repo)) + ': ' + abbrevCommit(codeReview.fromCommitHash) + (isComparison ? '  ' + abbrevCommit(codeReview.toCommitHash) : ''),
						description: getRelativeTimeDiff(Math.round(codeReview.review.lastActive / 1000)),
						detail: isComparison
							? abbrevText(fromSubject, 50) + '  ' + abbrevText(toSubject, 50)
							: fromSubject
					};
				});
			}
		);
	}
}

interface CodeReviewQuickPickItem extends vscode.QuickPickItem {
	codeReviewRepo: string;
	codeReviewId: string;
}
-e 

================================================================================
// FILE: ./src/repoManager.ts
================================================================================
import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import { getConfig } from './config';
import { DataSource } from './dataSource';
import { DEFAULT_REPO_STATE, ExtensionState } from './extensionState';
import { Logger } from './logger';
import { BooleanOverride, ErrorInfo, FileViewType, GitRepoSet, GitRepoState, PullRequestConfig, PullRequestConfigBase, PullRequestProvider, RepoCommitOrdering } from './types';
import { evalPromises, getPathFromStr, getPathFromUri, getRepoName, pathWithTrailingSlash, realpath, showErrorMessage, showInformationMessage } from './utils';
import { BufferedQueue } from './utils/bufferedQueue';
import { Disposable, toDisposable } from './utils/disposable';
import { Event, EventEmitter } from './utils/event';

export interface RepoChangeEvent {
	readonly repos: GitRepoSet;
	readonly numRepos: number;
	readonly loadRepo: string | null;
}

/**
 * Detects and manages repositories in Git Graph.
 */
export class RepoManager extends Disposable {
	private readonly dataSource: DataSource;
	private readonly extensionState: ExtensionState;
	private readonly logger: Logger;

	private repos: GitRepoSet;
	private ignoredRepos: string[];
	private maxDepthOfRepoSearch: number;

	private readonly folderWatchers: { [workspace: string]: vscode.FileSystemWatcher } = {};
	private readonly configWatcher: vscode.FileSystemWatcher;

	private readonly repoEventEmitter: EventEmitter<RepoChangeEvent>;

	private readonly onWatcherCreateQueue: BufferedQueue<string>;
	private readonly onWatcherChangeQueue: BufferedQueue<string>;
	private readonly checkRepoConfigQueue: BufferedQueue<string>;

	/**
	 * Creates the Git Graph Repository Manager, and runs startup tasks.
	 * @param dataSource The Git Graph DataSource instance.
	 * @param extensionState The Git Graph ExtensionState instance.
	 * @param logger The Git Graph Logger instance.
	 */
	constructor(dataSource: DataSource, extensionState: ExtensionState, onDidChangeConfiguration: Event<vscode.ConfigurationChangeEvent>, logger: Logger) {
		super();
		this.dataSource = dataSource;
		this.extensionState = extensionState;
		this.logger = logger;
		this.repos = extensionState.getRepos();
		this.ignoredRepos = extensionState.getIgnoredRepos();
		this.maxDepthOfRepoSearch = getConfig().maxDepthOfRepoSearch;

		this.configWatcher = vscode.workspace.createFileSystemWatcher('**/.vscode/vscode-git-graph.json');
		this.configWatcher.onDidCreate(this.onConfigWatcherCreateOrChange.bind(this));
		this.configWatcher.onDidChange(this.onConfigWatcherCreateOrChange.bind(this));

		this.repoEventEmitter = new EventEmitter<RepoChangeEvent>();

		this.onWatcherCreateQueue = new BufferedQueue<string>(this.processOnWatcherCreateEvent.bind(this), this.sendRepos.bind(this));
		this.onWatcherChangeQueue = new BufferedQueue<string>(this.processOnWatcherChangeEvent.bind(this), this.sendRepos.bind(this));
		this.checkRepoConfigQueue = new BufferedQueue<string>(this.checkRepoForNewConfig.bind(this), this.sendRepos.bind(this));

		this.startupTasks();

		this.registerDisposables(
			// Monitor changes to the workspace folders to:
			// - search added folders for repositories
			// - remove repositories within deleted folders
			// - apply changes to the order of workspace folders
			vscode.workspace.onDidChangeWorkspaceFolders(async (e) => {
				let changes = false, path;
				if (e.added.length > 0) {
					for (let i = 0; i < e.added.length; i++) {
						path = getPathFromUri(e.added[i].uri);
						if (await this.searchDirectoryForRepos(path, this.maxDepthOfRepoSearch)) changes = true;
						this.startWatchingFolder(path);
					}
				}
				if (e.removed.length > 0) {
					for (let i = 0; i < e.removed.length; i++) {
						path = getPathFromUri(e.removed[i].uri);
						if (this.removeReposWithinFolder(path)) changes = true;
						this.stopWatchingFolder(path);
					}
				}
				if (this.updateReposWorkspaceFolderIndex()) {
					this.extensionState.saveRepos(this.repos);
					changes = true;
				}

				if (changes) {
					this.sendRepos();
				}
			}),

			// Monitor changes to the maxDepthOfRepoSearch Extension Setting, and trigger a new search if needed
			onDidChangeConfiguration((event) => {
				if (event.affectsConfiguration('git-graph.maxDepthOfRepoSearch')) {
					this.maxDepthOfRepoSearchChanged();
				}
			}),

			// Dispose the Repository Event Emitter when disposed
			this.repoEventEmitter,

			// Dispose the configWatcher
			this.configWatcher,

			// Dispose the onWatcherCreateQueue
			this.onWatcherCreateQueue,

			// Dispose the onWatcherChangeQueue
			this.onWatcherChangeQueue,

			// Dispose the checkRepoConfigQueue,
			this.checkRepoConfigQueue,

			// Stop watching folders when disposed
			toDisposable(() => {
				const folders = Object.keys(this.folderWatchers);
				for (let i = 0; i < folders.length; i++) {
					this.stopWatchingFolder(folders[i]);
				}
			})
		);
	}

	/**
	 * Get the Event that can be used to subscribe to updates when the repositories available in Git Graph change.
	 */
	get onDidChangeRepos() {
		return this.repoEventEmitter.subscribe;
	}

	/**
	 * Apply the new value of `git-graph.maxDepthOfRepoSearch` to the RepoManager.
	 */
	private maxDepthOfRepoSearchChanged() {
		const newDepth = getConfig().maxDepthOfRepoSearch;
		if (newDepth > this.maxDepthOfRepoSearch) {
			this.maxDepthOfRepoSearch = newDepth;
			this.searchWorkspaceForRepos();
		} else {
			this.maxDepthOfRepoSearch = newDepth;
		}
	}

	/**
	 * Run various startup tasks when Git Graph is activated.
	 */
	private async startupTasks() {
		this.removeReposNotInWorkspace();
		if (this.updateReposWorkspaceFolderIndex()) {
			this.extensionState.saveRepos(this.repos);
		}
		if (!await this.checkReposExist()) {
			// On startup, ensure that sendRepo is called (even if no changes were made)
			this.sendRepos();
		}
		this.checkReposForNewConfig();
		await this.checkReposForNewSubmodules();
		await this.searchWorkspaceForRepos();
		this.startWatchingFolders();
	}

	/**
	 * Remove any repositories that are no longer in the current workspace.
	 */
	private removeReposNotInWorkspace() {
		const workspaceFolderInfo = getWorkspaceFolderInfoForRepoInclusionMapping();
		const rootsExact = workspaceFolderInfo.rootsExact, rootsFolder = workspaceFolderInfo.rootsFolder, repoPaths = Object.keys(this.repos);
		for (let i = 0; i < repoPaths.length; i++) {
			const repoPathFolder = pathWithTrailingSlash(repoPaths[i]);
			if (rootsExact.indexOf(repoPaths[i]) === -1 && !rootsFolder.find(root => repoPaths[i].startsWith(root)) && !rootsExact.find(root => root.startsWith(repoPathFolder))) {
				this.removeRepo(repoPaths[i]);
			}
		}
	}

	/**
	 * Register a new repository with Git Graph.
	 * @param path The path of the repository.
	 * @param loadRepo If TRUE and the Git Graph View is visible, load the Git Graph View with the repository being registered.
	 */
	public registerRepo(path: string, loadRepo: boolean) {
		return new Promise<{ root: string | null, error: string | null }>(async resolve => {
			let root = await this.dataSource.repoRoot(path);
			if (root === null) {
				resolve({ root: null, error: 'The folder "' + path + '" is not a Git repository.' });
			} else if (typeof this.repos[root] !== 'undefined') {
				resolve({ root: null, error: 'The folder "' + path + '" is contained within the known repository "' + root + '".' });
			} else {
				if (this.ignoredRepos.includes(root)) {
					this.ignoredRepos.splice(this.ignoredRepos.indexOf(root), 1);
					this.extensionState.setIgnoredRepos(this.ignoredRepos);
				}
				await this.addRepo(root);
				this.sendRepos(loadRepo ? root : null);
				resolve({ root: root, error: null });
			}
		});
	}

	/**
	 * Ignore a repository known to Git Graph. Unlike `removeRepo`, ignoring the repository will prevent it from being automatically detected and re-added the next time Visual Studio Code is started.
	 * @param repo The path of the repository.
	 * @returns TRUE => Repository was ignored, FALSE => Repository is not know to Git Graph.
	 */
	public ignoreRepo(repo: string) {
		if (this.isKnownRepo(repo)) {
			if (!this.ignoredRepos.includes(repo)) this.ignoredRepos.push(repo);
			this.extensionState.setIgnoredRepos(this.ignoredRepos);
			this.removeRepo(repo);
			this.sendRepos();
			return true;
		} else {
			return false;
		}
	}


	/* Repo Management */

	/**
	 * Get a set of all known repositories in the current workspace.
	 * @returns The set of repositories.
	 */
	public getRepos() {
		return Object.assign({}, this.repos);
	}

	/**
	 * Get the number of all known repositories in the current workspace.
	 * @returns The number of repositories.
	 */
	public getNumRepos() {
		return Object.keys(this.repos).length;
	}

	/**
	 * Get the repository that contains the specified file.
	 * @param path The path of the file.
	 * @returns The path of the repository containing the file, or NULL if no known repository contains the file.
	 */
	public getRepoContainingFile(path: string) {
		let repoPaths = Object.keys(this.repos), repo = null;
		for (let i = 0; i < repoPaths.length; i++) {
			if (path.startsWith(pathWithTrailingSlash(repoPaths[i])) && (repo === null || repo.length < repoPaths[i].length)) repo = repoPaths[i];
		}
		return repo;
	}

	/**
	 * Get all known repositories that are contained in the specified folder.
	 * @param path The path of the folder.
	 * @returns An array of the paths of all known repositories contained in the specified folder.
	 */
	private getReposInFolder(path: string) {
		let pathFolder = pathWithTrailingSlash(path), repoPaths = Object.keys(this.repos), reposInFolder: string[] = [];
		for (let i = 0; i < repoPaths.length; i++) {
			if (repoPaths[i] === path || repoPaths[i].startsWith(pathFolder)) reposInFolder.push(repoPaths[i]);
		}
		return reposInFolder;
	}

	/**
	 * Get the path of the known repository matching the specified repository path (checking symbolic links if necessary).
	 * @param repo The path of the repository.
	 * @returns The path of the known repository, or NULL if the specified repository is unknown.
	 */
	public async getKnownRepo(repo: string) {
		if (this.isKnownRepo(repo)) {
			// The path is already known as a repo
			return repo;
		}

		// Check to see if a known repository contains a symlink that resolves the repo
		let canonicalRepo = await realpath(repo);
		let repoPaths = Object.keys(this.repos);
		for (let i = 0; i < repoPaths.length; i++) {
			if (canonicalRepo === (await realpath(repoPaths[i]))) {
				return repoPaths[i];
			}
		}

		// Repo is unknown
		return null;
	}

	/**
	 * Check to see if a repository exactly matches a known repository.
	 * @param repo The path of the repository to check.
	 * @returns TRUE => Known repository, FALSE => Unknown repository.
	 */
	public isKnownRepo(repo: string) {
		return typeof this.repos[repo] !== 'undefined';
	}

	/**
	 * Add a new repository to Git Graph.
	 * @param repo The path of the repository.
	 * @returns TRUE => The repository was added, FALSE => The repository is ignored and couldn't be added.
	 */
	private async addRepo(repo: string) {
		if (this.ignoredRepos.includes(repo)) {
			return false;
		} else {
			this.repos[repo] = Object.assign({}, DEFAULT_REPO_STATE);
			this.updateReposWorkspaceFolderIndex(repo);
			this.extensionState.saveRepos(this.repos);
			this.logger.log('Added new repo: ' + repo);
			await this.checkRepoForNewConfig(repo, true);
			await this.searchRepoForSubmodules(repo);
			return true;
		}
	}

	/**
	 * Remove a known repository from Git Graph.
	 * @param repo The path of the repository.
	 */
	private removeRepo(repo: string) {
		delete this.repos[repo];
		this.extensionState.saveRepos(this.repos);
		this.logger.log('Removed repo: ' + repo);
	}

	/**
	 * Remove all repositories that are contained within the specified folder.
	 * @param path The path of the folder.
	 * @returns TRUE => At least one repository was removed, FALSE => No repositories were removed.
	 */
	private removeReposWithinFolder(path: string) {
		let reposInFolder = this.getReposInFolder(path);
		for (let i = 0; i < reposInFolder.length; i++) {
			this.removeRepo(reposInFolder[i]);
		}
		return reposInFolder.length > 0;
	}

	/**
	 * Checks if the specified path is within a known repository.
	 * @param path The path to check.
	 * @returns TRUE => Path is within a known repository, FALSE => Path isn't within a known repository.
	 */
	private isDirectoryWithinRepos(path: string) {
		let repoPaths = Object.keys(this.repos);
		for (let i = 0; i < repoPaths.length; i++) {
			if (path === repoPaths[i] || path.startsWith(pathWithTrailingSlash(repoPaths[i]))) return true;
		}
		return false;
	}

	/**
	 * Send the latest set of known repositories to subscribers as they have changed.
	 * @param loadRepo The optional path of a repository to load in the Git Graph View.
	 */
	private sendRepos(loadRepo: string | null = null) {
		this.repoEventEmitter.emit({
			repos: this.getRepos(),
			numRepos: this.getNumRepos(),
			loadRepo: loadRepo
		});
	}

	/**
	 * Check that all known repositories still exist. If they don't, remove them.
	 * @returns TRUE => At least one repository was removed or transferred, FALSE => No repositories were removed.
	 */
	public checkReposExist() {
		let repoPaths = Object.keys(this.repos), changes = false;
		return evalPromises(repoPaths, 3, (path) => this.dataSource.repoRoot(path)).then((results) => {
			for (let i = 0; i < repoPaths.length; i++) {
				if (results[i] === null) {
					this.removeRepo(repoPaths[i]);
					changes = true;
				} else if (repoPaths[i] !== results[i]) {
					this.transferRepoState(repoPaths[i], results[i]!);
					changes = true;
				}
			}
		}).catch(() => { }).then(() => {
			if (changes) {
				this.sendRepos();
			}
			return changes;
		});
	}

	/**
	 * Update each repositories workspaceFolderIndex based on the current workspace.
	 * @param repo If provided, only update this specific repository.
	 * @returns TRUE => At least one repository was changed, FALSE => No repositories were changed.
	 */
	private updateReposWorkspaceFolderIndex(repo: string | null = null) {
		const workspaceFolderInfo = getWorkspaceFolderInfoForRepoInclusionMapping();
		const rootsExact = workspaceFolderInfo.rootsExact, rootsFolder = workspaceFolderInfo.rootsFolder, workspaceFolders = workspaceFolderInfo.workspaceFolders;
		const repoPaths = repo !== null && this.isKnownRepo(repo) ? [repo] : Object.keys(this.repos);
		let changes = false, rootIndex: number, workspaceFolderIndex: number | null;
		for (let i = 0; i < repoPaths.length; i++) {
			rootIndex = rootsExact.indexOf(repoPaths[i]);
			if (rootIndex === -1) {
				// Find a workspace folder that contains the repository
				rootIndex = rootsFolder.findIndex((root) => repoPaths[i].startsWith(root));
			}
			if (rootIndex === -1) {
				// Find a workspace folder that is contained within the repository
				const repoPathFolder = pathWithTrailingSlash(repoPaths[i]);
				rootIndex = rootsExact.findIndex((root) => root.startsWith(repoPathFolder));
			}
			workspaceFolderIndex = rootIndex > -1 ? workspaceFolders[rootIndex].index : null;
			if (this.repos[repoPaths[i]].workspaceFolderIndex !== workspaceFolderIndex) {
				this.repos[repoPaths[i]].workspaceFolderIndex = workspaceFolderIndex;
				changes = true;
			}
		}
		return changes;
	}

	/**
	 * Set the state of a known repository.
	 * @param repo The repository the state belongs to.
	 * @param state The state.
	 */
	public setRepoState(repo: string, state: GitRepoState) {
		this.repos[repo] = state;
		this.extensionState.saveRepos(this.repos);
	}

	/**
	 * Transfer the repository state from one known repository to another.
	 * @param oldRepo The repository to transfer the state from.
	 * @param newRepo The repository to transfer the state to.
	 */
	private transferRepoState(oldRepo: string, newRepo: string) {
		this.repos[newRepo] = this.repos[oldRepo];
		delete this.repos[oldRepo];
		this.updateReposWorkspaceFolderIndex(newRepo);
		this.extensionState.saveRepos(this.repos);
		this.extensionState.transferRepo(oldRepo, newRepo);

		this.logger.log('Transferred repo state: ' + oldRepo + ' -> ' + newRepo);
	}


	/* Repo Searching */

	/**
	 * Search all of the current workspace folders for new repositories (and add them).
	 * @returns TRUE => At least one repository was added, FALSE => No repositories were added.
	 */
	public async searchWorkspaceForRepos() {
		this.logger.log('Searching workspace for new repos ...');
		let rootFolders = vscode.workspace.workspaceFolders, changes = false;
		if (typeof rootFolders !== 'undefined') {
			for (let i = 0; i < rootFolders.length; i++) {
				if (await this.searchDirectoryForRepos(getPathFromUri(rootFolders[i].uri), this.maxDepthOfRepoSearch)) changes = true;
			}
		}
		this.logger.log('Completed searching workspace for new repos');
		if (changes) this.sendRepos();
		return changes;
	}

	/**
	 * Search the specified directory for new repositories (and add them).
	 * @param directory The path of the directory to search.
	 * @param maxDepth The maximum depth to recursively search.
	 * @returns TRUE => At least one repository was added, FALSE => No repositories were added.
	 */
	private searchDirectoryForRepos(directory: string, maxDepth: number) {
		return new Promise<boolean>(resolve => {
			if (this.isDirectoryWithinRepos(directory)) {
				resolve(false);
				return;
			}

			this.dataSource.repoRoot(directory).then(async (root) => {
				if (root !== null) {
					resolve(await this.addRepo(root));
				} else if (maxDepth > 0) {
					fs.readdir(directory, async (err, dirContents) => {
						if (err) {
							resolve(false);
						} else {
							let dirs = [];
							for (let i = 0; i < dirContents.length; i++) {
								if (dirContents[i] !== '.git' && await isDirectory(directory + '/' + dirContents[i])) {
									dirs.push(directory + '/' + dirContents[i]);
								}
							}
							resolve((await evalPromises(dirs, 2, dir => this.searchDirectoryForRepos(dir, maxDepth - 1))).indexOf(true) > -1);
						}
					});
				} else {
					resolve(false);
				}
			}).catch(() => resolve(false));
		});
	}

	/**
	 * Check the know repositories for any new submodules (and add them).
	 */
	private async checkReposForNewSubmodules() {
		let repoPaths = Object.keys(this.repos), changes = false;
		for (let i = 0; i < repoPaths.length; i++) {
			if (await this.searchRepoForSubmodules(repoPaths[i])) changes = true;
		}
		if (changes) this.sendRepos();
	}

	/**
	 * Search a repository for any new submodules (and add them).
	 * @param repo The path of the repository to search.
	 * @returns TRUE => At least one submodule was added, FALSE => No submodules were added.
	 */
	private async searchRepoForSubmodules(repo: string) {
		let submodules = await this.dataSource.getSubmodules(repo), changes = false;
		for (let i = 0; i < submodules.length; i++) {
			if (!this.isKnownRepo(submodules[i])) {
				if (await this.addRepo(submodules[i])) changes = true;
			}
		}
		return changes;
	}


	/* Workspace Folder Watching */

	/**
	 * Start watching each of the folders in the current workspace for changes.
	 */
	private startWatchingFolders() {
		let rootFolders = vscode.workspace.workspaceFolders;
		if (typeof rootFolders !== 'undefined') {
			for (let i = 0; i < rootFolders.length; i++) {
				this.startWatchingFolder(getPathFromUri(rootFolders[i].uri));
			}
		}
	}

	/**
	 * Start watching the specified directory for file system events.
	 * @param path The path of the directory.
	 */
	private startWatchingFolder(path: string) {
		const watcher = vscode.workspace.createFileSystemWatcher(path + '/**');
		watcher.onDidCreate(this.onWatcherCreate.bind(this));
		watcher.onDidChange(this.onWatcherChange.bind(this));
		watcher.onDidDelete(this.onWatcherDelete.bind(this));
		this.folderWatchers[path] = watcher;
	}

	/**
	 * Stop watching the specified directory for file system events.
	 * @param path The path of the directory.
	 */
	private stopWatchingFolder(path: string) {
		this.folderWatchers[path].dispose();
		delete this.folderWatchers[path];
	}

	/**
	 * Handle a file system creation event.
	 * @param uri The URI of the creation event.
	 */
	private onWatcherCreate(uri: vscode.Uri) {
		let path = getPathFromUri(uri);
		if (path.indexOf('/.git/') > -1) return;
		if (path.endsWith('/.git')) path = path.slice(0, -5);
		this.onWatcherCreateQueue.enqueue(path);
	}

	/**
	 * Handle a file system change event.
	 * @param uri The URI of the change event.
	 */
	private onWatcherChange(uri: vscode.Uri) {
		let path = getPathFromUri(uri);
		if (path.indexOf('/.git/') > -1) return;
		if (path.endsWith('/.git')) path = path.slice(0, -5);
		this.onWatcherChangeQueue.enqueue(path);
	}

	/**
	 * Handle a file system deletion event.
	 * @param uri The URI of the deletion event.
	 */
	private onWatcherDelete(uri: vscode.Uri) {
		let path = getPathFromUri(uri);
		if (path.indexOf('/.git/') > -1) return;
		if (path.endsWith('/.git')) path = path.slice(0, -5);
		if (this.removeReposWithinFolder(path)) this.sendRepos();
	}

	/**
	 * Process a file system creation event.
	 * @param path The path of the file that was created.
	 * @returns TRUE => Change was made. FALSE => No change was made.
	 */
	private async processOnWatcherCreateEvent(path: string) {
		if (await isDirectory(path)) {
			if (await this.searchDirectoryForRepos(path, this.maxDepthOfRepoSearch)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Process a file system change event.
	 * @param path The path of the file that was changed.
	 * @returns TRUE => Change was made. FALSE => No change was made.
	 */
	private async processOnWatcherChangeEvent(path: string) {
		if (!await doesPathExist(path)) {
			if (this.removeReposWithinFolder(path)) {
				return true;
			}
		}
		return false;
	}


	/* Repository Configuration Management */

	/**
	 * Check the known repositories for new configuration files.
	 */
	private checkReposForNewConfig() {
		Object.keys(this.repos).forEach((repo) => this.checkRepoConfigQueue.enqueue(repo));
	}

	/**
	 * Check to see if the repository has a new configuration file.
	 * @param repo The repository to check.
	 * @param isRepoNew Is the repository new (was it just added)
	 */
	private async checkRepoForNewConfig(repo: string, isRepoNew: boolean = false) {
		try {
			const file = await readExternalConfigFile(repo);
			const state = this.repos[repo];
			if (state && file !== null && typeof file.exportedAt === 'number' && file.exportedAt > state.lastImportAt) {
				const validationError = validateExternalConfigFile(file);
				if (validationError === null) {
					const action = isRepoNew ? 'Yes' : await vscode.window.showInformationMessage('A newer Git Graph Repository Configuration File has been detected for the repository "' + (state.name || getRepoName(repo)) + '". Would you like to override your current repository configuration with the new changes?', 'Yes', 'No');
					if (this.isKnownRepo(repo) && action) {
						const state = this.repos[repo];
						if (action === 'Yes') {
							applyExternalConfigFile(file, state);
						}
						state.lastImportAt = file.exportedAt;
						this.extensionState.saveRepos(this.repos);
						if (!isRepoNew && action === 'Yes') {
							showInformationMessage('Git Graph Repository Configuration was successfully imported for the repository "' + (state.name || getRepoName(repo)) + '".');
						}
						return true;
					}
				} else {
					showErrorMessage('The value for "' + validationError + '" in the configuration file "' + getPathFromStr(path.join(repo, '.vscode', 'vscode-git-graph.json')) + '" is invalid.');
				}
			}
		} catch (_) { }
		return false;
	}

	/**
	 * Handle a file system create or change event for a configuration file.
	 * @param uri The URI of the create or change event.
	 */
	private onConfigWatcherCreateOrChange(uri: vscode.Uri) {
		const path = getPathFromUri(uri);
		const repo = this.getRepoContainingFile(path);
		if (repo !== null) {
			this.checkRepoConfigQueue.enqueue(repo);
		}
	}

	/**
	 * Export a repositories configuration.
	 * @param repo The path of the repository to export.
	 * @returns The ErrorInfo produced when performing this action.
	 */
	public exportRepoConfig(repo: string): Promise<ErrorInfo> {
		const file = generateExternalConfigFile(this.repos[repo]);
		return writeExternalConfigFile(repo, file).then((message) => {
			showInformationMessage(message);
			if (this.isKnownRepo(repo)) {
				this.repos[repo].lastImportAt = file.exportedAt!;
				this.extensionState.saveRepos(this.repos);
			}
			return null;
		}, (error) => error);
	}
}

/**
 * Gets the current workspace folders, and generates information required to identify whether a repository is within any of the workspace folders.
 * @returns The Workspace Folder Information.
 */
function getWorkspaceFolderInfoForRepoInclusionMapping() {
	let rootsExact = [], rootsFolder = [], workspaceFolders = vscode.workspace.workspaceFolders || [], path;
	for (let i = 0; i < workspaceFolders.length; i++) {
		path = getPathFromUri(workspaceFolders[i].uri);
		rootsExact.push(path);
		rootsFolder.push(pathWithTrailingSlash(path));
	}
	return {
		workspaceFolders: workspaceFolders,
		rootsExact: rootsExact,
		rootsFolder: rootsFolder
	};
}

/**
 * Check if the specified path is a directory.
 * @param path The path to check.
 * @returns TRUE => Directory, FALSE => Not a directory.
 */
function isDirectory(path: string) {
	return new Promise<boolean>(resolve => {
		fs.stat(path, (err, stats) => {
			resolve(err ? false : stats.isDirectory());
		});
	});
}

/**
 * Check if the specified path exists.
 * @param path The path to check.
 * @returns TRUE => Path exists, FALSE => Path doesn't exist.
 */
function doesPathExist(path: string) {
	return new Promise<boolean>(resolve => {
		fs.stat(path, err => resolve(!err));
	});
}


/** External Repo Config File */

export namespace ExternalRepoConfig {

	export const enum FileViewType {
		Tree = 'tree',
		List = 'list'
	}

	export interface IssueLinkingConfig {
		readonly issue: string;
		readonly url: string;
	}

	export const enum PullRequestProvider {
		Bitbucket = 'bitbucket',
		Custom = 'custom',
		GitHub = 'github',
		GitLab = 'gitlab'
	}

	interface PullRequestConfigBuiltIn extends PullRequestConfigBase {
		readonly provider: Exclude<PullRequestProvider, PullRequestProvider.Custom>;
		readonly custom: null;
	}

	interface PullRequestConfigCustom extends PullRequestConfigBase {
		readonly provider: PullRequestProvider.Custom;
		readonly custom: {
			readonly name: string,
			readonly templateUrl: string
		};
	}

	export type PullRequestConfig = PullRequestConfigBuiltIn | PullRequestConfigCustom;

	export interface File {
		commitOrdering?: RepoCommitOrdering;
		fileViewType?: FileViewType;
		hideRemotes?: string[];
		includeCommitsMentionedByReflogs?: boolean;
		issueLinkingConfig?: IssueLinkingConfig;
		name?: string | null;
		onlyFollowFirstParent?: boolean;
		onRepoLoadShowCheckedOutBranch?: boolean;
		onRepoLoadShowSpecificBranches?: string[];
		pullRequestConfig?: PullRequestConfig;
		showRemoteBranches?: boolean;
		showStashes?: boolean;
		showTags?: boolean;
		exportedAt?: number;
	}

}

/**
 * Reads the External Configuration File for a repository from the File System.
 * @param repo The path of the repository.
 * @returns A promise resolving to the parsed config file, or NULL if the file couldn't be read or parsed.
 */
function readExternalConfigFile(repo: string) {
	return new Promise<Readonly<ExternalRepoConfig.File> | null>((resolve) => {
		fs.readFile(path.join(repo, '.vscode', 'vscode-git-graph.json'), (err, data) => {
			if (err) {
				resolve(null);
			} else {
				try {
					const contents = JSON.parse(data.toString());
					resolve(typeof contents === 'object' ? contents : null);
				} catch (_) {
					resolve(null);
				}
			}
		});
	});
}

/**
 * Writes the External Configuration File of a repository to the File System.
 * @param repo The path of the repository.
 * @param file The file contents.
 * @returns A promise that resolves to a success message, or rejects to an error message.
 */
function writeExternalConfigFile(repo: string, file: ExternalRepoConfig.File) {
	return new Promise<string>((resolve, reject) => {
		const vscodePath = path.join(repo, '.vscode');
		fs.mkdir(vscodePath, (err) => {
			if (!err || err.code === 'EEXIST') {
				const configPath = path.join(vscodePath, 'vscode-git-graph.json');
				fs.writeFile(configPath, JSON.stringify(file, null, 4), (err) => {
					if (err) {
						reject('Failed to write the Git Graph Repository Configuration File to "' + getPathFromStr(configPath) + '".');
					} else {
						resolve('Successfully exported the Git Graph Repository Configuration to "' + getPathFromStr(configPath) + '".');
					}
				});
			} else {
				reject('An unexpected error occurred while checking if the "' + getPathFromStr(vscodePath) + '" directory exists. This directory is used to store the Git Graph Repository Configuration file.');
			}
		});
	});
}

/**
 * Generate the External Config File's contents from the Git Repositories state.
 * @param state The state being exported.
 * @returns The file contents.
 */
function generateExternalConfigFile(state: GitRepoState): Readonly<ExternalRepoConfig.File> {
	const file: ExternalRepoConfig.File = {};

	if (state.commitOrdering !== RepoCommitOrdering.Default) {
		file.commitOrdering = state.commitOrdering;
	}
	if (state.fileViewType !== FileViewType.Default) {
		switch (state.fileViewType) {
			case FileViewType.Tree:
				file.fileViewType = ExternalRepoConfig.FileViewType.Tree;
				break;
			case FileViewType.List:
				file.fileViewType = ExternalRepoConfig.FileViewType.List;
				break;
		}
	}
	if (state.hideRemotes.length > 0) {
		file.hideRemotes = state.hideRemotes;
	}
	if (state.includeCommitsMentionedByReflogs !== BooleanOverride.Default) {
		file.includeCommitsMentionedByReflogs = state.includeCommitsMentionedByReflogs === BooleanOverride.Enabled;
	}
	if (state.issueLinkingConfig !== null) {
		file.issueLinkingConfig = state.issueLinkingConfig;
	}
	if (state.name !== null) {
		file.name = state.name;
	}
	if (state.onlyFollowFirstParent !== BooleanOverride.Default) {
		file.onlyFollowFirstParent = state.onlyFollowFirstParent === BooleanOverride.Enabled;
	}
	if (state.onRepoLoadShowCheckedOutBranch !== BooleanOverride.Default) {
		file.onRepoLoadShowCheckedOutBranch = state.onRepoLoadShowCheckedOutBranch === BooleanOverride.Enabled;
	}
	if (state.onRepoLoadShowSpecificBranches !== null) {
		file.onRepoLoadShowSpecificBranches = state.onRepoLoadShowSpecificBranches;
	}
	if (state.pullRequestConfig !== null) {
		let provider: ExternalRepoConfig.PullRequestProvider;
		switch (state.pullRequestConfig.provider) {
			case PullRequestProvider.Bitbucket:
				provider = ExternalRepoConfig.PullRequestProvider.Bitbucket;
				break;
			case PullRequestProvider.Custom:
				provider = ExternalRepoConfig.PullRequestProvider.Custom;
				break;
			case PullRequestProvider.GitHub:
				provider = ExternalRepoConfig.PullRequestProvider.GitHub;
				break;
			case PullRequestProvider.GitLab:
				provider = ExternalRepoConfig.PullRequestProvider.GitLab;
				break;
		}
		file.pullRequestConfig = Object.assign({}, state.pullRequestConfig, { provider: provider });
	}
	if (state.showRemoteBranchesV2 !== BooleanOverride.Default) {
		file.showRemoteBranches = state.showRemoteBranchesV2 === BooleanOverride.Enabled;
	}
	if (state.showStashes !== BooleanOverride.Default) {
		file.showStashes = state.showStashes === BooleanOverride.Enabled;
	}
	if (state.showTags !== BooleanOverride.Default) {
		file.showTags = state.showTags === BooleanOverride.Enabled;
	}
	file.exportedAt = (new Date()).getTime();
	return file;
}

/**
 * Validate an external configuration file.
 * @param file The external configuration file.
 * @returns NULL => Value, String => The first field that is invalid.
 */
function validateExternalConfigFile(file: Readonly<ExternalRepoConfig.File>) {
	if (typeof file.commitOrdering !== 'undefined' && file.commitOrdering !== RepoCommitOrdering.Date && file.commitOrdering !== RepoCommitOrdering.AuthorDate && file.commitOrdering !== RepoCommitOrdering.Topological) {
		return 'commitOrdering';
	}
	if (typeof file.fileViewType !== 'undefined' && file.fileViewType !== ExternalRepoConfig.FileViewType.Tree && file.fileViewType !== ExternalRepoConfig.FileViewType.List) {
		return 'fileViewType';
	}
	if (typeof file.hideRemotes !== 'undefined' && (!Array.isArray(file.hideRemotes) || file.hideRemotes.some((remote) => typeof remote !== 'string'))) {
		return 'hideRemotes';
	}
	if (typeof file.includeCommitsMentionedByReflogs !== 'undefined' && typeof file.includeCommitsMentionedByReflogs !== 'boolean') {
		return 'includeCommitsMentionedByReflogs';
	}
	if (typeof file.issueLinkingConfig !== 'undefined' && (typeof file.issueLinkingConfig !== 'object' || file.issueLinkingConfig === null || typeof file.issueLinkingConfig.issue !== 'string' || typeof file.issueLinkingConfig.url !== 'string')) {
		return 'issueLinkingConfig';
	}
	if (typeof file.name !== 'undefined' && typeof file.name !== 'string') {
		return 'name';
	}
	if (typeof file.onlyFollowFirstParent !== 'undefined' && typeof file.onlyFollowFirstParent !== 'boolean') {
		return 'onlyFollowFirstParent';
	}
	if (typeof file.onRepoLoadShowCheckedOutBranch !== 'undefined' && typeof file.onRepoLoadShowCheckedOutBranch !== 'boolean') {
		return 'onRepoLoadShowCheckedOutBranch';
	}
	if (typeof file.onRepoLoadShowSpecificBranches !== 'undefined' && (!Array.isArray(file.onRepoLoadShowSpecificBranches) || file.onRepoLoadShowSpecificBranches.some((branch) => typeof branch !== 'string'))) {
		return 'onRepoLoadShowSpecificBranches';
	}
	if (typeof file.pullRequestConfig !== 'undefined' && (
		typeof file.pullRequestConfig !== 'object' ||
		file.pullRequestConfig === null ||
		(
			file.pullRequestConfig.provider !== ExternalRepoConfig.PullRequestProvider.Bitbucket &&
			(file.pullRequestConfig.provider !== ExternalRepoConfig.PullRequestProvider.Custom || typeof file.pullRequestConfig.custom !== 'object' || file.pullRequestConfig.custom === null || typeof file.pullRequestConfig.custom.name !== 'string' || typeof file.pullRequestConfig.custom.templateUrl !== 'string') &&
			file.pullRequestConfig.provider !== ExternalRepoConfig.PullRequestProvider.GitHub &&
			file.pullRequestConfig.provider !== ExternalRepoConfig.PullRequestProvider.GitLab
		) ||
		typeof file.pullRequestConfig.hostRootUrl !== 'string' ||
		typeof file.pullRequestConfig.sourceRemote !== 'string' ||
		typeof file.pullRequestConfig.sourceOwner !== 'string' ||
		typeof file.pullRequestConfig.sourceRepo !== 'string' ||
		(typeof file.pullRequestConfig.destRemote !== 'string' && file.pullRequestConfig.destRemote !== null) ||
		typeof file.pullRequestConfig.destOwner !== 'string' ||
		typeof file.pullRequestConfig.destRepo !== 'string' ||
		typeof file.pullRequestConfig.destProjectId !== 'string' ||
		typeof file.pullRequestConfig.destBranch !== 'string'
	)) {
		return 'pullRequestConfig';
	}
	if (typeof file.showRemoteBranches !== 'undefined' && typeof file.showRemoteBranches !== 'boolean') {
		return 'showRemoteBranches';
	}
	if (typeof file.showStashes !== 'undefined' && typeof file.showStashes !== 'boolean') {
		return 'showStashes';
	}
	if (typeof file.showTags !== 'undefined' && typeof file.showTags !== 'boolean') {
		return 'showTags';
	}
	return null;
}

/**
 * Apply the configuration provided in an external configuration file to a repository state.
 * @param file The file to apply.
 * @param state The state to be updated.
 */
function applyExternalConfigFile(file: Readonly<ExternalRepoConfig.File>, state: GitRepoState) {
	if (typeof file.commitOrdering !== 'undefined') {
		state.commitOrdering = file.commitOrdering;
	}
	if (typeof file.fileViewType !== 'undefined') {
		switch (file.fileViewType) {
			case ExternalRepoConfig.FileViewType.Tree:
				state.fileViewType = FileViewType.Tree;
				break;
			case ExternalRepoConfig.FileViewType.List:
				state.fileViewType = FileViewType.List;
				break;
		}
	}
	if (typeof file.hideRemotes !== 'undefined') {
		state.hideRemotes = file.hideRemotes;
	}
	if (typeof file.includeCommitsMentionedByReflogs !== 'undefined') {
		state.includeCommitsMentionedByReflogs = file.includeCommitsMentionedByReflogs ? BooleanOverride.Enabled : BooleanOverride.Disabled;
	}
	if (typeof file.issueLinkingConfig !== 'undefined') {
		state.issueLinkingConfig = {
			issue: file.issueLinkingConfig.issue,
			url: file.issueLinkingConfig.url
		};
	}
	if (typeof file.name !== 'undefined') {
		state.name = file.name;
	}
	if (typeof file.onlyFollowFirstParent !== 'undefined') {
		state.onlyFollowFirstParent = file.onlyFollowFirstParent ? BooleanOverride.Enabled : BooleanOverride.Disabled;
	}
	if (typeof file.onRepoLoadShowCheckedOutBranch !== 'undefined') {
		state.onRepoLoadShowCheckedOutBranch = file.onRepoLoadShowCheckedOutBranch ? BooleanOverride.Enabled : BooleanOverride.Disabled;
	}
	if (typeof file.onRepoLoadShowSpecificBranches !== 'undefined') {
		state.onRepoLoadShowSpecificBranches = file.onRepoLoadShowSpecificBranches;
	}
	if (typeof file.pullRequestConfig !== 'undefined') {
		let provider: PullRequestProvider;
		switch (file.pullRequestConfig.provider) {
			case ExternalRepoConfig.PullRequestProvider.Bitbucket:
				provider = PullRequestProvider.Bitbucket;
				break;
			case ExternalRepoConfig.PullRequestProvider.Custom:
				provider = PullRequestProvider.Custom;
				break;
			case ExternalRepoConfig.PullRequestProvider.GitHub:
				provider = PullRequestProvider.GitHub;
				break;
			case ExternalRepoConfig.PullRequestProvider.GitLab:
				provider = PullRequestProvider.GitLab;
				break;
		}
		state.pullRequestConfig = <PullRequestConfig>{
			provider: provider,
			custom: provider === PullRequestProvider.Custom
				? {
					name: file.pullRequestConfig.custom!.name,
					templateUrl: file.pullRequestConfig.custom!.templateUrl
				}
				: null,
			hostRootUrl: file.pullRequestConfig.hostRootUrl,
			sourceRemote: file.pullRequestConfig.sourceRemote,
			sourceOwner: file.pullRequestConfig.sourceOwner,
			sourceRepo: file.pullRequestConfig.sourceRepo,
			destRemote: file.pullRequestConfig.destRemote,
			destOwner: file.pullRequestConfig.destOwner,
			destRepo: file.pullRequestConfig.destRepo,
			destProjectId: file.pullRequestConfig.destProjectId,
			destBranch: file.pullRequestConfig.destBranch
		};
	}
	if (typeof file.showRemoteBranches !== 'undefined') {
		state.showRemoteBranchesV2 = file.showRemoteBranches ? BooleanOverride.Enabled : BooleanOverride.Disabled;
	}
	if (typeof file.showStashes !== 'undefined') {
		state.showStashes = file.showStashes ? BooleanOverride.Enabled : BooleanOverride.Disabled;
	}
	if (typeof file.showTags !== 'undefined') {
		state.showTags = file.showTags ? BooleanOverride.Enabled : BooleanOverride.Disabled;
	}
}
-e 

================================================================================
// FILE: ./src/life-cycle/utils.ts
================================================================================
/**
 * Git Graph generates an event when it is installed, updated, or uninstalled, that is anonymous, non-personal, and cannot be correlated.
 * - Each event only contains the Git Graph and Visual Studio Code version numbers, and a 256 bit cryptographically strong pseudo-random nonce.
 * - The two version numbers recorded in these events only allow aggregate compatibility information to be generated (e.g. 50% of users are
 *   using Visual Studio Code >= 1.41.0). These insights enable Git Graph to utilise the latest features of Visual Studio Code as soon as
 *   the majority of users are using a compatible version. The data cannot, and will not, be used for any other purpose.
 * - Full details are available at: https://api.mhutchie.com/vscode-git-graph/about
 */

import * as crypto from 'crypto';
import * as fs from 'fs';
import * as https from 'https';
import * as path from 'path';

type LifeCycleEvent = {
	stage: LifeCycleStage.Install;
	extension: string;
	vscode: string;
	nonce: string;
} | {
	stage: LifeCycleStage.Update;
	from: {
		extension: string,
		vscode: string
	};
	to: {
		extension: string,
		vscode: string
	};
	nonce: string;
} | {
	stage: LifeCycleStage.Uninstall;
	extension: string;
	vscode: string;
	nonce: string;
};

export enum LifeCycleStage {
	Install,
	Update,
	Uninstall
}

export interface LifeCycleState {
	previous: {
		extension: string,
		vscode: string,
	} | null;
	current: {
		extension: string,
		vscode: string
	};
	apiAvailable: boolean;
	queue: LifeCycleEvent[];
	attempts: number;
}

/**
 * Generate a 256 bit cryptographically strong pseudo-random nonce.
 * @returns The nonce.
 */
export function generateNonce() {
	return crypto.randomBytes(32).toString('base64');
}

/**
 * Gets the data directory for files used by the life cycle process.
 * @returns The path of the directory.
 */
export function getDataDirectory() {
	return path.join(__dirname, 'data');
}

/**
 * Gets the path of the life cycle file in the specified directory.
 * @param directory The path of the directory.
 * @returns The path of the life cycle file.
 */
function getLifeCycleFilePathInDirectory(directory: string) {
	return path.join(directory, 'life-cycle.json');
}

/**
 * Gets the life cycle state of Git Graph from the specified directory.
 * @param directory The directory that contains the life cycle state.
 * @returns The life cycle state.
 */
export function getLifeCycleStateInDirectory(directory: string) {
	return new Promise<LifeCycleState | null>((resolve) => {
		fs.readFile(getLifeCycleFilePathInDirectory(directory), (err, data) => {
			if (err) {
				resolve(null);
			} else {
				try {
					resolve(Object.assign({ attempts: 1 }, JSON.parse(data.toString())));
				} catch (_) {
					resolve(null);
				}
			}
		});
	});
}

/**
 * Saves the life cycle state of Git Graph in the specified directory.
 * @param directory The directory to store the life cycle state.
 * @param state The state to save.
 */
export function saveLifeCycleStateInDirectory(directory: string, state: LifeCycleState) {
	return new Promise((resolve, reject) => {
		fs.mkdir(directory, (err) => {
			if (!err || err.code === 'EEXIST') {
				fs.writeFile(getLifeCycleFilePathInDirectory(directory), JSON.stringify(state), (err) => {
					if (err) {
						reject();
					} else {
						resolve();
					}
				});
			} else {
				reject();
			}
		});
	});
}

/**
 * Send all events in a specified queue of life cycle events (typically only one event long).
 * @param queue The queue containing the events.
 * @returns TRUE => Queue was successfully sent & the API is still available, FALSE => The API is no longer available.
 */
export async function sendQueue(queue: LifeCycleEvent[]) {
	for (let i = 0; i < queue.length; i++) {
		if (!await sendEvent(queue[i])) return false;
	}
	return true;
}

/**
 * Send an event to the API.
 * @param event The event to send.
 * @returns TRUE => Event was successfully sent & the API is still available, FALSE => The API is no longer available.
 */
function sendEvent(event: LifeCycleEvent) {
	return new Promise<boolean>((resolve, reject) => {
		let completed = false, receivedResponse = false, apiAvailable = false;
		const complete = () => {
			if (!completed) {
				completed = true;
				if (receivedResponse) {
					resolve(apiAvailable);
				} else {
					reject();
				}
			}
		};

		const sendEvent: Omit<LifeCycleEvent, 'stage'> & { about: string, stage?: LifeCycleStage } = Object.assign({
			about: 'Information about this API is available at: https://api.mhutchie.com/vscode-git-graph/about'
		}, event);
		delete sendEvent.stage;

		const content = JSON.stringify(sendEvent);
		https.request({
			method: 'POST',
			hostname: 'api.mhutchie.com',
			path: '/vscode-git-graph/' + (event.stage === LifeCycleStage.Install ? 'install' : event.stage === LifeCycleStage.Update ? 'update' : 'uninstall'),
			headers: {
				'Content-Type': 'application/json',
				'Content-Length': content.length
			},
			agent: false,
			timeout: 15000
		}, (res) => {
			res.on('data', () => { });
			res.on('end', () => {
				if (res.statusCode === 201) {
					receivedResponse = true;
					apiAvailable = true;
				} else if (res.statusCode === 410) {
					receivedResponse = true;
				}
				complete();
			});
			res.on('error', complete);
		}).on('error', complete).on('close', complete).end(content);
	});
}
-e 

================================================================================
// FILE: ./src/life-cycle/uninstall.ts
================================================================================
/**
 * Git Graph generates an event when it is installed, updated, or uninstalled, that is anonymous, non-personal, and cannot be correlated.
 * - Each event only contains the Git Graph and Visual Studio Code version numbers, and a 256 bit cryptographically strong pseudo-random nonce.
 * - The two version numbers recorded in these events only allow aggregate compatibility information to be generated (e.g. 50% of users are
 *   using Visual Studio Code >= 1.41.0). These insights enable Git Graph to utilise the latest features of Visual Studio Code as soon as
 *   the majority of users are using a compatible version. The data cannot, and will not, be used for any other purpose.
 * - Full details are available at: https://api.mhutchie.com/vscode-git-graph/about
 */

import { LifeCycleStage, generateNonce, getDataDirectory, getLifeCycleStateInDirectory, sendQueue } from './utils';

(async function () {
	try {
		const state = await getLifeCycleStateInDirectory(getDataDirectory());
		if (state !== null) {
			if (state.apiAvailable) {
				state.queue.push({
					stage: LifeCycleStage.Uninstall,
					extension: state.current.extension,
					vscode: state.current.vscode,
					nonce: generateNonce()
				});
				await sendQueue(state.queue);
			}
		}
	} catch (_) { }
})();
-e 

================================================================================
// FILE: ./src/life-cycle/startup.ts
================================================================================
/**
 * Git Graph generates an event when it is installed, updated, or uninstalled, that is anonymous, non-personal, and cannot be correlated.
 * - Each event only contains the Git Graph and Visual Studio Code version numbers, and a 256 bit cryptographically strong pseudo-random nonce.
 * - The two version numbers recorded in these events only allow aggregate compatibility information to be generated (e.g. 50% of users are
 *   using Visual Studio Code >= 1.41.0). These insights enable Git Graph to utilise the latest features of Visual Studio Code as soon as
 *   the majority of users are using a compatible version. The data cannot, and will not, be used for any other purpose.
 * - Full details are available at: https://api.mhutchie.com/vscode-git-graph/about
 */

import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import { LifeCycleStage, LifeCycleState, generateNonce, getDataDirectory, getLifeCycleStateInDirectory, saveLifeCycleStateInDirectory, sendQueue } from './utils';
import { getExtensionVersion } from '../utils';

/**
 * Run on startup to detect if Git Graph has been installed or updated, and if so generate an event.
 * @param extensionContext The extension context of Git Graph.
 */
export async function onStartUp(extensionContext: vscode.ExtensionContext) {
	if (vscode.env.sessionId === 'someValue.sessionId') {
		// Extension is running in the Extension Development Host, don't proceed.
		return;
	}

	let state = await getLifeCycleStateInDirectory(extensionContext.globalStoragePath);

	if (state !== null && !state.apiAvailable) {
		// The API is no longer available, don't proceed.
		return;
	}

	const versions = {
		extension: await getExtensionVersion(extensionContext),
		vscode: vscode.version
	};

	if (state === null || state.current.extension !== versions.extension) {
		// This is the first startup after installing Git Graph, or Git Graph has been updated since the last startup.
		const nonce = await getNonce();

		if (state === null) {
			// Install
			state = {
				previous: null,
				current: versions,
				apiAvailable: true,
				queue: [{
					stage: LifeCycleStage.Install,
					extension: versions.extension,
					vscode: versions.vscode,
					nonce: nonce
				}],
				attempts: 1
			};
		} else {
			// Update
			state.previous = state.current;
			state.current = versions;
			state.queue.push({
				stage: LifeCycleStage.Update,
				from: state.previous,
				to: state.current,
				nonce: nonce
			});
			state.attempts = 1;
		}

		await saveLifeCycleState(extensionContext, state);
		state.apiAvailable = await sendQueue(state.queue);
		state.queue = [];
		await saveLifeCycleState(extensionContext, state);

	} else if (state.queue.length > 0 && state.attempts < 2) {
		// There are one or more events in the queue that previously failed to send, send them
		state.attempts++;
		await saveLifeCycleState(extensionContext, state);
		state.apiAvailable = await sendQueue(state.queue);
		state.queue = [];
		await saveLifeCycleState(extensionContext, state);
	}
}

/**
 * Saves the life cycle state to the extensions global storage directory (for use during future updates),
 * and to a directory in this Git Graph installation (for use during future uninstalls).
 * @param extensionContext The extension context of Git Graph.
 * @param state The state to save.
 */
function saveLifeCycleState(extensionContext: vscode.ExtensionContext, state: LifeCycleState) {
	return Promise.all([
		saveLifeCycleStateInDirectory(extensionContext.globalStoragePath, state),
		saveLifeCycleStateInDirectory(getDataDirectory(), state)
	]);
}

/**
 * Get a nonce generated for this installation of Git Graph.
 * @returns A 256 bit cryptographically strong pseudo-random nonce.
 */
function getNonce() {
	return new Promise<string>((resolve, reject) => {
		const dir = getDataDirectory();
		const file = path.join(dir, 'lock.json');
		fs.mkdir(dir, (err) => {
			if (err) {
				if (err.code === 'EEXIST') {
					// The directory already exists, attempt to read the previously created data
					fs.readFile(file, (err, data) => {
						if (err) {
							// Unable to read the file, reject
							reject();
						} else {
							try {
								// Resolve to the previously generated nonce
								resolve(JSON.parse(data.toString()).nonce);
							} catch (_) {
								reject();
							}
						}
					});
				} else {
					// An unexpected error occurred, reject
					reject();
				}
			} else {
				// The directory was created, generate a nonce
				const nonce = generateNonce();
				fs.writeFile(file, JSON.stringify({ nonce: nonce }), (err) => {
					if (err) {
						// Unable to save data
						reject();
					} else {
						// Nonce successfully saved, resolve to it
						resolve(nonce);
					}
				});
			}
		});
	});
}
-e 

================================================================================
// FILE: ./src/logger.ts
================================================================================
import * as vscode from 'vscode';
import { Disposable } from './utils/disposable';

const DOUBLE_QUOTE_REGEXP = /"/g;

/**
 * Manages the Git Graph Logger, which writes log information to the Git Graph Output Channel.
 */
export class Logger extends Disposable {
	private readonly channel: vscode.OutputChannel;

	/**
	 * Creates the Git Graph Logger.
	 */
	constructor() {
		super();
		this.channel = vscode.window.createOutputChannel('Git Graph');
		this.registerDisposable(this.channel);
	}

	/**
	 * Log a message to the Output Channel.
	 * @param message The string to be logged.
	 */
	public log(message: string) {
		const date = new Date();
		const timestamp = date.getFullYear() + '-' + pad2(date.getMonth() + 1) + '-' + pad2(date.getDate()) + ' ' + pad2(date.getHours()) + ':' + pad2(date.getMinutes()) + ':' + pad2(date.getSeconds()) + '.' + pad3(date.getMilliseconds());
		this.channel.appendLine('[' + timestamp + '] ' + message);
	}

	/**
	 * Log the execution of a spawned command to the Output Channel.
	 * @param cmd The command being spawned.
	 * @param args The arguments passed to the command.
	 */
	public logCmd(cmd: string, args: string[]) {
		this.log('> ' + cmd + ' ' + args.map((arg) => arg === ''
			? '""'
			: arg.startsWith('--format=')
				? '--format=...'
				: arg.includes(' ')
					? '"' + arg.replace(DOUBLE_QUOTE_REGEXP, '\\"') + '"'
					: arg
		).join(' '));
	}

	/**
	 * Log an error message to the Output Channel.
	 * @param message The string to be logged.
	 */
	public logError(message: string) {
		this.log('ERROR: ' + message);
	}
}

/**
 * Pad a number with a leading zero if it is less than two digits long.
 * @param n The number to be padded.
 * @returns The padded number.
 */
function pad2(n: number) {
	return (n > 9 ? '' : '0') + n;
}

/**
 * Pad a number with leading zeros if it is less than three digits long.
 * @param n The number to be padded.
 * @returns The padded number.
 */
function pad3(n: number) {
	return (n > 99 ? '' : n > 9 ? '0' : '00') + n;
}
-e 

================================================================================
// FILE: ./src/utils.ts
================================================================================
import * as cp from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import { getConfig } from './config';
import { DataSource } from './dataSource';
import { DiffSide, encodeDiffDocUri } from './diffDocProvider';
import { ExtensionState } from './extensionState';
import { ErrorInfo, GitFileStatus, GitRepoSet, PullRequestConfig, PullRequestProvider, RepoDropdownOrder } from './types';

export const UNCOMMITTED = '*';
export const UNABLE_TO_FIND_GIT_MSG = 'Unable to find a Git executable. Either: Set the Visual Studio Code Setting "git.path" to the path and filename of an existing Git executable, or install Git and restart Visual Studio Code.';


/* Path Manipulation */

const FS_REGEX = /\\/g;

/**
 * Get the normalised path of a URI.
 * @param uri The URI.
 * @returns The normalised path.
 */
export function getPathFromUri(uri: vscode.Uri) {
	return uri.fsPath.replace(FS_REGEX, '/');
}

/**
 * Get the normalised path of a string.
 * @param str The string.
 * @returns The normalised path.
 */
export function getPathFromStr(str: string) {
	return str.replace(FS_REGEX, '/');
}

/**
 * Get the path with a trailing slash.
 * @param path The path.
 * @returns The path with a trailing slash.
 */
export function pathWithTrailingSlash(path: string) {
	return path.endsWith('/') ? path : path + '/';
}

/**
 * Check whether a path is within the current Visual Studio Code Workspace.
 * @param path The path to check.
 * @returns TRUE => Path is in workspace, FALSE => Path isn't in workspace.
 */
export function isPathInWorkspace(path: string) {
	let rootsExact = [], rootsFolder = [], workspaceFolders = vscode.workspace.workspaceFolders;
	if (typeof workspaceFolders !== 'undefined') {
		for (let i = 0; i < workspaceFolders.length; i++) {
			let tmpPath = getPathFromUri(workspaceFolders[i].uri);
			rootsExact.push(tmpPath);
			rootsFolder.push(pathWithTrailingSlash(tmpPath));
		}
	}
	return rootsExact.indexOf(path) > -1 || rootsFolder.findIndex(x => path.startsWith(x)) > -1;
}

/**
 * Get the normalised canonical absolute path (i.e. resolves symlinks in `path`).
 * @param path The path.
 * @param native Use the native realpath.
 * @returns The normalised canonical absolute path.
 */
export function realpath(path: string, native: boolean = false) {
	return new Promise<string>((resolve) => {
		(native ? fs.realpath.native : fs.realpath)(path, (err, resolvedPath) => resolve(err !== null ? path : getPathFromUri(vscode.Uri.file(resolvedPath))));
	});
}

/**
 * Transform the path from a canonical absolute path to use symbolic links if the containing Visual Studio Code workspace folder has symbolic link(s).
 * @param path The canonical absolute path.
 * @returns The transformed path.
 */
export async function resolveToSymbolicPath(path: string) {
	let workspaceFolders = vscode.workspace.workspaceFolders;
	if (typeof workspaceFolders !== 'undefined') {
		for (let i = 0; i < workspaceFolders.length; i++) {
			let rootSymPath = getPathFromUri(workspaceFolders[i].uri);
			let rootCanonicalPath = await realpath(rootSymPath);
			if (path === rootCanonicalPath) {
				return rootSymPath;
			} else if (path.startsWith(rootCanonicalPath + '/')) {
				return rootSymPath + path.substring(rootCanonicalPath.length);
			} else if (rootCanonicalPath.startsWith(path + '/')) {
				let symPath = rootSymPath;
				let first = symPath.indexOf('/');
				while (true) {
					if (path === symPath || path === await realpath(symPath)) return symPath;
					let next = symPath.lastIndexOf('/');
					if (first !== next && next > -1) {
						symPath = symPath.substring(0, next);
					} else {
						return path;
					}
				}
			}
		}
	}
	return path;
}

/**
 * Checks whether a file exists, and the user has access to read it.
 * @param path The path of the file.
 * @returns Promise resolving to a boolean: TRUE => File exists, FALSE => File doesn't exist.
 */
export function doesFileExist(path: string) {
	return new Promise<boolean>((resolve) => {
		fs.access(path, fs.constants.R_OK, (err) => resolve(err === null));
	});
}


/* General Methods */

/**
 * Abbreviate a commit hash to the first eight characters.
 * @param commitHash The full commit hash.
 * @returns The abbreviated commit hash.
 */
export function abbrevCommit(commitHash: string) {
	return commitHash.substring(0, 8);
}

/**
 * Abbreviate a string to the specified number of characters.
 * @param text The string to abbreviate.
 * @param toChars The number of characters to abbreviate the string to.
 * @returns The abbreviated string.
 */
export function abbrevText(text: string, toChars: number) {
	return text.length <= toChars ? text : text.substring(0, toChars - 1) + '...';
}

/**
 * Get the relative time difference between the current time and a Unix timestamp.
 * @param unixTimestamp The Unix timestamp.
 * @returns The relative time difference (e.g. 12 minutes ago).
 */
export function getRelativeTimeDiff(unixTimestamp: number) {
	let diff = Math.round((new Date()).getTime() / 1000) - unixTimestamp, unit;
	if (diff < 60) {
		unit = 'second';
	} else if (diff < 3600) {
		unit = 'minute';
		diff /= 60;
	} else if (diff < 86400) {
		unit = 'hour';
		diff /= 3600;
	} else if (diff < 604800) {
		unit = 'day';
		diff /= 86400;
	} else if (diff < 2629800) {
		unit = 'week';
		diff /= 604800;
	} else if (diff < 31557600) {
		unit = 'month';
		diff /= 2629800;
	} else {
		unit = 'year';
		diff /= 31557600;
	}
	diff = Math.round(diff);
	return diff + ' ' + unit + (diff !== 1 ? 's' : '') + ' ago';
}

/**
 * Gets the version of Git Graph.
 * @param extensionContext The extension context of Git Graph.
 * @returns The Git Graph version.
 */
export function getExtensionVersion(extensionContext: vscode.ExtensionContext) {
	return new Promise<string>((resolve, reject) => {
		fs.readFile(path.join(extensionContext.extensionPath, 'package.json'), (err, data) => {
			if (err) {
				reject();
			} else {
				try {
					resolve(JSON.parse(data.toString()).version);
				} catch (_) {
					reject();
				}
			}
		});
	});
}

/**
 * Randomly generate a nonce.
 * @returns The nonce.
 */
export function getNonce() {
	let text = '';
	const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	for (let i = 0; i < 32; i++) {
		text += possible.charAt(Math.floor(Math.random() * possible.length));
	}
	return text;
}

/**
 * Get a short name for a repository.
 * @param path The path of the repository.
 * @returns The short name.
 */
export function getRepoName(path: string) {
	const firstSep = path.indexOf('/');
	if (firstSep === path.length - 1 || firstSep === -1) {
		return path; // Path has no slashes, or a single trailing slash ==> use the path
	} else {
		const p = path.endsWith('/') ? path.substring(0, path.length - 1) : path; // Remove trailing slash if it exists
		return p.substring(p.lastIndexOf('/') + 1);
	}
}

/**
 * Get a sorted list of repository paths from a given GitRepoSet.
 * @param repos The set of repositories.
 * @param order The order to sort the repositories.
 * @returns An array of ordered repository paths.
 */
export function getSortedRepositoryPaths(repos: GitRepoSet, order: RepoDropdownOrder): ReadonlyArray<string> {
	const repoPaths = Object.keys(repos);
	if (order === RepoDropdownOrder.WorkspaceFullPath) {
		return repoPaths.sort((a, b) => repos[a].workspaceFolderIndex === repos[b].workspaceFolderIndex
			? a.localeCompare(b)
			: repos[a].workspaceFolderIndex === null
				? 1
				: repos[b].workspaceFolderIndex === null
					? -1
					: repos[a].workspaceFolderIndex! - repos[b].workspaceFolderIndex!
		);
	} else if (order === RepoDropdownOrder.FullPath) {
		return repoPaths.sort((a, b) => a.localeCompare(b));
	} else {
		return repoPaths.map((path) => ({ name: repos[path].name || getRepoName(path), path: path }))
			.sort((a, b) => a.name !== b.name ? a.name.localeCompare(b.name) : a.path.localeCompare(b.path))
			.map((x) => x.path);
	}
}


/* Visual Studio Code Command Wrappers */

/**
 * Create an archive of a repository at a specific reference, and save to disk.
 * @param repo The path of the repository.
 * @param ref The reference of the revision to archive.
 * @param dataSource The DataSource instance that can be used to create the archive.
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export function archive(repo: string, ref: string, dataSource: DataSource): Thenable<ErrorInfo> {
	return vscode.window.showSaveDialog({
		defaultUri: vscode.Uri.file(repo),
		saveLabel: 'Create Archive',
		filters: { 'TAR Archive': ['tar'], 'ZIP Archive': ['zip'] }
	}).then(
		(uri) => {
			if (uri) {
				const extension = uri.fsPath.substring(uri.fsPath.lastIndexOf('.') + 1).toLowerCase();
				if (extension === 'tar' || extension === 'zip') {
					return dataSource.archive(repo, ref, uri.fsPath, extension);
				} else {
					return 'Invalid file extension "*.' + extension + '". The archive file must have a *.tar or *.zip extension.';
				}
			} else {
				return 'No file name was provided for the archive.';
			}
		},
		() => 'Visual Studio Code was unable to display the save dialog.'
	);
}


/**
 * Copy the path of a file in a repository to the clipboard.
 * @param repo The repository the file is contained in.
 * @param filePath The relative path of the file within the repository.
 * @param absolute TRUE => Absolute path, FALSE => Relative path.
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export function copyFilePathToClipboard(repo: string, filePath: string, absolute: boolean) {
	return copyToClipboard(absolute ? path.join(repo, filePath) : filePath);
}

/**
 * Copy a string to the clipboard.
 * @param text The string.
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export function copyToClipboard(text: string): Thenable<ErrorInfo> {
	return vscode.env.clipboard.writeText(text).then(
		() => null,
		() => 'Visual Studio Code was unable to write to the Clipboard.'
	);
}

/**
 * Construct the URL for creating a new Pull Request, and open it in the users default web browser.
 * @param config The Pull Request Provider's Configuration.
 * @param sourceOwner The owner of the repository that is the source of the Pull Request.
 * @param sourceRepo The name of the repository that is the source of the Pull Request.
 * @param sourceBranch The source branch the Pull Request should be created from.
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export function createPullRequest(config: PullRequestConfig, sourceOwner: string, sourceRepo: string, sourceBranch: string) {
	let templateUrl;
	switch (config.provider) {
		case PullRequestProvider.Bitbucket:
			templateUrl = '$1/$2/$3/pull-requests/new?source=$2/$3::$4&dest=$5/$6::$8';
			break;
		case PullRequestProvider.Custom:
			templateUrl = config.custom.templateUrl;
			break;
		case PullRequestProvider.GitHub:
			templateUrl = '$1/$5/$6/compare/$8...$2:$4';
			break;
		case PullRequestProvider.GitLab:
			templateUrl = '$1/$2/$3/-/merge_requests/new?merge_request[source_branch]=$4&merge_request[target_branch]=$8' +
				(config.destProjectId !== '' ? '&merge_request[target_project_id]=$7' : '');
			break;
	}

	const urlFieldValues = [
		config.hostRootUrl,
		sourceOwner, sourceRepo, sourceBranch,
		config.destOwner, config.destRepo, config.destProjectId, config.destBranch
	];

	const url = templateUrl.replace(/\$([1-8])/g, (_, index) => urlFieldValues[parseInt(index) - 1]);

	return openExternalUrl(url, 'Pull Request URL');
}

/**
 * Open the Visual Studio Code Settings Editor to the Git Graph Extension Settings.
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export function openExtensionSettings(): Thenable<ErrorInfo> {
	return vscode.commands.executeCommand('workbench.action.openSettings', '@ext:mhutchie.git-graph').then(
		() => null,
		() => 'Visual Studio Code was unable to open the Git Graph Extension Settings.'
	);
}

/**
 * Open an External URL using the default application.
 * @param url The URL for Visual Studio Code to open.
 * @param type The type of URL being opened (defaults to "External URL").
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export function openExternalUrl(url: string, type: string = 'External URL'): Thenable<ErrorInfo> {
	const getErrorMessage = () => 'Visual Studio Code was unable to open the ' + type + ': ' + url;
	try {
		return vscode.env.openExternal(vscode.Uri.parse(url)).then(
			(success) => success ? null : getErrorMessage(),
			getErrorMessage
		);
	} catch (_) {
		return Promise.resolve(getErrorMessage());
	}
}

/**
 * Open a file within a repository in Visual Studio Code.
 * @param repo The repository the file is contained in.
 * @param filePath The relative path of the file within the repository.
 * @param hash An optional commit hash where the file is known to have existed.
 * @param dataSource An optional DataSource instance, that's used to check if the file has been renamed.
 * @param viewColumn An optional ViewColumn that the file should be opened in.
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export async function openFile(repo: string, filePath: string, hash: string | null = null, dataSource: DataSource | null = null, viewColumn: vscode.ViewColumn | null = null) {
	let newFilePath = filePath;
	let newAbsoluteFilePath = path.join(repo, newFilePath);
	let fileExists = await doesFileExist(newAbsoluteFilePath);
	if (!fileExists && hash !== null && dataSource !== null) {
		const renamedFilePath = await dataSource.getNewPathOfRenamedFile(repo, hash, filePath);
		if (renamedFilePath !== null) {
			const renamedAbsoluteFilePath = path.join(repo, renamedFilePath);
			if (await doesFileExist(renamedAbsoluteFilePath)) {
				newFilePath = renamedFilePath;
				newAbsoluteFilePath = renamedAbsoluteFilePath;
				fileExists = true;
			}
		}
	}

	if (fileExists) {
		return vscode.commands.executeCommand('vscode.open', vscode.Uri.file(newAbsoluteFilePath), {
			preview: true,
			viewColumn: viewColumn === null ? getConfig().openNewTabEditorGroup : viewColumn
		}).then(
			() => null,
			() => 'Visual Studio Code was unable to open ' + newFilePath + '.'
		);
	} else {
		return 'The file ' + newFilePath + ' doesn\'t currently exist in this repository.';
	}
}

/**
 * Open the Visual Studio Code Diff View for a specific Git file change.
 * @param repo The repository the file is contained in.
 * @param fromHash The revision of the left-side of the Diff View.
 * @param toHash The revision of the right-side of the Diff View.
 * @param oldFilePath The relative path of the left-side file within the repository.
 * @param newFilePath The relative path of the right-side file within the repository.
 * @param type The Git file status of the change.
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export function viewDiff(repo: string, fromHash: string, toHash: string, oldFilePath: string, newFilePath: string, type: GitFileStatus) {
	if (type !== GitFileStatus.Untracked) {
		let abbrevFromHash = abbrevCommit(fromHash), abbrevToHash = toHash !== UNCOMMITTED ? abbrevCommit(toHash) : 'Present', pathComponents = newFilePath.split('/');
		let desc = fromHash === toHash
			? fromHash === UNCOMMITTED
				? 'Uncommitted'
				: (type === GitFileStatus.Added ? 'Added in ' + abbrevToHash : type === GitFileStatus.Deleted ? 'Deleted in ' + abbrevToHash : abbrevFromHash + '^  ' + abbrevToHash)
			: (type === GitFileStatus.Added ? 'Added between ' + abbrevFromHash + ' & ' + abbrevToHash : type === GitFileStatus.Deleted ? 'Deleted between ' + abbrevFromHash + ' & ' + abbrevToHash : abbrevFromHash + '  ' + abbrevToHash);
		let title = pathComponents[pathComponents.length - 1] + ' (' + desc + ')';
		if (fromHash === UNCOMMITTED) fromHash = 'HEAD';

		return vscode.commands.executeCommand('vscode.diff', encodeDiffDocUri(repo, oldFilePath, fromHash === toHash ? fromHash + '^' : fromHash, type, DiffSide.Old), encodeDiffDocUri(repo, newFilePath, toHash, type, DiffSide.New), title, {
			preview: true,
			viewColumn: getConfig().openNewTabEditorGroup
		}).then(
			() => null,
			() => 'Visual Studio Code was unable to load the diff editor for ' + newFilePath + '.'
		);
	} else {
		return openFile(repo, newFilePath);
	}
}

/**
 * Open the Visual Studio Code Diff View to display the changes of a file between a commit hash and the working tree.
 * @param repo The repository the file is contained in.
 * @param hash The revision of the left-side of the Diff View.
 * @param filePath The relative path of the file within the repository.
 * @param dataSource A DataSource instance, that's used to check if the file has been renamed.
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export async function viewDiffWithWorkingFile(repo: string, hash: string, filePath: string, dataSource: DataSource) {
	let newFilePath = filePath;
	let fileExists = await doesFileExist(path.join(repo, newFilePath));
	if (!fileExists) {
		const renamedFilePath = await dataSource.getNewPathOfRenamedFile(repo, hash, filePath);
		if (renamedFilePath !== null && await doesFileExist(path.join(repo, renamedFilePath))) {
			newFilePath = renamedFilePath;
			fileExists = true;
		}
	}

	const type = fileExists
		? filePath === newFilePath
			? GitFileStatus.Modified
			: GitFileStatus.Renamed
		: GitFileStatus.Deleted;

	return viewDiff(repo, hash, UNCOMMITTED, filePath, newFilePath, type);
}

/**
 * Open a Visual Studio Code Editor (readonly) for a file a specific Git revision.
 * @param repo The repository the file is contained in.
 * @param hash The revision of the file.
 * @param filePath The relative path of the file within the repository.
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export function viewFileAtRevision(repo: string, hash: string, filePath: string) {
	const pathComponents = filePath.split('/');
	const title = abbrevCommit(hash) + ': ' + pathComponents[pathComponents.length - 1];

	return vscode.commands.executeCommand('vscode.open', encodeDiffDocUri(repo, filePath, hash, GitFileStatus.Modified, DiffSide.New).with({ path: title }), {
		preview: true,
		viewColumn: getConfig().openNewTabEditorGroup
	}).then(
		() => null,
		() => 'Visual Studio Code was unable to open ' + filePath + ' at commit ' + abbrevCommit(hash) + '.'
	);
}

/**
 * Open the Visual Studio Code Source Control View.
 * @returns A promise resolving to the ErrorInfo of the executed command.
 */
export function viewScm(): Thenable<ErrorInfo> {
	return vscode.commands.executeCommand('workbench.view.scm').then(
		() => null,
		() => 'Visual Studio Code was unable to open the Source Control View.'
	);
}

/**
 * Open a new terminal, set up the Git executable, and optionally run a command.
 * @param cwd The working directory for the terminal.
 * @param gitPath The path of the Git executable.
 * @param command The command to run.
 * @param name The name for the terminal.
 */
export function openGitTerminal(cwd: string, gitPath: string, command: string | null, name: string) {
	let p = process.env['PATH'] || '', sep = isWindows() ? ';' : ':';
	if (p !== '' && !p.endsWith(sep)) p += sep;
	p += path.dirname(gitPath);

	const options: vscode.TerminalOptions = {
		cwd: cwd,
		name: 'Git Graph: ' + name,
		env: { 'PATH': p }
	};
	const shell = getConfig().integratedTerminalShell;
	if (shell !== '') options.shellPath = shell;

	const terminal = vscode.window.createTerminal(options);
	if (command !== null) {
		terminal.sendText('git ' + command);
	}
	terminal.show();
}

/**
 * Check whether Git Graph is running on a Windows-based platform.
 * @returns TRUE => Windows-based platform, FALSE => Not a Windows-based platform.
 */
function isWindows() {
	return process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';
}


/* Visual Studio Code API Wrappers */

/**
 * Show a Visual Studio Code Information Message Dialog with the specified message.
 * @param message The message to show.
 */
export function showInformationMessage(message: string) {
	return vscode.window.showInformationMessage(message).then(() => { }, () => { });
}

/**
 * Show a Visual Studio Code Error Message Dialog with the specified message.
 * @param message The message to show.
 */
export function showErrorMessage(message: string) {
	return vscode.window.showErrorMessage(message).then(() => { }, () => { });
}


/* Promise Methods */

/**
 * Evaluate promises in parallel, with at most `maxParallel` running at any point in time.
 * @param data The array of elements to be mapped via promises.
 * @param maxParallel The maximum number of promises to run at any point in time.
 * @param createPromise A function that creates a promise from an element of `data`.
 * @returns A result array evaluated by mapping promises generated from `data`.
 */
export function evalPromises<X, Y>(data: X[], maxParallel: number, createPromise: (val: X) => Promise<Y>) {
	return new Promise<Y[]>((resolve, reject) => {
		if (data.length === 1) {
			createPromise(data[0]).then(v => resolve([v])).catch(() => reject());
		} else if (data.length === 0) {
			resolve([]);
		} else {
			let results: Y[] = new Array(data.length), nextPromise = 0, rejected = false, completed = 0;
			function startNext() {
				let cur = nextPromise;
				nextPromise++;
				createPromise(data[cur]).then(result => {
					if (!rejected) {
						results[cur] = result;
						completed++;
						if (nextPromise < data.length) startNext();
						else if (completed === data.length) resolve(results);
					}
				}).catch(() => {
					reject();
					rejected = true;
				});
			}
			for (let i = 0; i < maxParallel && i < data.length; i++) startNext();
		}
	});
}

/**
 * Resolve the output of a spawned child process.
 * @param cmd The Child Process.
 * @returns Promise that resolves to [{code, error}, stdout, stderr]
 */
export function resolveSpawnOutput(cmd: cp.ChildProcess) {
	return Promise.all([
		new Promise<{ code: number, error: Error | null }>((resolve) => {
			// status promise
			let resolved = false;
			cmd.on('error', (error) => {
				if (resolved) return;
				resolve({ code: -1, error: error });
				resolved = true;
			});
			cmd.on('exit', (code) => {
				if (resolved) return;
				resolve({ code: code, error: null });
				resolved = true;
			});
		}),
		new Promise<Buffer>((resolve) => {
			// stdout promise
			let buffers: Buffer[] = [];
			cmd.stdout.on('data', (b: Buffer) => { buffers.push(b); });
			cmd.stdout.on('close', () => resolve(Buffer.concat(buffers)));
		}),
		new Promise<string>((resolve) => {
			// stderr promise
			let stderr = '';
			cmd.stderr.on('data', (d) => { stderr += d; });
			cmd.stderr.on('close', () => resolve(stderr));
		})
	]);
}


/* Find Git Executable */

// The following code matches the behaviour of equivalent functions in Visual Studio Code's Git Extension,
// however was rewritten to meet the needs of this extension.
// The original code has the following copyright notice "Copyright (c) 2015 - present Microsoft Corporation",
// and is licensed under the MIT License provided in ./licenses/LICENSE_MICROSOFT.
// https://github.com/microsoft/vscode/blob/473af338e1bd9ad4d9853933da1cd9d5d9e07dc9/extensions/git/src/git.ts#L44-L135

export interface GitExecutable {
	readonly path: string;
	readonly version: string;
}

/**
 * Find a Git executable that Git Graph can use.
 * @param extensionState The Git Graph ExtensionState instance.
 * @returns A Git executable.
 */
export async function findGit(extensionState: ExtensionState) {
	const lastKnownPath = extensionState.getLastKnownGitPath();
	if (lastKnownPath !== null) {
		try {
			return await getGitExecutable(lastKnownPath);
		} catch (_) { }
	}

	const configGitPaths = getConfig().gitPaths;
	if (configGitPaths.length > 0) {
		try {
			return await getGitExecutableFromPaths(configGitPaths);
		} catch (_) { }
	}

	switch (process.platform) {
		case 'darwin':
			return findGitOnDarwin();
		case 'win32':
			return findGitOnWin32();
		default:
			return getGitExecutable('git');
	}
}

/**
 * Find a Git executable on a Darwin-based platform that Git Graph can use.
 * @returns A Git executable.
 */
function findGitOnDarwin() {
	return new Promise<GitExecutable>((resolve, reject) => {
		cp.exec('which git', (err, stdout) => {
			if (err) return reject();

			const path = stdout.trim();
			if (path !== '/usr/bin/git') {
				getGitExecutable(path).then((exec) => resolve(exec), () => reject());
			} else {
				// must check if XCode is installed
				cp.exec('xcode-select -p', (err: any) => {
					if (err && err.code === 2) {
						// git is not installed, and launching /usr/bin/git will prompt the user to install it
						reject();
					} else {
						getGitExecutable(path).then((exec) => resolve(exec), () => reject());
					}
				});
			}
		});
	});
}

/**
 * Find a Git executable on a Windows-based platform that Git Graph can use.
 * @returns A Git executable.
 */
function findGitOnWin32() {
	return findSystemGitWin32(process.env['ProgramW6432'])
		.then(undefined, () => findSystemGitWin32(process.env['ProgramFiles(x86)']))
		.then(undefined, () => findSystemGitWin32(process.env['ProgramFiles']))
		.then(undefined, () => findSystemGitWin32(process.env['LocalAppData'] ? path.join(process.env['LocalAppData']!, 'Programs') : undefined))
		.then(undefined, () => findGitWin32InPath());
}
function findSystemGitWin32(pathBase?: string) {
	return pathBase
		? getGitExecutable(path.join(pathBase, 'Git', 'cmd', 'git.exe'))
		: Promise.reject<GitExecutable>();
}
async function findGitWin32InPath() {
	let dirs = (process.env['PATH'] || '').split(';');
	dirs.unshift(process.cwd());

	for (let i = 0; i < dirs.length; i++) {
		let file = path.join(dirs[i], 'git.exe');
		if (await isExecutable(file)) {
			try {
				return await getGitExecutable(file);
			} catch (_) { }
		}
	}
	return Promise.reject<GitExecutable>();
}

/**
 * Checks whether a path is an executable (a file that's not a symbolic link).
 * @param path The path to test.
 * @returns TRUE => Executable, FALSE => Not an Executable.
 */
function isExecutable(path: string) {
	return new Promise<boolean>(resolve => {
		fs.stat(path, (err, stat) => {
			resolve(!err && (stat.isFile() || stat.isSymbolicLink()));
		});
	});
}

/**
 * Tests whether the specified path corresponds to the path of a Git executable.
 * @param path The path of the Git executable.
 * @returns The GitExecutable data.
 */
export function getGitExecutable(path: string) {
	return new Promise<GitExecutable>((resolve, reject) => {
		resolveSpawnOutput(cp.spawn(path, ['--version'])).then((values) => {
			if (values[0].code === 0) {
				resolve({ path: path, version: values[1].toString().trim().replace(/^git version /, '') });
			} else {
				reject();
			}
		});
	});
}

/**
 * Tests whether one of the specified paths corresponds to the path of a Git executable.
 * @param paths The paths of possible Git executables.
 * @returns The GitExecutable data.
 */
export async function getGitExecutableFromPaths(paths: string[]): Promise<GitExecutable> {
	for (let i = 0; i < paths.length; i++) {
		try {
			return await getGitExecutable(paths[i]);
		} catch (_) { }
	}
	throw new Error('None of the provided paths are a Git executable');
}


/* Version Handling / Requirements */

export const enum GitVersionRequirement {
	FetchAndPruneTags = '2.17.0',
	GpgInfo = '2.4.0',
	PushStash = '2.13.2',
	TagDetails = '1.7.8'
}

export const enum VsCodeVersionRequirement {
	Codicons = '1.42.0'
}

/**
 * Checks whether a version is at least a required version.
 * @param version The version to check.
 * @param requiredVersion The minimum required version.
 * @returns TRUE => `version` is at least `requiredVersion`, FALSE => `version` is older than `requiredVersion`.
 */
export function doesVersionMeetRequirement(version: string, requiredVersion: GitVersionRequirement | VsCodeVersionRequirement) {
	const v1 = parseVersion(version);
	const v2 = parseVersion(requiredVersion);

	if (v1 === null || v2 === null) {
		// Unable to parse a version number
		return true;
	}

	if (v1.major > v2.major) return true; // Git major version is newer
	if (v1.major < v2.major) return false; // Git major version is older

	if (v1.minor > v2.minor) return true; // Git minor version is newer
	if (v1.minor < v2.minor) return false; // Git minor version is older

	if (v1.patch > v2.patch) return true; // Git patch version is newer
	if (v1.patch < v2.patch) return false; // Git patch version is older

	return true; // Versions are the same
}

/**
 * Parse a version number from a string.
 * @param version The string version number.
 * @returns The `major`.`minor`.`patch` version numbers.
 */
function parseVersion(version: string) {
	const match = version.trim().match(/^[0-9]+(\.[0-9]+|)(\.[0-9]+|)/);
	if (match === null) {
		// Unable to find a valid version number
		return null;
	}

	const comps = match[0].split('.');
	return {
		major: parseInt(comps[0], 10),
		minor: comps.length > 1 ? parseInt(comps[1], 10) : 0,
		patch: comps.length > 2 ? parseInt(comps[2], 10) : 0
	};
}

/**
 * Construct a message that explains to the user that the Git executable is not compatible with a feature.
 * @param executable The Git executable.
 * @param version The minimum required version.
 * @param feature An optional name for the feature.
 * @returns The message for the user.
 */
export function constructIncompatibleGitVersionMessage(executable: GitExecutable, version: GitVersionRequirement, feature?: string) {
	return 'A newer version of Git (>= ' + version + ') is required for ' + (feature ? feature : 'this feature') + '. Git ' + executable.version + ' is currently installed. Please install a newer version of Git to use this feature.';
}
-e 

================================================================================
// FILE: ./src/gitGraphView.ts
================================================================================
import * as path from 'path';
import * as vscode from 'vscode';
import { AvatarManager } from './avatarManager';
import { getConfig } from './config';
import { DataSource, GitCommitDetailsData, GitConfigKey } from './dataSource';
import { ExtensionState } from './extensionState';
import { Logger } from './logger';
import { RepoFileWatcher } from './repoFileWatcher';
import { RepoManager } from './repoManager';
import { ErrorInfo, GitConfigLocation, GitGraphViewInitialState, GitPushBranchMode, GitRepoSet, LoadGitGraphViewTo, RequestMessage, ResponseMessage, TabIconColourTheme } from './types';
import { UNABLE_TO_FIND_GIT_MSG, UNCOMMITTED, archive, copyFilePathToClipboard, copyToClipboard, createPullRequest, getNonce, openExtensionSettings, openExternalUrl, openFile, showErrorMessage, viewDiff, viewDiffWithWorkingFile, viewFileAtRevision, viewScm } from './utils';
import { Disposable, toDisposable } from './utils/disposable';

/**
 * Manages the Git Graph View.
 */
export class GitGraphView extends Disposable {
	public static currentPanel: GitGraphView | undefined;

	private readonly panel: vscode.WebviewPanel;
	private readonly extensionPath: string;
	private readonly avatarManager: AvatarManager;
	private readonly dataSource: DataSource;
	private readonly extensionState: ExtensionState;
	private readonly repoFileWatcher: RepoFileWatcher;
	private readonly repoManager: RepoManager;
	private readonly logger: Logger;
	private isGraphViewLoaded: boolean = false;
	private isPanelVisible: boolean = true;
	private currentRepo: string | null = null;
	private loadViewTo: LoadGitGraphViewTo = null; // Is used by the next call to getHtmlForWebview, and is then reset to null

	private loadRepoInfoRefreshId: number = 0;
	private loadCommitsRefreshId: number = 0;

	/**
	 * If a Git Graph View already exists, show and update it. Otherwise, create a Git Graph View.
	 * @param extensionPath The absolute file path of the directory containing the extension.
	 * @param dataSource The Git Graph DataSource instance.
	 * @param extensionState The Git Graph ExtensionState instance.
	 * @param avatarManger The Git Graph AvatarManager instance.
	 * @param repoManager The Git Graph RepoManager instance.
	 * @param logger The Git Graph Logger instance.
	 * @param loadViewTo What to load the view to.
	 */
	public static createOrShow(extensionPath: string, dataSource: DataSource, extensionState: ExtensionState, avatarManager: AvatarManager, repoManager: RepoManager, logger: Logger, loadViewTo: LoadGitGraphViewTo) {
		const column = vscode.window.activeTextEditor ? vscode.window.activeTextEditor.viewColumn : undefined;

		if (GitGraphView.currentPanel) {
			// If Git Graph panel already exists
			if (GitGraphView.currentPanel.isPanelVisible) {
				// If the Git Graph panel is visible
				if (loadViewTo !== null) {
					GitGraphView.currentPanel.respondLoadRepos(repoManager.getRepos(), loadViewTo);
				}
			} else {
				// If the Git Graph panel is not visible
				GitGraphView.currentPanel.loadViewTo = loadViewTo;
			}
			GitGraphView.currentPanel.panel.reveal(column);
		} else {
			// If Git Graph panel doesn't already exist
			GitGraphView.currentPanel = new GitGraphView(extensionPath, dataSource, extensionState, avatarManager, repoManager, logger, loadViewTo, column);
		}
	}

	/**
	 * Creates a Git Graph View.
	 * @param extensionPath The absolute file path of the directory containing the extension.
	 * @param dataSource The Git Graph DataSource instance.
	 * @param extensionState The Git Graph ExtensionState instance.
	 * @param avatarManger The Git Graph AvatarManager instance.
	 * @param repoManager The Git Graph RepoManager instance.
	 * @param logger The Git Graph Logger instance.
	 * @param loadViewTo What to load the view to.
	 * @param column The column the view should be loaded in.
	 */
	private constructor(extensionPath: string, dataSource: DataSource, extensionState: ExtensionState, avatarManager: AvatarManager, repoManager: RepoManager, logger: Logger, loadViewTo: LoadGitGraphViewTo, column: vscode.ViewColumn | undefined) {
		super();
		this.extensionPath = extensionPath;
		this.avatarManager = avatarManager;
		this.dataSource = dataSource;
		this.extensionState = extensionState;
		this.repoManager = repoManager;
		this.logger = logger;
		this.loadViewTo = loadViewTo;

		const config = getConfig();
		this.panel = vscode.window.createWebviewPanel('git-graph', 'Git Graph', column || vscode.ViewColumn.One, {
			enableScripts: true,
			localResourceRoots: [vscode.Uri.file(path.join(extensionPath, 'media'))],
			retainContextWhenHidden: config.retainContextWhenHidden
		});
		this.panel.iconPath = config.tabIconColourTheme === TabIconColourTheme.Colour
			? this.getResourcesUri('webview-icon.svg')
			: {
				light: this.getResourcesUri('webview-icon-light.svg'),
				dark: this.getResourcesUri('webview-icon-dark.svg')
			};


		this.registerDisposables(
			// Dispose Git Graph View resources when disposed
			toDisposable(() => {
				GitGraphView.currentPanel = undefined;
				this.repoFileWatcher.stop();
			}),

			// Dispose this Git Graph View when the Webview Panel is disposed
			this.panel.onDidDispose(() => this.dispose()),

			// Register a callback that is called when the view is shown or hidden
			this.panel.onDidChangeViewState(() => {
				if (this.panel.visible !== this.isPanelVisible) {
					if (this.panel.visible) {
						this.update();
					} else {
						this.currentRepo = null;
						this.repoFileWatcher.stop();
					}
					this.isPanelVisible = this.panel.visible;
				}
			}),

			// Subscribe to events triggered when a repository is added or deleted from Git Graph
			repoManager.onDidChangeRepos((event) => {
				if (!this.panel.visible) return;
				const loadViewTo = event.loadRepo !== null ? { repo: event.loadRepo } : null;
				if ((event.numRepos === 0 && this.isGraphViewLoaded) || (event.numRepos > 0 && !this.isGraphViewLoaded)) {
					this.loadViewTo = loadViewTo;
					this.update();
				} else {
					this.respondLoadRepos(event.repos, loadViewTo);
				}
			}),

			// Subscribe to events triggered when an avatar is available
			avatarManager.onAvatar((event) => {
				this.sendMessage({
					command: 'fetchAvatar',
					email: event.email,
					image: event.image
				});
			}),

			// Respond to messages sent from the Webview
			this.panel.webview.onDidReceiveMessage((msg) => this.respondToMessage(msg)),

			// Dispose the Webview Panel when disposed
			this.panel
		);

		// Instantiate a RepoFileWatcher that watches for file changes in the repository currently open in the Git Graph View
		this.repoFileWatcher = new RepoFileWatcher(logger, () => {
			if (this.panel.visible) {
				this.sendMessage({ command: 'refresh' });
			}
		});

		// Render the content of the Webview
		this.update();

		this.logger.log('Created Git Graph View' + (loadViewTo !== null ? ' (active repo: ' + loadViewTo.repo + ')' : ''));
	}

	/**
	 * Respond to a message sent from the front-end.
	 * @param msg The message that was received.
	 */
	private async respondToMessage(msg: RequestMessage) {
		this.repoFileWatcher.mute();
		let errorInfos: ErrorInfo[];

		switch (msg.command) {
			case 'addRemote':
				this.sendMessage({
					command: 'addRemote',
					error: await this.dataSource.addRemote(msg.repo, msg.name, msg.url, msg.pushUrl, msg.fetch)
				});
				break;
			case 'addTag':
				errorInfos = [await this.dataSource.addTag(msg.repo, msg.tagName, msg.commitHash, msg.type, msg.message, msg.force)];
				if (errorInfos[0] === null && msg.pushToRemote !== null) {
					errorInfos.push(...await this.dataSource.pushTag(msg.repo, msg.tagName, [msg.pushToRemote], msg.commitHash, msg.pushSkipRemoteCheck));
				}
				this.sendMessage({
					command: 'addTag',
					repo: msg.repo,
					tagName: msg.tagName,
					pushToRemote: msg.pushToRemote,
					commitHash: msg.commitHash,
					errors: errorInfos
				});
				break;
			case 'applyStash':
				this.sendMessage({
					command: 'applyStash',
					error: await this.dataSource.applyStash(msg.repo, msg.selector, msg.reinstateIndex)
				});
				break;
			case 'branchFromStash':
				this.sendMessage({
					command: 'branchFromStash',
					error: await this.dataSource.branchFromStash(msg.repo, msg.selector, msg.branchName)
				});
				break;
			case 'checkoutBranch':
				errorInfos = [await this.dataSource.checkoutBranch(msg.repo, msg.branchName, msg.remoteBranch)];
				if (errorInfos[0] === null && msg.pullAfterwards !== null) {
					errorInfos.push(await this.dataSource.pullBranch(msg.repo, msg.pullAfterwards.branchName, msg.pullAfterwards.remote, msg.pullAfterwards.createNewCommit, msg.pullAfterwards.squash));
				}
				this.sendMessage({
					command: 'checkoutBranch',
					pullAfterwards: msg.pullAfterwards,
					errors: errorInfos
				});
				break;
			case 'checkoutCommit':
				this.sendMessage({
					command: 'checkoutCommit',
					error: await this.dataSource.checkoutCommit(msg.repo, msg.commitHash)
				});
				break;
			case 'cherrypickCommit':
				errorInfos = [await this.dataSource.cherrypickCommit(msg.repo, msg.commitHash, msg.parentIndex, msg.recordOrigin, msg.noCommit)];
				if (errorInfos[0] === null && msg.noCommit) {
					errorInfos.push(await viewScm());
				}
				this.sendMessage({ command: 'cherrypickCommit', errors: errorInfos });
				break;
			case 'cleanUntrackedFiles':
				this.sendMessage({
					command: 'cleanUntrackedFiles',
					error: await this.dataSource.cleanUntrackedFiles(msg.repo, msg.directories)
				});
				break;
			case 'commitDetails':
				let data = await Promise.all<GitCommitDetailsData, string | null>([
					msg.commitHash === UNCOMMITTED
						? this.dataSource.getUncommittedDetails(msg.repo)
						: msg.stash === null
							? this.dataSource.getCommitDetails(msg.repo, msg.commitHash, msg.hasParents)
							: this.dataSource.getStashDetails(msg.repo, msg.commitHash, msg.stash),
					msg.avatarEmail !== null ? this.avatarManager.getAvatarImage(msg.avatarEmail) : Promise.resolve(null)
				]);
				this.sendMessage({
					command: 'commitDetails',
					...data[0],
					avatar: data[1],
					codeReview: msg.commitHash !== UNCOMMITTED ? this.extensionState.getCodeReview(msg.repo, msg.commitHash) : null,
					refresh: msg.refresh
				});
				break;
			case 'compareCommits':
				this.sendMessage({
					command: 'compareCommits',
					commitHash: msg.commitHash,
					compareWithHash: msg.compareWithHash,
					...await this.dataSource.getCommitComparison(msg.repo, msg.fromHash, msg.toHash),
					codeReview: msg.toHash !== UNCOMMITTED ? this.extensionState.getCodeReview(msg.repo, msg.fromHash + '-' + msg.toHash) : null,
					refresh: msg.refresh
				});
				break;
			case 'copyFilePath':
				this.sendMessage({
					command: 'copyFilePath',
					error: await copyFilePathToClipboard(msg.repo, msg.filePath, msg.absolute)
				});
				break;
			case 'copyToClipboard':
				this.sendMessage({
					command: 'copyToClipboard',
					type: msg.type,
					error: await copyToClipboard(msg.data)
				});
				break;
			case 'createArchive':
				this.sendMessage({
					command: 'createArchive',
					error: await archive(msg.repo, msg.ref, this.dataSource)
				});
				break;
			case 'createBranch':
				this.sendMessage({
					command: 'createBranch',
					errors: await this.dataSource.createBranch(msg.repo, msg.branchName, msg.commitHash, msg.checkout, msg.force)
				});
				break;
			case 'createPullRequest':
				errorInfos = [msg.push ? await this.dataSource.pushBranch(msg.repo, msg.sourceBranch, msg.sourceRemote, true, GitPushBranchMode.Normal) : null];
				if (errorInfos[0] === null) {
					errorInfos.push(await createPullRequest(msg.config, msg.sourceOwner, msg.sourceRepo, msg.sourceBranch));
				}
				this.sendMessage({
					command: 'createPullRequest',
					push: msg.push,
					errors: errorInfos
				});
				break;
			case 'deleteBranch':
				errorInfos = [await this.dataSource.deleteBranch(msg.repo, msg.branchName, msg.forceDelete)];
				if (errorInfos[0] === null) {
					for (let i = 0; i < msg.deleteOnRemotes.length; i++) {
						errorInfos.push(await this.dataSource.deleteRemoteBranch(msg.repo, msg.branchName, msg.deleteOnRemotes[i]));
					}
				}
				this.sendMessage({
					command: 'deleteBranch',
					repo: msg.repo,
					branchName: msg.branchName,
					deleteOnRemotes: msg.deleteOnRemotes,
					errors: errorInfos
				});
				break;
			case 'deleteRemote':
				this.sendMessage({
					command: 'deleteRemote',
					error: await this.dataSource.deleteRemote(msg.repo, msg.name)
				});
				break;
			case 'deleteRemoteBranch':
				this.sendMessage({
					command: 'deleteRemoteBranch',
					error: await this.dataSource.deleteRemoteBranch(msg.repo, msg.branchName, msg.remote)
				});
				break;
			case 'deleteTag':
				this.sendMessage({
					command: 'deleteTag',
					error: await this.dataSource.deleteTag(msg.repo, msg.tagName, msg.deleteOnRemote)
				});
				break;
			case 'deleteUserDetails':
				errorInfos = [];
				if (msg.name) {
					errorInfos.push(await this.dataSource.unsetConfigValue(msg.repo, GitConfigKey.UserName, msg.location));
				}
				if (msg.email) {
					errorInfos.push(await this.dataSource.unsetConfigValue(msg.repo, GitConfigKey.UserEmail, msg.location));
				}
				this.sendMessage({
					command: 'deleteUserDetails',
					errors: errorInfos
				});
				break;
			case 'dropCommit':
				this.sendMessage({
					command: 'dropCommit',
					error: await this.dataSource.dropCommit(msg.repo, msg.commitHash)
				});
				break;
			case 'dropStash':
				this.sendMessage({
					command: 'dropStash',
					error: await this.dataSource.dropStash(msg.repo, msg.selector)
				});
				break;
			case 'editRemote':
				this.sendMessage({
					command: 'editRemote',
					error: await this.dataSource.editRemote(msg.repo, msg.nameOld, msg.nameNew, msg.urlOld, msg.urlNew, msg.pushUrlOld, msg.pushUrlNew)
				});
				break;
			case 'editUserDetails':
				errorInfos = [
					await this.dataSource.setConfigValue(msg.repo, GitConfigKey.UserName, msg.name, msg.location),
					await this.dataSource.setConfigValue(msg.repo, GitConfigKey.UserEmail, msg.email, msg.location)
				];
				if (errorInfos[0] === null && errorInfos[1] === null) {
					if (msg.deleteLocalName) {
						errorInfos.push(await this.dataSource.unsetConfigValue(msg.repo, GitConfigKey.UserName, GitConfigLocation.Local));
					}
					if (msg.deleteLocalEmail) {
						errorInfos.push(await this.dataSource.unsetConfigValue(msg.repo, GitConfigKey.UserEmail, GitConfigLocation.Local));
					}
				}
				this.sendMessage({
					command: 'editUserDetails',
					errors: errorInfos
				});
				break;
			case 'endCodeReview':
				this.extensionState.endCodeReview(msg.repo, msg.id);
				break;
			case 'exportRepoConfig':
				this.sendMessage({
					command: 'exportRepoConfig',
					error: await this.repoManager.exportRepoConfig(msg.repo)
				});
				break;
			case 'fetch':
				this.sendMessage({
					command: 'fetch',
					error: await this.dataSource.fetch(msg.repo, msg.name, msg.prune, msg.pruneTags)
				});
				break;
			case 'fetchAvatar':
				this.avatarManager.fetchAvatarImage(msg.email, msg.repo, msg.remote, msg.commits);
				break;
			case 'fetchIntoLocalBranch':
				this.sendMessage({
					command: 'fetchIntoLocalBranch',
					error: await this.dataSource.fetchIntoLocalBranch(msg.repo, msg.remote, msg.remoteBranch, msg.localBranch, msg.force)
				});
				break;
			case 'loadCommits':
				this.loadCommitsRefreshId = msg.refreshId;
				this.sendMessage({
					command: 'loadCommits',
					refreshId: msg.refreshId,
					onlyFollowFirstParent: msg.onlyFollowFirstParent,
					...await this.dataSource.getCommits(msg.repo, msg.branches, msg.maxCommits, msg.showTags, msg.showRemoteBranches, msg.includeCommitsMentionedByReflogs, msg.onlyFollowFirstParent, msg.commitOrdering, msg.remotes, msg.hideRemotes, msg.stashes)
				});
				break;
			case 'loadConfig':
				this.sendMessage({
					command: 'loadConfig',
					repo: msg.repo,
					...await this.dataSource.getConfig(msg.repo, msg.remotes)
				});
				break;
			case 'loadRepoInfo':
				this.loadRepoInfoRefreshId = msg.refreshId;
				let repoInfo = await this.dataSource.getRepoInfo(msg.repo, msg.showRemoteBranches, msg.showStashes, msg.hideRemotes), isRepo = true;
				if (repoInfo.error) {
					// If an error occurred, check to make sure the repo still exists
					isRepo = (await this.dataSource.repoRoot(msg.repo)) !== null;
					if (!isRepo) repoInfo.error = null; // If the error is caused by the repo no longer existing, clear the error message
				}
				this.sendMessage({
					command: 'loadRepoInfo',
					refreshId: msg.refreshId,
					...repoInfo,
					isRepo: isRepo
				});
				if (msg.repo !== this.currentRepo) {
					this.currentRepo = msg.repo;
					this.extensionState.setLastActiveRepo(msg.repo);
					this.repoFileWatcher.start(msg.repo);
				}
				break;
			case 'loadRepos':
				if (!msg.check || !await this.repoManager.checkReposExist()) {
					// If not required to check repos, or no changes were found when checking, respond with repos
					this.respondLoadRepos(this.repoManager.getRepos(), null);
				}
				break;
			case 'merge':
				this.sendMessage({
					command: 'merge',
					actionOn: msg.actionOn,
					error: await this.dataSource.merge(msg.repo, msg.obj, msg.actionOn, msg.createNewCommit, msg.squash, msg.noCommit)
				});
				break;
			case 'openExtensionSettings':
				this.sendMessage({
					command: 'openExtensionSettings',
					error: await openExtensionSettings()
				});
				break;
			case 'openExternalDirDiff':
				this.sendMessage({
					command: 'openExternalDirDiff',
					error: await this.dataSource.openExternalDirDiff(msg.repo, msg.fromHash, msg.toHash, msg.isGui)
				});
				break;
			case 'openExternalUrl':
				this.sendMessage({
					command: 'openExternalUrl',
					error: await openExternalUrl(msg.url)
				});
				break;
			case 'openFile':
				this.sendMessage({
					command: 'openFile',
					error: await openFile(msg.repo, msg.filePath, msg.hash, this.dataSource)
				});
				break;
			case 'openTerminal':
				this.sendMessage({
					command: 'openTerminal',
					error: await this.dataSource.openGitTerminal(msg.repo, null, msg.name)
				});
				break;
			case 'popStash':
				this.sendMessage({
					command: 'popStash',
					error: await this.dataSource.popStash(msg.repo, msg.selector, msg.reinstateIndex)
				});
				break;
			case 'pruneRemote':
				this.sendMessage({
					command: 'pruneRemote',
					error: await this.dataSource.pruneRemote(msg.repo, msg.name)
				});
				break;
			case 'pullBranch':
				this.sendMessage({
					command: 'pullBranch',
					error: await this.dataSource.pullBranch(msg.repo, msg.branchName, msg.remote, msg.createNewCommit, msg.squash)
				});
				break;
			case 'pushBranch':
				this.sendMessage({
					command: 'pushBranch',
					willUpdateBranchConfig: msg.willUpdateBranchConfig,
					errors: await this.dataSource.pushBranchToMultipleRemotes(msg.repo, msg.branchName, msg.remotes, msg.setUpstream, msg.mode)
				});
				break;
			case 'pushStash':
				this.sendMessage({
					command: 'pushStash',
					error: await this.dataSource.pushStash(msg.repo, msg.message, msg.includeUntracked)
				});
				break;
			case 'pushTag':
				this.sendMessage({
					command: 'pushTag',
					repo: msg.repo,
					tagName: msg.tagName,
					remotes: msg.remotes,
					commitHash: msg.commitHash,
					errors: await this.dataSource.pushTag(msg.repo, msg.tagName, msg.remotes, msg.commitHash, msg.skipRemoteCheck)
				});
				break;
			case 'rebase':
				this.sendMessage({
					command: 'rebase',
					actionOn: msg.actionOn,
					interactive: msg.interactive,
					error: await this.dataSource.rebase(msg.repo, msg.obj, msg.actionOn, msg.ignoreDate, msg.interactive)
				});
				break;
			case 'renameBranch':
				this.sendMessage({
					command: 'renameBranch',
					error: await this.dataSource.renameBranch(msg.repo, msg.oldName, msg.newName)
				});
				break;
			case 'rescanForRepos':
				if (!(await this.repoManager.searchWorkspaceForRepos())) {
					showErrorMessage('No Git repositories were found in the current workspace.');
				}
				break;
			case 'resetFileToRevision':
				this.sendMessage({
					command: 'resetFileToRevision',
					error: await this.dataSource.resetFileToRevision(msg.repo, msg.commitHash, msg.filePath)
				});
				break;
			case 'resetToCommit':
				this.sendMessage({
					command: 'resetToCommit',
					error: await this.dataSource.resetToCommit(msg.repo, msg.commit, msg.resetMode)
				});
				break;
			case 'revertCommit':
				this.sendMessage({
					command: 'revertCommit',
					error: await this.dataSource.revertCommit(msg.repo, msg.commitHash, msg.parentIndex)
				});
				break;
			case 'setGlobalViewState':
				this.sendMessage({
					command: 'setGlobalViewState',
					error: await this.extensionState.setGlobalViewState(msg.state)
				});
				break;
			case 'setRepoState':
				this.repoManager.setRepoState(msg.repo, msg.state);
				break;
			case 'setWorkspaceViewState':
				this.sendMessage({
					command: 'setWorkspaceViewState',
					error: await this.extensionState.setWorkspaceViewState(msg.state)
				});
				break;
			case 'showErrorMessage':
				showErrorMessage(msg.message);
				break;
			case 'startCodeReview':
				this.sendMessage({
					command: 'startCodeReview',
					commitHash: msg.commitHash,
					compareWithHash: msg.compareWithHash,
					...await this.extensionState.startCodeReview(msg.repo, msg.id, msg.files, msg.lastViewedFile)
				});
				break;
			case 'tagDetails':
				this.sendMessage({
					command: 'tagDetails',
					tagName: msg.tagName,
					commitHash: msg.commitHash,
					...await this.dataSource.getTagDetails(msg.repo, msg.tagName)
				});
				break;
			case 'updateCodeReview':
				this.sendMessage({
					command: 'updateCodeReview',
					error: await this.extensionState.updateCodeReview(msg.repo, msg.id, msg.remainingFiles, msg.lastViewedFile)
				});
				break;
			case 'viewDiff':
				this.sendMessage({
					command: 'viewDiff',
					error: await viewDiff(msg.repo, msg.fromHash, msg.toHash, msg.oldFilePath, msg.newFilePath, msg.type)
				});
				break;
			case 'viewDiffWithWorkingFile':
				this.sendMessage({
					command: 'viewDiffWithWorkingFile',
					error: await viewDiffWithWorkingFile(msg.repo, msg.hash, msg.filePath, this.dataSource)
				});
				break;
			case 'viewFileAtRevision':
				this.sendMessage({
					command: 'viewFileAtRevision',
					error: await viewFileAtRevision(msg.repo, msg.hash, msg.filePath)
				});
				break;
			case 'viewScm':
				this.sendMessage({
					command: 'viewScm',
					error: await viewScm()
				});
				break;
		}

		this.repoFileWatcher.unmute();
	}

	/**
	 * Send a message to the front-end.
	 * @param msg The message to be sent.
	 */
	private sendMessage(msg: ResponseMessage) {
		if (this.isDisposed()) {
			this.logger.log('The Git Graph View has already been disposed, ignored sending "' + msg.command + '" message.');
		} else {
			this.panel.webview.postMessage(msg).then(
				() => { },
				() => {
					if (this.isDisposed()) {
						this.logger.log('The Git Graph View was disposed while sending "' + msg.command + '" message.');
					} else {
						this.logger.logError('Unable to send "' + msg.command + '" message to the Git Graph View.');
					}
				}
			);
		}
	}

	/**
	 * Update the HTML document loaded in the Webview.
	 */
	private update() {
		this.panel.webview.html = this.getHtmlForWebview();
	}

	/**
	 * Get the HTML document to be loaded in the Webview.
	 * @returns The HTML.
	 */
	private getHtmlForWebview() {
		const config = getConfig(), nonce = getNonce();
		const initialState: GitGraphViewInitialState = {
			config: {
				commitDetailsView: config.commitDetailsView,
				commitOrdering: config.commitOrder,
				contextMenuActionsVisibility: config.contextMenuActionsVisibility,
				customBranchGlobPatterns: config.customBranchGlobPatterns,
				customEmojiShortcodeMappings: config.customEmojiShortcodeMappings,
				customPullRequestProviders: config.customPullRequestProviders,
				dateFormat: config.dateFormat,
				defaultColumnVisibility: config.defaultColumnVisibility,
				dialogDefaults: config.dialogDefaults,
				enhancedAccessibility: config.enhancedAccessibility,
				fetchAndPrune: config.fetchAndPrune,
				fetchAndPruneTags: config.fetchAndPruneTags,
				fetchAvatars: config.fetchAvatars && this.extensionState.isAvatarStorageAvailable(),
				graph: config.graph,
				includeCommitsMentionedByReflogs: config.includeCommitsMentionedByReflogs,
				initialLoadCommits: config.initialLoadCommits,
				keybindings: config.keybindings,
				loadMoreCommits: config.loadMoreCommits,
				loadMoreCommitsAutomatically: config.loadMoreCommitsAutomatically,
				markdown: config.markdown,
				mute: config.muteCommits,
				onlyFollowFirstParent: config.onlyFollowFirstParent,
				onRepoLoad: config.onRepoLoad,
				referenceLabels: config.referenceLabels,
				repoDropdownOrder: config.repoDropdownOrder,
				showRemoteBranches: config.showRemoteBranches,
				showStashes: config.showStashes,
				showTags: config.showTags
			},
			lastActiveRepo: this.extensionState.getLastActiveRepo(),
			loadViewTo: this.loadViewTo,
			repos: this.repoManager.getRepos(),
			loadRepoInfoRefreshId: this.loadRepoInfoRefreshId,
			loadCommitsRefreshId: this.loadCommitsRefreshId
		};
		const globalState = this.extensionState.getGlobalViewState();
		const workspaceState = this.extensionState.getWorkspaceViewState();

		let body, numRepos = Object.keys(initialState.repos).length, colorVars = '', colorParams = '';
		for (let i = 0; i < initialState.config.graph.colours.length; i++) {
			colorVars += '--git-graph-color' + i + ':' + initialState.config.graph.colours[i] + '; ';
			colorParams += '[data-color="' + i + '"]{--git-graph-color:var(--git-graph-color' + i + ');} ';
		}

		if (this.dataSource.isGitExecutableUnknown()) {
			body = `<body class="unableToLoad">
			<h2>Unable to load Git Graph</h2>
			<p class="unableToLoadMessage">${UNABLE_TO_FIND_GIT_MSG}</p>
			</body>`;
		} else if (numRepos > 0) {
			body = `<body>
			<div id="view" tabindex="-1">
				<div id="controls">
					<span id="repoControl"><span class="unselectable">Repo: </span><div id="repoDropdown" class="dropdown"></div></span>
					<span id="branchControl"><span class="unselectable">Branches: </span><div id="branchDropdown" class="dropdown"></div></span>
					<label id="showRemoteBranchesControl"><input type="checkbox" id="showRemoteBranchesCheckbox" tabindex="-1"><span class="customCheckbox"></span>Show Remote Branches</label>
					<div id="findBtn" title="Find"></div>
					<div id="terminalBtn" title="Open a Terminal for this Repository"></div>
					<div id="settingsBtn" title="Repository Settings"></div>
					<div id="fetchBtn"></div>
					<div id="refreshBtn"></div>
				</div>
				<div id="content">
					<div id="commitGraph"></div>
					<div id="commitTable"></div>
				</div>
				<div id="footer"></div>
			</div>
			<div id="scrollShadow"></div>
			<script nonce="${nonce}">var initialState = ${JSON.stringify(initialState)}, globalState = ${JSON.stringify(globalState)}, workspaceState = ${JSON.stringify(workspaceState)};</script>
			<script nonce="${nonce}" src="${this.getMediaUri('out.min.js')}"></script>
			</body>`;
		} else {
			body = `<body class="unableToLoad">
			<h2>Unable to load Git Graph</h2>
			<p class="unableToLoadMessage">No Git repositories were found in the current workspace when it was last scanned by Git Graph.</p>
			<p>If your repositories are in subfolders of the open workspace folder(s), make sure you have set the Git Graph Setting "git-graph.maxDepthOfRepoSearch" appropriately (read the <a href="https://github.com/mhutchie/vscode-git-graph/wiki/Extension-Settings#max-depth-of-repo-search" target="_blank">documentation</a> for more information).</p>
			<p><div id="rescanForReposBtn" class="roundedBtn">Re-scan the current workspace for repositories</div></p>
			<script nonce="${nonce}">(function(){ var api = acquireVsCodeApi(); document.getElementById('rescanForReposBtn').addEventListener('click', function(){ api.postMessage({command: 'rescanForRepos'}); }); })();</script>
			</body>`;
		}
		this.isGraphViewLoaded = numRepos > 0;
		this.loadViewTo = null;

		return `<!DOCTYPE html>
		<html lang="en">
			<head>
				<meta charset="UTF-8">
				<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${standardiseCspSource(this.panel.webview.cspSource)} 'unsafe-inline'; script-src 'nonce-${nonce}'; img-src data:;">
				<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<link rel="stylesheet" type="text/css" href="${this.getMediaUri('out.min.css')}">
				<title>Git Graph</title>
				<style>body{${colorVars}} ${colorParams}</style>
			</head>
			${body}
		</html>`;
	}


	/* URI Manipulation Methods */

	/**
	 * Get a WebviewUri for a media file included in the extension.
	 * @param file The file name in the `media` directory.
	 * @returns The WebviewUri.
	 */
	private getMediaUri(file: string) {
		return this.panel.webview.asWebviewUri(this.getUri('media', file));
	}

	/**
	 * Get a File Uri for a resource file included in the extension.
	 * @param file The file name in the `resource` directory.
	 * @returns The Uri.
	 */
	private getResourcesUri(file: string) {
		return this.getUri('resources', file);
	}

	/**
	 * Get a File Uri for a file included in the extension.
	 * @param pathComps The path components relative to the root directory of the extension.
	 * @returns The File Uri.
	 */
	private getUri(...pathComps: string[]) {
		return vscode.Uri.file(path.join(this.extensionPath, ...pathComps));
	}


	/* Response Construction Methods */

	/**
	 * Send the known repositories to the front-end.
	 * @param repos The set of known repositories.
	 * @param loadViewTo What to load the view to.
	 */
	private respondLoadRepos(repos: GitRepoSet, loadViewTo: LoadGitGraphViewTo) {
		this.sendMessage({
			command: 'loadRepos',
			repos: repos,
			lastActiveRepo: this.extensionState.getLastActiveRepo(),
			loadViewTo: loadViewTo
		});
	}
}

/**
 * Standardise the CSP Source provided by Visual Studio Code for use with the Webview. It is idempotent unless called with http/https URI's, in which case it keeps only the authority portion of the http/https URI. This is necessary to be compatible with some web browser environments.
 * @param cspSource The value provide by Visual Studio Code.
 * @returns The standardised CSP Source.
 */
export function standardiseCspSource(cspSource: string) {
	if (cspSource.startsWith('http://') || cspSource.startsWith('https://')) {
		const pathIndex = cspSource.indexOf('/', 8), queryIndex = cspSource.indexOf('?', 8), fragmentIndex = cspSource.indexOf('#', 8);
		let endOfAuthorityIndex = pathIndex;
		if (queryIndex > -1 && (queryIndex < endOfAuthorityIndex || endOfAuthorityIndex === -1)) endOfAuthorityIndex = queryIndex;
		if (fragmentIndex > -1 && (fragmentIndex < endOfAuthorityIndex || endOfAuthorityIndex === -1)) endOfAuthorityIndex = fragmentIndex;
		return endOfAuthorityIndex > -1 ? cspSource.substring(0, endOfAuthorityIndex) : cspSource;
	} else {
		return cspSource;
	}
}
-e 

================================================================================
// FILE: ./src/extensionState.ts
================================================================================
import * as fs from 'fs';
import * as vscode from 'vscode';
import { Avatar, AvatarCache } from './avatarManager';
import { getConfig } from './config';
import { BooleanOverride, CodeReview, ErrorInfo, FileViewType, GitGraphViewGlobalState, GitGraphViewWorkspaceState, GitRepoSet, GitRepoState, RepoCommitOrdering } from './types';
import { GitExecutable, getPathFromStr } from './utils';
import { Disposable } from './utils/disposable';
import { Event } from './utils/event';

const AVATAR_STORAGE_FOLDER = '/avatars';
const AVATAR_CACHE = 'avatarCache';
const CODE_REVIEWS = 'codeReviews';
const GLOBAL_VIEW_STATE = 'globalViewState';
const IGNORED_REPOS = 'ignoredRepos';
const LAST_ACTIVE_REPO = 'lastActiveRepo';
const LAST_KNOWN_GIT_PATH = 'lastKnownGitPath';
const REPO_STATES = 'repoStates';
const WORKSPACE_VIEW_STATE = 'workspaceViewState';

export const DEFAULT_REPO_STATE: GitRepoState = {
	cdvDivider: 0.5,
	cdvHeight: 250,
	columnWidths: null,
	commitOrdering: RepoCommitOrdering.Default,
	fileViewType: FileViewType.Default,
	hideRemotes: [],
	includeCommitsMentionedByReflogs: BooleanOverride.Default,
	issueLinkingConfig: null,
	lastImportAt: 0,
	name: null,
	onlyFollowFirstParent: BooleanOverride.Default,
	onRepoLoadShowCheckedOutBranch: BooleanOverride.Default,
	onRepoLoadShowSpecificBranches: null,
	pullRequestConfig: null,
	showRemoteBranches: true,
	showRemoteBranchesV2: BooleanOverride.Default,
	showStashes: BooleanOverride.Default,
	showTags: BooleanOverride.Default,
	workspaceFolderIndex: null
};

const DEFAULT_GIT_GRAPH_VIEW_GLOBAL_STATE: GitGraphViewGlobalState = {
	alwaysAcceptCheckoutCommit: false,
	issueLinkingConfig: null,
	pushTagSkipRemoteCheck: false
};

const DEFAULT_GIT_GRAPH_VIEW_WORKSPACE_STATE: GitGraphViewWorkspaceState = {
	findIsCaseSensitive: false,
	findIsRegex: false,
	findOpenCommitDetailsView: false
};

export interface CodeReviewData {
	lastActive: number;
	lastViewedFile: string | null;
	remainingFiles: string[];
}
export type CodeReviews = { [repo: string]: { [id: string]: CodeReviewData } };

/**
 * Manages the Git Graph Extension State, which stores data in both the Visual Studio Code Global & Workspace State.
 */
export class ExtensionState extends Disposable {
	private readonly globalState: vscode.Memento;
	private readonly workspaceState: vscode.Memento;
	private readonly globalStoragePath: string;
	private avatarStorageAvailable: boolean = false;

	/**
	 * Creates the Git Graph Extension State.
	 * @param context The context of the extension.
	 * @param onDidChangeGitExecutable The Event emitting the Git executable for Git Graph to use.
	 */
	constructor(context: vscode.ExtensionContext, onDidChangeGitExecutable: Event<GitExecutable>) {
		super();
		this.globalState = context.globalState;
		this.workspaceState = context.workspaceState;

		this.globalStoragePath = getPathFromStr(context.globalStoragePath);
		fs.stat(this.globalStoragePath + AVATAR_STORAGE_FOLDER, (err) => {
			if (!err) {
				this.avatarStorageAvailable = true;
			} else {
				fs.mkdir(this.globalStoragePath, () => {
					fs.mkdir(this.globalStoragePath + AVATAR_STORAGE_FOLDER, (err) => {
						if (!err || err.code === 'EEXIST') {
							// The directory was created, or it already exists
							this.avatarStorageAvailable = true;
						}
					});
				});
			}
		});

		this.registerDisposable(
			onDidChangeGitExecutable((gitExecutable) => {
				this.setLastKnownGitPath(gitExecutable.path);
			})
		);
	}


	/* Known Repositories */

	/**
	 * Get the known repositories in the current workspace.
	 * @returns The set of repositories.
	 */
	public getRepos() {
		const repoSet = this.workspaceState.get<GitRepoSet>(REPO_STATES, {});
		const outputSet: GitRepoSet = {};
		let showRemoteBranchesDefaultValue: boolean | null = null;
		Object.keys(repoSet).forEach((repo) => {
			outputSet[repo] = Object.assign({}, DEFAULT_REPO_STATE, repoSet[repo]);
			if (typeof repoSet[repo].showRemoteBranchesV2 === 'undefined' && typeof repoSet[repo].showRemoteBranches !== 'undefined') {
				if (showRemoteBranchesDefaultValue === null) {
					showRemoteBranchesDefaultValue = getConfig().showRemoteBranches;
				}
				if (repoSet[repo].showRemoteBranches !== showRemoteBranchesDefaultValue) {
					outputSet[repo].showRemoteBranchesV2 = repoSet[repo].showRemoteBranches ? BooleanOverride.Enabled : BooleanOverride.Disabled;
				}
			}
		});
		return outputSet;
	}

	/**
	 * Set the known repositories in the current workspace.
	 * @param gitRepoSet The set of repositories.
	 */
	public saveRepos(gitRepoSet: GitRepoSet) {
		this.updateWorkspaceState(REPO_STATES, gitRepoSet);
	}

	/**
	 * Transfer state references from one known repository to another.
	 * @param oldRepo The repository to transfer state from.
	 * @param newRepo The repository to transfer state to.
	 */
	public transferRepo(oldRepo: string, newRepo: string) {
		if (this.getLastActiveRepo() === oldRepo) {
			this.setLastActiveRepo(newRepo);
		}

		let reviews = this.getCodeReviews();
		if (typeof reviews[oldRepo] !== 'undefined') {
			reviews[newRepo] = reviews[oldRepo];
			delete reviews[oldRepo];
			this.setCodeReviews(reviews);
		}
	}


	/* Global View State */

	/**
	 * Get the global state of the Git Graph View.
	 * @returns The global state.
	 */
	public getGlobalViewState() {
		const globalViewState = this.globalState.get<GitGraphViewGlobalState>(GLOBAL_VIEW_STATE, DEFAULT_GIT_GRAPH_VIEW_GLOBAL_STATE);
		return Object.assign({}, DEFAULT_GIT_GRAPH_VIEW_GLOBAL_STATE, globalViewState);
	}

	/**
	 * Set the global state of the Git Graph View.
	 * @param state The global state.
	 */
	public setGlobalViewState(state: GitGraphViewGlobalState) {
		return this.updateGlobalState(GLOBAL_VIEW_STATE, state);
	}


	/* Workspace View State */

	/**
	 * Get the workspace state of the Git Graph View.
	 * @returns The workspace state.
	 */
	public getWorkspaceViewState() {
		const workspaceViewState = this.workspaceState.get<GitGraphViewWorkspaceState>(WORKSPACE_VIEW_STATE, DEFAULT_GIT_GRAPH_VIEW_WORKSPACE_STATE);
		return Object.assign({}, DEFAULT_GIT_GRAPH_VIEW_WORKSPACE_STATE, workspaceViewState);
	}

	/**
	 * Set the workspace state of the Git Graph View.
	 * @param state The workspace state.
	 */
	public setWorkspaceViewState(state: GitGraphViewWorkspaceState) {
		return this.updateWorkspaceState(WORKSPACE_VIEW_STATE, state);
	}


	/* Ignored Repos */

	/**
	 * Get the ignored repositories in the current workspace.
	 * @returns An array of the paths of ignored repositories.
	 */
	public getIgnoredRepos() {
		return this.workspaceState.get<string[]>(IGNORED_REPOS, []);
	}

	/**
	 * Set the ignored repositories in the current workspace.
	 * @param ignoredRepos An array of the paths of ignored repositories.
	 */
	public setIgnoredRepos(ignoredRepos: string[]) {
		return this.updateWorkspaceState(IGNORED_REPOS, ignoredRepos);
	}


	/* Last Active Repo */

	/**
	 * Get the last active repository in the current workspace.
	 * @returns The path of the last active repository.
	 */
	public getLastActiveRepo() {
		return this.workspaceState.get<string | null>(LAST_ACTIVE_REPO, null);
	}

	/**
	 * Set the last active repository in the current workspace.
	 * @param repo The path of the last active repository.
	 */
	public setLastActiveRepo(repo: string | null) {
		this.updateWorkspaceState(LAST_ACTIVE_REPO, repo);
	}


	/* Last Known Git Path */

	/**
	 * Get the last known path of the Git executable used by Git Graph.
	 * @returns The path of the Git executable.
	 */
	public getLastKnownGitPath() {
		return this.globalState.get<string | null>(LAST_KNOWN_GIT_PATH, null);
	}

	/**
	 * Set the last known path of the Git executable used by Git Graph.
	 * @param path The path of the Git executable.
	 */
	private setLastKnownGitPath(path: string) {
		this.updateGlobalState(LAST_KNOWN_GIT_PATH, path);
	}


	/* Avatars */

	/**
	 * Checks whether the Avatar Storage Folder is available to store avatars.
	 * @returns TRUE => Avatar Storage Folder is available, FALSE => Avatar Storage Folder isn't available.
	 */
	public isAvatarStorageAvailable() {
		return this.avatarStorageAvailable;
	}

	/**
	 * Gets the path that is used to store avatars globally in Git Graph.
	 * @returns The folder path.
	 */
	public getAvatarStoragePath() {
		return this.globalStoragePath + AVATAR_STORAGE_FOLDER;
	}

	/**
	 * Gets the cache of avatars known to Git Graph.
	 * @returns The avatar cache.
	 */
	public getAvatarCache() {
		return this.globalState.get<AvatarCache>(AVATAR_CACHE, {});
	}

	/**
	 * Add a new avatar to the cache of avatars known to Git Graph.
	 * @param email The email address that the avatar is for.
	 * @param avatar The details of the avatar.
	 */
	public saveAvatar(email: string, avatar: Avatar) {
		let avatars = this.getAvatarCache();
		avatars[email] = avatar;
		this.updateGlobalState(AVATAR_CACHE, avatars);
	}

	/**
	 * Removes an avatar from the cache of avatars known to Git Graph.
	 * @param email The email address of the avatar to remove.
	 */
	public removeAvatarFromCache(email: string) {
		let avatars = this.getAvatarCache();
		delete avatars[email];
		this.updateGlobalState(AVATAR_CACHE, avatars);
	}

	/**
	 * Clear all avatars from the cache of avatars known to Git Graph.
	 * @returns A Thenable resolving to the ErrorInfo that resulted from executing this method.
	 */
	public clearAvatarCache() {
		return this.updateGlobalState(AVATAR_CACHE, {}).then((errorInfo) => {
			if (errorInfo === null) {
				fs.readdir(this.globalStoragePath + AVATAR_STORAGE_FOLDER, (err, files) => {
					if (err) return;
					for (let i = 0; i < files.length; i++) {
						fs.unlink(this.globalStoragePath + AVATAR_STORAGE_FOLDER + '/' + files[i], () => { });
					}
				});
			}
			return errorInfo;
		});
	}


	/* Code Review */

	// Note: id => the commit arguments to 'git diff' (either <commit hash> or <commit hash>-<commit hash>)

	/**
	 * Start a new Code Review.
	 * @param repo The repository the Code Review is in.
	 * @param id The ID of the Code Review.
	 * @param files An array of files that must be reviewed.
	 * @param lastViewedFile The last file the user reviewed before starting the Code Review.
	 * @returns The Code Review that was started.
	 */
	public startCodeReview(repo: string, id: string, files: string[], lastViewedFile: string | null) {
		let reviews = this.getCodeReviews();
		if (typeof reviews[repo] === 'undefined') reviews[repo] = {};
		reviews[repo][id] = { lastActive: (new Date()).getTime(), lastViewedFile: lastViewedFile, remainingFiles: files };
		return this.setCodeReviews(reviews).then((err) => ({
			codeReview: <CodeReview>Object.assign({ id: id }, reviews[repo][id]),
			error: err
		}));
	}

	/**
	 * End an existing Code Review.
	 * @param repo The repository the Code Review is in.
	 * @param id The ID of the Code Review.
	 */
	public endCodeReview(repo: string, id: string) {
		let reviews = this.getCodeReviews();
		removeCodeReview(reviews, repo, id);
		return this.setCodeReviews(reviews);
	}

	/**
	 * Get an existing Code Review.
	 * @param repo The repository the Code Review is in.
	 * @param id The ID of the Code Review.
	 * @returns The Code Review.
	 */
	public getCodeReview(repo: string, id: string) {
		let reviews = this.getCodeReviews();
		if (typeof reviews[repo] !== 'undefined' && typeof reviews[repo][id] !== 'undefined') {
			reviews[repo][id].lastActive = (new Date()).getTime();
			this.setCodeReviews(reviews);
			return <CodeReview>Object.assign({ id: id }, reviews[repo][id]);
		} else {
			return null;
		}
	}

	/**
	 * Update information for a specific Code Review.
	 * @param repo The repository the Code Review is in.
	 * @param id The ID of the Code Review.
	 * @param remainingFiles The files remaining for review.
	 * @param lastViewedFile The last viewed file. If null, don't change the last viewed file.
	 * @returns An error message if request can't be completed.
	 */
	public updateCodeReview(repo: string, id: string, remainingFiles: string[], lastViewedFile: string | null) {
		const reviews = this.getCodeReviews();

		if (typeof reviews[repo] === 'undefined' || typeof reviews[repo][id] === 'undefined') {
			return Promise.resolve('The Code Review could not be found.');
		}

		if (remainingFiles.length > 0) {
			reviews[repo][id].remainingFiles = remainingFiles;
			reviews[repo][id].lastActive = (new Date()).getTime();
			if (lastViewedFile !== null) {
				reviews[repo][id].lastViewedFile = lastViewedFile;
			}
		} else {
			removeCodeReview(reviews, repo, id);
		}

		return this.setCodeReviews(reviews);
	}

	/**
	 * Delete any Code Reviews that haven't been active during the last 90 days.
	 */
	public expireOldCodeReviews() {
		let reviews = this.getCodeReviews(), change = false, expireReviewsBefore = (new Date()).getTime() - 7776000000; // 90 days x 24 hours x 60 minutes x 60 seconds x 1000 milliseconds
		Object.keys(reviews).forEach((repo) => {
			Object.keys(reviews[repo]).forEach((id) => {
				if (reviews[repo][id].lastActive < expireReviewsBefore) {
					delete reviews[repo][id];
					change = true;
				}
			});
			removeCodeReviewRepoIfEmpty(reviews, repo);
		});
		if (change) this.setCodeReviews(reviews);
	}

	/**
	 * End all Code Reviews in the current workspace.
	 */
	public endAllWorkspaceCodeReviews() {
		this.setCodeReviews({});
	}

	/**
	 * Get all Code Reviews in the current workspace.
	 * @returns The set of Code Reviews.
	 */
	public getCodeReviews() {
		return this.workspaceState.get<CodeReviews>(CODE_REVIEWS, {});
	}

	/**
	 * Set the Code Reviews in the current workspace.
	 * @param reviews The set of Code Reviews.
	 */
	private setCodeReviews(reviews: CodeReviews) {
		return this.updateWorkspaceState(CODE_REVIEWS, reviews);
	}


	/* Update State Memento's */

	/**
	 * Update the Git Graph Global State with a new <key, value> pair.
	 * @param key The key.
	 * @param value The value.
	 * @returns A Thenable resolving to the ErrorInfo that resulted from updating the Global State.
	 */
	private updateGlobalState(key: string, value: any): Thenable<ErrorInfo> {
		return this.globalState.update(key, value).then(
			() => null,
			() => 'Visual Studio Code was unable to save the Git Graph Global State Memento.'
		);
	}

	/**
	 * Update the Git Graph Workspace State with a new <key, value> pair.
	 * @param key The key.
	 * @param value The value.
	 * @returns A Thenable resolving to the ErrorInfo that resulted from updating the Workspace State.
	 */
	private updateWorkspaceState(key: string, value: any): Thenable<ErrorInfo> {
		return this.workspaceState.update(key, value).then(
			() => null,
			() => 'Visual Studio Code was unable to save the Git Graph Workspace State Memento.'
		);
	}
}


/* Helper Methods */

/**
 * Remove a Code Review from a set of Code Reviews.
 * @param reviews The set of Code Reviews.
 * @param repo The repository the Code Review is in.
 * @param id The ID of the Code Review.
 */
function removeCodeReview(reviews: CodeReviews, repo: string, id: string) {
	if (typeof reviews[repo] !== 'undefined' && typeof reviews[repo][id] !== 'undefined') {
		delete reviews[repo][id];
		removeCodeReviewRepoIfEmpty(reviews, repo);
	}
}

/**
 * Remove a repository from a set of Code Reviews if the repository doesn't contain any Code Reviews.
 * @param reviews The set of Code Reviews.
 * @param repo The repository to perform this action on.
 */
function removeCodeReviewRepoIfEmpty(reviews: CodeReviews, repo: string) {
	if (typeof reviews[repo] !== 'undefined' && Object.keys(reviews[repo]).length === 0) {
		delete reviews[repo];
	}
}
-e 

================================================================================
// FILE: ./src/extension.ts
================================================================================
import * as vscode from 'vscode';
import { AvatarManager } from './avatarManager';
import { CommandManager } from './commands';
import { getConfig } from './config';
import { DataSource } from './dataSource';
import { DiffDocProvider } from './diffDocProvider';
import { ExtensionState } from './extensionState';
import { onStartUp } from './life-cycle/startup';
import { Logger } from './logger';
import { RepoManager } from './repoManager';
import { StatusBarItem } from './statusBarItem';
import { GitExecutable, UNABLE_TO_FIND_GIT_MSG, findGit, getGitExecutableFromPaths, showErrorMessage, showInformationMessage } from './utils';
import { EventEmitter } from './utils/event';

/**
 * Activate Git Graph.
 * @param context The context of the extension.
 */
export async function activate(context: vscode.ExtensionContext) {
	const logger = new Logger();
	logger.log('Starting Git Graph ...');

	const gitExecutableEmitter = new EventEmitter<GitExecutable>();
	const onDidChangeGitExecutable = gitExecutableEmitter.subscribe;

	const extensionState = new ExtensionState(context, onDidChangeGitExecutable);

	let gitExecutable: GitExecutable | null;
	try {
		gitExecutable = await findGit(extensionState);
		gitExecutableEmitter.emit(gitExecutable);
		logger.log('Using ' + gitExecutable.path + ' (version: ' + gitExecutable.version + ')');
	} catch (_) {
		gitExecutable = null;
		showErrorMessage(UNABLE_TO_FIND_GIT_MSG);
		logger.logError(UNABLE_TO_FIND_GIT_MSG);
	}

	const configurationEmitter = new EventEmitter<vscode.ConfigurationChangeEvent>();
	const onDidChangeConfiguration = configurationEmitter.subscribe;

	const dataSource = new DataSource(gitExecutable, onDidChangeConfiguration, onDidChangeGitExecutable, logger);
	const avatarManager = new AvatarManager(dataSource, extensionState, logger);
	const repoManager = new RepoManager(dataSource, extensionState, onDidChangeConfiguration, logger);
	const statusBarItem = new StatusBarItem(repoManager.getNumRepos(), repoManager.onDidChangeRepos, onDidChangeConfiguration, logger);
	const commandManager = new CommandManager(context, avatarManager, dataSource, extensionState, repoManager, gitExecutable, onDidChangeGitExecutable, logger);
	const diffDocProvider = new DiffDocProvider(dataSource);

	context.subscriptions.push(
		vscode.workspace.registerTextDocumentContentProvider(DiffDocProvider.scheme, diffDocProvider),
		vscode.workspace.onDidChangeConfiguration((event) => {
			if (event.affectsConfiguration('git-graph')) {
				configurationEmitter.emit(event);
			} else if (event.affectsConfiguration('git.path')) {
				const paths = getConfig().gitPaths;
				if (paths.length === 0) return;

				getGitExecutableFromPaths(paths).then((gitExecutable) => {
					gitExecutableEmitter.emit(gitExecutable);
					const msg = 'Git Graph is now using ' + gitExecutable.path + ' (version: ' + gitExecutable.version + ')';
					showInformationMessage(msg);
					logger.log(msg);
					repoManager.searchWorkspaceForRepos();
				}, () => {
					const msg = 'The new value of "git.path" ("' + paths.join('", "') + '") does not ' + (paths.length > 1 ? 'contain a string that matches' : 'match') + ' the path and filename of a valid Git executable.';
					showErrorMessage(msg);
					logger.logError(msg);
				});
			}
		}),
		diffDocProvider,
		commandManager,
		statusBarItem,
		repoManager,
		avatarManager,
		dataSource,
		configurationEmitter,
		extensionState,
		gitExecutableEmitter,
		logger
	);
	logger.log('Started Git Graph - Ready to use!');

	extensionState.expireOldCodeReviews();
	onStartUp(context).catch(() => { });
}

/**
 * Deactivate Git Graph.
 */
export function deactivate() { }
-e 

================================================================================
// FILE: ./src/diffDocProvider.ts
================================================================================
import * as path from 'path';
import * as vscode from 'vscode';
import { DataSource } from './dataSource';
import { GitFileStatus } from './types';
import { UNCOMMITTED, getPathFromStr, showErrorMessage } from './utils';
import { Disposable, toDisposable } from './utils/disposable';

export const enum DiffSide {
	Old,
	New
}

/**
 * Manages providing a specific revision of a repository file for use in the Visual Studio Code Diff View.
 */
export class DiffDocProvider extends Disposable implements vscode.TextDocumentContentProvider {
	public static scheme = 'git-graph';
	private readonly dataSource: DataSource;
	private readonly docs = new Map<string, DiffDocument>();
	private readonly onDidChangeEventEmitter = new vscode.EventEmitter<vscode.Uri>();

	/**
	 * Creates the Git Graph Diff Document Provider.
	 * @param dataSource The Git Graph DataSource instance.
	 */
	constructor(dataSource: DataSource) {
		super();
		this.dataSource = dataSource;

		this.registerDisposables(
			vscode.workspace.onDidCloseTextDocument((doc) => this.docs.delete(doc.uri.toString())),
			this.onDidChangeEventEmitter,
			toDisposable(() => this.docs.clear())
		);
	}

	/**
	 * An event to signal a resource has changed.
	 */
	get onDidChange() {
		return this.onDidChangeEventEmitter.event;
	}

	/**
	 * Provides the content of a text document at a specific Git revision.
	 * @param uri The `git-graph://file.ext?encoded-data` URI.
	 * @returns The content of the text document.
	 */
	public provideTextDocumentContent(uri: vscode.Uri): string | Thenable<string> {
		const document = this.docs.get(uri.toString());
		if (document) {
			return document.value;
		}

		const request = decodeDiffDocUri(uri);
		if (!request.exists) {
			// Return empty file (used for one side of added / deleted file diff)
			return '';
		}

		return this.dataSource.getCommitFile(request.repo, request.commit, request.filePath).then(
			(contents) => {
				const document = new DiffDocument(contents);
				this.docs.set(uri.toString(), document);
				return document.value;
			},
			(errorMessage) => {
				showErrorMessage('Unable to retrieve file: ' + errorMessage);
				return '';
			}
		);
	}
}

/**
 * Represents the content of a Diff Document.
 */
class DiffDocument {
	private readonly body: string;

	/**
	 * Creates a Diff Document with the specified content.
	 * @param body The content of the document.
	 */
	constructor(body: string) {
		this.body = body;
	}

	/**
	 * Get the content of the Diff Document.
	 */
	get value() {
		return this.body;
	}
}


/* Encoding and decoding URI's */

/**
 * Represents the data passed through `git-graph://file.ext?encoded-data` URI's by the DiffDocProvider.
 */
type DiffDocUriData = {
	filePath: string;
	commit: string;
	repo: string;
	exists: boolean;
};

/**
 * Produce the URI of a file to be used in the Visual Studio Diff View.
 * @param repo The repository the file is within.
 * @param filePath The path of the file.
 * @param commit The commit hash specifying the revision of the file.
 * @param type The Git file status of the change.
 * @param diffSide The side of the Diff View that this URI will be displayed on.
 * @returns A URI of the form `git-graph://file.ext?encoded-data` or `file://path/file.ext`
 */
export function encodeDiffDocUri(repo: string, filePath: string, commit: string, type: GitFileStatus, diffSide: DiffSide): vscode.Uri {
	if (commit === UNCOMMITTED && type !== GitFileStatus.Deleted) {
		return vscode.Uri.file(path.join(repo, filePath));
	}

	const fileDoesNotExist = (diffSide === DiffSide.Old && type === GitFileStatus.Added) || (diffSide === DiffSide.New && type === GitFileStatus.Deleted);
	const data: DiffDocUriData = {
		filePath: getPathFromStr(filePath),
		commit: commit,
		repo: repo,
		exists: !fileDoesNotExist
	};

	let extension: string;
	if (fileDoesNotExist) {
		extension = '';
	} else {
		const extIndex = data.filePath.indexOf('.', data.filePath.lastIndexOf('/') + 1);
		extension = extIndex > -1 ? data.filePath.substring(extIndex) : '';
	}

	return vscode.Uri.file('file' + extension).with({
		scheme: DiffDocProvider.scheme,
		query: Buffer.from(JSON.stringify(data)).toString('base64')
	});
}

/**
 * Decode the data from a `git-graph://file.ext?encoded-data` URI.
 * @param uri The URI to decode data from.
 * @returns The decoded DiffDocUriData.
 */
export function decodeDiffDocUri(uri: vscode.Uri): DiffDocUriData {
	return JSON.parse(Buffer.from(uri.query, 'base64').toString());
}
-e 

================================================================================
// FILE: ./src/repoFileWatcher.ts
================================================================================
import * as vscode from 'vscode';
import { Logger } from './logger';
import { getPathFromUri } from './utils';

const FILE_CHANGE_REGEX = /(^\.git\/(config|index|HEAD|refs\/stash|refs\/heads\/.*|refs\/remotes\/.*|refs\/tags\/.*)$)|(^(?!\.git).*$)|(^\.git[^\/]+$)/;

/**
 * Watches a Git repository for file events.
 */
export class RepoFileWatcher {
	private readonly logger: Logger;
	private readonly repoChangeCallback: () => void;
	private repo: string | null = null;
	private fsWatcher: vscode.FileSystemWatcher | null = null;
	private refreshTimeout: NodeJS.Timer | null = null;
	private muted: boolean = false;
	private resumeAt: number = 0;

	/**
	 * Creates a RepoFileWatcher.
	 * @param logger The Git Graph Logger instance.
	 * @param repoChangeCallback A callback to be invoked when a file event occurs in the repository.
	 */
	constructor(logger: Logger, repoChangeCallback: () => void) {
		this.logger = logger;
		this.repoChangeCallback = repoChangeCallback;
	}

	/**
	 * Start watching a repository for file events.
	 * @param repo The path of the repository to watch.
	 */
	public start(repo: string) {
		if (this.fsWatcher !== null) {
			// If there is an existing File System Watcher, stop it
			this.stop();
		}

		this.repo = repo;
		// Create a File System Watcher for all events within the specified repository
		this.fsWatcher = vscode.workspace.createFileSystemWatcher(repo + '/**');
		this.fsWatcher.onDidCreate(uri => this.refresh(uri));
		this.fsWatcher.onDidChange(uri => this.refresh(uri));
		this.fsWatcher.onDidDelete(uri => this.refresh(uri));
		this.logger.log('Started watching repo: ' + repo);
	}

	/**
	 * Stop watching the repository for file events.
	 */
	public stop() {
		if (this.fsWatcher !== null) {
			// If there is an existing File System Watcher, stop it
			this.fsWatcher.dispose();
			this.fsWatcher = null;
			this.logger.log('Stopped watching repo: ' + this.repo);
		}
		if (this.refreshTimeout !== null) {
			// If a timeout is active, clear it
			clearTimeout(this.refreshTimeout);
			this.refreshTimeout = null;
		}
	}

	/**
	 * Mute file events - Used to prevent many file events from being triggered when a Git action is executed by the Git Graph View.
	 */
	public mute() {
		this.muted = true;
	}

	/**
	 * Unmute file events - Used to resume normal watching after a Git action executed by the Git Graph View has completed.
	 */
	public unmute() {
		this.muted = false;
		this.resumeAt = (new Date()).getTime() + 1500;
	}


	/**
	 * Handle a file event triggered by the File System Watcher.
	 * @param uri The URI of the file that the event occurred on.
	 */
	private refresh(uri: vscode.Uri) {
		if (this.muted) return;
		if (!getPathFromUri(uri).replace(this.repo + '/', '').match(FILE_CHANGE_REGEX)) return;
		if ((new Date()).getTime() < this.resumeAt) return;

		if (this.refreshTimeout !== null) {
			clearTimeout(this.refreshTimeout);
		}
		this.refreshTimeout = setTimeout(() => {
			this.refreshTimeout = null;
			this.repoChangeCallback();
		}, 750);
	}
}
-e 

================================================================================
// FILE: ./src/config.ts
================================================================================
import * as vscode from 'vscode';
import {
	CommitDetailsViewConfig,
	CommitDetailsViewLocation,
	CommitOrdering,
	ContextMenuActionsVisibility,
	CustomBranchGlobPattern,
	CustomEmojiShortcodeMapping,
	CustomPullRequestProvider,
	DateFormat,
	DateFormatType,
	DateType,
	DefaultColumnVisibility,
	DialogDefaults,
	FileViewType,
	GitResetMode,
	GraphConfig,
	GraphStyle,
	GraphUncommittedChangesStyle,
	KeybindingConfig,
	MuteCommitsConfig,
	OnRepoLoadConfig,
	RefLabelAlignment,
	ReferenceLabelsConfig,
	RepoDropdownOrder,
	SquashMessageFormat,
	TabIconColourTheme,
	TagType
} from './types';

const VIEW_COLUMN_MAPPING: { [column: string]: vscode.ViewColumn } = {
	'Active': vscode.ViewColumn.Active,
	'Beside': vscode.ViewColumn.Beside,
	'One': vscode.ViewColumn.One,
	'Two': vscode.ViewColumn.Two,
	'Three': vscode.ViewColumn.Three,
	'Four': vscode.ViewColumn.Four,
	'Five': vscode.ViewColumn.Five,
	'Six': vscode.ViewColumn.Six,
	'Seven': vscode.ViewColumn.Seven,
	'Eight': vscode.ViewColumn.Eight,
	'Nine': vscode.ViewColumn.Nine
};

/**
 * Represents the users configuration of Git Graph Extension Settings.
 */
class Config {
	private readonly config: vscode.WorkspaceConfiguration;

	private static readonly KEYBINDING_REGEXP = /^CTRL\/CMD \+ [A-Z]$/;

	/**
	 * Creates a Config instance.
	 * @param repo An option path of a repository (to be used for Workspace Folder Scoped Configuration Values).
	 * @returns A Config instance.
	 */
	constructor(repo?: string) {
		this.config = vscode.workspace.getConfiguration('git-graph', repo ? vscode.Uri.file(repo) : undefined);
	}

	/**
	 * Get the Commit Details View configuration from the Extension Settings.
	 */
	get commitDetailsView(): CommitDetailsViewConfig {
		return {
			autoCenter: !!this.getRenamedExtensionSetting('commitDetailsView.autoCenter', 'autoCenterCommitDetailsView', true),
			fileTreeCompactFolders: !!this.getRenamedExtensionSetting('commitDetailsView.fileView.fileTree.compactFolders', 'commitDetailsViewFileTreeCompactFolders', true),
			fileViewType: this.getRenamedExtensionSetting<string>('commitDetailsView.fileView.type', 'defaultFileViewType', 'File Tree') === 'File List'
				? FileViewType.List
				: FileViewType.Tree,
			location: this.getRenamedExtensionSetting<string>('commitDetailsView.location', 'commitDetailsViewLocation', 'Inline') === 'Docked to Bottom'
				? CommitDetailsViewLocation.DockedToBottom
				: CommitDetailsViewLocation.Inline
		};
	}

	/**
	 * Get the value of the `git-graph.contextMenuActionsVisibility` Extension Setting.
	 */
	get contextMenuActionsVisibility(): ContextMenuActionsVisibility {
		const userConfig = this.config.get('contextMenuActionsVisibility', {});
		const config: ContextMenuActionsVisibility = {
			branch: { checkout: true, rename: true, delete: true, merge: true, rebase: true, push: true, viewIssue: true, createPullRequest: true, createArchive: true, selectInBranchesDropdown: true, unselectInBranchesDropdown: true, copyName: true },
			commit: { addTag: true, createBranch: true, checkout: true, cherrypick: true, revert: true, drop: true, merge: true, rebase: true, reset: true, copyHash: true, copySubject: true },
			commitDetailsViewFile: { viewDiff: true, viewFileAtThisRevision: true, viewDiffWithWorkingFile: true, openFile: true, markAsReviewed: true, markAsNotReviewed: true, resetFileToThisRevision: true, copyAbsoluteFilePath: true, copyRelativeFilePath: true },
			remoteBranch: { checkout: true, delete: true, fetch: true, merge: true, pull: true, viewIssue: true, createPullRequest: true, createArchive: true, selectInBranchesDropdown: true, unselectInBranchesDropdown: true, copyName: true },
			stash: { apply: true, createBranch: true, pop: true, drop: true, copyName: true, copyHash: true },
			tag: { viewDetails: true, delete: true, push: true, createArchive: true, copyName: true },
			uncommittedChanges: { stash: true, reset: true, clean: true, openSourceControlView: true }
		};
		mergeConfigObjects(config, userConfig);
		return config;
	}

	/**
	 * Get the value of the `git-graph.customBranchGlobPatterns` Extension Setting.
	 */
	get customBranchGlobPatterns(): CustomBranchGlobPattern[] {
		let inPatterns = this.config.get('customBranchGlobPatterns', <any[]>[]);
		let outPatterns: CustomBranchGlobPattern[] = [];
		for (let i = 0; i < inPatterns.length; i++) {
			if (typeof inPatterns[i].name === 'string' && typeof inPatterns[i].glob === 'string') {
				outPatterns.push({ name: inPatterns[i].name, glob: '--glob=' + inPatterns[i].glob });
			}
		}
		return outPatterns;
	}

	/**
	 * Get the value of the `git-graph.customEmojiShortcodeMappings` Extension Setting.
	 */
	get customEmojiShortcodeMappings(): CustomEmojiShortcodeMapping[] {
		let inMappings = this.config.get('customEmojiShortcodeMappings', <any[]>[]);
		let outMappings: CustomEmojiShortcodeMapping[] = [];
		for (let i = 0; i < inMappings.length; i++) {
			if (typeof inMappings[i].shortcode === 'string' && typeof inMappings[i].emoji === 'string') {
				outMappings.push({ shortcode: inMappings[i].shortcode, emoji: inMappings[i].emoji });
			}
		}
		return outMappings;
	}

	/**
	 * Get the value of the `git-graph.customPullRequestProviders` Extension Setting.
	 */
	get customPullRequestProviders(): CustomPullRequestProvider[] {
		let providers = this.config.get('customPullRequestProviders', <any[]>[]);
		return Array.isArray(providers)
			? providers
				.filter((provider) => typeof provider.name === 'string' && typeof provider.templateUrl === 'string')
				.map((provider) => ({ name: provider.name, templateUrl: provider.templateUrl }))
			: [];
	}

	/**
	 * Get the value of the `git-graph.date.format` Extension Setting.
	 */
	get dateFormat(): DateFormat {
		let configValue = this.getRenamedExtensionSetting<string>('date.format', 'dateFormat', 'Date & Time'), type = DateFormatType.DateAndTime, iso = false;
		if (configValue === 'Relative') {
			type = DateFormatType.Relative;
		} else {
			if (configValue.endsWith('Date Only')) type = DateFormatType.DateOnly;
			if (configValue.startsWith('ISO')) iso = true;
		}
		return { type: type, iso: iso };
	}

	/**
	 * Get the value of the `git-graph.date.type` Extension Setting.
	 */
	get dateType() {
		return this.getRenamedExtensionSetting<string>('date.type', 'dateType', 'Author Date') === 'Commit Date'
			? DateType.Commit
			: DateType.Author;
	}

	/**
	 * Get the value of the `git-graph.defaultColumnVisibility` Extension Setting.
	 */
	get defaultColumnVisibility(): DefaultColumnVisibility {
		let obj: any = this.config.get('defaultColumnVisibility', {});
		if (typeof obj === 'object' && obj !== null && typeof obj['Date'] === 'boolean' && typeof obj['Author'] === 'boolean' && typeof obj['Commit'] === 'boolean') {
			return { author: obj['Author'], commit: obj['Commit'], date: obj['Date'] };
		} else {
			return { author: true, commit: true, date: true };
		}
	}

	/**
	 * Get the value of the `git-graph.dialog.*` Extension Settings.
	 */
	get dialogDefaults(): DialogDefaults {
		let resetCommitMode = this.config.get<string>('dialog.resetCurrentBranchToCommit.mode', 'Mixed');
		let resetUncommittedMode = this.config.get<string>('dialog.resetUncommittedChanges.mode', 'Mixed');
		let refInputSpaceSubstitution = this.config.get<string>('dialog.general.referenceInputSpaceSubstitution', 'None');

		return {
			addTag: {
				pushToRemote: !!this.config.get('dialog.addTag.pushToRemote', false),
				type: this.config.get<string>('dialog.addTag.type', 'Annotated') === 'Lightweight' ? TagType.Lightweight : TagType.Annotated
			},
			applyStash: {
				reinstateIndex: !!this.config.get('dialog.applyStash.reinstateIndex', false)
			},
			cherryPick: {
				noCommit: !!this.config.get('dialog.cherryPick.noCommit', false),
				recordOrigin: !!this.config.get('dialog.cherryPick.recordOrigin', false)
			},
			createBranch: {
				checkout: !!this.config.get('dialog.createBranch.checkOut', false)
			},
			deleteBranch: {
				forceDelete: !!this.config.get('dialog.deleteBranch.forceDelete', false)
			},
			fetchIntoLocalBranch: {
				forceFetch: !!this.config.get('dialog.fetchIntoLocalBranch.forceFetch', false)
			},
			fetchRemote: {
				prune: !!this.config.get('dialog.fetchRemote.prune', false),
				pruneTags: !!this.config.get('dialog.fetchRemote.pruneTags', false)
			},
			general: {
				referenceInputSpaceSubstitution: refInputSpaceSubstitution === 'Hyphen' ? '-' : refInputSpaceSubstitution === 'Underscore' ? '_' : null
			},
			merge: {
				noCommit: !!this.config.get('dialog.merge.noCommit', false),
				noFastForward: !!this.config.get('dialog.merge.noFastForward', true),
				squash: !!this.config.get('dialog.merge.squashCommits', false)
			},
			popStash: {
				reinstateIndex: !!this.config.get('dialog.popStash.reinstateIndex', false)
			},
			pullBranch: {
				noFastForward: !!this.config.get('dialog.pullBranch.noFastForward', false),
				squash: !!this.config.get('dialog.pullBranch.squashCommits', false)
			},
			rebase: {
				ignoreDate: !!this.config.get('dialog.rebase.ignoreDate', true),
				interactive: !!this.config.get('dialog.rebase.launchInteractiveRebase', false)
			},
			resetCommit: {
				mode: resetCommitMode === 'Soft' ? GitResetMode.Soft : (resetCommitMode === 'Hard' ? GitResetMode.Hard : GitResetMode.Mixed)
			},
			resetUncommitted: {
				mode: resetUncommittedMode === 'Hard' ? GitResetMode.Hard : GitResetMode.Mixed
			},
			stashUncommittedChanges: {
				includeUntracked: !!this.config.get('dialog.stashUncommittedChanges.includeUntracked', true)
			}
		};
	}

	/**
	 * Get the value of the `git-graph.dialog.merge.squashMessageFormat` Extension Setting.
	 */
	get squashMergeMessageFormat() {
		return this.config.get<string>('dialog.merge.squashMessageFormat', 'Default') === 'Git SQUASH_MSG'
			? SquashMessageFormat.GitSquashMsg
			: SquashMessageFormat.Default;
	}

	/**
	 * Get the value of the `git-graph.dialog.pullBranch.squashMessageFormat` Extension Setting.
	 */
	get squashPullMessageFormat() {
		return this.config.get<string>('dialog.pullBranch.squashMessageFormat', 'Default') === 'Git SQUASH_MSG'
			? SquashMessageFormat.GitSquashMsg
			: SquashMessageFormat.Default;
	}

	/**
	 * Get the value of the `git-graph.enhancedAccessibility` Extension Setting.
	 */
	get enhancedAccessibility() {
		return !!this.config.get('enhancedAccessibility', false);
	}

	/**
	 * Get the value of the `git-graph.fileEncoding` Extension Setting.
	 */
	get fileEncoding() {
		return this.config.get<string>('fileEncoding', 'utf8');
	}

	/**
	 * Get the graph configuration from the Extension Settings.
	 */
	get graph(): GraphConfig {
		const colours = this.getRenamedExtensionSetting<string[]>('graph.colours', 'graphColours', []);
		return {
			colours: Array.isArray(colours) && colours.length > 0
				? colours.filter((v) => v.match(/^\s*(#[0-9a-fA-F]{6}|#[0-9a-fA-F]{8}|rgb[a]?\s*\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))\s*$/) !== null)
				: ['#0085d9', '#d9008f', '#00d90a', '#d98500', '#a300d9', '#ff0000', '#00d9cc', '#e138e8', '#85d900', '#dc5b23', '#6f24d6', '#ffcc00'],
			style: this.getRenamedExtensionSetting<string>('graph.style', 'graphStyle', 'rounded') === 'angular'
				? GraphStyle.Angular
				: GraphStyle.Rounded,
			grid: { x: 16, y: 24, offsetX: 16, offsetY: 12, expandY: 250 },
			uncommittedChanges: this.config.get<string>('graph.uncommittedChanges', 'Open Circle at the Uncommitted Changes') === 'Open Circle at the Checked Out Commit'
				? GraphUncommittedChangesStyle.OpenCircleAtTheCheckedOutCommit
				: GraphUncommittedChangesStyle.OpenCircleAtTheUncommittedChanges
		};
	}

	/**
	 * Get the value of the `git-graph.integratedTerminalShell` Extension Setting.
	 */
	get integratedTerminalShell() {
		return this.config.get('integratedTerminalShell', '');
	}

	/**
	 * Get the keybinding configuration from the `git-graph.keyboardShortcut.*` Extension Settings.
	 */
	get keybindings(): KeybindingConfig {
		return {
			find: this.getKeybinding('keyboardShortcut.find', 'f'),
			refresh: this.getKeybinding('keyboardShortcut.refresh', 'r'),
			scrollToHead: this.getKeybinding('keyboardShortcut.scrollToHead', 'h'),
			scrollToStash: this.getKeybinding('keyboardShortcut.scrollToStash', 's')
		};
	}

	/**
	 * Get the value of the `git-graph.maxDepthOfRepoSearch` Extension Setting.
	 */
	get maxDepthOfRepoSearch() {
		return this.config.get('maxDepthOfRepoSearch', 0);
	}

	/**
	 * Get the value of the `git-graph.markdown` Extension Setting.
	 */
	get markdown() {
		return !!this.config.get('markdown', true);
	}

	/**
	 * Get the value of the `git-graph.openNewTabEditorGroup` Extension Setting.
	 */
	get openNewTabEditorGroup(): vscode.ViewColumn {
		const location = this.getRenamedExtensionSetting<string>('openNewTabEditorGroup', 'openDiffTabLocation', 'Active');
		return typeof location === 'string' && typeof VIEW_COLUMN_MAPPING[location] !== 'undefined'
			? VIEW_COLUMN_MAPPING[location]
			: vscode.ViewColumn.Active;
	}

	/**
	 * Get the value of the `git-graph.openToTheRepoOfTheActiveTextEditorDocument` Extension Setting.
	 */
	get openToTheRepoOfTheActiveTextEditorDocument() {
		return !!this.config.get('openToTheRepoOfTheActiveTextEditorDocument', false);
	}

	/**
	 * Get the reference label configuration from the Extension Settings.
	 */
	get referenceLabels(): ReferenceLabelsConfig {
		const alignmentConfigValue = this.getRenamedExtensionSetting<string>('referenceLabels.alignment', 'referenceLabelAlignment', 'Normal');
		const alignment = alignmentConfigValue === 'Branches (on the left) & Tags (on the right)'
			? RefLabelAlignment.BranchesOnLeftAndTagsOnRight
			: alignmentConfigValue === 'Branches (aligned to the graph) & Tags (on the right)'
				? RefLabelAlignment.BranchesAlignedToGraphAndTagsOnRight
				: RefLabelAlignment.Normal;
		return {
			branchLabelsAlignedToGraph: alignment === RefLabelAlignment.BranchesAlignedToGraphAndTagsOnRight,
			combineLocalAndRemoteBranchLabels: !!this.getRenamedExtensionSetting('referenceLabels.combineLocalAndRemoteBranchLabels', 'combineLocalAndRemoteBranchLabels', true),
			tagLabelsOnRight: alignment !== RefLabelAlignment.Normal
		};
	}

	/**
	 * Get the value of the `git-graph.repository.commits.fetchAvatars` Extension Setting.
	 */
	get fetchAvatars() {
		return !!this.getRenamedExtensionSetting('repository.commits.fetchAvatars', 'fetchAvatars', false);
	}

	/**
	 * Get the value of the `git-graph.repository.commits.initialLoad` Extension Setting.
	 */
	get initialLoadCommits() {
		return this.getRenamedExtensionSetting('repository.commits.initialLoad', 'initialLoadCommits', 300);
	}


	/**
	 * Get the value of the `git-graph.repository.commits.loadMore` Extension Setting.
	 */
	get loadMoreCommits() {
		return this.getRenamedExtensionSetting('repository.commits.loadMore', 'loadMoreCommits', 100);
	}

	/**
	 * Get the value of the `git-graph.repository.commits.loadMoreAutomatically` Extension Setting.
	 */
	get loadMoreCommitsAutomatically() {
		return !!this.getRenamedExtensionSetting('repository.commits.loadMoreAutomatically', 'loadMoreCommitsAutomatically', true);
	}

	/**
	 * Get the mute commits configuration from the Extension Settings.
	 */
	get muteCommits(): MuteCommitsConfig {
		return {
			commitsNotAncestorsOfHead: !!this.getRenamedExtensionSetting('repository.commits.mute.commitsThatAreNotAncestorsOfHead', 'muteCommitsThatAreNotAncestorsOfHead', false),
			mergeCommits: !!this.getRenamedExtensionSetting('repository.commits.mute.mergeCommits', 'muteMergeCommits', true)
		};
	}

	/**
	 * Get the value of the `git-graph.repository.commits.order` Extension Setting.
	 */
	get commitOrder() {
		const ordering = this.getRenamedExtensionSetting<string>('repository.commits.order', 'commitOrdering', 'date');
		return ordering === 'author-date'
			? CommitOrdering.AuthorDate
			: ordering === 'topo'
				? CommitOrdering.Topological
				: CommitOrdering.Date;
	}

	/**
	 * Get the value of the `git-graph.repository.commits.showSignatureStatus` Extension Setting.
	 */
	get showSignatureStatus() {
		return !!this.getRenamedExtensionSetting('repository.commits.showSignatureStatus', 'showSignatureStatus', false);
	}

	/**
	 * Get the value of the `git-graph.repository.fetchAndPrune` Extension Setting.
	 */
	get fetchAndPrune() {
		return !!this.getRenamedExtensionSetting('repository.fetchAndPrune', 'fetchAndPrune', false);
	}

	/**
	 * Get the value of the `git-graph.repository.fetchAndPruneTags` Extension Setting.
	 */
	get fetchAndPruneTags() {
		return !!this.config.get('repository.fetchAndPruneTags', false);
	}

	/**
	 * Get the value of the `git-graph.repository.includeCommitsMentionedByReflogs` Extension Setting.
	 */
	get includeCommitsMentionedByReflogs() {
		return !!this.getRenamedExtensionSetting('repository.includeCommitsMentionedByReflogs', 'includeCommitsMentionedByReflogs', false);
	}

	/**
	 * Get the On Repo Load configuration from the Extension Settings.
	 */
	get onRepoLoad(): OnRepoLoadConfig {
		const branches = this.config.get('repository.onLoad.showSpecificBranches', []);
		return {
			scrollToHead: !!this.getRenamedExtensionSetting('repository.onLoad.scrollToHead', 'openRepoToHead', false),
			showCheckedOutBranch: !!this.getRenamedExtensionSetting('repository.onLoad.showCheckedOutBranch', 'showCurrentBranchByDefault', false),
			showSpecificBranches: Array.isArray(branches)
				? branches.filter((branch) => typeof branch === 'string')
				: []
		};
	}

	/**
	 * Get the value of the `git-graph.repository.onlyFollowFirstParent` Extension Setting.
	 */
	get onlyFollowFirstParent() {
		return !!this.getRenamedExtensionSetting('repository.onlyFollowFirstParent', 'onlyFollowFirstParent', false);
	}

	/**
	 * Get the value of the `git-graph.repository.showCommitsOnlyReferencedByTags` Extension Setting.
	 */
	get showCommitsOnlyReferencedByTags() {
		return !!this.getRenamedExtensionSetting('repository.showCommitsOnlyReferencedByTags', 'showCommitsOnlyReferencedByTags', true);
	}

	/**
	 * Get the value of the `git-graph.repository.showRemoteBranches` Extension Setting.
	 */
	get showRemoteBranches() {
		return !!this.config.get('repository.showRemoteBranches', true);
	}

	/**
	 * Get the value of the `git-graph.repository.showRemoteHeads` Extension Setting.
	 */
	get showRemoteHeads() {
		return !!this.config.get('repository.showRemoteHeads', true);
	}

	/**
	 * Get the value of the `git-graph.repository.showStashes` Extension Setting.
	 */
	get showStashes() {
		return !!this.config.get('repository.showStashes', true);
	}

	/**
	 * Get the value of the `git-graph.repository.showTags` Extension Setting.
	 */
	get showTags() {
		return !!this.getRenamedExtensionSetting('repository.showTags', 'showTags', true);
	}

	/**
	 * Get the value of the `git-graph.repository.showUncommittedChanges` Extension Setting.
	 */
	get showUncommittedChanges() {
		return !!this.getRenamedExtensionSetting('repository.showUncommittedChanges', 'showUncommittedChanges', true);
	}

	/**
	 * Get the value of the `git-graph.repository.showUntrackedFiles` Extension Setting.
	 */
	get showUntrackedFiles() {
		return !!this.getRenamedExtensionSetting('repository.showUntrackedFiles', 'showUntrackedFiles', true);
	}

	/**
	 * Get the value of the `git-graph.repository.sign.commits` Extension Setting.
	 */
	get signCommits() {
		return !!this.config.get('repository.sign.commits', false);
	}

	/**
	 * Get the value of the `git-graph.repository.sign.tags` Extension Setting.
	 */
	get signTags() {
		return !!this.config.get('repository.sign.tags', false);
	}

	/**
	 * Get the value of the `git-graph.repository.useMailmap` Extension Setting.
	 */
	get useMailmap() {
		return !!this.getRenamedExtensionSetting('repository.useMailmap', 'useMailmap', false);
	}

	/**
	 * Get the value of the `git-graph.repositoryDropdownOrder` Extension Setting.
	 */
	get repoDropdownOrder(): RepoDropdownOrder {
		const order = this.config.get<string>('repositoryDropdownOrder', 'Workspace Full Path');
		return order === 'Full Path'
			? RepoDropdownOrder.FullPath
			: order === 'Name'
				? RepoDropdownOrder.Name
				: RepoDropdownOrder.WorkspaceFullPath;
	}

	/**
	 * Get the value of the `git-graph.retainContextWhenHidden` Extension Setting.
	 */
	get retainContextWhenHidden() {
		return !!this.config.get('retainContextWhenHidden', true);
	}

	/**
	 * Get the value of the `git-graph.showStatusBarItem` Extension Setting.
	 */
	get showStatusBarItem() {
		return !!this.config.get('showStatusBarItem', true);
	}

	/**
	 * Get the value of the `git-graph.tabIconColourTheme` Extension Setting.
	 */
	get tabIconColourTheme() {
		return this.config.get<string>('tabIconColourTheme', 'colour') === 'grey'
			? TabIconColourTheme.Grey
			: TabIconColourTheme.Colour;
	}

	/**
	 * Get the Git executable paths configured by the `git.path` Visual Studio Code Setting.
	 */
	get gitPaths() {
		const configValue = vscode.workspace.getConfiguration('git').get<string | string[] | null>('path', null);
		if (configValue === null) {
			return [];
		} else if (typeof configValue === 'string') {
			return [configValue];
		} else if (Array.isArray(configValue)) {
			return configValue.filter((value) => typeof value === 'string');
		} else {
			return [];
		}
	}

	/**
	 * Get the normalised keybinding located by the provided section.
	 * @param section The section locating the keybinding setting.
	 * @param defaultValue The default keybinding.
	 * @returns The normalised keybinding.
	 */
	private getKeybinding(section: string, defaultValue: string) {
		const configValue = this.config.get<string>(section);
		if (typeof configValue === 'string') {
			if (configValue === 'UNASSIGNED') {
				return null;
			} else if (Config.KEYBINDING_REGEXP.test(configValue)) {
				return configValue.substring(11).toLowerCase();
			}
		}
		return defaultValue;
	}

	/**
	 * Get the value of a renamed extension setting.
	 * @param newSection The section locating the new setting.
	 * @param oldSection The section location the old setting.
	 * @param defaultValue The default value of the setting.
	 * @returns The value of the extension setting.
	 */
	private getRenamedExtensionSetting<T>(newSection: string, oldSection: string, defaultValue: T) {
		const newValues = this.config.inspect<T>(newSection), oldValues = this.config.inspect<T>(oldSection);
		if (typeof newValues !== 'undefined' && typeof newValues.workspaceValue !== 'undefined') return newValues.workspaceValue;
		if (typeof oldValues !== 'undefined' && typeof oldValues.workspaceValue !== 'undefined') return oldValues.workspaceValue;
		if (typeof newValues !== 'undefined' && typeof newValues.globalValue !== 'undefined') return newValues.globalValue;
		if (typeof oldValues !== 'undefined' && typeof oldValues.globalValue !== 'undefined') return oldValues.globalValue;
		return defaultValue;
	}
}

/**
 * Get a Config instance for retrieving the users configuration of Git Graph Extension Settings.
 * @param repo An optional path of a repository (to be used for Workspace Folder Scoped Configuration Values).
 * @returns A Config instance.
 */
export function getConfig(repo?: string) {
	return new Config(repo);
}

/**
 * Recursively apply the values in a user specified object to an object containing default values.
 * @param base An object containing the default values.
 * @param user An object specified by the user.
 */
function mergeConfigObjects(base: { [key: string]: any }, user: { [key: string]: any }) {
	if (typeof base !== typeof user) return;

	let keys = Object.keys(base);
	for (let i = 0; i < keys.length; i++) {
		if (typeof base[keys[i]] === 'object') {
			if (typeof user[keys[i]] === 'object') {
				mergeConfigObjects(base[keys[i]], user[keys[i]]);
			}
		} else if (typeof user[keys[i]] === typeof base[keys[i]]) {
			base[keys[i]] = user[keys[i]];
		}
	}
}
-e 

================================================================================
// FILE: ./src/types.ts
================================================================================
/* Git Interfaces / Types */

export interface GitCommit {
	readonly hash: string;
	readonly parents: ReadonlyArray<string>;
	readonly author: string;
	readonly email: string;
	readonly date: number;
	readonly message: string;
	readonly heads: ReadonlyArray<string>;
	readonly tags: ReadonlyArray<GitCommitTag>;
	readonly remotes: ReadonlyArray<GitCommitRemote>;
	readonly stash: GitCommitStash | null; // null => not a stash, otherwise => stash info
}

export interface GitCommitTag {
	readonly name: string;
	readonly annotated: boolean;
}

export interface GitCommitRemote {
	readonly name: string;
	readonly remote: string | null; // null => remote not found, otherwise => remote name
}

export interface GitCommitStash {
	readonly selector: string;
	readonly baseHash: string;
	readonly untrackedFilesHash: string | null;
}

export interface GitCommitDetails {
	readonly hash: string;
	readonly parents: ReadonlyArray<string>;
	readonly author: string;
	readonly authorEmail: string;
	readonly authorDate: number;
	readonly committer: string;
	readonly committerEmail: string;
	readonly committerDate: number;
	readonly signature: GitSignature | null;
	readonly body: string;
	readonly fileChanges: ReadonlyArray<GitFileChange>;
}

export const enum GitSignatureStatus {
	GoodAndValid = 'G',
	GoodWithUnknownValidity = 'U',
	GoodButExpired = 'X',
	GoodButMadeByExpiredKey = 'Y',
	GoodButMadeByRevokedKey = 'R',
	CannotBeChecked = 'E',
	Bad = 'B'
}

export interface GitSignature {
	readonly key: string;
	readonly signer: string;
	readonly status: GitSignatureStatus;
}

export const enum GitConfigLocation {
	Local = 'local',
	Global = 'global',
	System = 'system'
}

export interface GitFileChange {
	readonly oldFilePath: string;
	readonly newFilePath: string;
	readonly type: GitFileStatus;
	readonly additions: number | null;
	readonly deletions: number | null;
}

export const enum GitFileStatus {
	Added = 'A',
	Modified = 'M',
	Deleted = 'D',
	Renamed = 'R',
	Untracked = 'U'
}

export const enum GitPushBranchMode {
	Normal = '',
	Force = 'force',
	ForceWithLease = 'force-with-lease'
}

export interface GitRepoConfig {
	readonly branches: GitRepoConfigBranches;
	readonly diffTool: string | null;
	readonly guiDiffTool: string | null;
	readonly pushDefault: string | null;
	readonly remotes: ReadonlyArray<GitRepoSettingsRemote>;
	readonly user: {
		readonly name: {
			readonly local: string | null,
			readonly global: string | null
		},
		readonly email: {
			readonly local: string | null,
			readonly global: string | null
		}
	};
}

export type GitRepoConfigBranches = { [branchName: string]: GitRepoConfigBranch };

export interface GitRepoConfigBranch {
	readonly pushRemote: string | null;
	readonly remote: string | null;
}

export interface GitRepoSettingsRemote {
	readonly name: string;
	readonly url: string | null;
	readonly pushUrl: string | null;
}

export const enum GitResetMode {
	Soft = 'soft',
	Mixed = 'mixed',
	Hard = 'hard'
}

export interface GitStash {
	readonly hash: string;
	readonly baseHash: string;
	readonly untrackedFilesHash: string | null;
	readonly selector: string;
	readonly author: string;
	readonly email: string;
	readonly date: number;
	readonly message: string;
}

export interface GitTagDetails {
	readonly hash: string;
	readonly taggerName: string;
	readonly taggerEmail: string;
	readonly taggerDate: number;
	readonly message: string;
	readonly signature: GitSignature | null;
}


/* Git Repo State */

export interface CodeReview {
	id: string;
	lastActive: number;
	lastViewedFile: string | null;
	remainingFiles: string[];
}

export type ColumnWidth = number;

export type GitRepoSet = { [repo: string]: GitRepoState };

export interface IssueLinkingConfig {
	readonly issue: string;
	readonly url: string;
}

export interface PullRequestConfigBase {
	readonly hostRootUrl: string;
	readonly sourceRemote: string;
	readonly sourceOwner: string;
	readonly sourceRepo: string;
	readonly destRemote: string | null;
	readonly destOwner: string;
	readonly destRepo: string;
	readonly destProjectId: string; // Only used by GitLab
	readonly destBranch: string;
}

export const enum PullRequestProvider {
	Bitbucket,
	Custom,
	GitHub,
	GitLab
}

interface PullRequestConfigBuiltIn extends PullRequestConfigBase {
	readonly provider: Exclude<PullRequestProvider, PullRequestProvider.Custom>;
	readonly custom: null;
}

interface PullRequestConfigCustom extends PullRequestConfigBase {
	readonly provider: PullRequestProvider.Custom;
	readonly custom: {
		readonly name: string,
		readonly templateUrl: string
	};
}

export type PullRequestConfig = PullRequestConfigBuiltIn | PullRequestConfigCustom;

export interface GitRepoState {
	cdvDivider: number;
	cdvHeight: number;
	columnWidths: ColumnWidth[] | null;
	commitOrdering: RepoCommitOrdering;
	fileViewType: FileViewType;
	hideRemotes: string[];
	includeCommitsMentionedByReflogs: BooleanOverride;
	issueLinkingConfig: IssueLinkingConfig | null;
	lastImportAt: number;
	name: string | null;
	onlyFollowFirstParent: BooleanOverride;
	onRepoLoadShowCheckedOutBranch: BooleanOverride;
	onRepoLoadShowSpecificBranches: string[] | null;
	pullRequestConfig: PullRequestConfig | null;
	showRemoteBranches: boolean;
	showRemoteBranchesV2: BooleanOverride;
	showStashes: BooleanOverride;
	showTags: BooleanOverride;
	workspaceFolderIndex: number | null;
}


/* Git Graph View Types */

export interface GitGraphViewInitialState {
	readonly config: GitGraphViewConfig;
	readonly lastActiveRepo: string | null;
	readonly loadViewTo: LoadGitGraphViewTo;
	readonly repos: GitRepoSet;
	readonly loadRepoInfoRefreshId: number;
	readonly loadCommitsRefreshId: number;
}

export interface GitGraphViewConfig {
	readonly commitDetailsView: CommitDetailsViewConfig;
	readonly commitOrdering: CommitOrdering;
	readonly contextMenuActionsVisibility: ContextMenuActionsVisibility;
	readonly customBranchGlobPatterns: ReadonlyArray<CustomBranchGlobPattern>;
	readonly customEmojiShortcodeMappings: ReadonlyArray<CustomEmojiShortcodeMapping>;
	readonly customPullRequestProviders: ReadonlyArray<CustomPullRequestProvider>;
	readonly dateFormat: DateFormat;
	readonly defaultColumnVisibility: DefaultColumnVisibility;
	readonly dialogDefaults: DialogDefaults;
	readonly enhancedAccessibility: boolean;
	readonly fetchAndPrune: boolean;
	readonly fetchAndPruneTags: boolean;
	readonly fetchAvatars: boolean;
	readonly graph: GraphConfig;
	readonly includeCommitsMentionedByReflogs: boolean;
	readonly initialLoadCommits: number;
	readonly keybindings: KeybindingConfig
	readonly loadMoreCommits: number;
	readonly loadMoreCommitsAutomatically: boolean;
	readonly markdown: boolean;
	readonly mute: MuteCommitsConfig;
	readonly onlyFollowFirstParent: boolean;
	readonly onRepoLoad: OnRepoLoadConfig;
	readonly referenceLabels: ReferenceLabelsConfig;
	readonly repoDropdownOrder: RepoDropdownOrder;
	readonly showRemoteBranches: boolean;
	readonly showStashes: boolean;
	readonly showTags: boolean;
}

export interface GitGraphViewGlobalState {
	alwaysAcceptCheckoutCommit: boolean;
	issueLinkingConfig: IssueLinkingConfig | null;
	pushTagSkipRemoteCheck: boolean;
}

export interface GitGraphViewWorkspaceState {
	findIsCaseSensitive: boolean;
	findIsRegex: boolean;
	findOpenCommitDetailsView: boolean;
}

export interface CommitDetailsViewConfig {
	readonly autoCenter: boolean;
	readonly fileTreeCompactFolders: boolean;
	readonly fileViewType: FileViewType;
	readonly location: CommitDetailsViewLocation;
}

export interface GraphConfig {
	readonly colours: ReadonlyArray<string>;
	readonly style: GraphStyle;
	readonly grid: { x: number, y: number, offsetX: number, offsetY: number, expandY: number };
	readonly uncommittedChanges: GraphUncommittedChangesStyle;
}

export interface KeybindingConfig {
	readonly find: string | null;
	readonly refresh: string | null;
	readonly scrollToHead: string | null;
	readonly scrollToStash: string | null;
}

export type LoadGitGraphViewTo = {
	readonly repo: string,
	readonly commitDetails?: {
		readonly commitHash: string,
		readonly compareWithHash: string | null
	},
	readonly runCommandOnLoad?: 'fetch'
} | null;

export interface MuteCommitsConfig {
	readonly commitsNotAncestorsOfHead: boolean;
	readonly mergeCommits: boolean;
}

export interface OnRepoLoadConfig {
	readonly scrollToHead: boolean;
	readonly showCheckedOutBranch: boolean;
	readonly showSpecificBranches: ReadonlyArray<string>;
}

export interface ReferenceLabelsConfig {
	readonly branchLabelsAlignedToGraph: boolean;
	readonly combineLocalAndRemoteBranchLabels: boolean;
	readonly tagLabelsOnRight: boolean;
}


/* Extension Settings Types */

export const enum BooleanOverride {
	Default,
	Enabled,
	Disabled
}

export const enum CommitDetailsViewLocation {
	Inline,
	DockedToBottom
}

export const enum CommitOrdering {
	Date = 'date',
	AuthorDate = 'author-date',
	Topological = 'topo'
}

export interface ContextMenuActionsVisibility {
	readonly branch: {
		readonly checkout: boolean;
		readonly rename: boolean;
		readonly delete: boolean;
		readonly merge: boolean;
		readonly rebase: boolean;
		readonly push: boolean;
		readonly viewIssue: boolean;
		readonly createPullRequest: boolean;
		readonly createArchive: boolean;
		readonly selectInBranchesDropdown: boolean;
		readonly unselectInBranchesDropdown: boolean;
		readonly copyName: boolean;
	};
	readonly commit: {
		readonly addTag: boolean;
		readonly createBranch: boolean;
		readonly checkout: boolean;
		readonly cherrypick: boolean;
		readonly revert: boolean;
		readonly drop: boolean;
		readonly merge: boolean;
		readonly rebase: boolean;
		readonly reset: boolean;
		readonly copyHash: boolean;
		readonly copySubject: boolean;
	};
	readonly commitDetailsViewFile: {
		readonly viewDiff: boolean;
		readonly viewFileAtThisRevision: boolean;
		readonly viewDiffWithWorkingFile: boolean;
		readonly openFile: boolean;
		readonly markAsReviewed: boolean;
		readonly markAsNotReviewed: boolean;
		readonly resetFileToThisRevision: boolean;
		readonly copyAbsoluteFilePath: boolean;
		readonly copyRelativeFilePath: boolean;
	};
	readonly remoteBranch: {
		readonly checkout: boolean;
		readonly delete: boolean;
		readonly fetch: boolean;
		readonly merge: boolean;
		readonly pull: boolean;
		readonly viewIssue: boolean;
		readonly createPullRequest: boolean;
		readonly createArchive: boolean;
		readonly selectInBranchesDropdown: boolean;
		readonly unselectInBranchesDropdown: boolean;
		readonly copyName: boolean;
	};
	readonly stash: {
		readonly apply: boolean;
		readonly createBranch: boolean;
		readonly pop: boolean;
		readonly drop: boolean;
		readonly copyName: boolean;
		readonly copyHash: boolean;
	};
	readonly tag: {
		readonly viewDetails: boolean;
		readonly delete: boolean;
		readonly push: boolean;
		readonly createArchive: boolean;
		readonly copyName: boolean;
	};
	readonly uncommittedChanges: {
		readonly stash: boolean;
		readonly reset: boolean;
		readonly clean: boolean;
		readonly openSourceControlView: boolean;
	};
}

export interface CustomBranchGlobPattern {
	readonly name: string;
	readonly glob: string;
}

export interface CustomEmojiShortcodeMapping {
	readonly shortcode: string;
	readonly emoji: string;
}

export interface CustomPullRequestProvider {
	readonly name: string;
	readonly templateUrl: string;
}

export interface DateFormat {
	readonly type: DateFormatType;
	readonly iso: boolean;
}

export const enum DateFormatType {
	DateAndTime,
	DateOnly,
	Relative
}

export const enum DateType {
	Author,
	Commit
}

export interface DefaultColumnVisibility {
	readonly date: boolean;
	readonly author: boolean;
	readonly commit: boolean;
}

export interface DialogDefaults {
	readonly addTag: {
		readonly pushToRemote: boolean,
		readonly type: TagType
	};
	readonly applyStash: {
		readonly reinstateIndex: boolean
	};
	readonly cherryPick: {
		readonly noCommit: boolean,
		readonly recordOrigin: boolean
	};
	readonly createBranch: {
		readonly checkout: boolean
	};
	readonly deleteBranch: {
		readonly forceDelete: boolean
	};
	readonly fetchIntoLocalBranch: {
		readonly forceFetch: boolean
	};
	readonly fetchRemote: {
		readonly prune: boolean,
		readonly pruneTags: boolean
	};
	readonly general: {
		readonly referenceInputSpaceSubstitution: string | null
	};
	readonly merge: {
		readonly noCommit: boolean,
		readonly noFastForward: boolean,
		readonly squash: boolean
	};
	readonly popStash: {
		readonly reinstateIndex: boolean
	};
	readonly pullBranch: {
		readonly noFastForward: boolean,
		readonly squash: boolean
	};
	readonly rebase: {
		readonly ignoreDate: boolean,
		readonly interactive: boolean
	};
	readonly resetCommit: {
		readonly mode: GitResetMode
	};
	readonly resetUncommitted: {
		readonly mode: Exclude<GitResetMode, GitResetMode.Soft>
	};
	readonly stashUncommittedChanges: {
		readonly includeUntracked: boolean
	};
}

export const enum FileViewType {
	Default,
	Tree,
	List
}

export const enum GraphStyle {
	Rounded,
	Angular
}

export const enum GraphUncommittedChangesStyle {
	OpenCircleAtTheUncommittedChanges,
	OpenCircleAtTheCheckedOutCommit
}

export const enum RefLabelAlignment {
	Normal,
	BranchesOnLeftAndTagsOnRight,
	BranchesAlignedToGraphAndTagsOnRight
}

export const enum RepoCommitOrdering {
	Default = 'default',
	Date = 'date',
	AuthorDate = 'author-date',
	Topological = 'topo'
}

export const enum RepoDropdownOrder {
	FullPath,
	Name,
	WorkspaceFullPath
}

export const enum SquashMessageFormat {
	Default,
	GitSquashMsg
}

export const enum TabIconColourTheme {
	Colour,
	Grey
}

export const enum TagType {
	Annotated,
	Lightweight
}


/* Base Interfaces for Request / Response Messages */

export interface BaseMessage {
	readonly command: string;
}

export interface RepoRequest extends BaseMessage {
	readonly repo: string;
}

export interface ResponseWithErrorInfo extends BaseMessage {
	readonly error: ErrorInfo;
}

export interface ResponseWithMultiErrorInfo extends BaseMessage {
	readonly errors: ErrorInfo[];
}

export type ErrorInfo = string | null; // null => no error, otherwise => error message

export const enum ErrorInfoExtensionPrefix {
	PushTagCommitNotOnRemote = 'VSCODE_GIT_GRAPH:PUSH_TAG:COMMIT_NOT_ON_REMOTE:'
}

/* Request / Response Messages */

export interface RequestAddRemote extends RepoRequest {
	readonly command: 'addRemote';
	readonly name: string;
	readonly url: string;
	readonly pushUrl: string | null;
	readonly fetch: boolean;
}
export interface ResponseAddRemote extends ResponseWithErrorInfo {
	readonly command: 'addRemote';
}

export interface RequestAddTag extends RepoRequest {
	readonly command: 'addTag';
	readonly commitHash: string;
	readonly tagName: string;
	readonly type: TagType;
	readonly message: string;
	readonly pushToRemote: string | null; // string => name of the remote to push the tag to, null => don't push to a remote
	readonly pushSkipRemoteCheck: boolean;
	readonly force: boolean;
}
export interface ResponseAddTag extends ResponseWithMultiErrorInfo {
	readonly command: 'addTag';
	readonly repo: string;
	readonly tagName: string;
	readonly pushToRemote: string | null;
	readonly commitHash: string;
}

export interface RequestApplyStash extends RepoRequest {
	readonly command: 'applyStash';
	readonly selector: string;
	readonly reinstateIndex: boolean;
}
export interface ResponseApplyStash extends ResponseWithErrorInfo {
	readonly command: 'applyStash';
}

export interface RequestBranchFromStash extends RepoRequest {
	readonly command: 'branchFromStash';
	readonly selector: string;
	readonly branchName: string;
}
export interface ResponseBranchFromStash extends ResponseWithErrorInfo {
	readonly command: 'branchFromStash';
}

export interface RequestCheckoutBranch extends RepoRequest {
	readonly command: 'checkoutBranch';
	readonly branchName: string;
	readonly remoteBranch: string | null;
	readonly pullAfterwards: {
		readonly branchName: string;
		readonly remote: string;
		readonly createNewCommit: boolean;
		readonly squash: boolean;
	} | null; // NULL => Don't pull after checking out
}
export interface ResponseCheckoutBranch extends ResponseWithMultiErrorInfo {
	readonly command: 'checkoutBranch';
	readonly pullAfterwards: {
		readonly branchName: string;
		readonly remote: string;
	} | null; // NULL => Don't pull after checking out
}

export interface RequestCheckoutCommit extends RepoRequest {
	readonly command: 'checkoutCommit';
	readonly commitHash: string;
}
export interface ResponseCheckoutCommit extends ResponseWithErrorInfo {
	readonly command: 'checkoutCommit';
}

export interface RequestCherrypickCommit extends RepoRequest {
	readonly command: 'cherrypickCommit';
	readonly commitHash: string;
	readonly parentIndex: number;
	readonly recordOrigin: boolean;
	readonly noCommit: boolean;
}
export interface ResponseCherrypickCommit extends ResponseWithMultiErrorInfo {
	readonly command: 'cherrypickCommit';
}

export interface RequestCleanUntrackedFiles extends RepoRequest {
	readonly command: 'cleanUntrackedFiles';
	readonly directories: boolean;
}
export interface ResponseCleanUntrackedFiles extends ResponseWithErrorInfo {
	readonly command: 'cleanUntrackedFiles';
}

export interface RequestCommitDetails extends RepoRequest {
	readonly command: 'commitDetails';
	readonly commitHash: string;
	readonly hasParents: boolean;
	readonly stash: GitCommitStash | null; // null => request is for a commit, otherwise => request is for a stash
	readonly avatarEmail: string | null; // string => fetch avatar with the given email, null => don't fetch avatar
	readonly refresh: boolean;
}
export interface ResponseCommitDetails extends ResponseWithErrorInfo {
	readonly command: 'commitDetails';
	readonly commitDetails: GitCommitDetails | null;
	readonly avatar: string | null;
	readonly codeReview: CodeReview | null;
	readonly refresh: boolean;
}

export interface RequestCompareCommits extends RepoRequest {
	readonly command: 'compareCommits';
	readonly commitHash: string;
	readonly compareWithHash: string;
	readonly fromHash: string;
	readonly toHash: string;
	readonly refresh: boolean;
}
export interface ResponseCompareCommits extends ResponseWithErrorInfo {
	readonly command: 'compareCommits';
	readonly commitHash: string;
	readonly compareWithHash: string;
	readonly fileChanges: ReadonlyArray<GitFileChange>;
	readonly codeReview: CodeReview | null;
	readonly refresh: boolean;
}

export interface RequestCopyFilePath extends RepoRequest {
	readonly command: 'copyFilePath';
	readonly filePath: string;
	readonly absolute: boolean;
}
export interface ResponseCopyFilePath extends ResponseWithErrorInfo {
	readonly command: 'copyFilePath';
}

export interface RequestCopyToClipboard extends BaseMessage {
	readonly command: 'copyToClipboard';
	readonly type: string;
	readonly data: string;
}
export interface ResponseCopyToClipboard extends ResponseWithErrorInfo {
	readonly command: 'copyToClipboard';
	readonly type: string;
}

export interface RequestCreateArchive extends RepoRequest {
	readonly command: 'createArchive';
	readonly ref: string;
}
export interface ResponseCreateArchive extends ResponseWithErrorInfo {
	readonly command: 'createArchive';
}

export interface RequestCreateBranch extends RepoRequest {
	readonly command: 'createBranch';
	readonly commitHash: string;
	readonly branchName: string;
	readonly checkout: boolean;
	readonly force: boolean;
}
export interface ResponseCreateBranch extends ResponseWithMultiErrorInfo {
	readonly command: 'createBranch';
}

export interface RequestCreatePullRequest extends RepoRequest {
	readonly command: 'createPullRequest';
	readonly config: PullRequestConfig;
	readonly sourceRemote: string;
	readonly sourceOwner: string;
	readonly sourceRepo: string;
	readonly sourceBranch: string;
	readonly push: boolean;
}
export interface ResponseCreatePullRequest extends ResponseWithMultiErrorInfo {
	readonly command: 'createPullRequest';
	readonly push: boolean;
}

export interface RequestDeleteBranch extends RepoRequest {
	readonly command: 'deleteBranch';
	readonly branchName: string;
	readonly forceDelete: boolean;
	readonly deleteOnRemotes: ReadonlyArray<string>;
}
export interface ResponseDeleteBranch extends ResponseWithMultiErrorInfo {
	readonly command: 'deleteBranch';
	readonly repo: string;
	readonly branchName: string;
	readonly deleteOnRemotes: ReadonlyArray<string>;
}

export interface RequestDeleteRemote extends RepoRequest {
	readonly command: 'deleteRemote';
	readonly name: string;
}
export interface ResponseDeleteRemote extends ResponseWithErrorInfo {
	readonly command: 'deleteRemote';
}

export interface RequestDeleteRemoteBranch extends RepoRequest {
	readonly command: 'deleteRemoteBranch';
	readonly branchName: string;
	readonly remote: string;
}
export interface ResponseDeleteRemoteBranch extends ResponseWithErrorInfo {
	readonly command: 'deleteRemoteBranch';
}

export interface RequestDeleteTag extends RepoRequest {
	readonly command: 'deleteTag';
	readonly tagName: string;
	readonly deleteOnRemote: string | null; // null => don't delete on remote, otherwise => remote to delete on
}
export interface ResponseDeleteTag extends ResponseWithErrorInfo {
	readonly command: 'deleteTag';
}

export interface RequestDeleteUserDetails extends RepoRequest {
	readonly command: 'deleteUserDetails';
	readonly name: boolean; // TRUE => Delete Name, FALSE => Don't Delete Name
	readonly email: boolean; // TRUE => Delete Email, FALSE => Don't Delete Email
	readonly location: GitConfigLocation.Global | GitConfigLocation.Local;
}
export interface ResponseDeleteUserDetails extends ResponseWithMultiErrorInfo {
	readonly command: 'deleteUserDetails';
}

export interface RequestDropCommit extends RepoRequest {
	readonly command: 'dropCommit';
	readonly commitHash: string;
}
export interface ResponseDropCommit extends ResponseWithErrorInfo {
	readonly command: 'dropCommit';
}

export interface RequestDropStash extends RepoRequest {
	readonly command: 'dropStash';
	readonly selector: string;
}
export interface ResponseDropStash extends ResponseWithErrorInfo {
	readonly command: 'dropStash';
}

export interface RequestEditRemote extends RepoRequest {
	readonly command: 'editRemote';
	readonly nameOld: string;
	readonly nameNew: string;
	readonly urlOld: string | null;
	readonly urlNew: string | null;
	readonly pushUrlOld: string | null;
	readonly pushUrlNew: string | null;
}
export interface ResponseEditRemote extends ResponseWithErrorInfo {
	readonly command: 'editRemote';
}

export interface RequestEditUserDetails extends RepoRequest {
	readonly command: 'editUserDetails';
	readonly name: string;
	readonly email: string;
	readonly location: GitConfigLocation.Global | GitConfigLocation.Local;
	readonly deleteLocalName: boolean; // TRUE => Delete Local Name, FALSE => Don't Delete Local Name
	readonly deleteLocalEmail: boolean; // TRUE => Delete Local Email, FALSE => Don't Delete Local Email
}
export interface ResponseEditUserDetails extends ResponseWithMultiErrorInfo {
	readonly command: 'editUserDetails';
}

export interface RequestEndCodeReview extends RepoRequest {
	readonly command: 'endCodeReview';
	readonly id: string;
}

export interface RequestExportRepoConfig extends RepoRequest {
	readonly command: 'exportRepoConfig';
}
export interface ResponseExportRepoConfig extends ResponseWithErrorInfo {
	readonly command: 'exportRepoConfig';
}

export interface RequestFetch extends RepoRequest {
	readonly command: 'fetch';
	readonly name: string | null; // null => Fetch all remotes
	readonly prune: boolean;
	readonly pruneTags: boolean;
}
export interface ResponseFetch extends ResponseWithErrorInfo {
	readonly command: 'fetch';
}

export interface RequestFetchAvatar extends RepoRequest {
	readonly command: 'fetchAvatar';
	readonly remote: string | null;
	readonly email: string;
	readonly commits: string[];
}
export interface ResponseFetchAvatar extends BaseMessage {
	readonly command: 'fetchAvatar';
	readonly email: string;
	readonly image: string;
}

export interface RequestFetchIntoLocalBranch extends RepoRequest {
	readonly command: 'fetchIntoLocalBranch';
	readonly remote: string;
	readonly remoteBranch: string;
	readonly localBranch: string;
	readonly force: boolean;
}
export interface ResponseFetchIntoLocalBranch extends ResponseWithErrorInfo {
	readonly command: 'fetchIntoLocalBranch';
}

export interface RequestLoadCommits extends RepoRequest {
	readonly command: 'loadCommits';
	readonly refreshId: number;
	readonly branches: ReadonlyArray<string> | null; // null => Show All
	readonly maxCommits: number;
	readonly showTags: boolean;
	readonly showRemoteBranches: boolean;
	readonly includeCommitsMentionedByReflogs: boolean;
	readonly onlyFollowFirstParent: boolean;
	readonly commitOrdering: CommitOrdering;
	readonly remotes: ReadonlyArray<string>;
	readonly hideRemotes: ReadonlyArray<string>;
	readonly stashes: ReadonlyArray<GitStash>;
}
export interface ResponseLoadCommits extends ResponseWithErrorInfo {
	readonly command: 'loadCommits';
	readonly refreshId: number;
	readonly commits: GitCommit[];
	readonly head: string | null;
	readonly tags: string[];
	readonly moreCommitsAvailable: boolean;
	readonly onlyFollowFirstParent: boolean;
}

export interface RequestLoadConfig extends RepoRequest {
	readonly command: 'loadConfig';
	readonly remotes: ReadonlyArray<string>;
}
export interface ResponseLoadConfig extends ResponseWithErrorInfo {
	readonly command: 'loadConfig';
	readonly repo: string;
	readonly config: GitRepoConfig | null;
}

export interface RequestLoadRepoInfo extends RepoRequest {
	readonly command: 'loadRepoInfo';
	readonly refreshId: number;
	readonly showRemoteBranches: boolean;
	readonly showStashes: boolean;
	readonly hideRemotes: ReadonlyArray<string>;
}
export interface ResponseLoadRepoInfo extends ResponseWithErrorInfo {
	readonly command: 'loadRepoInfo';
	readonly refreshId: number;
	readonly branches: ReadonlyArray<string>;
	readonly head: string | null;
	readonly remotes: ReadonlyArray<string>;
	readonly stashes: ReadonlyArray<GitStash>;
	readonly isRepo: boolean;
}

export interface RequestLoadRepos extends BaseMessage {
	readonly command: 'loadRepos';
	readonly check: boolean;
}
export interface ResponseLoadRepos extends BaseMessage {
	readonly command: 'loadRepos';
	readonly repos: GitRepoSet;
	readonly lastActiveRepo: string | null;
	readonly loadViewTo: LoadGitGraphViewTo;
}

export const enum MergeActionOn {
	Branch = 'Branch',
	RemoteTrackingBranch = 'Remote-tracking Branch',
	Commit = 'Commit'
}
export interface RequestMerge extends RepoRequest {
	readonly command: 'merge';
	readonly obj: string;
	readonly actionOn: MergeActionOn;
	readonly createNewCommit: boolean;
	readonly squash: boolean;
	readonly noCommit: boolean;
}
export interface ResponseMerge extends ResponseWithErrorInfo {
	readonly command: 'merge';
	readonly actionOn: MergeActionOn;
}

export interface RequestOpenExtensionSettings extends BaseMessage {
	readonly command: 'openExtensionSettings';
}
export interface ResponseOpenExtensionSettings extends ResponseWithErrorInfo {
	readonly command: 'openExtensionSettings';
}

export interface RequestOpenExternalDirDiff extends RepoRequest {
	readonly command: 'openExternalDirDiff';
	readonly fromHash: string;
	readonly toHash: string;
	readonly isGui: boolean;
}
export interface ResponseOpenExternalDirDiff extends ResponseWithErrorInfo {
	readonly command: 'openExternalDirDiff';
}

export interface RequestOpenExternalUrl extends BaseMessage {
	readonly command: 'openExternalUrl';
	readonly url: string;
}
export interface ResponseOpenExternalUrl extends ResponseWithErrorInfo {
	readonly command: 'openExternalUrl';
}

export interface RequestOpenFile extends RepoRequest {
	readonly command: 'openFile';
	readonly hash: string;
	readonly filePath: string;
}
export interface ResponseOpenFile extends ResponseWithErrorInfo {
	readonly command: 'openFile';
}

export interface RequestOpenTerminal extends RepoRequest {
	readonly command: 'openTerminal';
	readonly name: string;
}
export interface ResponseOpenTerminal extends ResponseWithErrorInfo {
	readonly command: 'openTerminal';
}

export interface RequestPopStash extends RepoRequest {
	readonly command: 'popStash';
	readonly selector: string;
	readonly reinstateIndex: boolean;
}
export interface ResponsePopStash extends ResponseWithErrorInfo {
	readonly command: 'popStash';
}

export interface RequestPruneRemote extends RepoRequest {
	readonly command: 'pruneRemote';
	readonly name: string;
}
export interface ResponsePruneRemote extends ResponseWithErrorInfo {
	readonly command: 'pruneRemote';
}

export interface RequestPullBranch extends RepoRequest {
	readonly command: 'pullBranch';
	readonly branchName: string;
	readonly remote: string;
	readonly createNewCommit: boolean;
	readonly squash: boolean;
}
export interface ResponsePullBranch extends ResponseWithErrorInfo {
	readonly command: 'pullBranch';
}

export interface RequestPushBranch extends RepoRequest {
	readonly command: 'pushBranch';
	readonly branchName: string;
	readonly remotes: string[];
	readonly setUpstream: boolean;
	readonly mode: GitPushBranchMode;
	readonly willUpdateBranchConfig: boolean;
}
export interface ResponsePushBranch extends ResponseWithMultiErrorInfo {
	readonly command: 'pushBranch';
	readonly willUpdateBranchConfig: boolean;
}

export interface RequestPushStash extends RepoRequest {
	readonly command: 'pushStash';
	readonly message: string;
	readonly includeUntracked: boolean;
}
export interface ResponsePushStash extends ResponseWithErrorInfo {
	readonly command: 'pushStash';
}

export interface RequestPushTag extends RepoRequest {
	readonly command: 'pushTag';
	readonly tagName: string;
	readonly remotes: string[];
	readonly commitHash: string;
	readonly skipRemoteCheck: boolean;
}
export interface ResponsePushTag extends ResponseWithMultiErrorInfo {
	readonly command: 'pushTag';
	readonly repo: string;
	readonly tagName: string;
	readonly remotes: string[];
	readonly commitHash: string;
}

export const enum RebaseActionOn {
	Branch = 'Branch',
	Commit = 'Commit'
}
export interface RequestRebase extends RepoRequest {
	readonly command: 'rebase';
	readonly obj: string;
	readonly actionOn: RebaseActionOn;
	readonly ignoreDate: boolean;
	readonly interactive: boolean;
}
export interface ResponseRebase extends ResponseWithErrorInfo {
	readonly command: 'rebase';
	readonly actionOn: RebaseActionOn;
	readonly interactive: boolean;
}

export interface ResponseRefresh extends BaseMessage {
	readonly command: 'refresh';
}

export interface RequestRenameBranch extends RepoRequest {
	readonly command: 'renameBranch';
	readonly oldName: string;
	readonly newName: string;
}
export interface ResponseRenameBranch extends ResponseWithErrorInfo {
	readonly command: 'renameBranch';
}

export interface RequestRescanForRepos extends BaseMessage {
	readonly command: 'rescanForRepos';
}

export interface RequestResetFileToRevision extends RepoRequest {
	readonly command: 'resetFileToRevision';
	readonly commitHash: string;
	readonly filePath: string;
}
export interface ResponseResetFileToRevision extends ResponseWithErrorInfo {
	readonly command: 'resetFileToRevision';
}

export interface RequestResetToCommit extends RepoRequest {
	readonly command: 'resetToCommit';
	readonly commit: string;
	readonly resetMode: GitResetMode;
}
export interface ResponseResetToCommit extends ResponseWithErrorInfo {
	readonly command: 'resetToCommit';
}

export interface RequestRevertCommit extends RepoRequest {
	readonly command: 'revertCommit';
	readonly commitHash: string;
	readonly parentIndex: number;
}
export interface ResponseRevertCommit extends ResponseWithErrorInfo {
	readonly command: 'revertCommit';
}

export interface RequestSetGlobalViewState extends BaseMessage {
	readonly command: 'setGlobalViewState';
	readonly state: GitGraphViewGlobalState;
}
export interface ResponseSetGlobalViewState extends ResponseWithErrorInfo {
	readonly command: 'setGlobalViewState';
}

export interface RequestSetRepoState extends RepoRequest {
	readonly command: 'setRepoState';
	readonly state: GitRepoState;
}

export interface RequestSetWorkspaceViewState extends BaseMessage {
	readonly command: 'setWorkspaceViewState';
	readonly state: GitGraphViewWorkspaceState;
}
export interface ResponseSetWorkspaceViewState extends ResponseWithErrorInfo {
	readonly command: 'setWorkspaceViewState';
}

export interface RequestShowErrorDialog extends BaseMessage {
	readonly command: 'showErrorMessage';
	readonly message: string;
}

export interface RequestStartCodeReview extends RepoRequest {
	readonly command: 'startCodeReview';
	readonly id: string;
	readonly files: string[];
	readonly lastViewedFile: string | null;
	readonly commitHash: string;
	readonly compareWithHash: string | null;
}
export interface ResponseStartCodeReview extends ResponseWithErrorInfo {
	readonly command: 'startCodeReview';
	readonly codeReview: CodeReview;
	readonly commitHash: string;
	readonly compareWithHash: string | null;
}

export interface RequestTagDetails extends RepoRequest {
	readonly command: 'tagDetails';
	readonly tagName: string;
	readonly commitHash: string;
}
export interface ResponseTagDetails extends ResponseWithErrorInfo {
	readonly command: 'tagDetails';
	readonly tagName: string;
	readonly commitHash: string;
	readonly details: GitTagDetails | null;
}

export interface RequestUpdateCodeReview extends RepoRequest {
	readonly command: 'updateCodeReview';
	readonly id: string;
	readonly remainingFiles: string[];
	readonly lastViewedFile: string | null;
}

export interface ResponseUpdateCodeReview extends ResponseWithErrorInfo {
	readonly command: 'updateCodeReview';
}

export interface RequestViewDiff extends RepoRequest {
	readonly command: 'viewDiff';
	readonly fromHash: string;
	readonly toHash: string;
	readonly oldFilePath: string;
	readonly newFilePath: string;
	readonly type: GitFileStatus;
}
export interface ResponseViewDiff extends ResponseWithErrorInfo {
	readonly command: 'viewDiff';
}

export interface RequestViewDiffWithWorkingFile extends RepoRequest {
	readonly command: 'viewDiffWithWorkingFile';
	readonly hash: string;
	readonly filePath: string;
}
export interface ResponseViewDiffWithWorkingFile extends ResponseWithErrorInfo {
	readonly command: 'viewDiffWithWorkingFile';
}

export interface RequestViewFileAtRevision extends RepoRequest {
	readonly command: 'viewFileAtRevision';
	readonly hash: string;
	readonly filePath: string;
}
export interface ResponseViewFileAtRevision extends ResponseWithErrorInfo {
	readonly command: 'viewFileAtRevision';
}

export interface RequestViewScm extends BaseMessage {
	readonly command: 'viewScm';
}
export interface ResponseViewScm extends ResponseWithErrorInfo {
	readonly command: 'viewScm';
}

export type RequestMessage =
	RequestAddRemote
	| RequestAddTag
	| RequestApplyStash
	| RequestBranchFromStash
	| RequestCheckoutBranch
	| RequestCheckoutCommit
	| RequestCherrypickCommit
	| RequestCleanUntrackedFiles
	| RequestCommitDetails
	| RequestCompareCommits
	| RequestCopyFilePath
	| RequestCopyToClipboard
	| RequestCreateArchive
	| RequestCreateBranch
	| RequestCreatePullRequest
	| RequestDeleteBranch
	| RequestDeleteRemote
	| RequestDeleteRemoteBranch
	| RequestDeleteTag
	| RequestDeleteUserDetails
	| RequestDropCommit
	| RequestDropStash
	| RequestEditRemote
	| RequestEditUserDetails
	| RequestEndCodeReview
	| RequestExportRepoConfig
	| RequestFetch
	| RequestFetchAvatar
	| RequestFetchIntoLocalBranch
	| RequestLoadCommits
	| RequestLoadConfig
	| RequestLoadRepoInfo
	| RequestLoadRepos
	| RequestMerge
	| RequestOpenExtensionSettings
	| RequestOpenExternalDirDiff
	| RequestOpenExternalUrl
	| RequestOpenFile
	| RequestOpenTerminal
	| RequestPopStash
	| RequestPruneRemote
	| RequestPullBranch
	| RequestPushBranch
	| RequestPushStash
	| RequestPushTag
	| RequestRebase
	| RequestRenameBranch
	| RequestRescanForRepos
	| RequestResetFileToRevision
	| RequestResetToCommit
	| RequestRevertCommit
	| RequestSetGlobalViewState
	| RequestSetRepoState
	| RequestSetWorkspaceViewState
	| RequestShowErrorDialog
	| RequestStartCodeReview
	| RequestTagDetails
	| RequestUpdateCodeReview
	| RequestViewDiff
	| RequestViewDiffWithWorkingFile
	| RequestViewFileAtRevision
	| RequestViewScm;

export type ResponseMessage =
	ResponseAddRemote
	| ResponseAddTag
	| ResponseApplyStash
	| ResponseBranchFromStash
	| ResponseCheckoutBranch
	| ResponseCheckoutCommit
	| ResponseCherrypickCommit
	| ResponseCleanUntrackedFiles
	| ResponseCompareCommits
	| ResponseCommitDetails
	| ResponseCopyFilePath
	| ResponseCopyToClipboard
	| ResponseCreateArchive
	| ResponseCreateBranch
	| ResponseCreatePullRequest
	| ResponseDeleteBranch
	| ResponseDeleteRemote
	| ResponseDeleteRemoteBranch
	| ResponseDeleteTag
	| ResponseDeleteUserDetails
	| ResponseDropCommit
	| ResponseDropStash
	| ResponseEditRemote
	| ResponseEditUserDetails
	| ResponseExportRepoConfig
	| ResponseFetch
	| ResponseFetchAvatar
	| ResponseFetchIntoLocalBranch
	| ResponseLoadCommits
	| ResponseLoadConfig
	| ResponseLoadRepoInfo
	| ResponseLoadRepos
	| ResponseMerge
	| ResponseOpenExtensionSettings
	| ResponseOpenExternalDirDiff
	| ResponseOpenExternalUrl
	| ResponseOpenFile
	| ResponseOpenTerminal
	| ResponsePopStash
	| ResponsePruneRemote
	| ResponsePullBranch
	| ResponsePushBranch
	| ResponsePushStash
	| ResponsePushTag
	| ResponseRebase
	| ResponseRefresh
	| ResponseRenameBranch
	| ResponseResetFileToRevision
	| ResponseResetToCommit
	| ResponseRevertCommit
	| ResponseSetGlobalViewState
	| ResponseSetWorkspaceViewState
	| ResponseStartCodeReview
	| ResponseTagDetails
	| ResponseUpdateCodeReview
	| ResponseViewDiff
	| ResponseViewDiffWithWorkingFile
	| ResponseViewFileAtRevision
	| ResponseViewScm;


/** Helper Types */

type PrimitiveTypes = string | number | boolean | symbol | bigint | undefined | null;

/**
 * Make all properties in T writeable
 */
export type Writeable<T> = { -readonly [K in keyof T]: T[K] };

/**
 * Make all properties in T recursively readonly
 */
export type DeepReadonly<T> = T extends PrimitiveTypes
	? T
	: T extends (Array<infer U> | ReadonlyArray<infer U>)
	? ReadonlyArray<DeepReadonly<U>>
	: { readonly [K in keyof T]: DeepReadonly<T[K]> };

/**
 * Make all properties in T recursively writeable
 */
export type DeepWriteable<T> = T extends PrimitiveTypes
	? T
	: T extends (Array<infer U> | ReadonlyArray<infer U>)
	? Array<DeepWriteable<U>>
	: { -readonly [K in keyof T]: DeepWriteable<T[K]> };
-e 

================================================================================
// FILE: ./src/dataSource.ts
================================================================================
import * as cp from 'child_process';
import * as fs from 'fs';
import { decode, encodingExists } from 'iconv-lite';
import * as path from 'path';
import * as vscode from 'vscode';
import { AskpassEnvironment, AskpassManager } from './askpass/askpassManager';
import { getConfig } from './config';
import { Logger } from './logger';
import { CommitOrdering, DateType, DeepWriteable, ErrorInfo, ErrorInfoExtensionPrefix, GitCommit, GitCommitDetails, GitCommitStash, GitConfigLocation, GitFileChange, GitFileStatus, GitPushBranchMode, GitRepoConfig, GitRepoConfigBranches, GitResetMode, GitSignature, GitSignatureStatus, GitStash, GitTagDetails, MergeActionOn, RebaseActionOn, SquashMessageFormat, TagType, Writeable } from './types';
import { GitExecutable, GitVersionRequirement, UNABLE_TO_FIND_GIT_MSG, UNCOMMITTED, abbrevCommit, constructIncompatibleGitVersionMessage, doesVersionMeetRequirement, getPathFromStr, getPathFromUri, openGitTerminal, pathWithTrailingSlash, realpath, resolveSpawnOutput, showErrorMessage } from './utils';
import { Disposable } from './utils/disposable';
import { Event } from './utils/event';

const DRIVE_LETTER_PATH_REGEX = /^[a-z]:\//;
const EOL_REGEX = /\r\n|\r|\n/g;
const INVALID_BRANCH_REGEXP = /^\(.* .*\)$/;
const REMOTE_HEAD_BRANCH_REGEXP = /^remotes\/.*\/HEAD$/;
const GIT_LOG_SEPARATOR = 'XX7Nal-YARtTpjCikii9nJxER19D6diSyk-AWkPb';

export const enum GitConfigKey {
	DiffGuiTool = 'diff.guitool',
	DiffTool = 'diff.tool',
	RemotePushDefault = 'remote.pushdefault',
	UserEmail = 'user.email',
	UserName = 'user.name'
}

const GPG_STATUS_CODE_PARSING_DETAILS: Readonly<{ [statusCode: string]: GpgStatusCodeParsingDetails }> = {
	'GOODSIG': { status: GitSignatureStatus.GoodAndValid, uid: true },
	'BADSIG': { status: GitSignatureStatus.Bad, uid: true },
	'ERRSIG': { status: GitSignatureStatus.CannotBeChecked, uid: false },
	'EXPSIG': { status: GitSignatureStatus.GoodButExpired, uid: true },
	'EXPKEYSIG': { status: GitSignatureStatus.GoodButMadeByExpiredKey, uid: true },
	'REVKEYSIG': { status: GitSignatureStatus.GoodButMadeByRevokedKey, uid: true }
};

/**
 * Interfaces Git Graph with the Git executable to provide all Git integrations.
 */
export class DataSource extends Disposable {
	private readonly logger: Logger;
	private readonly askpassEnv: AskpassEnvironment;
	private gitExecutable!: GitExecutable | null;
	private gitExecutableSupportsGpgInfo!: boolean;
	private gitFormatCommitDetails!: string;
	private gitFormatLog!: string;
	private gitFormatStash!: string;

	/**
	 * Creates the Git Graph Data Source.
	 * @param gitExecutable The Git executable available to Git Graph at startup.
	 * @param onDidChangeGitExecutable The Event emitting the Git executable for Git Graph to use.
	 * @param logger The Git Graph Logger instance.
	 */
	constructor(gitExecutable: GitExecutable | null, onDidChangeConfiguration: Event<vscode.ConfigurationChangeEvent>, onDidChangeGitExecutable: Event<GitExecutable>, logger: Logger) {
		super();
		this.logger = logger;
		this.setGitExecutable(gitExecutable);

		const askpassManager = new AskpassManager();
		this.askpassEnv = askpassManager.getEnv();

		this.registerDisposables(
			onDidChangeConfiguration((event) => {
				if (
					event.affectsConfiguration('git-graph.date.type') || event.affectsConfiguration('git-graph.dateType') ||
					event.affectsConfiguration('git-graph.repository.commits.showSignatureStatus') || event.affectsConfiguration('git-graph.showSignatureStatus') ||
					event.affectsConfiguration('git-graph.repository.useMailmap') || event.affectsConfiguration('git-graph.useMailmap')
				) {
					this.generateGitCommandFormats();
				}
			}),
			onDidChangeGitExecutable((gitExecutable) => {
				this.setGitExecutable(gitExecutable);
			}),
			askpassManager
		);
	}

	/**
	 * Check if the Git executable is unknown.
	 * @returns TRUE => Git executable is unknown, FALSE => Git executable is known.
	 */
	public isGitExecutableUnknown() {
		return this.gitExecutable === null;
	}

	/**
	 * Set the Git executable used by the DataSource.
	 * @param gitExecutable The Git executable.
	 */
	private setGitExecutable(gitExecutable: GitExecutable | null) {
		this.gitExecutable = gitExecutable;
		this.gitExecutableSupportsGpgInfo = gitExecutable !== null && doesVersionMeetRequirement(gitExecutable.version, GitVersionRequirement.GpgInfo);
		this.generateGitCommandFormats();
	}

	/**
	 * Generate the format strings used by various Git commands.
	 */
	private generateGitCommandFormats() {
		const config = getConfig();
		const dateType = config.dateType === DateType.Author ? '%at' : '%ct';
		const useMailmap = config.useMailmap;

		this.gitFormatCommitDetails = [
			'%H', '%P', // Hash & Parent Information
			useMailmap ? '%aN' : '%an', useMailmap ? '%aE' : '%ae', '%at', useMailmap ? '%cN' : '%cn', useMailmap ? '%cE' : '%ce', '%ct', // Author / Commit Information
			...(config.showSignatureStatus && this.gitExecutableSupportsGpgInfo ? ['%G?', '%GS', '%GK'] : ['', '', '']), // GPG Key Information
			'%B' // Body
		].join(GIT_LOG_SEPARATOR);

		this.gitFormatLog = [
			'%H', '%P', // Hash & Parent Information
			useMailmap ? '%aN' : '%an', useMailmap ? '%aE' : '%ae', dateType, // Author / Commit Information
			'%s' // Subject
		].join(GIT_LOG_SEPARATOR);

		this.gitFormatStash = [
			'%H', '%P', '%gD', // Hash, Parent & Selector Information
			useMailmap ? '%aN' : '%an', useMailmap ? '%aE' : '%ae', dateType, // Author / Commit Information
			'%s' // Subject
		].join(GIT_LOG_SEPARATOR);
	}


	/* Get Data Methods - Core */

	/**
	 * Get the high-level information of a repository.
	 * @param repo The path of the repository.
	 * @param showRemoteBranches Are remote branches shown.
	 * @param showStashes Are stashes shown.
	 * @param hideRemotes An array of hidden remotes.
	 * @returns The repositories information.
	 */
	public getRepoInfo(repo: string, showRemoteBranches: boolean, showStashes: boolean, hideRemotes: ReadonlyArray<string>): Promise<GitRepoInfo> {
		return Promise.all([
			this.getBranches(repo, showRemoteBranches, hideRemotes),
			this.getRemotes(repo),
			showStashes ? this.getStashes(repo) : Promise.resolve([])
		]).then((results) => {
			return { branches: results[0].branches, head: results[0].head, remotes: results[1], stashes: results[2], error: null };
		}).catch((errorMessage) => {
			return { branches: [], head: null, remotes: [], stashes: [], error: errorMessage };
		});
	}

	/**
	 * Get the commits in a repository.
	 * @param repo The path of the repository.
	 * @param branches The list of branch heads to display, or NULL (show all).
	 * @param maxCommits The maximum number of commits to return.
	 * @param showTags Are tags are shown.
	 * @param showRemoteBranches Are remote branches shown.
	 * @param includeCommitsMentionedByReflogs Should commits mentioned by reflogs being included.
	 * @param onlyFollowFirstParent Only follow the first parent of commits.
	 * @param commitOrdering The order for commits to be returned.
	 * @param remotes An array of known remotes.
	 * @param hideRemotes An array of hidden remotes.
	 * @param stashes An array of all stashes in the repository.
	 * @returns The commits in the repository.
	 */
	public getCommits(repo: string, branches: ReadonlyArray<string> | null, maxCommits: number, showTags: boolean, showRemoteBranches: boolean, includeCommitsMentionedByReflogs: boolean, onlyFollowFirstParent: boolean, commitOrdering: CommitOrdering, remotes: ReadonlyArray<string>, hideRemotes: ReadonlyArray<string>, stashes: ReadonlyArray<GitStash>): Promise<GitCommitData> {
		const config = getConfig();
		return Promise.all([
			this.getLog(repo, branches, maxCommits + 1, showTags && config.showCommitsOnlyReferencedByTags, showRemoteBranches, includeCommitsMentionedByReflogs, onlyFollowFirstParent, commitOrdering, remotes, hideRemotes, stashes),
			this.getRefs(repo, showRemoteBranches, config.showRemoteHeads, hideRemotes).then((refData: GitRefData) => refData, (errorMessage: string) => errorMessage)
		]).then(async (results) => {
			let commits: GitCommitRecord[] = results[0], refData: GitRefData | string = results[1], i;
			let moreCommitsAvailable = commits.length === maxCommits + 1;
			if (moreCommitsAvailable) commits.pop();

			// It doesn't matter if getRefs() was rejected if no commits exist
			if (typeof refData === 'string') {
				// getRefs() returned an error message (string)
				if (commits.length > 0) {
					// Commits exist, throw the error
					throw refData;
				} else {
					// No commits exist, so getRefs() will always return an error. Set refData to the default value
					refData = { head: null, heads: [], tags: [], remotes: [] };
				}
			}

			if (refData.head !== null && config.showUncommittedChanges) {
				for (i = 0; i < commits.length; i++) {
					if (refData.head === commits[i].hash) {
						const numUncommittedChanges = await this.getUncommittedChanges(repo);
						if (numUncommittedChanges > 0) {
							commits.unshift({ hash: UNCOMMITTED, parents: [refData.head], author: '*', email: '', date: Math.round((new Date()).getTime() / 1000), message: 'Uncommitted Changes (' + numUncommittedChanges + ')' });
						}
						break;
					}
				}
			}

			let commitNodes: DeepWriteable<GitCommit>[] = [];
			let commitLookup: { [hash: string]: number } = {};

			for (i = 0; i < commits.length; i++) {
				commitLookup[commits[i].hash] = i;
				commitNodes.push({ ...commits[i], heads: [], tags: [], remotes: [], stash: null });
			}

			/* Insert Stashes */
			let toAdd: { index: number, data: GitStash }[] = [];
			for (i = 0; i < stashes.length; i++) {
				if (typeof commitLookup[stashes[i].hash] === 'number') {
					commitNodes[commitLookup[stashes[i].hash]].stash = {
						selector: stashes[i].selector,
						baseHash: stashes[i].baseHash,
						untrackedFilesHash: stashes[i].untrackedFilesHash
					};
				} else if (typeof commitLookup[stashes[i].baseHash] === 'number') {
					toAdd.push({ index: commitLookup[stashes[i].baseHash], data: stashes[i] });
				}
			}
			toAdd.sort((a, b) => a.index !== b.index ? a.index - b.index : b.data.date - a.data.date);
			for (i = toAdd.length - 1; i >= 0; i--) {
				let stash = toAdd[i].data;
				commitNodes.splice(toAdd[i].index, 0, {
					hash: stash.hash,
					parents: [stash.baseHash],
					author: stash.author,
					email: stash.email,
					date: stash.date,
					message: stash.message,
					heads: [], tags: [], remotes: [],
					stash: {
						selector: stash.selector,
						baseHash: stash.baseHash,
						untrackedFilesHash: stash.untrackedFilesHash
					}
				});
			}
			for (i = 0; i < commitNodes.length; i++) {
				// Correct commit lookup after stashes have been spliced in
				commitLookup[commitNodes[i].hash] = i;
			}

			/* Annotate Heads */
			for (i = 0; i < refData.heads.length; i++) {
				if (typeof commitLookup[refData.heads[i].hash] === 'number') commitNodes[commitLookup[refData.heads[i].hash]].heads.push(refData.heads[i].name);
			}

			/* Annotate Tags */
			if (showTags) {
				for (i = 0; i < refData.tags.length; i++) {
					if (typeof commitLookup[refData.tags[i].hash] === 'number') commitNodes[commitLookup[refData.tags[i].hash]].tags.push({ name: refData.tags[i].name, annotated: refData.tags[i].annotated });
				}
			}

			/* Annotate Remotes */
			for (i = 0; i < refData.remotes.length; i++) {
				if (typeof commitLookup[refData.remotes[i].hash] === 'number') {
					let name = refData.remotes[i].name;
					let remote = remotes.find(remote => name.startsWith(remote + '/'));
					commitNodes[commitLookup[refData.remotes[i].hash]].remotes.push({ name: name, remote: remote ? remote : null });
				}
			}

			return {
				commits: commitNodes,
				head: refData.head,
				tags: unique(refData.tags.map((tag) => tag.name)),
				moreCommitsAvailable: moreCommitsAvailable,
				error: null
			};
		}).catch((errorMessage) => {
			return { commits: [], head: null, tags: [], moreCommitsAvailable: false, error: errorMessage };
		});
	}

	/**
	 * Get various Git config variables for a repository that are consumed by the Git Graph View.
	 * @param repo The path of the repository.
	 * @param remotes An array of known remotes.
	 * @returns The config data.
	 */
	public getConfig(repo: string, remotes: ReadonlyArray<string>): Promise<GitRepoConfigData> {
		return Promise.all([
			this.getConfigList(repo),
			this.getConfigList(repo, GitConfigLocation.Local),
			this.getConfigList(repo, GitConfigLocation.Global)
		]).then((results) => {
			const consolidatedConfigs = results[0], localConfigs = results[1], globalConfigs = results[2];

			const branches: GitRepoConfigBranches = {};
			Object.keys(localConfigs).forEach((key) => {
				if (key.startsWith('branch.')) {
					if (key.endsWith('.remote')) {
						const branchName = key.substring(7, key.length - 7);
						branches[branchName] = {
							pushRemote: typeof branches[branchName] !== 'undefined' ? branches[branchName].pushRemote : null,
							remote: localConfigs[key]
						};
					} else if (key.endsWith('.pushremote')) {
						const branchName = key.substring(7, key.length - 11);
						branches[branchName] = {
							pushRemote: localConfigs[key],
							remote: typeof branches[branchName] !== 'undefined' ? branches[branchName].remote : null
						};
					}
				}
			});

			return {
				config: {
					branches: branches,
					diffTool: getConfigValue(consolidatedConfigs, GitConfigKey.DiffTool),
					guiDiffTool: getConfigValue(consolidatedConfigs, GitConfigKey.DiffGuiTool),
					pushDefault: getConfigValue(consolidatedConfigs, GitConfigKey.RemotePushDefault),
					remotes: remotes.map((remote) => ({
						name: remote,
						url: getConfigValue(localConfigs, 'remote.' + remote + '.url'),
						pushUrl: getConfigValue(localConfigs, 'remote.' + remote + '.pushurl')
					})),
					user: {
						name: {
							local: getConfigValue(localConfigs, GitConfigKey.UserName),
							global: getConfigValue(globalConfigs, GitConfigKey.UserName)
						},
						email: {
							local: getConfigValue(localConfigs, GitConfigKey.UserEmail),
							global: getConfigValue(globalConfigs, GitConfigKey.UserEmail)
						}
					}
				},
				error: null
			};
		}).catch((errorMessage) => {
			return { config: null, error: errorMessage };
		});
	}


	/* Get Data Methods - Commit Details View */

	/**
	 * Get the commit details for the Commit Details View.
	 * @param repo The path of the repository.
	 * @param commitHash The hash of the commit open in the Commit Details View.
	 * @param hasParents Does the commit have parents
	 * @returns The commit details.
	 */
	public getCommitDetails(repo: string, commitHash: string, hasParents: boolean): Promise<GitCommitDetailsData> {
		const fromCommit = commitHash + (hasParents ? '^' : '');
		return Promise.all([
			this.getCommitDetailsBase(repo, commitHash),
			this.getDiffNameStatus(repo, fromCommit, commitHash),
			this.getDiffNumStat(repo, fromCommit, commitHash)
		]).then((results) => {
			results[0].fileChanges = generateFileChanges(results[1], results[2], null);
			return { commitDetails: results[0], error: null };
		}).catch((errorMessage) => {
			return { commitDetails: null, error: errorMessage };
		});
	}

	/**
	 * Get the stash details for the Commit Details View.
	 * @param repo The path of the repository.
	 * @param commitHash The hash of the stash commit open in the Commit Details View.
	 * @param stash The stash.
	 * @returns The stash details.
	 */
	public getStashDetails(repo: string, commitHash: string, stash: GitCommitStash): Promise<GitCommitDetailsData> {
		return Promise.all([
			this.getCommitDetailsBase(repo, commitHash),
			this.getDiffNameStatus(repo, stash.baseHash, commitHash),
			this.getDiffNumStat(repo, stash.baseHash, commitHash),
			stash.untrackedFilesHash !== null ? this.getDiffNameStatus(repo, stash.untrackedFilesHash, stash.untrackedFilesHash) : Promise.resolve([]),
			stash.untrackedFilesHash !== null ? this.getDiffNumStat(repo, stash.untrackedFilesHash, stash.untrackedFilesHash) : Promise.resolve([])
		]).then((results) => {
			results[0].fileChanges = generateFileChanges(results[1], results[2], null);
			if (stash.untrackedFilesHash !== null) {
				generateFileChanges(results[3], results[4], null).forEach((fileChange) => {
					if (fileChange.type === GitFileStatus.Added) {
						fileChange.type = GitFileStatus.Untracked;
						results[0].fileChanges.push(fileChange);
					}
				});
			}
			return { commitDetails: results[0], error: null };
		}).catch((errorMessage) => {
			return { commitDetails: null, error: errorMessage };
		});
	}

	/**
	 * Get the uncommitted details for the Commit Details View.
	 * @param repo The path of the repository.
	 * @returns The uncommitted details.
	 */
	public getUncommittedDetails(repo: string): Promise<GitCommitDetailsData> {
		return Promise.all([
			this.getDiffNameStatus(repo, 'HEAD', ''),
			this.getDiffNumStat(repo, 'HEAD', ''),
			this.getStatus(repo)
		]).then((results) => {
			return {
				commitDetails: {
					hash: UNCOMMITTED, parents: [],
					author: '', authorEmail: '', authorDate: 0,
					committer: '', committerEmail: '', committerDate: 0, signature: null,
					body: '', fileChanges: generateFileChanges(results[0], results[1], results[2])
				},
				error: null
			};
		}).catch((errorMessage) => {
			return { commitDetails: null, error: errorMessage };
		});
	}

	/**
	 * Get the comparison details for the Commit Comparison View.
	 * @param repo The path of the repository.
	 * @param fromHash The commit hash the comparison is from.
	 * @param toHash The commit hash the comparison is to.
	 * @returns The comparison details.
	 */
	public getCommitComparison(repo: string, fromHash: string, toHash: string): Promise<GitCommitComparisonData> {
		return Promise.all<DiffNameStatusRecord[], DiffNumStatRecord[], GitStatusFiles | null>([
			this.getDiffNameStatus(repo, fromHash, toHash === UNCOMMITTED ? '' : toHash),
			this.getDiffNumStat(repo, fromHash, toHash === UNCOMMITTED ? '' : toHash),
			toHash === UNCOMMITTED ? this.getStatus(repo) : Promise.resolve(null)
		]).then((results) => {
			return {
				fileChanges: generateFileChanges(results[0], results[1], results[2]),
				error: null
			};
		}).catch((errorMessage) => {
			return { fileChanges: [], error: errorMessage };
		});
	}

	/**
	 * Get the contents of a file at a specific revision.
	 * @param repo The path of the repository.
	 * @param commitHash The commit hash specifying the revision of the file.
	 * @param filePath The path of the file relative to the repositories root.
	 * @returns The file contents.
	 */
	public getCommitFile(repo: string, commitHash: string, filePath: string) {
		return this._spawnGit(['show', commitHash + ':' + filePath], repo, stdout => {
			const encoding = getConfig(repo).fileEncoding;
			return decode(stdout, encodingExists(encoding) ? encoding : 'utf8');
		});
	}


	/* Get Data Methods - General */

	/**
	 * Get the subject of a commit.
	 * @param repo The path of the repository.
	 * @param commitHash The commit hash.
	 * @returns The subject string, or NULL if an error occurred.
	 */
	public getCommitSubject(repo: string, commitHash: string): Promise<string | null> {
		return this.spawnGit(['-c', 'log.showSignature=false', 'log', '--format=%s', '-n', '1', commitHash, '--'], repo, (stdout) => {
			return stdout.trim().replace(/\s+/g, ' ');
		}).then((subject) => subject, () => null);
	}

	/**
	 * Get the URL of a repositories remote.
	 * @param repo The path of the repository.
	 * @param remote The name of the remote.
	 * @returns The URL, or NULL if an error occurred.
	 */
	public getRemoteUrl(repo: string, remote: string): Promise<string | null> {
		return this.spawnGit(['config', '--get', 'remote.' + remote + '.url'], repo, (stdout) => {
			return stdout.split(EOL_REGEX)[0];
		}).then((url) => url, () => null);
	}

	/**
	 * Check to see if a file has been renamed between a commit and the working tree, and return the new file path.
	 * @param repo The path of the repository.
	 * @param commitHash The commit hash where `oldFilePath` is known to have existed.
	 * @param oldFilePath The file path that may have been renamed.
	 * @returns The new renamed file path, or NULL if either: the file wasn't renamed or the Git command failed to execute.
	 */
	public getNewPathOfRenamedFile(repo: string, commitHash: string, oldFilePath: string) {
		return this.getDiffNameStatus(repo, commitHash, '', 'R').then((renamed) => {
			const renamedRecordForFile = renamed.find((record) => record.oldFilePath === oldFilePath);
			return renamedRecordForFile ? renamedRecordForFile.newFilePath : null;
		}).catch(() => null);
	}

	/**
	 * Get the details of a tag.
	 * @param repo The path of the repository.
	 * @param tagName The name of the tag.
	 * @returns The tag details.
	 */
	public getTagDetails(repo: string, tagName: string): Promise<GitTagDetailsData> {
		if (this.gitExecutable !== null && !doesVersionMeetRequirement(this.gitExecutable.version, GitVersionRequirement.TagDetails)) {
			return Promise.resolve({ details: null, error: constructIncompatibleGitVersionMessage(this.gitExecutable, GitVersionRequirement.TagDetails, 'retrieving Tag Details') });
		}

		const ref = 'refs/tags/' + tagName;
		return this.spawnGit(['for-each-ref', ref, '--format=' + ['%(objectname)', '%(taggername)', '%(taggeremail)', '%(taggerdate:unix)', '%(contents:signature)', '%(contents)'].join(GIT_LOG_SEPARATOR)], repo, (stdout) => {
			const data = stdout.split(GIT_LOG_SEPARATOR);
			return {
				hash: data[0],
				taggerName: data[1],
				taggerEmail: data[2].substring(data[2].startsWith('<') ? 1 : 0, data[2].length - (data[2].endsWith('>') ? 1 : 0)),
				taggerDate: parseInt(data[3]),
				message: removeTrailingBlankLines(data.slice(5).join(GIT_LOG_SEPARATOR).replace(data[4], '').split(EOL_REGEX)).join('\n'),
				signed: data[4] !== ''
			};
		}).then(async (tag) => ({
			details: {
				hash: tag.hash,
				taggerName: tag.taggerName,
				taggerEmail: tag.taggerEmail,
				taggerDate: tag.taggerDate,
				message: tag.message,
				signature: tag.signed
					? await this.getTagSignature(repo, ref)
					: null
			},
			error: null
		})).catch((errorMessage) => ({
			details: null,
			error: errorMessage
		}));
	}

	/**
	 * Get the submodules of a repository.
	 * @param repo The path of the repository.
	 * @returns An array of the paths of the submodules.
	 */
	public getSubmodules(repo: string) {
		return new Promise<string[]>(resolve => {
			fs.readFile(path.join(repo, '.gitmodules'), { encoding: 'utf8' }, async (err, data) => {
				let submodules: string[] = [];
				if (!err) {
					let lines = data.split(EOL_REGEX), inSubmoduleSection = false, match;
					const section = /^\s*\[.*\]\s*$/, submodule = /^\s*\[submodule "([^"]+)"\]\s*$/, pathProp = /^\s*path\s+=\s+(.*)$/;

					for (let i = 0; i < lines.length; i++) {
						if (lines[i].match(section) !== null) {
							inSubmoduleSection = lines[i].match(submodule) !== null;
							continue;
						}

						if (inSubmoduleSection && (match = lines[i].match(pathProp)) !== null) {
							let root = await this.repoRoot(getPathFromUri(vscode.Uri.file(path.join(repo, getPathFromStr(match[1])))));
							if (root !== null && !submodules.includes(root)) {
								submodules.push(root);
							}
						}
					}
				}
				resolve(submodules);
			});
		});
	}


	/* Repository Info Methods */

	/**
	 * Check if there are any staged changes in the repository.
	 * @param repo The path of the repository.
	 * @returns TRUE => Staged Changes, FALSE => No Staged Changes.
	 */
	private areStagedChanges(repo: string) {
		return this.spawnGit(['diff-index', 'HEAD'], repo, (stdout) => stdout !== '').then(changes => changes, () => false);
	}

	/**
	 * Get the root of the repository containing the specified path.
	 * @param pathOfPotentialRepo The path that is potentially a repository (or is contained within a repository).
	 * @returns STRING => The root of the repository, NULL => `pathOfPotentialRepo` is not in a repository.
	 */
	public repoRoot(pathOfPotentialRepo: string) {
		return this.spawnGit(['rev-parse', '--show-toplevel'], pathOfPotentialRepo, (stdout) => getPathFromUri(vscode.Uri.file(path.normalize(stdout.trim())))).then(async (pathReturnedByGit) => {
			if (process.platform === 'win32') {
				// On Windows Mapped Network Drives with Git >= 2.25.0, `git rev-parse --show-toplevel` returns the UNC Path for the Mapped Network Drive, instead of the Drive Letter.
				// Attempt to replace the UNC Path with the Drive Letter.
				let driveLetterPathMatch: RegExpMatchArray | null;
				if ((driveLetterPathMatch = pathOfPotentialRepo.match(DRIVE_LETTER_PATH_REGEX)) && !pathReturnedByGit.match(DRIVE_LETTER_PATH_REGEX)) {
					const realPathForDriveLetter = pathWithTrailingSlash(await realpath(driveLetterPathMatch[0], true));
					if (realPathForDriveLetter !== driveLetterPathMatch[0] && pathReturnedByGit.startsWith(realPathForDriveLetter)) {
						pathReturnedByGit = driveLetterPathMatch[0] + pathReturnedByGit.substring(realPathForDriveLetter.length);
					}
				}
			}
			let path = pathOfPotentialRepo;
			let first = path.indexOf('/');
			while (true) {
				if (pathReturnedByGit === path || pathReturnedByGit === await realpath(path)) return path;
				let next = path.lastIndexOf('/');
				if (first !== next && next > -1) {
					path = path.substring(0, next);
				} else {
					return pathReturnedByGit;
				}
			}
		}).catch(() => null); // null => path is not in a repo
	}


	/* Git Action Methods - Remotes */

	/**
	 * Add a new remote to a repository.
	 * @param repo The path of the repository.
	 * @param name The name of the remote.
	 * @param url The URL of the remote.
	 * @param pushUrl The Push URL of the remote.
	 * @param fetch Fetch the remote after it is added.
	 * @returns The ErrorInfo from the executed command.
	 */
	public async addRemote(repo: string, name: string, url: string, pushUrl: string | null, fetch: boolean) {
		let status = await this.runGitCommand(['remote', 'add', name, url], repo);
		if (status !== null) return status;

		if (pushUrl !== null) {
			status = await this.runGitCommand(['remote', 'set-url', name, '--push', pushUrl], repo);
			if (status !== null) return status;
		}

		return fetch ? this.fetch(repo, name, false, false) : null;
	}

	/**
	 * Delete an existing remote from a repository.
	 * @param repo The path of the repository.
	 * @param name The name of the remote.
	 * @returns The ErrorInfo from the executed command.
	 */
	public deleteRemote(repo: string, name: string) {
		return this.runGitCommand(['remote', 'remove', name], repo);
	}

	/**
	 * Edit an existing remote of a repository.
	 * @param repo The path of the repository.
	 * @param nameOld The old name of the remote.
	 * @param nameNew The new name of the remote.
	 * @param urlOld The old URL of the remote.
	 * @param urlNew The new URL of the remote.
	 * @param pushUrlOld The old Push URL of the remote.
	 * @param pushUrlNew The new Push URL of the remote.
	 * @returns The ErrorInfo from the executed command.
	 */
	public async editRemote(repo: string, nameOld: string, nameNew: string, urlOld: string | null, urlNew: string | null, pushUrlOld: string | null, pushUrlNew: string | null) {
		if (nameOld !== nameNew) {
			let status = await this.runGitCommand(['remote', 'rename', nameOld, nameNew], repo);
			if (status !== null) return status;
		}

		if (urlOld !== urlNew) {
			let args = ['remote', 'set-url', nameNew];
			if (urlNew === null) args.push('--delete', urlOld!);
			else if (urlOld === null) args.push('--add', urlNew);
			else args.push(urlNew, urlOld);

			let status = await this.runGitCommand(args, repo);
			if (status !== null) return status;
		}

		if (pushUrlOld !== pushUrlNew) {
			let args = ['remote', 'set-url', '--push', nameNew];
			if (pushUrlNew === null) args.push('--delete', pushUrlOld!);
			else if (pushUrlOld === null) args.push('--add', pushUrlNew);
			else args.push(pushUrlNew, pushUrlOld);

			let status = await this.runGitCommand(args, repo);
			if (status !== null) return status;
		}

		return null;
	}

	/**
	 * Prune an existing remote of a repository.
	 * @param repo The path of the repository.
	 * @param name The name of the remote.
	 * @returns The ErrorInfo from the executed command.
	 */
	public pruneRemote(repo: string, name: string) {
		return this.runGitCommand(['remote', 'prune', name], repo);
	}


	/* Git Action Methods - Tags */

	/**
	 * Add a new tag to a commit.
	 * @param repo The path of the repository.
	 * @param tagName The name of the tag.
	 * @param commitHash The hash of the commit the tag should be added to.
	 * @param type Is the tag annotated or lightweight.
	 * @param message The message of the tag (if it is an annotated tag).
	 * @param force Force add the tag, replacing an existing tag with the same name (if it exists).
	 * @returns The ErrorInfo from the executed command.
	 */
	public addTag(repo: string, tagName: string, commitHash: string, type: TagType, message: string, force: boolean) {
		const args = ['tag'];
		if (force) {
			args.push('-f');
		}
		if (type === TagType.Lightweight) {
			args.push(tagName);
		} else {
			args.push(getConfig().signTags ? '-s' : '-a', tagName, '-m', message);
		}
		args.push(commitHash);
		return this.runGitCommand(args, repo);
	}

	/**
	 * Delete an existing tag from a repository.
	 * @param repo The path of the repository.
	 * @param tagName The name of the tag.
	 * @param deleteOnRemote The name of the remote to delete the tag on, or NULL.
	 * @returns The ErrorInfo from the executed command.
	 */
	public async deleteTag(repo: string, tagName: string, deleteOnRemote: string | null) {
		if (deleteOnRemote !== null) {
			let status = await this.runGitCommand(['push', deleteOnRemote, '--delete', tagName], repo);
			if (status !== null) return status;
		}
		return this.runGitCommand(['tag', '-d', tagName], repo);
	}


	/* Git Action Methods - Remote Sync */

	/**
	 * Fetch from the repositories remote(s).
	 * @param repo The path of the repository.
	 * @param remote The remote to fetch, or NULL (fetch all remotes).
	 * @param prune Is pruning enabled.
	 * @param pruneTags Should tags be pruned.
	 * @returns The ErrorInfo from the executed command.
	 */
	public fetch(repo: string, remote: string | null, prune: boolean, pruneTags: boolean) {
		let args = ['fetch', remote === null ? '--all' : remote];

		if (prune) {
			args.push('--prune');
		}
		if (pruneTags) {
			if (!prune) {
				return Promise.resolve('In order to Prune Tags, pruning must also be enabled when fetching from ' + (remote !== null ? 'a remote' : 'remote(s)') + '.');
			} else if (this.gitExecutable !== null && !doesVersionMeetRequirement(this.gitExecutable.version, GitVersionRequirement.FetchAndPruneTags)) {
				return Promise.resolve(constructIncompatibleGitVersionMessage(this.gitExecutable, GitVersionRequirement.FetchAndPruneTags, 'pruning tags when fetching'));
			}
			args.push('--prune-tags');
		}

		return this.runGitCommand(args, repo);
	}

	/**
	 * Push a branch to a remote.
	 * @param repo The path of the repository.
	 * @param branchName The name of the branch to push.
	 * @param remote The remote to push the branch to.
	 * @param setUpstream Set the branches upstream.
	 * @param mode The mode of the push.
	 * @returns The ErrorInfo from the executed command.
	 */
	public pushBranch(repo: string, branchName: string, remote: string, setUpstream: boolean, mode: GitPushBranchMode) {
		let args = ['push'];
		args.push(remote, branchName);
		if (setUpstream) args.push('--set-upstream');
		if (mode !== GitPushBranchMode.Normal) args.push('--' + mode);

		return this.runGitCommand(args, repo);
	}

	/**
	 * Push a branch to multiple remotes.
	 * @param repo The path of the repository.
	 * @param branchName The name of the branch to push.
	 * @param remotes The remotes to push the branch to.
	 * @param setUpstream Set the branches upstream.
	 * @param mode The mode of the push.
	 * @returns The ErrorInfo's from the executed commands.
	 */
	public async pushBranchToMultipleRemotes(repo: string, branchName: string, remotes: string[], setUpstream: boolean, mode: GitPushBranchMode): Promise<ErrorInfo[]> {
		if (remotes.length === 0) {
			return ['No remote(s) were specified to push the branch ' + branchName + ' to.'];
		}

		const results: ErrorInfo[] = [];
		for (let i = 0; i < remotes.length; i++) {
			const result = await this.pushBranch(repo, branchName, remotes[i], setUpstream, mode);
			results.push(result);
			if (result !== null) break;
		}
		return results;
	}

	/**
	 * Push a tag to remote(s).
	 * @param repo The path of the repository.
	 * @param tagName The name of the tag to push.
	 * @param remotes The remote(s) to push the tag to.
	 * @param commitHash The commit hash the tag is on.
	 * @param skipRemoteCheck Skip checking that the tag is on each of the `remotes`.
	 * @returns The ErrorInfo's from the executed commands.
	 */
	public async pushTag(repo: string, tagName: string, remotes: string[], commitHash: string, skipRemoteCheck: boolean): Promise<ErrorInfo[]> {
		if (remotes.length === 0) {
			return ['No remote(s) were specified to push the tag ' + tagName + ' to.'];
		}

		if (!skipRemoteCheck) {
			const remotesContainingCommit = await this.getRemotesContainingCommit(repo, commitHash, remotes).catch(() => remotes);
			const remotesNotContainingCommit = remotes.filter((remote) => !remotesContainingCommit.includes(remote));
			if (remotesNotContainingCommit.length > 0) {
				return [ErrorInfoExtensionPrefix.PushTagCommitNotOnRemote + JSON.stringify(remotesNotContainingCommit)];
			}
		}

		const results: ErrorInfo[] = [];
		for (let i = 0; i < remotes.length; i++) {
			const result = await this.runGitCommand(['push', remotes[i], tagName], repo);
			results.push(result);
			if (result !== null) break;
		}
		return results;
	}


	/* Git Action Methods - Branches */

	/**
	 * Checkout a branch in a repository.
	 * @param repo The path of the repository.
	 * @param branchName The name of the branch to checkout.
	 * @param remoteBranch The name of the remote branch to check out (if not NULL).
	 * @returns The ErrorInfo from the executed command.
	 */
	public checkoutBranch(repo: string, branchName: string, remoteBranch: string | null) {
		let args = ['checkout'];
		if (remoteBranch === null) args.push(branchName);
		else args.push('-b', branchName, remoteBranch);

		return this.runGitCommand(args, repo);
	}

	/**
	 * Create a branch at a commit.
	 * @param repo The path of the repository.
	 * @param branchName The name of the branch.
	 * @param commitHash The hash of the commit the branch should be created at.
	 * @param checkout Check out the branch after it is created.
	 * @param force Force create the branch, replacing an existing branch with the same name (if it exists).
	 * @returns The ErrorInfo's from the executed command(s).
	 */
	public async createBranch(repo: string, branchName: string, commitHash: string, checkout: boolean, force: boolean) {
		const args = [];
		if (checkout && !force) {
			args.push('checkout', '-b');
		} else {
			args.push('branch');
			if (force) {
				args.push('-f');
			}
		}
		args.push(branchName, commitHash);

		const statuses = [await this.runGitCommand(args, repo)];
		if (statuses[0] === null && checkout && force) {
			statuses.push(await this.checkoutBranch(repo, branchName, null));
		}
		return statuses;
	}

	/**
	 * Delete a branch in a repository.
	 * @param repo The path of the repository.
	 * @param branchName The name of the branch.
	 * @param force Should force the branch to be deleted (even if not merged).
	 * @returns The ErrorInfo from the executed command.
	 */
	public deleteBranch(repo: string, branchName: string, force: boolean) {
		return this.runGitCommand(['branch', force ? '-D' : '-d', branchName], repo);
	}

	/**
	 * Delete a remote branch in a repository.
	 * @param repo The path of the repository.
	 * @param branchName The name of the branch.
	 * @param remote The name of the remote to delete the branch on.
	 * @returns The ErrorInfo from the executed command.
	 */
	public async deleteRemoteBranch(repo: string, branchName: string, remote: string) {
		let remoteStatus = await this.runGitCommand(['push', remote, '--delete', branchName], repo);
		if (remoteStatus !== null && (new RegExp('remote ref does not exist', 'i')).test(remoteStatus)) {
			let trackingBranchStatus = await this.runGitCommand(['branch', '-d', '-r', remote + '/' + branchName], repo);
			return trackingBranchStatus === null ? null : 'Branch does not exist on the remote, deleting the remote tracking branch ' + remote + '/' + branchName + '.\n' + trackingBranchStatus;
		}
		return remoteStatus;
	}

	/**
	 * Fetch a remote branch into a local branch.
	 * @param repo The path of the repository.
	 * @param remote The name of the remote containing the remote branch.
	 * @param remoteBranch The name of the remote branch.
	 * @param localBranch The name of the local branch.
	 * @param force Force fetch the remote branch.
	 * @returns The ErrorInfo from the executed command.
	 */
	public fetchIntoLocalBranch(repo: string, remote: string, remoteBranch: string, localBranch: string, force: boolean) {
		const args = ['fetch'];
		if (force) {
			args.push('-f');
		}
		args.push(remote, remoteBranch + ':' + localBranch);
		return this.runGitCommand(args, repo);
	}

	/**
	 * Pull a remote branch into the current branch.
	 * @param repo The path of the repository.
	 * @param branchName The name of the remote branch.
	 * @param remote The name of the remote containing the remote branch.
	 * @param createNewCommit Is `--no-ff` enabled if a merge is required.
	 * @param squash Is `--squash` enabled if a merge is required.
	 * @returns The ErrorInfo from the executed command.
	 */
	public pullBranch(repo: string, branchName: string, remote: string, createNewCommit: boolean, squash: boolean) {
		const args = ['pull', remote, branchName], config = getConfig();
		if (squash) {
			args.push('--squash');
		} else if (createNewCommit) {
			args.push('--no-ff');
		}
		if (config.signCommits) {
			args.push('-S');
		}
		return this.runGitCommand(args, repo).then((pullStatus) => {
			return pullStatus === null && squash
				? this.commitSquashIfStagedChangesExist(repo, remote + '/' + branchName, MergeActionOn.Branch, config.squashPullMessageFormat, config.signCommits)
				: pullStatus;
		});
	}

	/**
	 * Rename a branch in a repository.
	 * @param repo The path of the repository.
	 * @param oldName The old name of the branch.
	 * @param newName The new name of the branch.
	 * @returns The ErrorInfo from the executed command.
	 */
	public renameBranch(repo: string, oldName: string, newName: string) {
		return this.runGitCommand(['branch', '-m', oldName, newName], repo);
	}


	/* Git Action Methods - Branches & Commits */

	/**
	 * Merge a branch or commit into the current branch.
	 * @param repo The path of the repository.
	 * @param obj The object to be merged into the current branch.
	 * @param actionOn Is the merge on a branch, remote-tracking branch or commit.
	 * @param createNewCommit Is `--no-ff` enabled.
	 * @param squash Is `--squash` enabled.
	 * @param noCommit Is `--no-commit` enabled.
	 * @returns The ErrorInfo from the executed command.
	 */
	public merge(repo: string, obj: string, actionOn: MergeActionOn, createNewCommit: boolean, squash: boolean, noCommit: boolean) {
		const args = ['merge', obj], config = getConfig();
		if (squash) {
			args.push('--squash');
		} else if (createNewCommit) {
			args.push('--no-ff');
		}
		if (noCommit) {
			args.push('--no-commit');
		}
		if (config.signCommits) {
			args.push('-S');
		}
		return this.runGitCommand(args, repo).then((mergeStatus) => {
			return mergeStatus === null && squash && !noCommit
				? this.commitSquashIfStagedChangesExist(repo, obj, actionOn, config.squashMergeMessageFormat, config.signCommits)
				: mergeStatus;
		});
	}

	/**
	 * Rebase the current branch on a branch or commit.
	 * @param repo The path of the repository.
	 * @param obj The object the current branch will be rebased onto.
	 * @param actionOn Is the rebase on a branch or commit.
	 * @param ignoreDate Is `--ignore-date` enabled.
	 * @param interactive Should the rebase be performed interactively.
	 * @returns The ErrorInfo from the executed command.
	 */
	public rebase(repo: string, obj: string, actionOn: RebaseActionOn, ignoreDate: boolean, interactive: boolean) {
		if (interactive) {
			return this.openGitTerminal(
				repo,
				'rebase --interactive ' + (getConfig().signCommits ? '-S ' : '') + (actionOn === RebaseActionOn.Branch ? obj.replace(/'/g, '"\'"') : obj),
				'Rebase on "' + (actionOn === RebaseActionOn.Branch ? obj : abbrevCommit(obj)) + '"'
			);
		} else {
			const args = ['rebase', obj];
			if (ignoreDate) {
				args.push('--ignore-date');
			}
			if (getConfig().signCommits) {
				args.push('-S');
			}
			return this.runGitCommand(args, repo);
		}
	}


	/* Git Action Methods - Branches & Tags */

	/**
	 * Create an archive of a repository at a specific reference, and save to disk.
	 * @param repo The path of the repository.
	 * @param ref The reference of the revision to archive.
	 * @param outputFilePath The file path that the archive should be saved to.
	 * @param type The type of archive.
	 * @returns The ErrorInfo from the executed command.
	 */
	public archive(repo: string, ref: string, outputFilePath: string, type: 'tar' | 'zip') {
		return this.runGitCommand(['archive', '--format=' + type, '-o', outputFilePath, ref], repo);
	}


	/* Git Action Methods - Commits */

	/**
	 * Checkout a commit in a repository.
	 * @param repo The path of the repository.
	 * @param commitHash The hash of the commit to check out.
	 * @returns The ErrorInfo from the executed command.
	 */
	public checkoutCommit(repo: string, commitHash: string) {
		return this.runGitCommand(['checkout', commitHash], repo);
	}

	/**
	 * Cherrypick a commit in a repository.
	 * @param repo The path of the repository.
	 * @param commitHash The hash of the commit to be cherry picked.
	 * @param parentIndex The parent index if the commit is a merge.
	 * @param recordOrigin Is `-x` enabled.
	 * @param noCommit Is `--no-commit` enabled.
	 * @returns The ErrorInfo from the executed command.
	 */
	public cherrypickCommit(repo: string, commitHash: string, parentIndex: number, recordOrigin: boolean, noCommit: boolean) {
		const args = ['cherry-pick'];
		if (noCommit) {
			args.push('--no-commit');
		}
		if (recordOrigin) {
			args.push('-x');
		}
		if (getConfig().signCommits) {
			args.push('-S');
		}
		if (parentIndex > 0) {
			args.push('-m', parentIndex.toString());
		}
		args.push(commitHash);
		return this.runGitCommand(args, repo);
	}

	/**
	 * Drop a commit in a repository.
	 * @param repo The path of the repository.
	 * @param commitHash The hash of the commit to drop.
	 * @returns The ErrorInfo from the executed command.
	 */
	public dropCommit(repo: string, commitHash: string) {
		const args = ['rebase'];
		if (getConfig().signCommits) {
			args.push('-S');
		}
		args.push('--onto', commitHash + '^', commitHash);
		return this.runGitCommand(args, repo);
	}

	/**
	 * Reset the current branch to a specified commit.
	 * @param repo The path of the repository.
	 * @param commit The hash of the commit that the current branch should be reset to.
	 * @param resetMode The mode of the reset.
	 * @returns The ErrorInfo from the executed command.
	 */
	public resetToCommit(repo: string, commit: string, resetMode: GitResetMode) {
		return this.runGitCommand(['reset', '--' + resetMode, commit], repo);
	}

	/**
	 * Revert a commit in a repository.
	 * @param repo The path of the repository.
	 * @param commitHash The hash of the commit to revert.
	 * @param parentIndex The parent index if the commit is a merge.
	 * @returns The ErrorInfo from the executed command.
	 */
	public revertCommit(repo: string, commitHash: string, parentIndex: number) {
		const args = ['revert', '--no-edit'];
		if (getConfig().signCommits) {
			args.push('-S');
		}
		if (parentIndex > 0) {
			args.push('-m', parentIndex.toString());
		}
		args.push(commitHash);
		return this.runGitCommand(args, repo);
	}


	/* Git Action Methods - Config */

	/**
	 * Set a configuration value for a repository.
	 * @param repo The path of the repository.
	 * @param key The Git Config Key to be set.
	 * @param value The value to be set.
	 * @param location The location where the configuration value should be set.
	 * @returns The ErrorInfo from the executed command.
	 */
	public setConfigValue(repo: string, key: GitConfigKey, value: string, location: GitConfigLocation) {
		return this.runGitCommand(['config', '--' + location, key, value], repo);
	}

	/**
	 * Unset a configuration value for a repository.
	 * @param repo The path of the repository.
	 * @param key The Git Config Key to be unset.
	 * @param location The location where the configuration value should be unset.
	 * @returns The ErrorInfo from the executed command.
	 */
	public unsetConfigValue(repo: string, key: GitConfigKey, location: GitConfigLocation) {
		return this.runGitCommand(['config', '--' + location, '--unset-all', key], repo);
	}


	/* Git Action Methods - Uncommitted */

	/**
	 * Clean the untracked files in a repository.
	 * @param repo The path of the repository.
	 * @param directories Is `-d` enabled.
	 * @returns The ErrorInfo from the executed command.
	 */
	public cleanUntrackedFiles(repo: string, directories: boolean) {
		return this.runGitCommand(['clean', '-f' + (directories ? 'd' : '')], repo);
	}


	/* Git Action Methods - File */

	/**
	 * Reset a file to the specified revision.
	 * @param repo The path of the repository.
	 * @param commitHash The commit to reset the file to.
	 * @param filePath The file to reset.
	 * @returns The ErrorInfo from the executed command.
	 */
	public resetFileToRevision(repo: string, commitHash: string, filePath: string) {
		return this.runGitCommand(['checkout', commitHash, '--', filePath], repo);
	}


	/* Git Action Methods - Stash */

	/**
	 * Apply a stash in a repository.
	 * @param repo The path of the repository.
	 * @param selector The selector of the stash.
	 * @param reinstateIndex Is `--index` enabled.
	 * @returns The ErrorInfo from the executed command.
	 */
	public applyStash(repo: string, selector: string, reinstateIndex: boolean) {
		let args = ['stash', 'apply'];
		if (reinstateIndex) args.push('--index');
		args.push(selector);

		return this.runGitCommand(args, repo);
	}

	/**
	 * Create a branch from a stash.
	 * @param repo The path of the repository.
	 * @param selector The selector of the stash.
	 * @param branchName The name of the branch to be created.
	 * @returns The ErrorInfo from the executed command.
	 */
	public branchFromStash(repo: string, selector: string, branchName: string) {
		return this.runGitCommand(['stash', 'branch', branchName, selector], repo);
	}

	/**
	 * Drop a stash in a repository.
	 * @param repo The path of the repository.
	 * @param selector The selector of the stash.
	 * @returns The ErrorInfo from the executed command.
	 */
	public dropStash(repo: string, selector: string) {
		return this.runGitCommand(['stash', 'drop', selector], repo);
	}

	/**
	 * Pop a stash in a repository.
	 * @param repo The path of the repository.
	 * @param selector The selector of the stash.
	 * @param reinstateIndex Is `--index` enabled.
	 * @returns The ErrorInfo from the executed command.
	 */
	public popStash(repo: string, selector: string, reinstateIndex: boolean) {
		let args = ['stash', 'pop'];
		if (reinstateIndex) args.push('--index');
		args.push(selector);

		return this.runGitCommand(args, repo);
	}

	/**
	 * Push the uncommitted changes to a stash.
	 * @param repo The path of the repository.
	 * @param message The message of the stash.
	 * @param includeUntracked Is `--include-untracked` enabled.
	 * @returns The ErrorInfo from the executed command.
	 */
	public pushStash(repo: string, message: string, includeUntracked: boolean): Promise<ErrorInfo> {
		if (this.gitExecutable === null) {
			return Promise.resolve(UNABLE_TO_FIND_GIT_MSG);
		} else if (!doesVersionMeetRequirement(this.gitExecutable.version, GitVersionRequirement.PushStash)) {
			return Promise.resolve(constructIncompatibleGitVersionMessage(this.gitExecutable, GitVersionRequirement.PushStash));
		}

		let args = ['stash', 'push'];
		if (includeUntracked) args.push('--include-untracked');
		if (message !== '') args.push('--message', message);
		return this.runGitCommand(args, repo);
	}


	/* Public Utils */

	/**
	 * Opens an external directory diff for the specified commits.
	 * @param repo The path of the repository.
	 * @param fromHash The commit hash the diff is from.
	 * @param toHash The commit hash the diff is to.
	 * @param isGui Is the external diff tool GUI based.
	 * @returns The ErrorInfo from the executed command.
	 */
	public openExternalDirDiff(repo: string, fromHash: string, toHash: string, isGui: boolean) {
		return new Promise<ErrorInfo>((resolve) => {
			if (this.gitExecutable === null) {
				resolve(UNABLE_TO_FIND_GIT_MSG);
			} else {
				const args = ['difftool', '--dir-diff'];
				if (isGui) {
					args.push('-g');
				}
				if (fromHash === toHash) {
					if (toHash === UNCOMMITTED) {
						args.push('HEAD');
					} else {
						args.push(toHash + '^..' + toHash);
					}
				} else {
					if (toHash === UNCOMMITTED) {
						args.push(fromHash);
					} else {
						args.push(fromHash + '..' + toHash);
					}
				}
				if (isGui) {
					this.logger.log('External diff tool is being opened (' + args[args.length - 1] + ')');
					this.runGitCommand(args, repo).then((errorInfo) => {
						this.logger.log('External diff tool has exited (' + args[args.length - 1] + ')');
						if (errorInfo !== null) {
							const errorMessage = errorInfo.replace(EOL_REGEX, ' ');
							this.logger.logError(errorMessage);
							showErrorMessage(errorMessage);
						}
					});
				} else {
					openGitTerminal(repo, this.gitExecutable.path, args.join(' '), 'Open External Directory Diff');
				}
				setTimeout(() => resolve(null), 1500);
			}
		});
	}

	/**
	 * Open a new terminal, set up the Git executable, and optionally run a command.
	 * @param repo The path of the repository.
	 * @param command The command to run.
	 * @param name The name for the terminal.
	 * @returns The ErrorInfo from opening the terminal.
	 */
	public openGitTerminal(repo: string, command: string | null, name: string) {
		return new Promise<ErrorInfo>((resolve) => {
			if (this.gitExecutable === null) {
				resolve(UNABLE_TO_FIND_GIT_MSG);
			} else {
				openGitTerminal(repo, this.gitExecutable.path, command, name);
				setTimeout(() => resolve(null), 1000);
			}
		});
	}


	/* Private Data Providers */

	/**
	 * Get the branches in a repository.
	 * @param repo The path of the repository.
	 * @param showRemoteBranches Are remote branches shown.
	 * @param hideRemotes An array of hidden remotes.
	 * @returns The branch data.
	 */
	private getBranches(repo: string, showRemoteBranches: boolean, hideRemotes: ReadonlyArray<string>) {
		let args = ['branch'];
		if (showRemoteBranches) args.push('-a');
		args.push('--no-color');

		const hideRemotePatterns = hideRemotes.map((remote) => 'remotes/' + remote + '/');
		const showRemoteHeads = getConfig().showRemoteHeads;

		return this.spawnGit(args, repo, (stdout) => {
			let branchData: GitBranchData = { branches: [], head: null, error: null };
			let lines = stdout.split(EOL_REGEX);
			for (let i = 0; i < lines.length - 1; i++) {
				let name = lines[i].substring(2).split(' -> ')[0];
				if (INVALID_BRANCH_REGEXP.test(name) || hideRemotePatterns.some((pattern) => name.startsWith(pattern)) || (!showRemoteHeads && REMOTE_HEAD_BRANCH_REGEXP.test(name))) {
					continue;
				}

				if (lines[i][0] === '*') {
					branchData.head = name;
					branchData.branches.unshift(name);
				} else {
					branchData.branches.push(name);
				}
			}
			return branchData;
		});
	}

	/**
	 * Get the base commit details for the Commit Details View.
	 * @param repo The path of the repository.
	 * @param commitHash The hash of the commit open in the Commit Details View.
	 * @returns The base commit details.
	 */
	private getCommitDetailsBase(repo: string, commitHash: string) {
		return this.spawnGit(['-c', 'log.showSignature=false', 'show', '--quiet', commitHash, '--format=' + this.gitFormatCommitDetails], repo, (stdout): DeepWriteable<GitCommitDetails> => {
			const commitInfo = stdout.split(GIT_LOG_SEPARATOR);
			return {
				hash: commitInfo[0],
				parents: commitInfo[1] !== '' ? commitInfo[1].split(' ') : [],
				author: commitInfo[2],
				authorEmail: commitInfo[3],
				authorDate: parseInt(commitInfo[4]),
				committer: commitInfo[5],
				committerEmail: commitInfo[6],
				committerDate: parseInt(commitInfo[7]),
				signature: ['G', 'U', 'X', 'Y', 'R', 'E', 'B'].includes(commitInfo[8])
					? {
						key: commitInfo[10].trim(),
						signer: commitInfo[9].trim(),
						status: <GitSignatureStatus>commitInfo[8]
					}
					: null,
				body: removeTrailingBlankLines(commitInfo.slice(11).join(GIT_LOG_SEPARATOR).split(EOL_REGEX)).join('\n'),
				fileChanges: []
			};
		});
	}

	/**
	 * Get the configuration list of a repository.
	 * @param repo The path of the repository.
	 * @param location The location of the configuration to be listed.
	 * @returns A set of key-value pairs of Git configuration records.
	 */
	private getConfigList(repo: string, location?: GitConfigLocation): Promise<GitConfigSet> {
		const args = ['--no-pager', 'config', '--list', '-z', '--includes'];
		if (location) {
			args.push('--' + location);
		}

		return this.spawnGit(args, repo, (stdout) => {
			const configs: GitConfigSet = {}, keyValuePairs = stdout.split('\0');
			const numPairs = keyValuePairs.length - 1;
			let comps, key;
			for (let i = 0; i < numPairs; i++) {
				comps = keyValuePairs[i].split(EOL_REGEX);
				key = comps.shift()!;
				configs[key] = comps.join('\n');
			}
			return configs;
		}).catch((errorMessage) => {
			if (typeof errorMessage === 'string') {
				const message = errorMessage.toLowerCase();
				if (message.startsWith('fatal: unable to read config file') && message.endsWith('no such file or directory')) {
					// If the Git command failed due to the configuration file not existing, return an empty list instead of throwing the exception
					return {};
				}
			} else {
				errorMessage = 'An unexpected error occurred while spawning the Git child process.';
			}
			throw errorMessage;
		});
	}

	/**
	 * Get the diff `--name-status` records.
	 * @param repo The path of the repository.
	 * @param fromHash The revision the diff is from.
	 * @param toHash The revision the diff is to.
	 * @param filter The types of file changes to retrieve (defaults to `AMDR`).
	 * @returns An array of `--name-status` records.
	 */
	private getDiffNameStatus(repo: string, fromHash: string, toHash: string, filter: string = 'AMDR') {
		return this.execDiff(repo, fromHash, toHash, '--name-status', filter).then((output) => {
			let records: DiffNameStatusRecord[] = [], i = 0;
			while (i < output.length && output[i] !== '') {
				let type = <GitFileStatus>output[i][0];
				if (type === GitFileStatus.Added || type === GitFileStatus.Deleted || type === GitFileStatus.Modified) {
					// Add, Modify, or Delete
					let p = getPathFromStr(output[i + 1]);
					records.push({ type: type, oldFilePath: p, newFilePath: p });
					i += 2;
				} else if (type === GitFileStatus.Renamed) {
					// Rename
					records.push({ type: type, oldFilePath: getPathFromStr(output[i + 1]), newFilePath: getPathFromStr(output[i + 2]) });
					i += 3;
				} else {
					break;
				}
			}
			return records;
		});
	}

	/**
	 * Get the diff `--numstat` records.
	 * @param repo The path of the repository.
	 * @param fromHash The revision the diff is from.
	 * @param toHash The revision the diff is to.
	 * @param filter The types of file changes to retrieve (defaults to `AMDR`).
	 * @returns An array of `--numstat` records.
	 */
	private getDiffNumStat(repo: string, fromHash: string, toHash: string, filter: string = 'AMDR') {
		return this.execDiff(repo, fromHash, toHash, '--numstat', filter).then((output) => {
			let records: DiffNumStatRecord[] = [], i = 0;
			while (i < output.length && output[i] !== '') {
				let fields = output[i].split('\t');
				if (fields.length !== 3) break;
				if (fields[2] !== '') {
					// Add, Modify, or Delete
					records.push({ filePath: getPathFromStr(fields[2]), additions: parseInt(fields[0]), deletions: parseInt(fields[1]) });
					i += 1;
				} else {
					// Rename
					records.push({ filePath: getPathFromStr(output[i + 2]), additions: parseInt(fields[0]), deletions: parseInt(fields[1]) });
					i += 3;
				}
			}
			return records;
		});
	}

	/**
	 * Get the raw commits in a repository.
	 * @param repo The path of the repository.
	 * @param branches The list of branch heads to display, or NULL (show all).
	 * @param num The maximum number of commits to return.
	 * @param includeTags Include commits only referenced by tags.
	 * @param includeRemotes Include remote branches.
	 * @param includeCommitsMentionedByReflogs Include commits mentioned by reflogs.
	 * @param onlyFollowFirstParent Only follow the first parent of commits.
	 * @param order The order for commits to be returned.
	 * @param remotes An array of the known remotes.
	 * @param hideRemotes An array of hidden remotes.
	 * @param stashes An array of all stashes in the repository.
	 * @returns An array of commits.
	 */
	private getLog(repo: string, branches: ReadonlyArray<string> | null, num: number, includeTags: boolean, includeRemotes: boolean, includeCommitsMentionedByReflogs: boolean, onlyFollowFirstParent: boolean, order: CommitOrdering, remotes: ReadonlyArray<string>, hideRemotes: ReadonlyArray<string>, stashes: ReadonlyArray<GitStash>) {
		const args = ['-c', 'log.showSignature=false', 'log', '--max-count=' + num, '--format=' + this.gitFormatLog, '--' + order + '-order'];
		if (onlyFollowFirstParent) {
			args.push('--first-parent');
		}
		if (branches !== null) {
			for (let i = 0; i < branches.length; i++) {
				args.push(branches[i]);
			}
		} else {
			// Show All
			args.push('--branches');
			if (includeTags) args.push('--tags');
			if (includeCommitsMentionedByReflogs) args.push('--reflog');
			if (includeRemotes) {
				if (hideRemotes.length === 0) {
					args.push('--remotes');
				} else {
					remotes.filter((remote) => !hideRemotes.includes(remote)).forEach((remote) => {
						args.push('--glob=refs/remotes/' + remote);
					});
				}
			}

			// Add the unique list of base hashes of stashes, so that commits only referenced by stashes are displayed
			const stashBaseHashes = stashes.map((stash) => stash.baseHash);
			stashBaseHashes.filter((hash, index) => stashBaseHashes.indexOf(hash) === index).forEach((hash) => args.push(hash));

			args.push('HEAD');
		}
		args.push('--');

		return this.spawnGit(args, repo, (stdout) => {
			let lines = stdout.split(EOL_REGEX);
			let commits: GitCommitRecord[] = [];
			for (let i = 0; i < lines.length - 1; i++) {
				let line = lines[i].split(GIT_LOG_SEPARATOR);
				if (line.length !== 6) break;
				commits.push({ hash: line[0], parents: line[1] !== '' ? line[1].split(' ') : [], author: line[2], email: line[3], date: parseInt(line[4]), message: line[5] });
			}
			return commits;
		});
	}

	/**
	 * Get the references in a repository.
	 * @param repo The path of the repository.
	 * @param showRemoteBranches Are remote branches shown.
	 * @param showRemoteHeads Are remote heads shown.
	 * @param hideRemotes An array of hidden remotes.
	 * @returns The references data.
	 */
	private getRefs(repo: string, showRemoteBranches: boolean, showRemoteHeads: boolean, hideRemotes: ReadonlyArray<string>) {
		let args = ['show-ref'];
		if (!showRemoteBranches) args.push('--heads', '--tags');
		args.push('-d', '--head');

		const hideRemotePatterns = hideRemotes.map((remote) => 'refs/remotes/' + remote + '/');

		return this.spawnGit(args, repo, (stdout) => {
			let refData: GitRefData = { head: null, heads: [], tags: [], remotes: [] };
			let lines = stdout.split(EOL_REGEX);
			for (let i = 0; i < lines.length - 1; i++) {
				let line = lines[i].split(' ');
				if (line.length < 2) continue;

				let hash = line.shift()!;
				let ref = line.join(' ');

				if (ref.startsWith('refs/heads/')) {
					refData.heads.push({ hash: hash, name: ref.substring(11) });
				} else if (ref.startsWith('refs/tags/')) {
					let annotated = ref.endsWith('^{}');
					refData.tags.push({ hash: hash, name: (annotated ? ref.substring(10, ref.length - 3) : ref.substring(10)), annotated: annotated });
				} else if (ref.startsWith('refs/remotes/')) {
					if (!hideRemotePatterns.some((pattern) => ref.startsWith(pattern)) && (showRemoteHeads || !ref.endsWith('/HEAD'))) {
						refData.remotes.push({ hash: hash, name: ref.substring(13) });
					}
				} else if (ref === 'HEAD') {
					refData.head = hash;
				}
			}
			return refData;
		});
	}

	/**
	 * Get all of the remotes that contain the specified commit hash.
	 * @param repo The path of the repository.
	 * @param commitHash The commit hash to test.
	 * @param knownRemotes The list of known remotes to check for.
	 * @returns A promise resolving to a list of remote names.
	 */
	private getRemotesContainingCommit(repo: string, commitHash: string, knownRemotes: string[]) {
		return this.spawnGit(['branch', '-r', '--no-color', '--contains=' + commitHash], repo, (stdout) => {
			// Get the names of all known remote branches that contain commitHash
			const branchNames = stdout.split(EOL_REGEX)
				.filter((line) => line.length > 2)
				.map((line) => line.substring(2).split(' -> ')[0])
				.filter((branchName) => !INVALID_BRANCH_REGEXP.test(branchName));

			// Get all the remotes that are the prefix of at least one remote branch name
			return knownRemotes.filter((knownRemote) => {
				const knownRemotePrefix = knownRemote + '/';
				return branchNames.some((branchName) => branchName.startsWith(knownRemotePrefix));
			});
		});
	}

	/**
	 * Get the stashes in a repository.
	 * @param repo The path of the repository.
	 * @returns An array of stashes.
	 */
	private getStashes(repo: string) {
		return this.spawnGit(['reflog', '--format=' + this.gitFormatStash, 'refs/stash', '--'], repo, (stdout) => {
			let lines = stdout.split(EOL_REGEX);
			let stashes: GitStash[] = [];
			for (let i = 0; i < lines.length - 1; i++) {
				let line = lines[i].split(GIT_LOG_SEPARATOR);
				if (line.length !== 7 || line[1] === '') continue;
				let parentHashes = line[1].split(' ');
				stashes.push({
					hash: line[0],
					baseHash: parentHashes[0],
					untrackedFilesHash: parentHashes.length === 3 ? parentHashes[2] : null,
					selector: line[2],
					author: line[3],
					email: line[4],
					date: parseInt(line[5]),
					message: line[6]
				});
			}
			return stashes;
		}).catch(() => <GitStash[]>[]);
	}

	/**
	 * Get the names of the remotes of a repository.
	 * @param repo The path of the repository.
	 * @returns An array of remote names.
	 */
	private getRemotes(repo: string) {
		return this.spawnGit(['remote'], repo, (stdout) => {
			let lines = stdout.split(EOL_REGEX);
			lines.pop();
			return lines;
		});
	}

	/**
	 * Get the signature of a signed tag.
	 * @param repo The path of the repository.
	 * @param ref The reference identifying the tag.
	 * @returns A Promise resolving to the signature.
	 */
	private getTagSignature(repo: string, ref: string): Promise<GitSignature> {
		return this._spawnGit(['verify-tag', '--raw', ref], repo, (stdout, stderr) => stderr || stdout.toString(), true).then((output) => {
			const records = output.split(EOL_REGEX)
				.filter((line) => line.startsWith('[GNUPG:] '))
				.map((line) => line.split(' '));

			let signature: Writeable<GitSignature> | null = null, trustLevel: string | null = null, parsingDetails: GpgStatusCodeParsingDetails | undefined;
			for (let i = 0; i < records.length; i++) {
				parsingDetails = GPG_STATUS_CODE_PARSING_DETAILS[records[i][1]];
				if (parsingDetails) {
					if (signature !== null) {
						throw new Error('Multiple Signatures Exist: As Git currently doesn\'t support them, nor does Git Graph (for consistency).');
					} else {
						signature = {
							status: parsingDetails.status,
							key: records[i][2],
							signer: parsingDetails.uid ? records[i].slice(3).join(' ') : '' // When parsingDetails.uid === TRUE, the signer is the rest of the record (so join the remaining arguments)
						};
					}
				} else if (records[i][1].startsWith('TRUST_')) {
					trustLevel = records[i][1];
				}
			}

			if (signature !== null && signature.status === GitSignatureStatus.GoodAndValid && (trustLevel === 'TRUST_UNDEFINED' || trustLevel === 'TRUST_NEVER')) {
				signature.status = GitSignatureStatus.GoodWithUnknownValidity;
			}

			if (signature !== null) {
				return signature;
			} else {
				throw new Error('No Signature could be parsed.');
			}
		}).catch(() => ({
			status: GitSignatureStatus.CannotBeChecked,
			key: '',
			signer: ''
		}));
	}

	/**
	 * Get the number of uncommitted changes in a repository.
	 * @param repo The path of the repository.
	 * @returns The number of uncommitted changes.
	 */
	private getUncommittedChanges(repo: string) {
		return this.spawnGit(['status', '--untracked-files=' + (getConfig().showUntrackedFiles ? 'all' : 'no'), '--porcelain'], repo, (stdout) => {
			const numLines = stdout.split(EOL_REGEX).length;
			return numLines > 1 ? numLines - 1 : 0;
		});
	}

	/**
	 * Get the untracked and deleted files that are not staged or committed.
	 * @param repo The path of the repository.
	 * @returns The untracked and deleted files.
	 */
	private getStatus(repo: string) {
		return this.spawnGit(['status', '-s', '--untracked-files=' + (getConfig().showUntrackedFiles ? 'all' : 'no'), '--porcelain', '-z'], repo, (stdout) => {
			let output = stdout.split('\0'), i = 0;
			let status: GitStatusFiles = { deleted: [], untracked: [] };
			let path = '', c1 = '', c2 = '';
			while (i < output.length && output[i] !== '') {
				if (output[i].length < 4) break;
				path = output[i].substring(3);
				c1 = output[i].substring(0, 1);
				c2 = output[i].substring(1, 2);
				if (c1 === 'D' || c2 === 'D') status.deleted.push(path);
				else if (c1 === '?' || c2 === '?') status.untracked.push(path);

				if (c1 === 'R' || c2 === 'R' || c1 === 'C' || c2 === 'C') {
					// Renames or copies
					i += 2;
				} else {
					i += 1;
				}
			}
			return status;
		});
	}


	/* Private Utils */

	/**
	 * Check if there are staged changes that resulted from a squash merge, and if so, commit them.
	 * @param repo The path of the repository.
	 * @param obj The object being squash merged into the current branch.
	 * @param actionOn Is the merge on a branch, remote-tracking branch or commit.
	 * @param squashMessageFormat The format to be used in the commit message of the squash.
	 * @returns The ErrorInfo from the executed command.
	 */
	private commitSquashIfStagedChangesExist(repo: string, obj: string, actionOn: MergeActionOn, squashMessageFormat: SquashMessageFormat, signCommits: boolean): Promise<ErrorInfo> {
		return this.areStagedChanges(repo).then((changes) => {
			if (changes) {
				const args = ['commit'];
				if (signCommits) {
					args.push('-S');
				}
				if (squashMessageFormat === SquashMessageFormat.Default) {
					args.push('-m', 'Merge ' + actionOn.toLowerCase() + ' \'' + obj + '\'');
				} else {
					args.push('--no-edit');
				}
				return this.runGitCommand(args, repo);
			} else {
				return null;
			}
		});
	}

	/**
	 * Get the diff between two revisions.
	 * @param repo The path of the repository.
	 * @param fromHash The revision the diff is from.
	 * @param toHash The revision the diff is to.
	 * @param arg Sets the data reported from the diff.
	 * @param filter The types of file changes to retrieve.
	 * @returns The diff output.
	 */
	private execDiff(repo: string, fromHash: string, toHash: string, arg: '--numstat' | '--name-status', filter: string) {
		let args: string[];
		if (fromHash === toHash) {
			args = ['diff-tree', arg, '-r', '--root', '--find-renames', '--diff-filter=' + filter, '-z', fromHash];
		} else {
			args = ['diff', arg, '--find-renames', '--diff-filter=' + filter, '-z', fromHash];
			if (toHash !== '') args.push(toHash);
		}

		return this.spawnGit(args, repo, (stdout) => {
			let lines = stdout.split('\0');
			if (fromHash === toHash) lines.shift();
			return lines;
		});
	}

	/**
	 * Run a Git command (typically for a Git Graph View action).
	 * @param args The arguments to pass to Git.
	 * @param repo The repository to run the command in.
	 * @returns The returned ErrorInfo (suitable for being sent to the Git Graph View).
	 */
	private runGitCommand(args: string[], repo: string): Promise<ErrorInfo> {
		return this._spawnGit(args, repo, () => null).catch((errorMessage: string) => errorMessage);
	}

	/**
	 * Spawn Git, with the return value resolved from `stdout` as a string.
	 * @param args The arguments to pass to Git.
	 * @param repo The repository to run the command in.
	 * @param resolveValue A callback invoked to resolve the data from `stdout`.
	 */
	private spawnGit<T>(args: string[], repo: string, resolveValue: { (stdout: string): T }) {
		return this._spawnGit(args, repo, (stdout) => resolveValue(stdout.toString()));
	}

	/**
	 * Spawn Git, with the return value resolved from `stdout` as a buffer.
	 * @param args The arguments to pass to Git.
	 * @param repo The repository to run the command in.
	 * @param resolveValue A callback invoked to resolve the data from `stdout` and `stderr`.
	 * @param ignoreExitCode Ignore the exit code returned by Git (default: `FALSE`).
	 */
	private _spawnGit<T>(args: string[], repo: string, resolveValue: { (stdout: Buffer, stderr: string): T }, ignoreExitCode: boolean = false) {
		return new Promise<T>((resolve, reject) => {
			if (this.gitExecutable === null) {
				return reject(UNABLE_TO_FIND_GIT_MSG);
			}

			resolveSpawnOutput(cp.spawn(this.gitExecutable.path, args, {
				cwd: repo,
				env: Object.assign({}, process.env, this.askpassEnv)
			})).then((values) => {
				const status = values[0], stdout = values[1], stderr = values[2];
				if (status.code === 0 || ignoreExitCode) {
					resolve(resolveValue(stdout, stderr));
				} else {
					reject(getErrorMessage(status.error, stdout, stderr));
				}
			});

			this.logger.logCmd('git', args);
		});
	}
}


/**
 * Generates the file changes from the diff output and status information.
 * @param nameStatusRecords The `--name-status` records.
 * @param numStatRecords The `--numstat` records.
 * @param status The deleted and untracked files.
 * @returns An array of file changes.
 */
function generateFileChanges(nameStatusRecords: DiffNameStatusRecord[], numStatRecords: DiffNumStatRecord[], status: GitStatusFiles | null) {
	let fileChanges: Writeable<GitFileChange>[] = [], fileLookup: { [file: string]: number } = {}, i = 0;

	for (i = 0; i < nameStatusRecords.length; i++) {
		fileLookup[nameStatusRecords[i].newFilePath] = fileChanges.length;
		fileChanges.push({ oldFilePath: nameStatusRecords[i].oldFilePath, newFilePath: nameStatusRecords[i].newFilePath, type: nameStatusRecords[i].type, additions: null, deletions: null });
	}

	if (status !== null) {
		let filePath;
		for (i = 0; i < status.deleted.length; i++) {
			filePath = getPathFromStr(status.deleted[i]);
			if (typeof fileLookup[filePath] === 'number') {
				fileChanges[fileLookup[filePath]].type = GitFileStatus.Deleted;
			} else {
				fileChanges.push({ oldFilePath: filePath, newFilePath: filePath, type: GitFileStatus.Deleted, additions: null, deletions: null });
			}
		}
		for (i = 0; i < status.untracked.length; i++) {
			filePath = getPathFromStr(status.untracked[i]);
			fileChanges.push({ oldFilePath: filePath, newFilePath: filePath, type: GitFileStatus.Untracked, additions: null, deletions: null });
		}
	}

	for (i = 0; i < numStatRecords.length; i++) {
		if (typeof fileLookup[numStatRecords[i].filePath] === 'number') {
			fileChanges[fileLookup[numStatRecords[i].filePath]].additions = numStatRecords[i].additions;
			fileChanges[fileLookup[numStatRecords[i].filePath]].deletions = numStatRecords[i].deletions;
		}
	}

	return fileChanges;
}

/**
 * Get the specified config value from a set of key-value config pairs.
 * @param configs A set key-value pairs of Git configuration records.
 * @param key The key of the desired config.
 * @returns The value for `key` if it exists, otherwise NULL.
 */
function getConfigValue(configs: GitConfigSet, key: string) {
	return typeof configs[key] !== 'undefined' ? configs[key] : null;
}

/**
 * Produce a suitable error message from a spawned Git command that terminated with an erroneous status code.
 * @param error An error generated by JavaScript (optional).
 * @param stdoutBuffer A buffer containing the data outputted to `stdout`.
 * @param stderr A string containing the data outputted to `stderr`.
 * @returns A suitable error message.
 */
function getErrorMessage(error: Error | null, stdoutBuffer: Buffer, stderr: string) {
	let stdout = stdoutBuffer.toString(), lines: string[];
	if (stdout !== '' || stderr !== '') {
		lines = (stderr + stdout).split(EOL_REGEX);
		lines.pop();
	} else if (error) {
		lines = error.message.split(EOL_REGEX);
	} else {
		lines = [];
	}
	return lines.join('\n');
}

/**
 * Remove trailing blank lines from an array of lines.
 * @param lines The array of lines.
 * @returns The same array.
 */
function removeTrailingBlankLines(lines: string[]) {
	while (lines.length > 0 && lines[lines.length - 1] === '') {
		lines.pop();
	}
	return lines;
}

/**
 * Get all the unique strings from an array of strings.
 * @param items The array of strings with duplicates.
 * @returns An array of unique strings.
 */
function unique(items: ReadonlyArray<string>) {
	const uniqueItems: { [item: string]: true } = {};
	items.forEach((item) => uniqueItems[item] = true);
	return Object.keys(uniqueItems);
}


/* Types */

interface DiffNameStatusRecord {
	type: GitFileStatus;
	oldFilePath: string;
	newFilePath: string;
}

interface DiffNumStatRecord {
	filePath: string;
	additions: number;
	deletions: number;
}

interface GitBranchData {
	branches: string[];
	head: string | null;
	error: ErrorInfo;
}

interface GitCommitRecord {
	hash: string;
	parents: string[];
	author: string;
	email: string;
	date: number;
	message: string;
}

interface GitCommitData {
	commits: GitCommit[];
	head: string | null;
	tags: string[];
	moreCommitsAvailable: boolean;
	error: ErrorInfo;
}

export interface GitCommitDetailsData {
	commitDetails: GitCommitDetails | null;
	error: ErrorInfo;
}

interface GitCommitComparisonData {
	fileChanges: GitFileChange[];
	error: ErrorInfo;
}

type GitConfigSet = { [key: string]: string };

interface GitRef {
	hash: string;
	name: string;
}

interface GitRefTag extends GitRef {
	annotated: boolean;
}

interface GitRefData {
	head: string | null;
	heads: GitRef[];
	tags: GitRefTag[];
	remotes: GitRef[];
}

interface GitRepoInfo extends GitBranchData {
	remotes: string[];
	stashes: GitStash[];
}

interface GitRepoConfigData {
	config: GitRepoConfig | null;
	error: ErrorInfo;
}

interface GitStatusFiles {
	deleted: string[];
	untracked: string[];
}

interface GitTagDetailsData {
	details: GitTagDetails | null;
	error: ErrorInfo;
}

interface GpgStatusCodeParsingDetails {
	readonly status: GitSignatureStatus,
	readonly uid: boolean
}
-e 

================================================================================
// FILE: ./src/utils/bufferedQueue.ts
================================================================================
import { Disposable, toDisposable } from './disposable';

/**
 * Represents a BufferedQueue, which is queue that buffers items for a short period of time before processing them.
 */
export class BufferedQueue<T> extends Disposable {
	private readonly queue: T[] = [];
	private timeout: NodeJS.Timer | null = null;
	private processing: boolean = false;

	private readonly bufferDuration: number;
	private onItem: (item: T) => Promise<boolean>;
	private onChanges: () => void;

	/**
	 * Constructs a BufferedQueue instance.
	 * @param onItem A callback invoked to process an item in the queue.
	 * @param onChanges A callback invoked when a change was indicated by onItem.
	 * @param bufferDuration The number of milliseconds to buffer items in the queue.
	 * @returns The BufferedQueue instance.
	 */
	constructor(onItem: (item: T) => Promise<boolean>, onChanges: () => void, bufferDuration: number = 1000) {
		super();
		this.bufferDuration = bufferDuration;
		this.onItem = onItem;
		this.onChanges = onChanges;

		this.registerDisposable(toDisposable(() => {
			if (this.timeout !== null) {
				clearTimeout(this.timeout);
				this.timeout = null;
			}
		}));
	}

	/**
	 * Enqueue an item if it doesn't already exist in the queue.
	 * @param item The item to enqueue.
	 */
	public enqueue(item: T) {
		const itemIndex = this.queue.indexOf(item);
		if (itemIndex > -1) {
			this.queue.splice(itemIndex, 1);
		}
		this.queue.push(item);

		if (!this.processing) {
			if (this.timeout !== null) {
				clearTimeout(this.timeout);
			}
			this.timeout = setTimeout(() => {
				this.timeout = null;
				this.run();
			}, this.bufferDuration);
		}
	}

	/**
	 * Process all of the items that are currently queued, and call the onChanges callback if any of the items resulted in a change
	 */
	private async run() {
		this.processing = true;
		let item, changes = false;
		while (item = this.queue.shift()) {
			if (await this.onItem(item)) {
				changes = true;
			}
		}
		this.processing = false;
		if (changes) this.onChanges();
	}
}
-e 

================================================================================
// FILE: ./src/utils/event.ts
================================================================================
import * as vscode from 'vscode';

/**
 * A function used by a subscriber to process an event emitted from an EventEmitter.
 */
type EventListener<T> = (event: T) => void;

/**
 * A function used to subscribe to an EventEmitter.
 */
export type Event<T> = (listener: EventListener<T>) => vscode.Disposable;

/**
 * Represents an EventEmitter, which is used to automate the delivery of events to subscribers. This applies the observer pattern.
 */
export class EventEmitter<T> implements vscode.Disposable {
	private readonly event: Event<T>;
	private listeners: EventListener<T>[] = [];

	/**
	 * Creates an EventEmitter.
	 */
	constructor() {
		this.event = (listener: EventListener<T>) => {
			this.listeners.push(listener);
			return {
				dispose: () => {
					const removeListener = this.listeners.indexOf(listener);
					if (removeListener > -1) {
						this.listeners.splice(removeListener, 1);
					}
				}
			};
		};
	}

	/**
	 * Disposes the resources used by the EventEmitter.
	 */
	public dispose() {
		this.listeners = [];
	}

	/**
	 * Emit an event to all subscribers of the EventEmitter.
	 * @param event The event to emit.
	 */
	public emit(event: T) {
		this.listeners.forEach((listener) => {
			try {
				listener(event);
			} catch (_) { }
		});
	}

	/**
	 * Does the EventEmitter have any registered listeners.
	 * @returns TRUE => There are one or more registered subscribers, FALSE => There are no registered subscribers
	 */
	public hasSubscribers() {
		return this.listeners.length > 0;
	}

	/**
	 * Get the Event of this EventEmitter, which can be used to subscribe to the emitted events.
	 * @returns The Event.
	 */
	get subscribe() {
		return this.event;
	}
}
-e 

================================================================================
// FILE: ./src/utils/disposable.ts
================================================================================
import * as vscode from 'vscode';

export class Disposable implements vscode.Disposable {
	private disposables: vscode.Disposable[] = [];
	private disposed: boolean = false;

	/**
	 * Disposes the resources used by the subclass.
	 */
	public dispose() {
		this.disposed = true;
		this.disposables.forEach((disposable) => {
			try {
				disposable.dispose();
			} catch (_) { }
		});
		this.disposables = [];
	}

	/**
	 * Register a single disposable.
	 */
	protected registerDisposable(disposable: vscode.Disposable) {
		this.disposables.push(disposable);
	}

	/**
	 * Register multiple disposables.
	 */
	protected registerDisposables(...disposables: vscode.Disposable[]) {
		this.disposables.push(...disposables);
	}

	/**
	 * Is the Disposable disposed.
	 * @returns `TRUE` => Disposable has been disposed, `FALSE` => Disposable hasn't been disposed.
	 */
	protected isDisposed() {
		return this.disposed;
	}
}

export function toDisposable(fn: () => void): vscode.Disposable {
	return {
		dispose: fn
	};
}
-e 

================================================================================
// FILE: ./src/utils/@types/node/index.d.ts
================================================================================
/**
 * This file contains types for additional methods used by Git Graph, that were added between the
 * version of @types/node (8.10.62) and the version of Node.js (10.11.0) used by the minimum
 * version of Visual Studio Code that Git Graph supports. Unfortunately @types/node 10.11.0 can't
 * be used, as it is not compatible with Typescript >= 3.7.2. Once the minimum version of Visual
 * Studio Code that Git Graph supports is increased, such that it's version of @types/node is
 * compatible with Typescript >= 3.7.2, @types/node will be updated, and this file will be removed.
 */
declare module 'fs' {
	namespace realpath {
		function native(path: PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void): void;
	}
}
-e 

================================================================================
// FILE: ./src/avatarManager.ts
================================================================================
import * as crypto from 'crypto';
import * as fs from 'fs';
import * as https from 'https';
import * as url from 'url';
import { DataSource } from './dataSource';
import { ExtensionState } from './extensionState';
import { Logger } from './logger';
import { Disposable, toDisposable } from './utils/disposable';
import { EventEmitter } from './utils/event';

/**
 * Manages fetching and caching Avatars.
 */
export class AvatarManager extends Disposable {
	private readonly dataSource: DataSource;
	private readonly extensionState: ExtensionState;
	private readonly logger: Logger;
	private readonly avatarStorageFolder: string;
	private readonly avatarEventEmitter: EventEmitter<AvatarEvent>;

	private avatars: AvatarCache;
	private queue: AvatarRequestQueue;
	private remoteSourceCache: { [repo: string]: RemoteSource } = {};
	private interval: NodeJS.Timer | null = null;

	private githubTimeout: number = 0;
	private gitLabTimeout: number = 0;

	/**
	 * Creates the Git Graph Avatar Manager.
	 * @param dataSource The Git Graph DataSource instance.
	 * @param extensionState The Git Graph ExtensionState instance.
	 * @param logger The Git Graph Logger instance.
	 */
	constructor(dataSource: DataSource, extensionState: ExtensionState, logger: Logger) {
		super();
		this.dataSource = dataSource;
		this.extensionState = extensionState;
		this.logger = logger;
		this.avatarStorageFolder = this.extensionState.getAvatarStoragePath();
		this.avatarEventEmitter = new EventEmitter<AvatarEvent>();
		this.avatars = this.extensionState.getAvatarCache();
		this.queue = new AvatarRequestQueue(() => {
			if (this.interval !== null) return;
			this.interval = setInterval(() => {
				// Fetch avatars every 10 seconds
				this.fetchAvatarsInterval();
			}, 10000);
			this.fetchAvatarsInterval();
		});

		this.registerDisposables(
			// Stop fetching avatars when disposed
			toDisposable(() => {
				this.stopInterval();
			}),

			// Dispose the avatar event emitter
			this.avatarEventEmitter
		);
	}

	/**
	 * Stops the interval used to fetch avatars.
	 */
	private stopInterval() {
		if (this.interval !== null) {
			clearInterval(this.interval);
			this.interval = null;
			this.remoteSourceCache = {};
		}
	}

	/**
	 * Fetch an avatar, either from the cache if it already exists, or queue it to be fetched.
	 * @param email The email address identifying the avatar.
	 * @param repo The repository that the avatar is used in.
	 * @param remote The remote that the avatar can be fetched from.
	 * @param commits The commits that reference the avatar.
	 */
	public fetchAvatarImage(email: string, repo: string, remote: string | null, commits: string[]) {
		if (typeof this.avatars[email] !== 'undefined') {
			// Avatar exists in the cache
			let t = (new Date()).getTime();
			if (this.avatars[email].timestamp < t - 1209600000 || (this.avatars[email].identicon && this.avatars[email].timestamp < t - 345600000)) {
				// Refresh avatar after 14 days, or if an avatar couldn't previously be found after 4 days
				this.queue.add(email, repo, remote, commits, false);
			}

			this.emitAvatar(email).catch(() => {
				// Avatar couldn't be found, request it again
				this.removeAvatarFromCache(email);
				this.queue.add(email, repo, remote, commits, true);
			});
		} else {
			// Avatar not in the cache, request it
			this.queue.add(email, repo, remote, commits, true);
		}
	}

	/**
	 * Get the image data of an avatar.
	 * @param email The email address identifying the avatar.
	 * @returns A base64 encoded data URI if the avatar exists, otherwise NULL.
	 */
	public getAvatarImage(email: string) {
		return new Promise<string | null>((resolve) => {
			if (typeof this.avatars[email] !== 'undefined' && this.avatars[email].image !== null) {
				fs.readFile(this.avatarStorageFolder + '/' + this.avatars[email].image, (err, data) => {
					resolve(err ? null : 'data:image/' + this.avatars[email].image.split('.')[1] + ';base64,' + data.toString('base64'));
				});
			} else {
				resolve(null);
			}
		});
	}

	/**
	 * Get the Event that can be used to subscribe to receive requested avatars.
	 * @returns The Event.
	 */
	get onAvatar() {
		return this.avatarEventEmitter.subscribe;
	}

	/**
	 * Remove an avatar from the cache.
	 * @param email The email address identifying the avatar.
	 */
	private removeAvatarFromCache(email: string) {
		delete this.avatars[email];
		this.extensionState.removeAvatarFromCache(email);
	}

	/**
	 * Remove all avatars from the cache.
	 * @returns A Thenable resolving to the ErrorInfo that resulted from executing this method.
	 */
	public clearCache() {
		this.avatars = {};
		return this.extensionState.clearAvatarCache();
	}

	/**
	 * Triggered by an interval to fetch avatars from Github, GitLab and Gravatar.
	 */
	private async fetchAvatarsInterval() {
		if (this.queue.hasItems()) {
			let avatarRequest = this.queue.takeItem();
			if (avatarRequest === null) return; // No avatar can be checked at the current time

			let remoteSource = await this.getRemoteSource(avatarRequest); // Fetch the remote source of the avatar
			switch (remoteSource.type) {
				case 'github':
					this.fetchFromGithub(avatarRequest, remoteSource.owner, remoteSource.repo);
					break;
				case 'gitlab':
					this.fetchFromGitLab(avatarRequest);
					break;
				default:
					this.fetchFromGravatar(avatarRequest);
			}
		} else {
			// Stop the interval if there are no items remaining in the queue
			this.stopInterval();
		}
	}

	/**
	 * Get the remote source of an avatar request.
	 * @param avatarRequest The avatar request.
	 * @returns The remote source.
	 */
	private async getRemoteSource(avatarRequest: AvatarRequestItem) {
		if (typeof this.remoteSourceCache[avatarRequest.repo] === 'object') {
			// If the repo exists in the cache of remote sources
			return this.remoteSourceCache[avatarRequest.repo];
		} else {
			// Fetch the remote repo source
			let remoteSource: RemoteSource = { type: 'gravatar' };
			if (avatarRequest.remote !== null) {
				let remoteUrl = await this.dataSource.getRemoteUrl(avatarRequest.repo, avatarRequest.remote);
				if (remoteUrl !== null) {
					// Depending on the domain of the remote repo source, determine the type of source it is
					let match;
					if ((match = remoteUrl.match(/^(https:\/\/github\.com\/|git@github\.com:)([^\/]+)\/(.*)\.git$/)) !== null) {
						remoteSource = { type: 'github', owner: match[2], repo: match[3] };
					} else if (remoteUrl.startsWith('https://gitlab.com/') || remoteUrl.startsWith('git@gitlab.com:')) {
						remoteSource = { type: 'gitlab' };
					}
				}
			}
			this.remoteSourceCache[avatarRequest.repo] = remoteSource; // Add the remote source to the cache for future use
			return remoteSource;
		}
	}

	/**
	 * Fetch an avatar from Github.
	 * @param avatarRequest The avatar request to fetch.
	 * @param owner The owner of the repository.
	 * @param repo The repository that the avatar is used in.
	 */
	private fetchFromGithub(avatarRequest: AvatarRequestItem, owner: string, repo: string) {
		let t = (new Date()).getTime();
		if (t < this.githubTimeout) {
			// Defer request until after timeout
			this.queue.addItem(avatarRequest, this.githubTimeout, false);
			this.fetchAvatarsInterval();
			return;
		}

		this.logger.log('Requesting Avatar for ' + maskEmail(avatarRequest.email) + ' from GitHub');

		const commitIndex = avatarRequest.commits.length < 5
			? avatarRequest.commits.length - 1 - avatarRequest.attempts
			: Math.round((4 - avatarRequest.attempts) * 0.25 * (avatarRequest.commits.length - 1));

		let triggeredOnError = false;
		const onError = () => {
			if (!triggeredOnError) {
				// If an error occurs, try again after 5 minutes
				triggeredOnError = true;
				this.githubTimeout = t + 300000;
				this.queue.addItem(avatarRequest, this.githubTimeout, false);
			}
		};

		https.get({
			hostname: 'api.github.com', path: '/repos/' + owner + '/' + repo + '/commits/' + avatarRequest.commits[commitIndex],
			headers: { 'User-Agent': 'vscode-git-graph' },
			agent: false, timeout: 15000
		}, (res) => {
			let respBody = '';
			res.on('data', (chunk: Buffer) => { respBody += chunk; });
			res.on('end', async () => {
				if (res.headers['x-ratelimit-remaining'] === '0') {
					// If the GitHub Api rate limit was reached, store the github timeout to prevent subsequent requests
					this.githubTimeout = parseInt(<string>res.headers['x-ratelimit-reset']) * 1000;
					this.logger.log('GitHub API Rate Limit Reached - Paused fetching from GitHub until the Rate Limit is reset');
				}

				if (res.statusCode === 200) { // Success
					let commit: any = JSON.parse(respBody);
					if (commit.author && commit.author.avatar_url) { // Avatar url found
						let img = await this.downloadAvatarImage(avatarRequest.email, commit.author.avatar_url + '&size=162');
						if (img !== null) {
							this.saveAvatar(avatarRequest.email, img, false);
						} else {
							this.logger.log('Failed to download avatar from GitHub for ' + maskEmail(avatarRequest.email));
						}
						return;
					}
				} else if (res.statusCode === 403) {
					// Rate limit reached, try again after timeout
					this.queue.addItem(avatarRequest, this.githubTimeout, false);
					return;
				} else if (res.statusCode === 422 && avatarRequest.commits.length > avatarRequest.attempts + 1 && avatarRequest.attempts < 4) {
					// Commit not found on remote, try again with the next commit if less than 5 attempts have been made
					this.queue.addItem(avatarRequest, 0, true);
					return;
				} else if (res.statusCode! >= 500) {
					// If server error, try again after 10 minutes
					this.githubTimeout = t + 600000;
					this.queue.addItem(avatarRequest, this.githubTimeout, false);
					return;
				}
				this.fetchFromGravatar(avatarRequest); // Fallback to Gravatar
			});
			res.on('error', onError);
		}).on('error', onError);
	}

	/**
	 * Fetch an avatar from GitLab.
	 * @param avatarRequest The avatar request to fetch.
	 */
	private fetchFromGitLab(avatarRequest: AvatarRequestItem) {
		let t = (new Date()).getTime();
		if (t < this.gitLabTimeout) {
			// Defer request until after timeout
			this.queue.addItem(avatarRequest, this.gitLabTimeout, false);
			this.fetchAvatarsInterval();
			return;
		}

		this.logger.log('Requesting Avatar for ' + maskEmail(avatarRequest.email) + ' from GitLab');

		let triggeredOnError = false;
		const onError = () => {
			if (!triggeredOnError) {
				// If an error occurs, try again after 5 minutes
				triggeredOnError = true;
				this.gitLabTimeout = t + 300000;
				this.queue.addItem(avatarRequest, this.gitLabTimeout, false);
			}
		};

		https.get({
			hostname: 'gitlab.com', path: '/api/v4/users?search=' + avatarRequest.email,
			headers: { 'User-Agent': 'vscode-git-graph', 'Private-Token': 'w87U_3gAxWWaPtFgCcus' }, // Token only has read access
			agent: false, timeout: 15000
		}, (res) => {
			let respBody = '';
			res.on('data', (chunk: Buffer) => { respBody += chunk; });
			res.on('end', async () => {
				if (res.headers['ratelimit-remaining'] === '0') {
					// If the GitLab Api rate limit was reached, store the gitlab timeout to prevent subsequent requests
					this.gitLabTimeout = parseInt(<string>res.headers['ratelimit-reset']) * 1000;
					this.logger.log('GitLab API Rate Limit Reached - Paused fetching from GitLab until the Rate Limit is reset');
				}

				if (res.statusCode === 200) { // Success
					let users: any = JSON.parse(respBody);
					if (users.length > 0 && users[0].avatar_url) { // Avatar url found
						let img = await this.downloadAvatarImage(avatarRequest.email, users[0].avatar_url);
						if (img !== null) {
							this.saveAvatar(avatarRequest.email, img, false);
						} else {
							this.logger.log('Failed to download avatar from GitLab for ' + maskEmail(avatarRequest.email));
						}
						return;
					}
				} else if (res.statusCode === 429) {
					// Rate limit reached, try again after timeout
					this.queue.addItem(avatarRequest, this.gitLabTimeout, false);
					return;
				} else if (res.statusCode! >= 500) {
					// If server error, try again after 10 minutes
					this.gitLabTimeout = t + 600000;
					this.queue.addItem(avatarRequest, this.gitLabTimeout, false);
					return;
				}
				this.fetchFromGravatar(avatarRequest); // Fallback to Gravatar
			});
			res.on('error', onError);
		}).on('error', onError);
	}

	/**
	 * Fetch an avatar from Gravatar.
	 * @param avatarRequest The avatar request to fetch.
	 */
	private async fetchFromGravatar(avatarRequest: AvatarRequestItem) {
		this.logger.log('Requesting Avatar for ' + maskEmail(avatarRequest.email) + ' from Gravatar');
		const hash: string = crypto.createHash('md5').update(avatarRequest.email.trim().toLowerCase()).digest('hex');

		let img = await this.downloadAvatarImage(avatarRequest.email, 'https://secure.gravatar.com/avatar/' + hash + '?s=162&d=404'), identicon = false;
		if (img === null) {
			img = await this.downloadAvatarImage(avatarRequest.email, 'https://secure.gravatar.com/avatar/' + hash + '?s=162&d=identicon');
			identicon = true;
		}

		if (img !== null) {
			this.saveAvatar(avatarRequest.email, img, identicon);
		} else {
			this.logger.log('No Avatar could be found for ' + maskEmail(avatarRequest.email));
		}
	}

	/**
	 * Download and save an avatar image.
	 * @param email The email address identifying the avatar.
	 * @param imageUrl The URL the avatar can be downloaded from.
	 * @returns A promise that resolves to the image name of the avatar on disk, or NULL if downloading failed.
	 */
	private downloadAvatarImage(email: string, imageUrl: string) {
		return (new Promise<string | null>((resolve) => {
			const hash = crypto.createHash('md5').update(email).digest('hex');
			const imgUrl = url.parse(imageUrl);

			let completed = false;
			const complete = (fileName: string | null = null) => {
				if (!completed) {
					completed = true;
					resolve(fileName);
				}
			};

			https.get({
				hostname: imgUrl.hostname, path: imgUrl.path,
				headers: { 'User-Agent': 'vscode-git-graph' },
				agent: false, timeout: 15000
			}, (res) => {
				let imageBufferArray: Buffer[] = [];
				res.on('data', (chunk: Buffer) => { imageBufferArray.push(chunk); });
				res.on('end', () => {
					if (res.statusCode === 200) { // If success response, save the image to the avatar folder
						let format = res.headers['content-type']!.split('/')[1];
						fs.writeFile(this.avatarStorageFolder + '/' + hash + '.' + format, Buffer.concat(imageBufferArray), err => {
							complete(err ? null : hash + '.' + format);
						});
					} else {
						complete();
					}
				});
				res.on('error', complete);
			}).on('error', complete);
		})).catch(() => null);
	}

	/**
	 * Emit an AvatarEvent to any listeners.
	 * @param email The email address identifying the avatar.
	 * @returns A promise indicating if the event was emitted successfully.
	 */
	private emitAvatar(email: string) {
		return new Promise<boolean>((resolve, reject) => {
			if (this.avatarEventEmitter.hasSubscribers()) {
				this.getAvatarImage(email).then((image) => {
					if (image === null) {
						reject();
					} else {
						this.avatarEventEmitter.emit({
							email: email,
							image: image
						});
						resolve(true);
					}
				});
			} else {
				resolve(false);
			}
		});
	}

	/**
	 * Save an avatar in the cache.
	 * @param email The email address identifying the avatar.
	 * @param image The image name of the avatar on disk.
	 * @param identicon Whether this avatar is an identicon.
	 */
	private saveAvatar(email: string, image: string, identicon: boolean) {
		if (typeof this.avatars[email] !== 'undefined') {
			if (!identicon || this.avatars[email].identicon) {
				this.avatars[email].image = image;
				this.avatars[email].identicon = identicon;
			}
			this.avatars[email].timestamp = (new Date()).getTime();
		} else {
			this.avatars[email] = { image: image, timestamp: (new Date()).getTime(), identicon: identicon };
		}
		this.extensionState.saveAvatar(email, this.avatars[email]);
		this.logger.log('Saved Avatar for ' + maskEmail(email));
		this.emitAvatar(email).then(
			(sent) => this.logger.log(sent
				? 'Sent Avatar for ' + maskEmail(email) + ' to the Git Graph View'
				: 'Avatar for ' + maskEmail(email) + ' is ready to be used the next time the Git Graph View is opened'
			),
			() => this.logger.log('Failed to Send Avatar for ' + maskEmail(email) + ' to the Git Graph View')
		);
	}
}

/**
 * Represents a queue of avatar requests, ordered by their `checkAfter` value.
 */
class AvatarRequestQueue {
	private queue: AvatarRequestItem[] = [];
	private itemsAvailableCallback: () => void;

	/**
	 * Create an Avatar Request Queue.
	 * @param itemsAvailableCallback A callback that is invoked when the queue transitions from having no items, to having at least one item.
	 */
	constructor(itemsAvailableCallback: () => void) {
		this.itemsAvailableCallback = itemsAvailableCallback;
	}

	/**
	 * Create and add a new avatar request to the queue.
	 * @param email The email address identifying the avatar.
	 * @param repo The repository that the avatar is used in.
	 * @param remote The remote that the avatar can be fetched from.
	 * @param commits The commits that reference the avatar.
	 * @param immediate Whether the avatar should be fetched immediately.
	 */
	public add(email: string, repo: string, remote: string | null, commits: string[], immediate: boolean) {
		const existingRequest = this.queue.find((request) => request.email === email && request.repo === repo);
		if (existingRequest) {
			commits.forEach((commit) => {
				if (!existingRequest.commits.includes(commit)) {
					existingRequest.commits.push(commit);
				}
			});
		} else {
			this.insertItem({
				email: email,
				repo: repo,
				remote: remote,
				commits: commits,
				checkAfter: immediate || this.queue.length === 0
					? 0
					: this.queue[this.queue.length - 1].checkAfter + 1,
				attempts: 0
			});
		}
	}

	/**
	 * Add an existing avatar request item back onto the queue.
	 * @param item The avatar request item.
	 * @param checkAfter The earliest time the avatar should be requested.
	 * @param failedAttempt Did the fetch attempt fail.
	 */
	public addItem(item: AvatarRequestItem, checkAfter: number, failedAttempt: boolean) {
		item.checkAfter = checkAfter;
		if (failedAttempt) item.attempts++;
		this.insertItem(item);
	}

	/**
	 * Check if there are items in the queue.
	 * @returns TRUE => Items in the queue, FALSE => Queue is empty.
	 */
	public hasItems() {
		return this.queue.length > 0;
	}

	/**
	 * Take the next item from the queue if an item is available.
	 * @returns An avatar request item, or NULL if no item is available.
	 */
	public takeItem() {
		if (this.queue.length > 0 && this.queue[0].checkAfter < (new Date()).getTime()) return this.queue.shift()!;
		return null;
	}

	/**
	 * Insert an avatar request item into the queue.
	 * @param item The avatar request item.
	 */
	private insertItem(item: AvatarRequestItem) {
		let l = 0, r = this.queue.length - 1, c, prevLength = this.queue.length;
		while (l <= r) {
			c = l + r >> 1;
			if (this.queue[c].checkAfter <= item.checkAfter) {
				l = c + 1;
			} else {
				r = c - 1;
			}
		}
		this.queue.splice(l, 0, item);
		if (prevLength === 0) this.itemsAvailableCallback();
	}
}

/**
 * Mask an email address for logging.
 * @param email The string containing the email address.
 * @returns The masked email address.
 */
function maskEmail(email: string) {
	return email.substring(0, email.indexOf('@')) + '@*****';
}

export interface Avatar {
	image: string;
	timestamp: number;
	identicon: boolean;
}

export type AvatarCache = { [email: string]: Avatar };

interface AvatarRequestItem {
	email: string;
	repo: string;
	remote: string | null;
	commits: string[];
	checkAfter: number;
	attempts: number;
}

interface GitHubRemoteSource {
	readonly type: 'github';
	readonly owner: string;
	readonly repo: string;
}

export interface AvatarEvent {
	email: string;
	image: string;
}

interface GitLabRemoteSource {
	readonly type: 'gitlab';
}

interface GravatarRemoteSource {
	readonly type: 'gravatar';
}

type RemoteSource = GitHubRemoteSource | GitLabRemoteSource | GravatarRemoteSource;
-e 

================================================================================
// FILE: ./src/askpass/askpassManager.ts
================================================================================
/*---------------------------------------------------------------------------------------------
 *  This code is based on the askpass implementation in the Microsoft Visual Studio Code Git Extension
 *  https://github.com/microsoft/vscode/blob/473af338e1bd9ad4d9853933da1cd9d5d9e07dc9/extensions/git/src/askpass.ts,
 *  which has the following copyright notice & license:
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See ./licenses/LICENSE_MICROSOFT for license information.
 *--------------------------------------------------------------------------------------------*/

import * as fs from 'fs';
import * as http from 'http';
import * as os from 'os';
import * as path from 'path';
import * as vscode from 'vscode';
import { getNonce } from '../utils';
import { Disposable, toDisposable } from '../utils/disposable';

export interface AskpassEnvironment {
	GIT_ASKPASS: string;
	ELECTRON_RUN_AS_NODE?: string;
	VSCODE_GIT_GRAPH_ASKPASS_NODE?: string;
	VSCODE_GIT_GRAPH_ASKPASS_MAIN?: string;
	VSCODE_GIT_GRAPH_ASKPASS_HANDLE?: string;
}

export interface AskpassRequest {
	host: string;
	request: string;
}

export class AskpassManager extends Disposable {
	private ipcHandlePath: string;
	private server: http.Server;
	private enabled = true;

	constructor() {
		super();
		this.ipcHandlePath = getIPCHandlePath(getNonce());
		this.server = http.createServer((req, res) => this.onRequest(req, res));
		try {
			this.server.listen(this.ipcHandlePath);
			this.server.on('error', () => { });
		} catch (err) {
			this.enabled = false;
		}
		fs.chmod(path.join(__dirname, 'askpass.sh'), '755', () => { });
		fs.chmod(path.join(__dirname, 'askpass-empty.sh'), '755', () => { });

		this.registerDisposable(
			// Close the Askpass Server
			toDisposable(() => {
				try {
					this.server.close();
					if (process.platform !== 'win32') {
						fs.unlinkSync(this.ipcHandlePath);
					}
				} catch (e) { }
			})
		);
	}

	private onRequest(req: http.IncomingMessage, res: http.ServerResponse): void {
		let reqData = '';
		req.setEncoding('utf8');
		req.on('data', (d) => reqData += d);
		req.on('end', () => {
			let data = JSON.parse(reqData) as AskpassRequest;
			vscode.window.showInputBox({ placeHolder: data.request, prompt: 'Git Graph: ' + data.host, password: /password/i.test(data.request), ignoreFocusOut: true }).then(result => {
				res.writeHead(200);
				res.end(JSON.stringify(result || ''));
			}, () => {
				res.writeHead(500);
				res.end();
			});
		});
	}

	public getEnv(): AskpassEnvironment {
		return this.enabled
			? {
				ELECTRON_RUN_AS_NODE: '1',
				GIT_ASKPASS: path.join(__dirname, 'askpass.sh'),
				VSCODE_GIT_GRAPH_ASKPASS_NODE: process.execPath,
				VSCODE_GIT_GRAPH_ASKPASS_MAIN: path.join(__dirname, 'askpassMain.js'),
				VSCODE_GIT_GRAPH_ASKPASS_HANDLE: this.ipcHandlePath
			}
			: {
				GIT_ASKPASS: path.join(__dirname, 'askpass-empty.sh')
			};
	}
}

function getIPCHandlePath(nonce: string): string {
	if (process.platform === 'win32') {
		return '\\\\.\\pipe\\git-graph-askpass-' + nonce + '-sock';
	} else if (process.env['XDG_RUNTIME_DIR']) {
		return path.join(process.env['XDG_RUNTIME_DIR'] as string, 'git-graph-askpass-' + nonce + '.sock');
	} else {
		return path.join(os.tmpdir(), 'git-graph-askpass-' + nonce + '.sock');
	}
}
-e 

================================================================================
// FILE: ./src/askpass/askpassMain.ts
================================================================================
/*---------------------------------------------------------------------------------------------
 *  This code is based on the askpass implementation in the Microsoft Visual Studio Code Git Extension
 *  https://github.com/microsoft/vscode/blob/473af338e1bd9ad4d9853933da1cd9d5d9e07dc9/extensions/git/src/askpass-main.ts,
 *  which has the following copyright notice & license:
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See ./licenses/LICENSE_MICROSOFT for license information.
 *--------------------------------------------------------------------------------------------*/

import * as fs from 'fs';
import * as http from 'http';

function fatal(err: any): void {
	console.error('Missing or invalid credentials.');
	console.error(err);
	process.exit(1);
}

function main(argv: string[]): void {
	if (argv.length !== 5) return fatal('Wrong number of arguments');
	if (!process.env['VSCODE_GIT_GRAPH_ASKPASS_HANDLE']) return fatal('Missing handle');
	if (!process.env['VSCODE_GIT_GRAPH_ASKPASS_PIPE']) return fatal('Missing pipe');

	const output = process.env['VSCODE_GIT_GRAPH_ASKPASS_PIPE']!;
	const socketPath = process.env['VSCODE_GIT_GRAPH_ASKPASS_HANDLE']!;

	const req = http.request({ socketPath, path: '/', method: 'POST' }, res => {
		if (res.statusCode !== 200) return fatal('Bad status code: ' + res.statusCode);

		let resData = '';
		res.setEncoding('utf8');
		res.on('data', (d) => resData += d);
		res.on('end', () => {
			try {
				let response = JSON.parse(resData);
				fs.writeFileSync(output, response + '\n');
			} catch (err) {
				return fatal('Error parsing response');
			}
			setTimeout(() => process.exit(0), 0);
		});
	});

	req.on('error', () => fatal('Error in request'));
	req.write(JSON.stringify({ request: argv[2], host: argv[4].substring(1, argv[4].length - 2) }));
	req.end();
}

main(process.argv);
-e 

================================================================================
// FILE: ./src/statusBarItem.ts
================================================================================
import * as vscode from 'vscode';
import { getConfig } from './config';
import { Logger } from './logger';
import { RepoChangeEvent } from './repoManager';
import { Disposable } from './utils/disposable';
import { Event } from './utils/event';

/**
 * Manages the Git Graph Status Bar Item, which allows users to open the Git Graph View from the Visual Studio Code Status Bar.
 */
export class StatusBarItem extends Disposable {
	private readonly logger: Logger;
	private readonly statusBarItem: vscode.StatusBarItem;
	private isVisible: boolean = false;
	private numRepos: number = 0;

	/**
	 * Creates the Git Graph Status Bar Item.
	 * @param repoManager The Git Graph RepoManager instance.
	 * @param logger The Git Graph Logger instance.
	 */
	constructor(initialNumRepos: number, onDidChangeRepos: Event<RepoChangeEvent>, onDidChangeConfiguration: Event<vscode.ConfigurationChangeEvent>, logger: Logger) {
		super();
		this.logger = logger;

		const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 1);
		statusBarItem.text = 'Git Graph';
		statusBarItem.tooltip = 'View Git Graph';
		statusBarItem.command = 'git-graph.view';
		this.statusBarItem = statusBarItem;

		this.registerDisposables(
			onDidChangeRepos((event) => {
				this.setNumRepos(event.numRepos);
			}),
			onDidChangeConfiguration((event) => {
				if (event.affectsConfiguration('git-graph.showStatusBarItem')) {
					this.refresh();
				}
			}),
			statusBarItem
		);

		this.setNumRepos(initialNumRepos);
	}

	/**
	 * Sets the number of repositories known to Git Graph, before refreshing the Status Bar Item.
	 * @param numRepos The number of repositories known to Git Graph.
	 */
	private setNumRepos(numRepos: number) {
		this.numRepos = numRepos;
		this.refresh();
	}

	/**
	 * Show or hide the Status Bar Item according to the configured value of `git-graph.showStatusBarItem`, and the number of repositories known to Git Graph.
	 */
	private refresh() {
		const shouldBeVisible = getConfig().showStatusBarItem && this.numRepos > 0;
		if (this.isVisible !== shouldBeVisible) {
			if (shouldBeVisible) {
				this.statusBarItem.show();
				this.logger.log('Showing "Git Graph" Status Bar Item');
			} else {
				this.statusBarItem.hide();
				this.logger.log('Hiding "Git Graph" Status Bar Item');
			}
			this.isVisible = shouldBeVisible;
		}
	}
}
-e 

